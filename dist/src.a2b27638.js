// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/leaflet/dist/leaflet-src.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.leaflet = {}));
})(this, (function (exports) { 'use strict';

  var version = "1.9.4";

  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */

  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
  function extend(dest) {
  	var i, j, len, src;

  	for (j = 1, len = arguments.length; j < len; j++) {
  		src = arguments[j];
  		for (i in src) {
  			dest[i] = src[i];
  		}
  	}
  	return dest;
  }

  // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  var create$2 = Object.create || (function () {
  	function F() {}
  	return function (proto) {
  		F.prototype = proto;
  		return new F();
  	};
  })();

  // @function bind(fn: Function, â€¦): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.
  function bind(fn, obj) {
  	var slice = Array.prototype.slice;

  	if (fn.bind) {
  		return fn.bind.apply(fn, slice.call(arguments, 1));
  	}

  	var args = slice.call(arguments, 2);

  	return function () {
  		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  	};
  }

  // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)
  var lastId = 0;

  // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.
  function stamp(obj) {
  	if (!('_leaflet_id' in obj)) {
  		obj['_leaflet_id'] = ++lastId;
  	}
  	return obj._leaflet_id;
  }

  // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.
  function throttle(fn, time, context) {
  	var lock, args, wrapperFn, later;

  	later = function () {
  		// reset lock and call if queued
  		lock = false;
  		if (args) {
  			wrapperFn.apply(context, args);
  			args = false;
  		}
  	};

  	wrapperFn = function () {
  		if (lock) {
  			// called too soon, queue to call later
  			args = arguments;

  		} else {
  			// call and lock until later
  			fn.apply(context, arguments);
  			setTimeout(later, time);
  			lock = true;
  		}
  	};

  	return wrapperFn;
  }

  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.
  function wrapNum(x, range, includeMax) {
  	var max = range[1],
  	    min = range[0],
  	    d = max - min;
  	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  }

  // @function falseFn(): Function
  // Returns a function which always returns `false`.
  function falseFn() { return false; }

  // @function formatNum(num: Number, precision?: Number|false): Number
  // Returns the number `num` rounded with specified `precision`.
  // The default `precision` value is 6 decimal places.
  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).
  function formatNum(num, precision) {
  	if (precision === false) { return num; }
  	var pow = Math.pow(10, precision === undefined ? 6 : precision);
  	return Math.round(num * pow) / pow;
  }

  // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
  function trim(str) {
  	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }

  // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.
  function splitWords(str) {
  	return trim(str).split(/\s+/);
  }

  // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
  function setOptions(obj, options) {
  	if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
  		obj.options = obj.options ? create$2(obj.options) : {};
  	}
  	for (var i in options) {
  		obj.options[i] = options[i];
  	}
  	return obj.options;
  }

  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
  	var params = [];
  	for (var i in obj) {
  		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
  	}
  	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_ -]+) *\}/g;

  // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values â€” they will be evaluated passing `data` as an argument.
  function template(str, data) {
  	return str.replace(templateRe, function (str, key) {
  		var value = data[key];

  		if (value === undefined) {
  			throw new Error('No value provided for variable ' + str);

  		} else if (typeof value === 'function') {
  			value = value(data);
  		}
  		return value;
  	});
  }

  // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  var isArray = Array.isArray || function (obj) {
  	return (Object.prototype.toString.call(obj) === '[object Array]');
  };

  // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  function indexOf(array, el) {
  	for (var i = 0; i < array.length; i++) {
  		if (array[i] === el) { return i; }
  	}
  	return -1;
  }

  // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).
  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
  	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0;

  // fallback for IE 7-8
  function timeoutDefer(fn) {
  	var time = +new Date(),
  	    timeToCall = Math.max(0, 16 - (time - lastTime));

  	lastTime = time + timeToCall;
  	return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
  		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
  function requestAnimFrame(fn, context, immediate) {
  	if (immediate && requestFn === timeoutDefer) {
  		fn.call(context);
  	} else {
  		return requestFn.call(window, bind(fn, context));
  	}
  }

  // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
  function cancelAnimFrame(id) {
  	if (id) {
  		cancelFn.call(window, id);
  	}
  }

  var Util = {
    __proto__: null,
    extend: extend,
    create: create$2,
    bind: bind,
    get lastId () { return lastId; },
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  };

  // @class Class
  // @aka L.Class

  // @section
  // @uninheritable

  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {

  	// @function extend(props: Object): Function
  	// [Extends the current class](#class-inheritance) given the properties to be included.
  	// Returns a Javascript function that is a class constructor (to be called with `new`).
  	var NewClass = function () {

  		setOptions(this);

  		// call the constructor
  		if (this.initialize) {
  			this.initialize.apply(this, arguments);
  		}

  		// call all constructor hooks
  		this.callInitHooks();
  	};

  	var parentProto = NewClass.__super__ = this.prototype;

  	var proto = create$2(parentProto);
  	proto.constructor = NewClass;

  	NewClass.prototype = proto;

  	// inherit parent's statics
  	for (var i in this) {
  		if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
  			NewClass[i] = this[i];
  		}
  	}

  	// mix static properties into the class
  	if (props.statics) {
  		extend(NewClass, props.statics);
  	}

  	// mix includes into the prototype
  	if (props.includes) {
  		checkDeprecatedMixinEvents(props.includes);
  		extend.apply(null, [proto].concat(props.includes));
  	}

  	// mix given properties into the prototype
  	extend(proto, props);
  	delete proto.statics;
  	delete proto.includes;

  	// merge options
  	if (proto.options) {
  		proto.options = parentProto.options ? create$2(parentProto.options) : {};
  		extend(proto.options, props.options);
  	}

  	proto._initHooks = [];

  	// add method for calling all hooks
  	proto.callInitHooks = function () {

  		if (this._initHooksCalled) { return; }

  		if (parentProto.callInitHooks) {
  			parentProto.callInitHooks.call(this);
  		}

  		this._initHooksCalled = true;

  		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
  			proto._initHooks[i].call(this);
  		}
  	};

  	return NewClass;
  };


  // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.
  Class.include = function (props) {
  	var parentOptions = this.prototype.options;
  	extend(this.prototype, props);
  	if (props.options) {
  		this.prototype.options = parentOptions;
  		this.mergeOptions(props.options);
  	}
  	return this;
  };

  // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.
  Class.mergeOptions = function (options) {
  	extend(this.prototype.options, options);
  	return this;
  };

  // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.
  Class.addInitHook = function (fn) { // (Function) || (String, args...)
  	var args = Array.prototype.slice.call(arguments, 1);

  	var init = typeof fn === 'function' ? fn : function () {
  		this[fn].apply(this, args);
  	};

  	this.prototype._initHooks = this.prototype._initHooks || [];
  	this.prototype._initHooks.push(init);
  	return this;
  };

  function checkDeprecatedMixinEvents(includes) {
  	/* global L: true */
  	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

  	includes = isArray(includes) ? includes : [includes];

  	for (var i = 0; i < includes.length; i++) {
  		if (includes[i] === L.Mixin.Events) {
  			console.warn('Deprecated include of L.Mixin.Events: ' +
  				'this property will be removed in future releases, ' +
  				'please inherit from L.Evented instead.', new Error().stack);
  		}
  	}
  }

  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */

  var Events = {
  	/* @method on(type: String, fn: Function, context?: Object): this
  	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  	 *
  	 * @alternative
  	 * @method on(eventMap: Object): this
  	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  	 */
  	on: function (types, fn, context) {

  		// types can be a map of types/handlers
  		if (typeof types === 'object') {
  			for (var type in types) {
  				// we don't process space-separated events here for performance;
  				// it's a hot path since Layer uses the on(obj) syntax
  				this._on(type, types[type], fn);
  			}

  		} else {
  			// types can be a string of space-separated words
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._on(types[i], fn, context);
  			}
  		}

  		return this;
  	},

  	/* @method off(type: String, fn?: Function, context?: Object): this
  	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  	 *
  	 * @alternative
  	 * @method off(eventMap: Object): this
  	 * Removes a set of type/listener pairs.
  	 *
  	 * @alternative
  	 * @method off: this
  	 * Removes all listeners to all events on the object. This includes implicitly attached events.
  	 */
  	off: function (types, fn, context) {

  		if (!arguments.length) {
  			// clear all listeners if called without arguments
  			delete this._events;

  		} else if (typeof types === 'object') {
  			for (var type in types) {
  				this._off(type, types[type], fn);
  			}

  		} else {
  			types = splitWords(types);

  			var removeAll = arguments.length === 1;
  			for (var i = 0, len = types.length; i < len; i++) {
  				if (removeAll) {
  					this._off(types[i]);
  				} else {
  					this._off(types[i], fn, context);
  				}
  			}
  		}

  		return this;
  	},

  	// attach listener (without syntactic sugar now)
  	_on: function (type, fn, context, _once) {
  		if (typeof fn !== 'function') {
  			console.warn('wrong listener type: ' + typeof fn);
  			return;
  		}

  		// check if fn already there
  		if (this._listens(type, fn, context) !== false) {
  			return;
  		}

  		if (context === this) {
  			// Less memory footprint.
  			context = undefined;
  		}

  		var newListener = {fn: fn, ctx: context};
  		if (_once) {
  			newListener.once = true;
  		}

  		this._events = this._events || {};
  		this._events[type] = this._events[type] || [];
  		this._events[type].push(newListener);
  	},

  	_off: function (type, fn, context) {
  		var listeners,
  		    i,
  		    len;

  		if (!this._events) {
  			return;
  		}

  		listeners = this._events[type];
  		if (!listeners) {
  			return;
  		}

  		if (arguments.length === 1) { // remove all
  			if (this._firingCount) {
  				// Set all removed listeners to noop
  				// so they are not called if remove happens in fire
  				for (i = 0, len = listeners.length; i < len; i++) {
  					listeners[i].fn = falseFn;
  				}
  			}
  			// clear all listeners for a type if function isn't specified
  			delete this._events[type];
  			return;
  		}

  		if (typeof fn !== 'function') {
  			console.warn('wrong listener type: ' + typeof fn);
  			return;
  		}

  		// find fn and remove it
  		var index = this._listens(type, fn, context);
  		if (index !== false) {
  			var listener = listeners[index];
  			if (this._firingCount) {
  				// set the removed listener to noop so that's not called if remove happens in fire
  				listener.fn = falseFn;

  				/* copy array in case events are being fired */
  				this._events[type] = listeners = listeners.slice();
  			}
  			listeners.splice(index, 1);
  		}
  	},

  	// @method fire(type: String, data?: Object, propagate?: Boolean): this
  	// Fires an event of the specified type. You can optionally provide a data
  	// object â€” the first argument of the listener function will contain its
  	// properties. The event can optionally be propagated to event parents.
  	fire: function (type, data, propagate) {
  		if (!this.listens(type, propagate)) { return this; }

  		var event = extend({}, data, {
  			type: type,
  			target: this,
  			sourceTarget: data && data.sourceTarget || this
  		});

  		if (this._events) {
  			var listeners = this._events[type];
  			if (listeners) {
  				this._firingCount = (this._firingCount + 1) || 1;
  				for (var i = 0, len = listeners.length; i < len; i++) {
  					var l = listeners[i];
  					// off overwrites l.fn, so we need to copy fn to a var
  					var fn = l.fn;
  					if (l.once) {
  						this.off(type, fn, l.ctx);
  					}
  					fn.call(l.ctx || this, event);
  				}

  				this._firingCount--;
  			}
  		}

  		if (propagate) {
  			// propagate the event to parents (set with addEventParent)
  			this._propagateEvent(event);
  		}

  		return this;
  	},

  	// @method listens(type: String, propagate?: Boolean): Boolean
  	// @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
  	// Returns `true` if a particular event type has any listeners attached to it.
  	// The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
  	listens: function (type, fn, context, propagate) {
  		if (typeof type !== 'string') {
  			console.warn('"string" type argument expected');
  		}

  		// we don't overwrite the input `fn` value, because we need to use it for propagation
  		var _fn = fn;
  		if (typeof fn !== 'function') {
  			propagate = !!fn;
  			_fn = undefined;
  			context = undefined;
  		}

  		var listeners = this._events && this._events[type];
  		if (listeners && listeners.length) {
  			if (this._listens(type, _fn, context) !== false) {
  				return true;
  			}
  		}

  		if (propagate) {
  			// also check parents for listeners if event propagates
  			for (var id in this._eventParents) {
  				if (this._eventParents[id].listens(type, fn, context, propagate)) { return true; }
  			}
  		}
  		return false;
  	},

  	// returns the index (number) or false
  	_listens: function (type, fn, context) {
  		if (!this._events) {
  			return false;
  		}

  		var listeners = this._events[type] || [];
  		if (!fn) {
  			return !!listeners.length;
  		}

  		if (context === this) {
  			// Less memory footprint.
  			context = undefined;
  		}

  		for (var i = 0, len = listeners.length; i < len; i++) {
  			if (listeners[i].fn === fn && listeners[i].ctx === context) {
  				return i;
  			}
  		}
  		return false;

  	},

  	// @method once(â€¦): this
  	// Behaves as [`on(â€¦)`](#evented-on), except the listener will only get fired once and then removed.
  	once: function (types, fn, context) {

  		// types can be a map of types/handlers
  		if (typeof types === 'object') {
  			for (var type in types) {
  				// we don't process space-separated events here for performance;
  				// it's a hot path since Layer uses the on(obj) syntax
  				this._on(type, types[type], fn, true);
  			}

  		} else {
  			// types can be a string of space-separated words
  			types = splitWords(types);

  			for (var i = 0, len = types.length; i < len; i++) {
  				this._on(types[i], fn, context, true);
  			}
  		}

  		return this;
  	},

  	// @method addEventParent(obj: Evented): this
  	// Adds an event parent - an `Evented` that will receive propagated events
  	addEventParent: function (obj) {
  		this._eventParents = this._eventParents || {};
  		this._eventParents[stamp(obj)] = obj;
  		return this;
  	},

  	// @method removeEventParent(obj: Evented): this
  	// Removes an event parent, so it will stop receiving propagated events
  	removeEventParent: function (obj) {
  		if (this._eventParents) {
  			delete this._eventParents[stamp(obj)];
  		}
  		return this;
  	},

  	_propagateEvent: function (e) {
  		for (var id in this._eventParents) {
  			this._eventParents[id].fire(e.type, extend({
  				layer: e.target,
  				propagatedFrom: e.target
  			}, e), true);
  		}
  	}
  };

  // aliases; we should ditch those eventually

  // @method addEventListener(â€¦): this
  // Alias to [`on(â€¦)`](#evented-on)
  Events.addEventListener = Events.on;

  // @method removeEventListener(â€¦): this
  // Alias to [`off(â€¦)`](#evented-off)

  // @method clearAllEventListeners(â€¦): this
  // Alias to [`off()`](#evented-off)
  Events.removeEventListener = Events.clearAllEventListeners = Events.off;

  // @method addOneTimeEventListener(â€¦): this
  // Alias to [`once(â€¦)`](#evented-once)
  Events.addOneTimeEventListener = Events.once;

  // @method fireEvent(â€¦): this
  // Alias to [`fire(â€¦)`](#evented-fire)
  Events.fireEvent = Events.fire;

  // @method hasEventListeners(â€¦): Boolean
  // Alias to [`listens(â€¦)`](#evented-listens)
  Events.hasEventListeners = Events.listens;

  var Evented = Class.extend(Events);

  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
  	// @property x: Number; The `x` coordinate of the point
  	this.x = (round ? Math.round(x) : x);
  	// @property y: Number; The `y` coordinate of the point
  	this.y = (round ? Math.round(y) : y);
  }

  var trunc = Math.trunc || function (v) {
  	return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {

  	// @method clone(): Point
  	// Returns a copy of the current point.
  	clone: function () {
  		return new Point(this.x, this.y);
  	},

  	// @method add(otherPoint: Point): Point
  	// Returns the result of addition of the current and the given points.
  	add: function (point) {
  		// non-destructive, returns a new point
  		return this.clone()._add(toPoint(point));
  	},

  	_add: function (point) {
  		// destructive, used directly for performance in situations where it's safe to modify existing point
  		this.x += point.x;
  		this.y += point.y;
  		return this;
  	},

  	// @method subtract(otherPoint: Point): Point
  	// Returns the result of subtraction of the given point from the current.
  	subtract: function (point) {
  		return this.clone()._subtract(toPoint(point));
  	},

  	_subtract: function (point) {
  		this.x -= point.x;
  		this.y -= point.y;
  		return this;
  	},

  	// @method divideBy(num: Number): Point
  	// Returns the result of division of the current point by the given number.
  	divideBy: function (num) {
  		return this.clone()._divideBy(num);
  	},

  	_divideBy: function (num) {
  		this.x /= num;
  		this.y /= num;
  		return this;
  	},

  	// @method multiplyBy(num: Number): Point
  	// Returns the result of multiplication of the current point by the given number.
  	multiplyBy: function (num) {
  		return this.clone()._multiplyBy(num);
  	},

  	_multiplyBy: function (num) {
  		this.x *= num;
  		this.y *= num;
  		return this;
  	},

  	// @method scaleBy(scale: Point): Point
  	// Multiply each coordinate of the current point by each coordinate of
  	// `scale`. In linear algebra terms, multiply the point by the
  	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
  	// defined by `scale`.
  	scaleBy: function (point) {
  		return new Point(this.x * point.x, this.y * point.y);
  	},

  	// @method unscaleBy(scale: Point): Point
  	// Inverse of `scaleBy`. Divide each coordinate of the current point by
  	// each coordinate of `scale`.
  	unscaleBy: function (point) {
  		return new Point(this.x / point.x, this.y / point.y);
  	},

  	// @method round(): Point
  	// Returns a copy of the current point with rounded coordinates.
  	round: function () {
  		return this.clone()._round();
  	},

  	_round: function () {
  		this.x = Math.round(this.x);
  		this.y = Math.round(this.y);
  		return this;
  	},

  	// @method floor(): Point
  	// Returns a copy of the current point with floored coordinates (rounded down).
  	floor: function () {
  		return this.clone()._floor();
  	},

  	_floor: function () {
  		this.x = Math.floor(this.x);
  		this.y = Math.floor(this.y);
  		return this;
  	},

  	// @method ceil(): Point
  	// Returns a copy of the current point with ceiled coordinates (rounded up).
  	ceil: function () {
  		return this.clone()._ceil();
  	},

  	_ceil: function () {
  		this.x = Math.ceil(this.x);
  		this.y = Math.ceil(this.y);
  		return this;
  	},

  	// @method trunc(): Point
  	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
  	trunc: function () {
  		return this.clone()._trunc();
  	},

  	_trunc: function () {
  		this.x = trunc(this.x);
  		this.y = trunc(this.y);
  		return this;
  	},

  	// @method distanceTo(otherPoint: Point): Number
  	// Returns the cartesian distance between the current and the given points.
  	distanceTo: function (point) {
  		point = toPoint(point);

  		var x = point.x - this.x,
  		    y = point.y - this.y;

  		return Math.sqrt(x * x + y * y);
  	},

  	// @method equals(otherPoint: Point): Boolean
  	// Returns `true` if the given point has the same coordinates.
  	equals: function (point) {
  		point = toPoint(point);

  		return point.x === this.x &&
  		       point.y === this.y;
  	},

  	// @method contains(otherPoint: Point): Boolean
  	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
  	contains: function (point) {
  		point = toPoint(point);

  		return Math.abs(point.x) <= Math.abs(this.x) &&
  		       Math.abs(point.y) <= Math.abs(this.y);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point for debugging purposes.
  	toString: function () {
  		return 'Point(' +
  		        formatNum(this.x) + ', ' +
  		        formatNum(this.y) + ')';
  	}
  };

  // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.

  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.
  function toPoint(x, y, round) {
  	if (x instanceof Point) {
  		return x;
  	}
  	if (isArray(x)) {
  		return new Point(x[0], x[1]);
  	}
  	if (x === undefined || x === null) {
  		return x;
  	}
  	if (typeof x === 'object' && 'x' in x && 'y' in x) {
  		return new Point(x.x, x.y);
  	}
  	return new Point(x, y, round);
  }

  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Bounds(a, b) {
  	if (!a) { return; }

  	var points = b ? [a, b] : a;

  	for (var i = 0, len = points.length; i < len; i++) {
  		this.extend(points[i]);
  	}
  }

  Bounds.prototype = {
  	// @method extend(point: Point): this
  	// Extends the bounds to contain the given point.

  	// @alternative
  	// @method extend(otherBounds: Bounds): this
  	// Extend the bounds to contain the given bounds
  	extend: function (obj) {
  		var min2, max2;
  		if (!obj) { return this; }

  		if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {
  			min2 = max2 = toPoint(obj);
  		} else {
  			obj = toBounds(obj);
  			min2 = obj.min;
  			max2 = obj.max;

  			if (!min2 || !max2) { return this; }
  		}

  		// @property min: Point
  		// The top left corner of the rectangle.
  		// @property max: Point
  		// The bottom right corner of the rectangle.
  		if (!this.min && !this.max) {
  			this.min = min2.clone();
  			this.max = max2.clone();
  		} else {
  			this.min.x = Math.min(min2.x, this.min.x);
  			this.max.x = Math.max(max2.x, this.max.x);
  			this.min.y = Math.min(min2.y, this.min.y);
  			this.max.y = Math.max(max2.y, this.max.y);
  		}
  		return this;
  	},

  	// @method getCenter(round?: Boolean): Point
  	// Returns the center point of the bounds.
  	getCenter: function (round) {
  		return toPoint(
  		        (this.min.x + this.max.x) / 2,
  		        (this.min.y + this.max.y) / 2, round);
  	},

  	// @method getBottomLeft(): Point
  	// Returns the bottom-left point of the bounds.
  	getBottomLeft: function () {
  		return toPoint(this.min.x, this.max.y);
  	},

  	// @method getTopRight(): Point
  	// Returns the top-right point of the bounds.
  	getTopRight: function () { // -> Point
  		return toPoint(this.max.x, this.min.y);
  	},

  	// @method getTopLeft(): Point
  	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
  	getTopLeft: function () {
  		return this.min; // left, top
  	},

  	// @method getBottomRight(): Point
  	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
  	getBottomRight: function () {
  		return this.max; // right, bottom
  	},

  	// @method getSize(): Point
  	// Returns the size of the given bounds
  	getSize: function () {
  		return this.max.subtract(this.min);
  	},

  	// @method contains(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle contains the given one.
  	// @alternative
  	// @method contains(point: Point): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) {
  		var min, max;

  		if (typeof obj[0] === 'number' || obj instanceof Point) {
  			obj = toPoint(obj);
  		} else {
  			obj = toBounds(obj);
  		}

  		if (obj instanceof Bounds) {
  			min = obj.min;
  			max = obj.max;
  		} else {
  			min = max = obj;
  		}

  		return (min.x >= this.min.x) &&
  		       (max.x <= this.max.x) &&
  		       (min.y >= this.min.y) &&
  		       (max.y <= this.max.y);
  	},

  	// @method intersects(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds
  	// intersect if they have at least one point in common.
  	intersects: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
  		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

  		return xIntersects && yIntersects;
  	},

  	// @method overlaps(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
  	// overlap if their intersection is an area.
  	overlaps: function (bounds) { // (Bounds) -> Boolean
  		bounds = toBounds(bounds);

  		var min = this.min,
  		    max = this.max,
  		    min2 = bounds.min,
  		    max2 = bounds.max,
  		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
  		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

  		return xOverlaps && yOverlaps;
  	},

  	// @method isValid(): Boolean
  	// Returns `true` if the bounds are properly initialized.
  	isValid: function () {
  		return !!(this.min && this.max);
  	},


  	// @method pad(bufferRatio: Number): Bounds
  	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  	// Negative values will retract the bounds.
  	pad: function (bufferRatio) {
  		var min = this.min,
  		max = this.max,
  		heightBuffer = Math.abs(min.x - max.x) * bufferRatio,
  		widthBuffer = Math.abs(min.y - max.y) * bufferRatio;


  		return toBounds(
  			toPoint(min.x - heightBuffer, min.y - widthBuffer),
  			toPoint(max.x + heightBuffer, max.y + widthBuffer));
  	},


  	// @method equals(otherBounds: Bounds): Boolean
  	// Returns `true` if the rectangle is equivalent to the given bounds.
  	equals: function (bounds) {
  		if (!bounds) { return false; }

  		bounds = toBounds(bounds);

  		return this.min.equals(bounds.getTopLeft()) &&
  			this.max.equals(bounds.getBottomRight());
  	},
  };


  // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.
  function toBounds(a, b) {
  	if (!a || a instanceof Bounds) {
  		return a;
  	}
  	return new Bounds(a, b);
  }

  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
  	if (!corner1) { return; }

  	var latlngs = corner2 ? [corner1, corner2] : corner1;

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		this.extend(latlngs[i]);
  	}
  }

  LatLngBounds.prototype = {

  	// @method extend(latlng: LatLng): this
  	// Extend the bounds to contain the given point

  	// @alternative
  	// @method extend(otherBounds: LatLngBounds): this
  	// Extend the bounds to contain the given bounds
  	extend: function (obj) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLng) {
  			sw2 = obj;
  			ne2 = obj;

  		} else if (obj instanceof LatLngBounds) {
  			sw2 = obj._southWest;
  			ne2 = obj._northEast;

  			if (!sw2 || !ne2) { return this; }

  		} else {
  			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
  		}

  		if (!sw && !ne) {
  			this._southWest = new LatLng(sw2.lat, sw2.lng);
  			this._northEast = new LatLng(ne2.lat, ne2.lng);
  		} else {
  			sw.lat = Math.min(sw2.lat, sw.lat);
  			sw.lng = Math.min(sw2.lng, sw.lng);
  			ne.lat = Math.max(ne2.lat, ne.lat);
  			ne.lng = Math.max(ne2.lng, ne.lng);
  		}

  		return this;
  	},

  	// @method pad(bufferRatio: Number): LatLngBounds
  	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
  	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
  	// Negative values will retract the bounds.
  	pad: function (bufferRatio) {
  		var sw = this._southWest,
  		    ne = this._northEast,
  		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
  		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

  		return new LatLngBounds(
  		        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
  		        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
  	},

  	// @method getCenter(): LatLng
  	// Returns the center point of the bounds.
  	getCenter: function () {
  		return new LatLng(
  		        (this._southWest.lat + this._northEast.lat) / 2,
  		        (this._southWest.lng + this._northEast.lng) / 2);
  	},

  	// @method getSouthWest(): LatLng
  	// Returns the south-west point of the bounds.
  	getSouthWest: function () {
  		return this._southWest;
  	},

  	// @method getNorthEast(): LatLng
  	// Returns the north-east point of the bounds.
  	getNorthEast: function () {
  		return this._northEast;
  	},

  	// @method getNorthWest(): LatLng
  	// Returns the north-west point of the bounds.
  	getNorthWest: function () {
  		return new LatLng(this.getNorth(), this.getWest());
  	},

  	// @method getSouthEast(): LatLng
  	// Returns the south-east point of the bounds.
  	getSouthEast: function () {
  		return new LatLng(this.getSouth(), this.getEast());
  	},

  	// @method getWest(): Number
  	// Returns the west longitude of the bounds
  	getWest: function () {
  		return this._southWest.lng;
  	},

  	// @method getSouth(): Number
  	// Returns the south latitude of the bounds
  	getSouth: function () {
  		return this._southWest.lat;
  	},

  	// @method getEast(): Number
  	// Returns the east longitude of the bounds
  	getEast: function () {
  		return this._northEast.lng;
  	},

  	// @method getNorth(): Number
  	// Returns the north latitude of the bounds
  	getNorth: function () {
  		return this._northEast.lat;
  	},

  	// @method contains(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle contains the given one.

  	// @alternative
  	// @method contains (latlng: LatLng): Boolean
  	// Returns `true` if the rectangle contains the given point.
  	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
  		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
  			obj = toLatLng(obj);
  		} else {
  			obj = toLatLngBounds(obj);
  		}

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2, ne2;

  		if (obj instanceof LatLngBounds) {
  			sw2 = obj.getSouthWest();
  			ne2 = obj.getNorthEast();
  		} else {
  			sw2 = ne2 = obj;
  		}

  		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
  		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
  	},

  	// @method intersects(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
  	intersects: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
  		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

  		return latIntersects && lngIntersects;
  	},

  	// @method overlaps(otherBounds: LatLngBounds): Boolean
  	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
  	overlaps: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		var sw = this._southWest,
  		    ne = this._northEast,
  		    sw2 = bounds.getSouthWest(),
  		    ne2 = bounds.getNorthEast(),

  		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
  		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

  		return latOverlaps && lngOverlaps;
  	},

  	// @method toBBoxString(): String
  	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
  	toBBoxString: function () {
  		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
  	},

  	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
  	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (bounds, maxMargin) {
  		if (!bounds) { return false; }

  		bounds = toLatLngBounds(bounds);

  		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
  		       this._northEast.equals(bounds.getNorthEast(), maxMargin);
  	},

  	// @method isValid(): Boolean
  	// Returns `true` if the bounds are properly initialized.
  	isValid: function () {
  		return !!(this._southWest && this._northEast);
  	}
  };

  // TODO International date line?

  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
  function toLatLngBounds(a, b) {
  	if (a instanceof LatLngBounds) {
  		return a;
  	}
  	return new LatLngBounds(a, b);
  }

  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLng(lat, lng, alt) {
  	if (isNaN(lat) || isNaN(lng)) {
  		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
  	}

  	// @property lat: Number
  	// Latitude in degrees
  	this.lat = +lat;

  	// @property lng: Number
  	// Longitude in degrees
  	this.lng = +lng;

  	// @property alt: Number
  	// Altitude in meters (optional)
  	if (alt !== undefined) {
  		this.alt = +alt;
  	}
  }

  LatLng.prototype = {
  	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
  	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
  	equals: function (obj, maxMargin) {
  		if (!obj) { return false; }

  		obj = toLatLng(obj);

  		var margin = Math.max(
  		        Math.abs(this.lat - obj.lat),
  		        Math.abs(this.lng - obj.lng));

  		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
  	},

  	// @method toString(): String
  	// Returns a string representation of the point (for debugging purposes).
  	toString: function (precision) {
  		return 'LatLng(' +
  		        formatNum(this.lat, precision) + ', ' +
  		        formatNum(this.lng, precision) + ')';
  	},

  	// @method distanceTo(otherLatLng: LatLng): Number
  	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
  	distanceTo: function (other) {
  		return Earth.distance(this, toLatLng(other));
  	},

  	// @method wrap(): LatLng
  	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
  	wrap: function () {
  		return Earth.wrapLatLng(this);
  	},

  	// @method toBounds(sizeInMeters: Number): LatLngBounds
  	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
  	toBounds: function (sizeInMeters) {
  		var latAccuracy = 180 * sizeInMeters / 40075017,
  		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

  		return toLatLngBounds(
  		        [this.lat - latAccuracy, this.lng - lngAccuracy],
  		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
  	},

  	clone: function () {
  		return new LatLng(this.lat, this.lng, this.alt);
  	}
  };



  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
  	if (a instanceof LatLng) {
  		return a;
  	}
  	if (isArray(a) && typeof a[0] !== 'object') {
  		if (a.length === 3) {
  			return new LatLng(a[0], a[1], a[2]);
  		}
  		if (a.length === 2) {
  			return new LatLng(a[0], a[1]);
  		}
  		return null;
  	}
  	if (a === undefined || a === null) {
  		return a;
  	}
  	if (typeof a === 'object' && 'lat' in a) {
  		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
  	}
  	if (b === undefined) {
  		return null;
  	}
  	return new LatLng(a, b, c);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */

  var CRS = {
  	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
  	// Projects geographical coordinates into pixel coordinates for a given zoom.
  	latLngToPoint: function (latlng, zoom) {
  		var projectedPoint = this.projection.project(latlng),
  		    scale = this.scale(zoom);

  		return this.transformation._transform(projectedPoint, scale);
  	},

  	// @method pointToLatLng(point: Point, zoom: Number): LatLng
  	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
  	// zoom into geographical coordinates.
  	pointToLatLng: function (point, zoom) {
  		var scale = this.scale(zoom),
  		    untransformedPoint = this.transformation.untransform(point, scale);

  		return this.projection.unproject(untransformedPoint);
  	},

  	// @method project(latlng: LatLng): Point
  	// Projects geographical coordinates into coordinates in units accepted for
  	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
  	project: function (latlng) {
  		return this.projection.project(latlng);
  	},

  	// @method unproject(point: Point): LatLng
  	// Given a projected coordinate returns the corresponding LatLng.
  	// The inverse of `project`.
  	unproject: function (point) {
  		return this.projection.unproject(point);
  	},

  	// @method scale(zoom: Number): Number
  	// Returns the scale used when transforming projected coordinates into
  	// pixel coordinates for a particular zoom. For example, it returns
  	// `256 * 2^zoom` for Mercator-based CRS.
  	scale: function (zoom) {
  		return 256 * Math.pow(2, zoom);
  	},

  	// @method zoom(scale: Number): Number
  	// Inverse of `scale()`, returns the zoom level corresponding to a scale
  	// factor of `scale`.
  	zoom: function (scale) {
  		return Math.log(scale / 256) / Math.LN2;
  	},

  	// @method getProjectedBounds(zoom: Number): Bounds
  	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
  	getProjectedBounds: function (zoom) {
  		if (this.infinite) { return null; }

  		var b = this.projection.bounds,
  		    s = this.scale(zoom),
  		    min = this.transformation.transform(b.min, s),
  		    max = this.transformation.transform(b.max, s);

  		return new Bounds(min, max);
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates.

  	// @property code: String
  	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
  	//
  	// @property wrapLng: Number[]
  	// An array of two numbers defining whether the longitude (horizontal) coordinate
  	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
  	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
  	//
  	// @property wrapLat: Number[]
  	// Like `wrapLng`, but for the latitude (vertical) axis.

  	// wrapLng: [min, max],
  	// wrapLat: [min, max],

  	// @property infinite: Boolean
  	// If true, the coordinate space will be unbounded (infinite in both axes)
  	infinite: false,

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where lat and lng has been wrapped according to the
  	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
  	wrapLatLng: function (latlng) {
  		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
  		    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
  		    alt = latlng.alt;

  		return new LatLng(lat, lng, alt);
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring
  	// that its center is within the CRS's bounds.
  	// Only accepts actual `L.LatLngBounds` instances, not arrays.
  	wrapLatLngBounds: function (bounds) {
  		var center = bounds.getCenter(),
  		    newCenter = this.wrapLatLng(center),
  		    latShift = center.lat - newCenter.lat,
  		    lngShift = center.lng - newCenter.lng;

  		if (latShift === 0 && lngShift === 0) {
  			return bounds;
  		}

  		var sw = bounds.getSouthWest(),
  		    ne = bounds.getNorthEast(),
  		    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
  		    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

  		return new LatLngBounds(newSw, newNe);
  	}
  };

  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
  	wrapLng: [-180, 180],

  	// Mean Earth Radius, as recommended for use by
  	// the International Union of Geodesy and Geophysics,
  	// see https://rosettacode.org/wiki/Haversine_formula
  	R: 6371000,

  	// distance between two geographical points using spherical law of cosines approximation
  	distance: function (latlng1, latlng2) {
  		var rad = Math.PI / 180,
  		    lat1 = latlng1.lat * rad,
  		    lat2 = latlng2.lat * rad,
  		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
  		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
  		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
  		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  		return this.R * c;
  	}
  });

  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection â€” the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;

  var SphericalMercator = {

  	R: earthRadius,
  	MAX_LATITUDE: 85.0511287798,

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    max = this.MAX_LATITUDE,
  		    lat = Math.max(Math.min(max, latlng.lat), -max),
  		    sin = Math.sin(lat * d);

  		return new Point(
  			this.R * latlng.lng * d,
  			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI;

  		return new LatLng(
  			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
  			point.x * d / this.R);
  	},

  	bounds: (function () {
  		var d = earthRadius * Math.PI;
  		return new Bounds([-d, -d], [d, d]);
  	})()
  };

  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */


  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.
  function Transformation(a, b, c, d) {
  	if (isArray(a)) {
  		// use array properties
  		this._a = a[0];
  		this._b = a[1];
  		this._c = a[2];
  		this._d = a[3];
  		return;
  	}
  	this._a = a;
  	this._b = b;
  	this._c = c;
  	this._d = d;
  }

  Transformation.prototype = {
  	// @method transform(point: Point, scale?: Number): Point
  	// Returns a transformed point, optionally multiplied by the given scale.
  	// Only accepts actual `L.Point` instances, not arrays.
  	transform: function (point, scale) { // (Point, Number) -> Point
  		return this._transform(point.clone(), scale);
  	},

  	// destructive transform (faster)
  	_transform: function (point, scale) {
  		scale = scale || 1;
  		point.x = scale * (this._a * point.x + this._b);
  		point.y = scale * (this._c * point.y + this._d);
  		return point;
  	},

  	// @method untransform(point: Point, scale?: Number): Point
  	// Returns the reverse transformation of the given point, optionally divided
  	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
  	untransform: function (point, scale) {
  		scale = scale || 1;
  		return new Point(
  		        (point.x / scale - this._b) / this._a,
  		        (point.y / scale - this._d) / this._c);
  	}
  };

  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)

  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.

  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
  	return new Transformation(a, b, c, d);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */

  var EPSG3857 = extend({}, Earth, {
  	code: 'EPSG:3857',
  	projection: SphericalMercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * SphericalMercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  var EPSG900913 = extend({}, EPSG3857, {
  	code: 'EPSG:900913'
  });

  // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:

  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
  function svgCreate(name) {
  	return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions
  function pointsToPath(rings, closed) {
  	var str = '',
  	i, j, len, len2, points, p;

  	for (i = 0, len = rings.length; i < len; i++) {
  		points = rings[i];

  		for (j = 0, len2 = points.length; j < len2; j++) {
  			p = points[j];
  			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
  		}

  		// closes the ring for polygons; "x" is VML syntax
  		str += closed ? (Browser.svg ? 'z' : 'x') : '';
  	}

  	// SVG complains about empty path strings
  	return str || 'M0 0';
  }

  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */

  var style = document.documentElement.style;

  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
  var ie = 'ActiveXObject' in window;

  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
  var ielt9 = ie && !document.addEventListener;

  // @property edge: Boolean; `true` for the Edge web browser.
  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

  // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
  var webkit = userAgentContains('webkit');

  // @property android: Boolean
  // **Deprecated.** `true` for any browser running on an Android platform.
  var android = userAgentContains('android');

  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.
  var android23 = userAgentContains('android 2') || userAgentContains('android 3');

  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)
  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

  // @property opera: Boolean; `true` for the Opera browser
  var opera = !!window.opera;

  // @property chrome: Boolean; `true` for the Chrome browser.
  var chrome = !edge && userAgentContains('chrome');

  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

  // @property safari: Boolean; `true` for the Safari browser.
  var safari = !chrome && userAgentContains('safari');

  var phantom = userAgentContains('phantom');

  // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).
  var opera12 = 'OTransition' in style;

  // @property win: Boolean; `true` when the browser is running in a Windows platform
  var win = navigator.platform.indexOf('Win') === 0;

  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
  var ie3d = ie && ('transition' in style);

  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
  var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
  var gecko3d = 'MozPerspective' in style;

  // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.
  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

  // @property mobile: Boolean; `true` for all browsers running in a mobile device.
  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
  var mobileWebkit = mobile && webkit;

  // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
  var mobileWebkit3d = mobile && webkit3d;

  // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).
  var msPointer = !window.PointerEvent && window.MSPointerEvent;

  // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
  var pointer = !!(window.PointerEvent || msPointer);

  // @property touchNative: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // **This does not necessarily mean** that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.
  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;

  // @property touch: Boolean
  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.
  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.
  var touch = !window.L_NO_TOUCH && (touchNative || pointer);

  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
  var mobileOpera = mobile && opera;

  // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.
  var mobileGecko = mobile && gecko;

  // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
  var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;

  // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.
  var passiveEvents = (function () {
  	var supportsPassiveOption = false;
  	try {
  		var opts = Object.defineProperty({}, 'passive', {
  			get: function () { // eslint-disable-line getter-return
  				supportsPassiveOption = true;
  			}
  		});
  		window.addEventListener('testPassiveEventSupport', falseFn, opts);
  		window.removeEventListener('testPassiveEventSupport', falseFn, opts);
  	} catch (e) {
  		// Errors can safely be ignored since this is only a browser support test.
  	}
  	return supportsPassiveOption;
  }());

  // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
  var canvas$1 = (function () {
  	return !!document.createElement('canvas').getContext;
  }());

  // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);

  var inlineSvg = !!svg$1 && (function () {
  	var div = document.createElement('div');
  	div.innerHTML = '<svg/>';
  	return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';
  })();

  // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
  var vml = !svg$1 && (function () {
  	try {
  		var div = document.createElement('div');
  		div.innerHTML = '<v:shape adj="1"/>';

  		var shape = div.firstChild;
  		shape.style.behavior = 'url(#default#VML)';

  		return shape && (typeof shape.adj === 'object');

  	} catch (e) {
  		return false;
  	}
  }());


  // @property mac: Boolean; `true` when the browser is running in a Mac platform
  var mac = navigator.platform.indexOf('Mac') === 0;

  // @property mac: Boolean; `true` when the browser is running in a Linux platform
  var linux = navigator.platform.indexOf('Linux') === 0;

  function userAgentContains(str) {
  	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }


  var Browser = {
  	ie: ie,
  	ielt9: ielt9,
  	edge: edge,
  	webkit: webkit,
  	android: android,
  	android23: android23,
  	androidStock: androidStock,
  	opera: opera,
  	chrome: chrome,
  	gecko: gecko,
  	safari: safari,
  	phantom: phantom,
  	opera12: opera12,
  	win: win,
  	ie3d: ie3d,
  	webkit3d: webkit3d,
  	gecko3d: gecko3d,
  	any3d: any3d,
  	mobile: mobile,
  	mobileWebkit: mobileWebkit,
  	mobileWebkit3d: mobileWebkit3d,
  	msPointer: msPointer,
  	pointer: pointer,
  	touch: touch,
  	touchNative: touchNative,
  	mobileOpera: mobileOpera,
  	mobileGecko: mobileGecko,
  	retina: retina,
  	passiveEvents: passiveEvents,
  	canvas: canvas$1,
  	svg: svg$1,
  	vml: vml,
  	inlineSvg: inlineSvg,
  	mac: mac,
  	linux: linux
  };

  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN =   Browser.msPointer ? 'MSPointerDown'   : 'pointerdown';
  var POINTER_MOVE =   Browser.msPointer ? 'MSPointerMove'   : 'pointermove';
  var POINTER_UP =     Browser.msPointer ? 'MSPointerUp'     : 'pointerup';
  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';
  var pEvent = {
  	touchstart  : POINTER_DOWN,
  	touchmove   : POINTER_MOVE,
  	touchend    : POINTER_UP,
  	touchcancel : POINTER_CANCEL
  };
  var handle = {
  	touchstart  : _onPointerStart,
  	touchmove   : _handlePointer,
  	touchend    : _handlePointer,
  	touchcancel : _handlePointer
  };
  var _pointers = {};
  var _pointerDocListener = false;

  // Provides a touch events wrapper for (ms)pointer events.
  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler) {
  	if (type === 'touchstart') {
  		_addPointerDocListener();
  	}
  	if (!handle[type]) {
  		console.warn('wrong event specified:', type);
  		return falseFn;
  	}
  	handler = handle[type].bind(this, handler);
  	obj.addEventListener(pEvent[type], handler, false);
  	return handler;
  }

  function removePointerListener(obj, type, handler) {
  	if (!pEvent[type]) {
  		console.warn('wrong event specified:', type);
  		return;
  	}
  	obj.removeEventListener(pEvent[type], handler, false);
  }

  function _globalPointerDown(e) {
  	_pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
  	if (_pointers[e.pointerId]) {
  		_pointers[e.pointerId] = e;
  	}
  }

  function _globalPointerUp(e) {
  	delete _pointers[e.pointerId];
  }

  function _addPointerDocListener() {
  	// need to keep track of what pointers and how many are active to provide e.touches emulation
  	if (!_pointerDocListener) {
  		// we listen document as any drags that end by moving the touch off the screen get fired there
  		document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
  		document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
  		document.addEventListener(POINTER_UP, _globalPointerUp, true);
  		document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

  		_pointerDocListener = true;
  	}
  }

  function _handlePointer(handler, e) {
  	if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) { return; }

  	e.touches = [];
  	for (var i in _pointers) {
  		e.touches.push(_pointers[i]);
  	}
  	e.changedTouches = [e];

  	handler(e);
  }

  function _onPointerStart(handler, e) {
  	// IE10 specific: MsTouch needs preventDefault. See #2000
  	if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
  		preventDefault(e);
  	}
  	_handlePointer(handler, e);
  }

  /*
   * Extends the event handling code with double tap support for mobile browsers.
   *
   * Note: currently most browsers fire native dblclick, with only a few exceptions
   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)
   */

  function makeDblclick(event) {
  	// in modern browsers `type` cannot be just overridden:
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only
  	var newEvent = {},
  	    prop, i;
  	for (i in event) {
  		prop = event[i];
  		newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
  	}
  	event = newEvent;
  	newEvent.type = 'dblclick';
  	newEvent.detail = 2;
  	newEvent.isTrusted = false;
  	newEvent._simulated = true; // for debug purposes
  	return newEvent;
  }

  var delay = 200;
  function addDoubleTapListener(obj, handler) {
  	// Most browsers handle double tap natively
  	obj.addEventListener('dblclick', handler);

  	// On some platforms the browser doesn't fire native dblclicks for touch events.
  	// It seems that in all such cases `detail` property of `click` event is always `1`.
  	// So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.
  	var last = 0,
  	    detail;
  	function simDblclick(e) {
  		if (e.detail !== 1) {
  			detail = e.detail; // keep in sync to avoid false dblclick in some cases
  			return;
  		}

  		if (e.pointerType === 'mouse' ||
  			(e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents)) {

  			return;
  		}

  		// When clicking on an <input>, the browser generates a click on its
  		// <label> (and vice versa) triggering two clicks in quick succession.
  		// This ignores clicks on elements which are a label with a 'for'
  		// attribute (or children of such a label), but not children of
  		// a <input>.
  		var path = getPropagationPath(e);
  		if (path.some(function (el) {
  			return el instanceof HTMLLabelElement && el.attributes.for;
  		}) &&
  			!path.some(function (el) {
  				return (
  					el instanceof HTMLInputElement ||
  					el instanceof HTMLSelectElement
  				);
  			})
  		) {
  			return;
  		}

  		var now = Date.now();
  		if (now - last <= delay) {
  			detail++;
  			if (detail === 2) {
  				handler(makeDblclick(e));
  			}
  		} else {
  			detail = 1;
  		}
  		last = now;
  	}

  	obj.addEventListener('click', simDblclick);

  	return {
  		dblclick: handler,
  		simDblclick: simDblclick
  	};
  }

  function removeDoubleTapListener(obj, handlers) {
  	obj.removeEventListener('dblclick', handlers.dblclick);
  	obj.removeEventListener('click', handlers.simDblclick);
  }

  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */


  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
  var TRANSFORM = testProp(
  	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

  // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser

  // @property TRANSITION: String
  // Vendor-prefixed transition style name.
  var TRANSITION = testProp(
  	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

  // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.
  var TRANSITION_END =
  	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


  // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.
  function get(id) {
  	return typeof id === 'string' ? document.getElementById(id) : id;
  }

  // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.
  function getStyle(el, style) {
  	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

  	if ((!value || value === 'auto') && document.defaultView) {
  		var css = document.defaultView.getComputedStyle(el, null);
  		value = css ? css[style] : null;
  	}
  	return value === 'auto' ? null : value;
  }

  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
  function create$1(tagName, className, container) {
  	var el = document.createElement(tagName);
  	el.className = className || '';

  	if (container) {
  		container.appendChild(el);
  	}
  	return el;
  }

  // @function remove(el: HTMLElement)
  // Removes `el` from its parent element
  function remove(el) {
  	var parent = el.parentNode;
  	if (parent) {
  		parent.removeChild(el);
  	}
  }

  // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`
  function empty(el) {
  	while (el.firstChild) {
  		el.removeChild(el.firstChild);
  	}
  }

  // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.
  function toFront(el) {
  	var parent = el.parentNode;
  	if (parent && parent.lastChild !== el) {
  		parent.appendChild(el);
  	}
  }

  // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.
  function toBack(el) {
  	var parent = el.parentNode;
  	if (parent && parent.firstChild !== el) {
  		parent.insertBefore(el, parent.firstChild);
  	}
  }

  // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.
  function hasClass(el, name) {
  	if (el.classList !== undefined) {
  		return el.classList.contains(name);
  	}
  	var className = getClass(el);
  	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  }

  // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.
  function addClass(el, name) {
  	if (el.classList !== undefined) {
  		var classes = splitWords(name);
  		for (var i = 0, len = classes.length; i < len; i++) {
  			el.classList.add(classes[i]);
  		}
  	} else if (!hasClass(el, name)) {
  		var className = getClass(el);
  		setClass(el, (className ? className + ' ' : '') + name);
  	}
  }

  // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.
  function removeClass(el, name) {
  	if (el.classList !== undefined) {
  		el.classList.remove(name);
  	} else {
  		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
  	}
  }

  // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.
  function setClass(el, name) {
  	if (el.className.baseVal === undefined) {
  		el.className = name;
  	} else {
  		// in case of SVG element
  		el.className.baseVal = name;
  	}
  }

  // @function getClass(el: HTMLElement): String
  // Returns the element's class.
  function getClass(el) {
  	// Check if the element is an SVGElementInstance and use the correspondingElement instead
  	// (Required for linked SVG elements in IE11.)
  	if (el.correspondingElement) {
  		el = el.correspondingElement;
  	}
  	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  }

  // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.
  function setOpacity(el, value) {
  	if ('opacity' in el.style) {
  		el.style.opacity = value;
  	} else if ('filter' in el.style) {
  		_setOpacityIE(el, value);
  	}
  }

  function _setOpacityIE(el, value) {
  	var filter = false,
  	    filterName = 'DXImageTransform.Microsoft.Alpha';

  	// filters collection throws an error if we try to retrieve a filter that doesn't exist
  	try {
  		filter = el.filters.item(filterName);
  	} catch (e) {
  		// don't set opacity to 1 if we haven't already set an opacity,
  		// it isn't needed and breaks transparent pngs.
  		if (value === 1) { return; }
  	}

  	value = Math.round(value * 100);

  	if (filter) {
  		filter.Enabled = (value !== 100);
  		filter.Opacity = value;
  	} else {
  		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
  	}
  }

  // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.
  function testProp(props) {
  	var style = document.documentElement.style;

  	for (var i = 0; i < props.length; i++) {
  		if (props[i] in style) {
  			return props[i];
  		}
  	}
  	return false;
  }

  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.
  function setTransform(el, offset, scale) {
  	var pos = offset || new Point(0, 0);

  	el.style[TRANSFORM] =
  		(Browser.ie3d ?
  			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
  			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
  		(scale ? ' scale(' + scale + ')' : '');
  }

  // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).
  function setPosition(el, point) {

  	/*eslint-disable */
  	el._leaflet_pos = point;
  	/* eslint-enable */

  	if (Browser.any3d) {
  		setTransform(el, point);
  	} else {
  		el.style.left = point.x + 'px';
  		el.style.top = point.y + 'px';
  	}
  }

  // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.
  function getPosition(el) {
  	// this method is only used for elements previously positioned using setPosition,
  	// so it's safe to cache the position for performance

  	return el._leaflet_pos || new Point(0, 0);
  }

  // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.

  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
  var disableTextSelection;
  var enableTextSelection;
  var _userSelect;
  if ('onselectstart' in document) {
  	disableTextSelection = function () {
  		on(window, 'selectstart', preventDefault);
  	};
  	enableTextSelection = function () {
  		off(window, 'selectstart', preventDefault);
  	};
  } else {
  	var userSelectProperty = testProp(
  		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

  	disableTextSelection = function () {
  		if (userSelectProperty) {
  			var style = document.documentElement.style;
  			_userSelect = style[userSelectProperty];
  			style[userSelectProperty] = 'none';
  		}
  	};
  	enableTextSelection = function () {
  		if (userSelectProperty) {
  			document.documentElement.style[userSelectProperty] = _userSelect;
  			_userSelect = undefined;
  		}
  	};
  }

  // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.
  function disableImageDrag() {
  	on(window, 'dragstart', preventDefault);
  }

  // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
  function enableImageDrag() {
  	off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle;
  // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.
  function preventOutline(element) {
  	while (element.tabIndex === -1) {
  		element = element.parentNode;
  	}
  	if (!element.style) { return; }
  	restoreOutline();
  	_outlineElement = element;
  	_outlineStyle = element.style.outlineStyle;
  	element.style.outlineStyle = 'none';
  	on(window, 'keydown', restoreOutline);
  }

  // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
  function restoreOutline() {
  	if (!_outlineElement) { return; }
  	_outlineElement.style.outlineStyle = _outlineStyle;
  	_outlineElement = undefined;
  	_outlineStyle = undefined;
  	off(window, 'keydown', restoreOutline);
  }

  // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.
  function getSizedParentNode(element) {
  	do {
  		element = element.parentNode;
  	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
  	return element;
  }

  // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  function getScale(element) {
  	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

  	return {
  		x: rect.width / element.offsetWidth || 1,
  		y: rect.height / element.offsetHeight || 1,
  		boundingClientRect: rect
  	};
  }

  var DomUtil = {
    __proto__: null,
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    get disableTextSelection () { return disableTextSelection; },
    get enableTextSelection () { return enableTextSelection; },
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };

  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */

  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).

  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function on(obj, types, fn, context) {

  	if (types && typeof types === 'object') {
  		for (var type in types) {
  			addOne(obj, type, types[type], fn);
  		}
  	} else {
  		types = splitWords(types);

  		for (var i = 0, len = types.length; i < len; i++) {
  			addOne(obj, types[i], fn, context);
  		}
  	}

  	return this;
  }

  var eventsKey = '_leaflet_events';

  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.

  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  // @alternative
  // @function off(el: HTMLElement, types: String): this
  // Removes all previously added listeners of given types.

  // @alternative
  // @function off(el: HTMLElement): this
  // Removes all previously added listeners from given HTMLElement
  function off(obj, types, fn, context) {

  	if (arguments.length === 1) {
  		batchRemove(obj);
  		delete obj[eventsKey];

  	} else if (types && typeof types === 'object') {
  		for (var type in types) {
  			removeOne(obj, type, types[type], fn);
  		}

  	} else {
  		types = splitWords(types);

  		if (arguments.length === 2) {
  			batchRemove(obj, function (type) {
  				return indexOf(types, type) !== -1;
  			});
  		} else {
  			for (var i = 0, len = types.length; i < len; i++) {
  				removeOne(obj, types[i], fn, context);
  			}
  		}
  	}

  	return this;
  }

  function batchRemove(obj, filterFn) {
  	for (var id in obj[eventsKey]) {
  		var type = id.split(/\d/)[0];
  		if (!filterFn || filterFn(type)) {
  			removeOne(obj, type, null, null, id);
  		}
  	}
  }

  var mouseSubst = {
  	mouseenter: 'mouseover',
  	mouseleave: 'mouseout',
  	wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
  	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

  	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

  	var handler = function (e) {
  		return fn.call(context || obj, e || window.event);
  	};

  	var originalHandler = handler;

  	if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
  		// Needs DomEvent.Pointer.js
  		handler = addPointerListener(obj, type, handler);

  	} else if (Browser.touch && (type === 'dblclick')) {
  		handler = addDoubleTapListener(obj, handler);

  	} else if ('addEventListener' in obj) {

  		if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' ||  type === 'mousewheel') {
  			obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {passive: false} : false);

  		} else if (type === 'mouseenter' || type === 'mouseleave') {
  			handler = function (e) {
  				e = e || window.event;
  				if (isExternalTarget(obj, e)) {
  					originalHandler(e);
  				}
  			};
  			obj.addEventListener(mouseSubst[type], handler, false);

  		} else {
  			obj.addEventListener(type, originalHandler, false);
  		}

  	} else {
  		obj.attachEvent('on' + type, handler);
  	}

  	obj[eventsKey] = obj[eventsKey] || {};
  	obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context, id) {
  	id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');
  	var handler = obj[eventsKey] && obj[eventsKey][id];

  	if (!handler) { return this; }

  	if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
  		removePointerListener(obj, type, handler);

  	} else if (Browser.touch && (type === 'dblclick')) {
  		removeDoubleTapListener(obj, handler);

  	} else if ('removeEventListener' in obj) {

  		obj.removeEventListener(mouseSubst[type] || type, handler, false);

  	} else {
  		obj.detachEvent('on' + type, handler);
  	}

  	obj[eventsKey][id] = null;
  }

  // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```
  function stopPropagation(e) {

  	if (e.stopPropagation) {
  		e.stopPropagation();
  	} else if (e.originalEvent) {  // In case of Leaflet event.
  		e.originalEvent._stopped = true;
  	} else {
  		e.cancelBubble = true;
  	}

  	return this;
  }

  // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
  function disableScrollPropagation(el) {
  	addOne(el, 'wheel', stopPropagation);
  	return this;
  }

  // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).
  function disableClickPropagation(el) {
  	on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);
  	el['_leaflet_disable_click'] = true;
  	return this;
  }

  // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.
  function preventDefault(e) {
  	if (e.preventDefault) {
  		e.preventDefault();
  	} else {
  		e.returnValue = false;
  	}
  	return this;
  }

  // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.
  function stop(e) {
  	preventDefault(e);
  	stopPropagation(e);
  	return this;
  }

  // @function getPropagationPath(ev: DOMEvent): Array
  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).
  // Returns an array containing the `HTMLElement`s that the given DOM event
  // should propagate to (if not stopped).
  function getPropagationPath(ev) {
  	if (ev.composedPath) {
  		return ev.composedPath();
  	}

  	var path = [];
  	var el = ev.target;

  	while (el) {
  		path.push(el);
  		el = el.parentNode;
  	}
  	return path;
  }


  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.
  function getMousePosition(e, container) {
  	if (!container) {
  		return new Point(e.clientX, e.clientY);
  	}

  	var scale = getScale(container),
  	    offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

  	return new Point(
  		// offset.left/top values are in page scale (like clientX/Y),
  		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
  		(e.clientX - offset.left) / scale.x - container.clientLeft,
  		(e.clientY - offset.top) / scale.y - container.clientTop
  	);
  }


  //  except , Safari and
  // We need double the scroll pixels (see #7403 and #4538) for all Browsers
  // except OSX (Mac) -> 3x, Chrome running on Linux 1x

  var wheelPxFactor =
  	(Browser.linux && Browser.chrome) ? window.devicePixelRatio :
  	Browser.mac ? window.devicePixelRatio * 3 :
  	window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
  // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.
  function getWheelDelta(e) {
  	return (Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
  	       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
  	       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
  	       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
  	       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
  	       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
  	       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
  	       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
  	       0;
  }

  // check if element really left/entered the event target (for mouseenter/mouseleave)
  function isExternalTarget(el, e) {

  	var related = e.relatedTarget;

  	if (!related) { return true; }

  	try {
  		while (related && (related !== el)) {
  			related = related.parentNode;
  		}
  	} catch (err) {
  		return false;
  	}
  	return (related !== el);
  }

  var DomEvent = {
    __proto__: null,
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getPropagationPath: getPropagationPath,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };

  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);
   *
   * myPositionMarker.on("click", function() {
   * 	var pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());
   * 	pos.y -= 25;
   * 	var fx = new L.PosAnimation();
   *
   * 	fx.once('end',function() {
   * 		pos.y += 25;
   * 		fx.run(myPositionMarker._icon, pos, 0.8);
   * 	});
   *
   * 	fx.run(myPositionMarker._icon, pos, 0.3);
   * });
   *
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({

  	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
  	// Run an animation of a given element to a new position, optionally setting
  	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
  	// argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
  	// `0.5` by default).
  	run: function (el, newPos, duration, easeLinearity) {
  		this.stop();

  		this._el = el;
  		this._inProgress = true;
  		this._duration = duration || 0.25;
  		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

  		this._startPos = getPosition(el);
  		this._offset = newPos.subtract(this._startPos);
  		this._startTime = +new Date();

  		// @event start: Event
  		// Fired when the animation starts
  		this.fire('start');

  		this._animate();
  	},

  	// @method stop()
  	// Stops the animation (if currently running).
  	stop: function () {
  		if (!this._inProgress) { return; }

  		this._step(true);
  		this._complete();
  	},

  	_animate: function () {
  		// animation loop
  		this._animId = requestAnimFrame(this._animate, this);
  		this._step();
  	},

  	_step: function (round) {
  		var elapsed = (+new Date()) - this._startTime,
  		    duration = this._duration * 1000;

  		if (elapsed < duration) {
  			this._runFrame(this._easeOut(elapsed / duration), round);
  		} else {
  			this._runFrame(1);
  			this._complete();
  		}
  	},

  	_runFrame: function (progress, round) {
  		var pos = this._startPos.add(this._offset.multiplyBy(progress));
  		if (round) {
  			pos._round();
  		}
  		setPosition(this._el, pos);

  		// @event step: Event
  		// Fired continuously during the animation.
  		this.fire('step');
  	},

  	_complete: function () {
  		cancelAnimFrame(this._animId);

  		this._inProgress = false;
  		// @event end: Event
  		// Fired when the animation ends.
  		this.fire('end');
  	},

  	_easeOut: function (t) {
  		return 1 - Math.pow(1 - t, this._easeOutPower);
  	}
  });

  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API â€” it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({

  	options: {
  		// @section Map State Options
  		// @option crs: CRS = L.CRS.EPSG3857
  		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
  		// sure what it means.
  		crs: EPSG3857,

  		// @option center: LatLng = undefined
  		// Initial geographic center of the map
  		center: undefined,

  		// @option zoom: Number = undefined
  		// Initial map zoom level
  		zoom: undefined,

  		// @option minZoom: Number = *
  		// Minimum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the lowest of their `minZoom` options will be used instead.
  		minZoom: undefined,

  		// @option maxZoom: Number = *
  		// Maximum zoom level of the map.
  		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
  		// the highest of their `maxZoom` options will be used instead.
  		maxZoom: undefined,

  		// @option layers: Layer[] = []
  		// Array of layers that will be added to the map initially
  		layers: [],

  		// @option maxBounds: LatLngBounds = null
  		// When this option is set, the map restricts the view to the given
  		// geographical bounds, bouncing the user back if the user tries to pan
  		// outside the view. To set the restriction dynamically, use
  		// [`setMaxBounds`](#map-setmaxbounds) method.
  		maxBounds: undefined,

  		// @option renderer: Renderer = *
  		// The default method for drawing vector layers on the map. `L.SVG`
  		// or `L.Canvas` by default depending on browser support.
  		renderer: undefined,


  		// @section Animation Options
  		// @option zoomAnimation: Boolean = true
  		// Whether the map zoom animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		zoomAnimation: true,

  		// @option zoomAnimationThreshold: Number = 4
  		// Won't animate zoom if the zoom difference exceeds this value.
  		zoomAnimationThreshold: 4,

  		// @option fadeAnimation: Boolean = true
  		// Whether the tile fade animation is enabled. By default it's enabled
  		// in all browsers that support CSS3 Transitions except Android.
  		fadeAnimation: true,

  		// @option markerZoomAnimation: Boolean = true
  		// Whether markers animate their zoom with the zoom animation, if disabled
  		// they will disappear for the length of the animation. By default it's
  		// enabled in all browsers that support CSS3 Transitions except Android.
  		markerZoomAnimation: true,

  		// @option transform3DLimit: Number = 2^23
  		// Defines the maximum size of a CSS translation transform. The default
  		// value should not be changed unless a web browser positions layers in
  		// the wrong place after doing a large `panBy`.
  		transform3DLimit: 8388608, // Precision limit of a 32-bit float

  		// @section Interaction Options
  		// @option zoomSnap: Number = 1
  		// Forces the map's zoom level to always be a multiple of this, particularly
  		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
  		// By default, the zoom level snaps to the nearest integer; lower values
  		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
  		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
  		zoomSnap: 1,

  		// @option zoomDelta: Number = 1
  		// Controls how much the map's zoom level will change after a
  		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
  		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
  		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
  		zoomDelta: 1,

  		// @option trackResize: Boolean = true
  		// Whether the map automatically handles browser window resize to update itself.
  		trackResize: true
  	},

  	initialize: function (id, options) { // (HTMLElement or String, Object)
  		options = setOptions(this, options);

  		// Make sure to assign internal flags at the beginning,
  		// to avoid inconsistent state in some edge cases.
  		this._handlers = [];
  		this._layers = {};
  		this._zoomBoundLayers = {};
  		this._sizeChanged = true;

  		this._initContainer(id);
  		this._initLayout();

  		// hack for https://github.com/Leaflet/Leaflet/issues/1980
  		this._onResize = bind(this._onResize, this);

  		this._initEvents();

  		if (options.maxBounds) {
  			this.setMaxBounds(options.maxBounds);
  		}

  		if (options.zoom !== undefined) {
  			this._zoom = this._limitZoom(options.zoom);
  		}

  		if (options.center && options.zoom !== undefined) {
  			this.setView(toLatLng(options.center), options.zoom, {reset: true});
  		}

  		this.callInitHooks();

  		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
  		this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera &&
  				this.options.zoomAnimation;

  		// zoom transitions run with the same duration for all layers, so if one of transitionend events
  		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
  		if (this._zoomAnimated) {
  			this._createAnimProxy();
  			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
  		}

  		this._addLayers(this.options.layers);
  	},


  	// @section Methods for modifying map state

  	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) with the given
  	// animation options.
  	setView: function (center, zoom, options) {

  		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
  		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
  		options = options || {};

  		this._stop();

  		if (this._loaded && !options.reset && options !== true) {

  			if (options.animate !== undefined) {
  				options.zoom = extend({animate: options.animate}, options.zoom);
  				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
  			}

  			// try animating pan or zoom
  			var moved = (this._zoom !== zoom) ?
  				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
  				this._tryAnimatedPan(center, options.pan);

  			if (moved) {
  				// prevent resize handler call, the view will refresh after animation anyway
  				clearTimeout(this._sizeTimer);
  				return this;
  			}
  		}

  		// animation didn't start, just reset the map view
  		this._resetView(center, zoom, options.pan && options.pan.noMoveStart);

  		return this;
  	},

  	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
  	// Sets the zoom of the map.
  	setZoom: function (zoom, options) {
  		if (!this._loaded) {
  			this._zoom = zoom;
  			return this;
  		}
  		return this.setView(this.getCenter(), zoom, {zoom: options});
  	},

  	// @method zoomIn(delta?: Number, options?: Zoom options): this
  	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomIn: function (delta, options) {
  		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom + delta, options);
  	},

  	// @method zoomOut(delta?: Number, options?: Zoom options): this
  	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
  	zoomOut: function (delta, options) {
  		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
  		return this.setZoom(this._zoom - delta, options);
  	},

  	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified geographical point on the map
  	// stationary (e.g. used internally for scroll zoom and double-click zoom).
  	// @alternative
  	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
  	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
  	setZoomAround: function (latlng, zoom, options) {
  		var scale = this.getZoomScale(zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

  		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
  		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

  		return this.setView(newCenter, zoom, {zoom: options});
  	},

  	_getBoundsCenterZoom: function (bounds, options) {

  		options = options || {};
  		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

  		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

  		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

  		if (zoom === Infinity) {
  			return {
  				center: bounds.getCenter(),
  				zoom: zoom
  			};
  		}

  		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

  		    swPoint = this.project(bounds.getSouthWest(), zoom),
  		    nePoint = this.project(bounds.getNorthEast(), zoom),
  		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

  		return {
  			center: center,
  			zoom: zoom
  		};
  	},

  	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets a map view that contains the given geographical bounds with the
  	// maximum zoom level possible.
  	fitBounds: function (bounds, options) {

  		bounds = toLatLngBounds(bounds);

  		if (!bounds.isValid()) {
  			throw new Error('Bounds are not valid.');
  		}

  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.setView(target.center, target.zoom, options);
  	},

  	// @method fitWorld(options?: fitBounds options): this
  	// Sets a map view that mostly contains the whole world with the maximum
  	// zoom level possible.
  	fitWorld: function (options) {
  		return this.fitBounds([[-90, -180], [90, 180]], options);
  	},

  	// @method panTo(latlng: LatLng, options?: Pan options): this
  	// Pans the map to a given center.
  	panTo: function (center, options) { // (LatLng)
  		return this.setView(center, this._zoom, {pan: options});
  	},

  	// @method panBy(offset: Point, options?: Pan options): this
  	// Pans the map by a given number of pixels (animated).
  	panBy: function (offset, options) {
  		offset = toPoint(offset).round();
  		options = options || {};

  		if (!offset.x && !offset.y) {
  			return this.fire('moveend');
  		}
  		// If we pan too far, Chrome gets issues with tiles
  		// and makes them disappear or appear in the wrong place (slightly offset) #2602
  		if (options.animate !== true && !this.getSize().contains(offset)) {
  			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
  			return this;
  		}

  		if (!this._panAnim) {
  			this._panAnim = new PosAnimation();

  			this._panAnim.on({
  				'step': this._onPanTransitionStep,
  				'end': this._onPanTransitionEnd
  			}, this);
  		}

  		// don't fire movestart if animating inertia
  		if (!options.noMoveStart) {
  			this.fire('movestart');
  		}

  		// animate pan unless animate: false specified
  		if (options.animate !== false) {
  			addClass(this._mapPane, 'leaflet-pan-anim');

  			var newPos = this._getMapPanePos().subtract(offset).round();
  			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
  		} else {
  			this._rawPanBy(offset);
  			this.fire('move').fire('moveend');
  		}

  		return this;
  	},

  	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
  	// Sets the view of the map (geographical center and zoom) performing a smooth
  	// pan-zoom animation.
  	flyTo: function (targetCenter, targetZoom, options) {

  		options = options || {};
  		if (options.animate === false || !Browser.any3d) {
  			return this.setView(targetCenter, targetZoom, options);
  		}

  		this._stop();

  		var from = this.project(this.getCenter()),
  		    to = this.project(targetCenter),
  		    size = this.getSize(),
  		    startZoom = this._zoom;

  		targetCenter = toLatLng(targetCenter);
  		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

  		var w0 = Math.max(size.x, size.y),
  		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
  		    u1 = (to.distanceTo(from)) || 1,
  		    rho = 1.42,
  		    rho2 = rho * rho;

  		function r(i) {
  			var s1 = i ? -1 : 1,
  			    s2 = i ? w1 : w0,
  			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
  			    b1 = 2 * s2 * rho2 * u1,
  			    b = t1 / b1,
  			    sq = Math.sqrt(b * b + 1) - b;

  			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
  			    // thus triggering an infinite loop in flyTo
  			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

  			return log;
  		}

  		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
  		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
  		function tanh(n) { return sinh(n) / cosh(n); }

  		var r0 = r(0);

  		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
  		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

  		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

  		var start = Date.now(),
  		    S = (r(1) - r0) / rho,
  		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

  		function frame() {
  			var t = (Date.now() - start) / duration,
  			    s = easeOut(t) * S;

  			if (t <= 1) {
  				this._flyToFrame = requestAnimFrame(frame, this);

  				this._move(
  					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
  					this.getScaleZoom(w0 / w(s), startZoom),
  					{flyTo: true});

  			} else {
  				this
  					._move(targetCenter, targetZoom)
  					._moveEnd(true);
  			}
  		}

  		this._moveStart(true, options.noMoveStart);

  		frame.call(this);
  		return this;
  	},

  	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
  	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
  	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
  	flyToBounds: function (bounds, options) {
  		var target = this._getBoundsCenterZoom(bounds, options);
  		return this.flyTo(target.center, target.zoom, options);
  	},

  	// @method setMaxBounds(bounds: LatLngBounds): this
  	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
  	setMaxBounds: function (bounds) {
  		bounds = toLatLngBounds(bounds);

  		if (this.listens('moveend', this._panInsideMaxBounds)) {
  			this.off('moveend', this._panInsideMaxBounds);
  		}

  		if (!bounds.isValid()) {
  			this.options.maxBounds = null;
  			return this;
  		}

  		this.options.maxBounds = bounds;

  		if (this._loaded) {
  			this._panInsideMaxBounds();
  		}

  		return this.on('moveend', this._panInsideMaxBounds);
  	},

  	// @method setMinZoom(zoom: Number): this
  	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
  	setMinZoom: function (zoom) {
  		var oldZoom = this.options.minZoom;
  		this.options.minZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() < this.options.minZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method setMaxZoom(zoom: Number): this
  	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
  	setMaxZoom: function (zoom) {
  		var oldZoom = this.options.maxZoom;
  		this.options.maxZoom = zoom;

  		if (this._loaded && oldZoom !== zoom) {
  			this.fire('zoomlevelschange');

  			if (this.getZoom() > this.options.maxZoom) {
  				return this.setZoom(zoom);
  			}
  		}

  		return this;
  	},

  	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
  	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
  	panInsideBounds: function (bounds, options) {
  		this._enforcingBounds = true;
  		var center = this.getCenter(),
  		    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

  		if (!center.equals(newCenter)) {
  			this.panTo(newCenter, options);
  		}

  		this._enforcingBounds = false;
  		return this;
  	},

  	// @method panInside(latlng: LatLng, options?: padding options): this
  	// Pans the map the minimum amount to make the `latlng` visible. Use
  	// padding options to fit the display to more restricted bounds.
  	// If `latlng` is already within the (optionally padded) display bounds,
  	// the map will not be panned.
  	panInside: function (latlng, options) {
  		options = options || {};

  		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
  		    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
  		    pixelCenter = this.project(this.getCenter()),
  		    pixelPoint = this.project(latlng),
  		    pixelBounds = this.getPixelBounds(),
  		    paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),
  		    paddedSize = paddedBounds.getSize();

  		if (!paddedBounds.contains(pixelPoint)) {
  			this._enforcingBounds = true;
  			var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
  			var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
  			pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
  			pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
  			this.panTo(this.unproject(pixelCenter), options);
  			this._enforcingBounds = false;
  		}
  		return this;
  	},

  	// @method invalidateSize(options: Zoom/pan options): this
  	// Checks if the map container size changed and updates the map if so â€”
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default. If `options.pan` is `false`, panning will not occur.
  	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
  	// that it doesn't happen often even if the method is called many
  	// times in a row.

  	// @alternative
  	// @method invalidateSize(animate: Boolean): this
  	// Checks if the map container size changed and updates the map if so â€”
  	// call it after you've changed the map size dynamically, also animating
  	// pan by default.
  	invalidateSize: function (options) {
  		if (!this._loaded) { return this; }

  		options = extend({
  			animate: false,
  			pan: true
  		}, options === true ? {animate: true} : options);

  		var oldSize = this.getSize();
  		this._sizeChanged = true;
  		this._lastCenter = null;

  		var newSize = this.getSize(),
  		    oldCenter = oldSize.divideBy(2).round(),
  		    newCenter = newSize.divideBy(2).round(),
  		    offset = oldCenter.subtract(newCenter);

  		if (!offset.x && !offset.y) { return this; }

  		if (options.animate && options.pan) {
  			this.panBy(offset);

  		} else {
  			if (options.pan) {
  				this._rawPanBy(offset);
  			}

  			this.fire('move');

  			if (options.debounceMoveend) {
  				clearTimeout(this._sizeTimer);
  				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
  			} else {
  				this.fire('moveend');
  			}
  		}

  		// @section Map state change events
  		// @event resize: ResizeEvent
  		// Fired when the map is resized.
  		return this.fire('resize', {
  			oldSize: oldSize,
  			newSize: newSize
  		});
  	},

  	// @section Methods for modifying map state
  	// @method stop(): this
  	// Stops the currently running `panTo` or `flyTo` animation, if any.
  	stop: function () {
  		this.setZoom(this._limitZoom(this._zoom));
  		if (!this.options.zoomSnap) {
  			this.fire('viewreset');
  		}
  		return this._stop();
  	},

  	// @section Geolocation methods
  	// @method locate(options?: Locate options): this
  	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
  	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
  	// and optionally sets the map view to the user's location with respect to
  	// detection accuracy (or to the world view if geolocation failed).
  	// Note that, if your page doesn't use HTTPS, this method will fail in
  	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
  	// See `Locate options` for more details.
  	locate: function (options) {

  		options = this._locateOptions = extend({
  			timeout: 10000,
  			watch: false
  			// setView: false
  			// maxZoom: <Number>
  			// maximumAge: 0
  			// enableHighAccuracy: false
  		}, options);

  		if (!('geolocation' in navigator)) {
  			this._handleGeolocationError({
  				code: 0,
  				message: 'Geolocation not supported.'
  			});
  			return this;
  		}

  		var onResponse = bind(this._handleGeolocationResponse, this),
  		    onError = bind(this._handleGeolocationError, this);

  		if (options.watch) {
  			this._locationWatchId =
  			        navigator.geolocation.watchPosition(onResponse, onError, options);
  		} else {
  			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
  		}
  		return this;
  	},

  	// @method stopLocate(): this
  	// Stops watching location previously initiated by `map.locate({watch: true})`
  	// and aborts resetting the map view if map.locate was called with
  	// `{setView: true}`.
  	stopLocate: function () {
  		if (navigator.geolocation && navigator.geolocation.clearWatch) {
  			navigator.geolocation.clearWatch(this._locationWatchId);
  		}
  		if (this._locateOptions) {
  			this._locateOptions.setView = false;
  		}
  		return this;
  	},

  	_handleGeolocationError: function (error) {
  		if (!this._container._leaflet_id) { return; }

  		var c = error.code,
  		    message = error.message ||
  		            (c === 1 ? 'permission denied' :
  		            (c === 2 ? 'position unavailable' : 'timeout'));

  		if (this._locateOptions.setView && !this._loaded) {
  			this.fitWorld();
  		}

  		// @section Location events
  		// @event locationerror: ErrorEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
  		this.fire('locationerror', {
  			code: c,
  			message: 'Geolocation error: ' + message + '.'
  		});
  	},

  	_handleGeolocationResponse: function (pos) {
  		if (!this._container._leaflet_id) { return; }

  		var lat = pos.coords.latitude,
  		    lng = pos.coords.longitude,
  		    latlng = new LatLng(lat, lng),
  		    bounds = latlng.toBounds(pos.coords.accuracy * 2),
  		    options = this._locateOptions;

  		if (options.setView) {
  			var zoom = this.getBoundsZoom(bounds);
  			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
  		}

  		var data = {
  			latlng: latlng,
  			bounds: bounds,
  			timestamp: pos.timestamp
  		};

  		for (var i in pos.coords) {
  			if (typeof pos.coords[i] === 'number') {
  				data[i] = pos.coords[i];
  			}
  		}

  		// @event locationfound: LocationEvent
  		// Fired when geolocation (using the [`locate`](#map-locate) method)
  		// went successfully.
  		this.fire('locationfound', data);
  	},

  	// TODO Appropriate docs section?
  	// @section Other Methods
  	// @method addHandler(name: String, HandlerClass: Function): this
  	// Adds a new `Handler` to the map, given its name and constructor function.
  	addHandler: function (name, HandlerClass) {
  		if (!HandlerClass) { return this; }

  		var handler = this[name] = new HandlerClass(this);

  		this._handlers.push(handler);

  		if (this.options[name]) {
  			handler.enable();
  		}

  		return this;
  	},

  	// @method remove(): this
  	// Destroys the map and clears all related event listeners.
  	remove: function () {

  		this._initEvents(true);
  		if (this.options.maxBounds) { this.off('moveend', this._panInsideMaxBounds); }

  		if (this._containerId !== this._container._leaflet_id) {
  			throw new Error('Map container is being reused by another instance');
  		}

  		try {
  			// throws error in IE6-8
  			delete this._container._leaflet_id;
  			delete this._containerId;
  		} catch (e) {
  			/*eslint-disable */
  			this._container._leaflet_id = undefined;
  			/* eslint-enable */
  			this._containerId = undefined;
  		}

  		if (this._locationWatchId !== undefined) {
  			this.stopLocate();
  		}

  		this._stop();

  		remove(this._mapPane);

  		if (this._clearControlPos) {
  			this._clearControlPos();
  		}
  		if (this._resizeRequest) {
  			cancelAnimFrame(this._resizeRequest);
  			this._resizeRequest = null;
  		}

  		this._clearHandlers();

  		if (this._loaded) {
  			// @section Map state change events
  			// @event unload: Event
  			// Fired when the map is destroyed with [remove](#map-remove) method.
  			this.fire('unload');
  		}

  		var i;
  		for (i in this._layers) {
  			this._layers[i].remove();
  		}
  		for (i in this._panes) {
  			remove(this._panes[i]);
  		}

  		this._layers = [];
  		this._panes = [];
  		delete this._mapPane;
  		delete this._renderer;

  		return this;
  	},

  	// @section Other Methods
  	// @method createPane(name: String, container?: HTMLElement): HTMLElement
  	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
  	// then returns it. The pane is created as a child of `container`, or
  	// as a child of the main map pane if not set.
  	createPane: function (name, container) {
  		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
  		    pane = create$1('div', className, container || this._mapPane);

  		if (name) {
  			this._panes[name] = pane;
  		}
  		return pane;
  	},

  	// @section Methods for Getting Map State

  	// @method getCenter(): LatLng
  	// Returns the geographical center of the map view
  	getCenter: function () {
  		this._checkIfLoaded();

  		if (this._lastCenter && !this._moved()) {
  			return this._lastCenter.clone();
  		}
  		return this.layerPointToLatLng(this._getCenterLayerPoint());
  	},

  	// @method getZoom(): Number
  	// Returns the current zoom level of the map view
  	getZoom: function () {
  		return this._zoom;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the geographical bounds visible in the current map view
  	getBounds: function () {
  		var bounds = this.getPixelBounds(),
  		    sw = this.unproject(bounds.getBottomLeft()),
  		    ne = this.unproject(bounds.getTopRight());

  		return new LatLngBounds(sw, ne);
  	},

  	// @method getMinZoom(): Number
  	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
  	getMinZoom: function () {
  		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
  	},

  	// @method getMaxZoom(): Number
  	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
  	getMaxZoom: function () {
  		return this.options.maxZoom === undefined ?
  			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
  			this.options.maxZoom;
  	},

  	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
  	// Returns the maximum zoom level on which the given bounds fit to the map
  	// view in its entirety. If `inside` (optional) is set to `true`, the method
  	// instead returns the minimum zoom level on which the map view fits into
  	// the given bounds in its entirety.
  	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
  		bounds = toLatLngBounds(bounds);
  		padding = toPoint(padding || [0, 0]);

  		var zoom = this.getZoom() || 0,
  		    min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    nw = bounds.getNorthWest(),
  		    se = bounds.getSouthEast(),
  		    size = this.getSize().subtract(padding),
  		    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
  		    snap = Browser.any3d ? this.options.zoomSnap : 1,
  		    scalex = size.x / boundsSize.x,
  		    scaley = size.y / boundsSize.y,
  		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

  		zoom = this.getScaleZoom(scale, zoom);

  		if (snap) {
  			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
  			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
  		}

  		return Math.max(min, Math.min(max, zoom));
  	},

  	// @method getSize(): Point
  	// Returns the current size of the map container (in pixels).
  	getSize: function () {
  		if (!this._size || this._sizeChanged) {
  			this._size = new Point(
  				this._container.clientWidth || 0,
  				this._container.clientHeight || 0);

  			this._sizeChanged = false;
  		}
  		return this._size.clone();
  	},

  	// @method getPixelBounds(): Bounds
  	// Returns the bounds of the current map view in projected pixel
  	// coordinates (sometimes useful in layer and overlay implementations).
  	getPixelBounds: function (center, zoom) {
  		var topLeftPoint = this._getTopLeftPoint(center, zoom);
  		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
  	},

  	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
  	// the map pane? "left point of the map layer" can be confusing, specially
  	// since there can be negative offsets.
  	// @method getPixelOrigin(): Point
  	// Returns the projected pixel coordinates of the top left point of
  	// the map layer (useful in custom layer and overlay implementations).
  	getPixelOrigin: function () {
  		this._checkIfLoaded();
  		return this._pixelOrigin;
  	},

  	// @method getPixelWorldBounds(zoom?: Number): Bounds
  	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
  	// If `zoom` is omitted, the map's current zoom level is used.
  	getPixelWorldBounds: function (zoom) {
  		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
  	},

  	// @section Other Methods

  	// @method getPane(pane: String|HTMLElement): HTMLElement
  	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
  	getPane: function (pane) {
  		return typeof pane === 'string' ? this._panes[pane] : pane;
  	},

  	// @method getPanes(): Object
  	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
  	// the panes as values.
  	getPanes: function () {
  		return this._panes;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the map.
  	getContainer: function () {
  		return this._container;
  	},


  	// @section Conversion Methods

  	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
  	// Returns the scale factor to be applied to a map transition from zoom level
  	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
  	getZoomScale: function (toZoom, fromZoom) {
  		// TODO replace with universal implementation after refactoring projections
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		return crs.scale(toZoom) / crs.scale(fromZoom);
  	},

  	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
  	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
  	// level and everything is scaled by a factor of `scale`. Inverse of
  	// [`getZoomScale`](#map-getZoomScale).
  	getScaleZoom: function (scale, fromZoom) {
  		var crs = this.options.crs;
  		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
  		var zoom = crs.zoom(scale * crs.scale(fromZoom));
  		return isNaN(zoom) ? Infinity : zoom;
  	},

  	// @method project(latlng: LatLng, zoom: Number): Point
  	// Projects a geographical coordinate `LatLng` according to the projection
  	// of the map's CRS, then scales it according to `zoom` and the CRS's
  	// `Transformation`. The result is pixel coordinate relative to
  	// the CRS origin.
  	project: function (latlng, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
  	},

  	// @method unproject(point: Point, zoom: Number): LatLng
  	// Inverse of [`project`](#map-project).
  	unproject: function (point, zoom) {
  		zoom = zoom === undefined ? this._zoom : zoom;
  		return this.options.crs.pointToLatLng(toPoint(point), zoom);
  	},

  	// @method layerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding geographical coordinate (for the current zoom level).
  	layerPointToLatLng: function (point) {
  		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
  		return this.unproject(projectedPoint);
  	},

  	// @method latLngToLayerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the [origin pixel](#map-getpixelorigin).
  	latLngToLayerPoint: function (latlng) {
  		var projectedPoint = this.project(toLatLng(latlng))._round();
  		return projectedPoint._subtract(this.getPixelOrigin());
  	},

  	// @method wrapLatLng(latlng: LatLng): LatLng
  	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
  	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
  	// CRS's bounds.
  	// By default this means longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees.
  	wrapLatLng: function (latlng) {
  		return this.options.crs.wrapLatLng(toLatLng(latlng));
  	},

  	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
  	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
  	// its center is within the CRS's bounds.
  	// By default this means the center longitude is wrapped around the dateline so its
  	// value is between -180 and +180 degrees, and the majority of the bounds
  	// overlaps the CRS's bounds.
  	wrapLatLngBounds: function (latlng) {
  		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
  	},

  	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
  	// Returns the distance between two geographical coordinates according to
  	// the map's CRS. By default this measures distance in meters.
  	distance: function (latlng1, latlng2) {
  		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
  	},

  	// @method containerPointToLayerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the map container, returns the corresponding
  	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
  	containerPointToLayerPoint: function (point) { // (Point)
  		return toPoint(point).subtract(this._getMapPanePos());
  	},

  	// @method layerPointToContainerPoint(point: Point): Point
  	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
  	// returns the corresponding pixel coordinate relative to the map container.
  	layerPointToContainerPoint: function (point) { // (Point)
  		return toPoint(point).add(this._getMapPanePos());
  	},

  	// @method containerPointToLatLng(point: Point): LatLng
  	// Given a pixel coordinate relative to the map container, returns
  	// the corresponding geographical coordinate (for the current zoom level).
  	containerPointToLatLng: function (point) {
  		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
  		return this.layerPointToLatLng(layerPoint);
  	},

  	// @method latLngToContainerPoint(latlng: LatLng): Point
  	// Given a geographical coordinate, returns the corresponding pixel coordinate
  	// relative to the map container.
  	latLngToContainerPoint: function (latlng) {
  		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
  	},

  	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to the
  	// map container where the event took place.
  	mouseEventToContainerPoint: function (e) {
  		return getMousePosition(e, this._container);
  	},

  	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
  	// Given a MouseEvent object, returns the pixel coordinate relative to
  	// the [origin pixel](#map-getpixelorigin) where the event took place.
  	mouseEventToLayerPoint: function (e) {
  		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
  	},

  	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
  	// Given a MouseEvent object, returns geographical coordinate where the
  	// event took place.
  	mouseEventToLatLng: function (e) { // (MouseEvent)
  		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
  	},


  	// map initialization methods

  	_initContainer: function (id) {
  		var container = this._container = get(id);

  		if (!container) {
  			throw new Error('Map container not found.');
  		} else if (container._leaflet_id) {
  			throw new Error('Map container is already initialized.');
  		}

  		on(container, 'scroll', this._onScroll, this);
  		this._containerId = stamp(container);
  	},

  	_initLayout: function () {
  		var container = this._container;

  		this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

  		addClass(container, 'leaflet-container' +
  			(Browser.touch ? ' leaflet-touch' : '') +
  			(Browser.retina ? ' leaflet-retina' : '') +
  			(Browser.ielt9 ? ' leaflet-oldie' : '') +
  			(Browser.safari ? ' leaflet-safari' : '') +
  			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

  		var position = getStyle(container, 'position');

  		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {
  			container.style.position = 'relative';
  		}

  		this._initPanes();

  		if (this._initControlPos) {
  			this._initControlPos();
  		}
  	},

  	_initPanes: function () {
  		var panes = this._panes = {};
  		this._paneRenderers = {};

  		// @section
  		//
  		// Panes are DOM elements used to control the ordering of layers on the map. You
  		// can access panes with [`map.getPane`](#map-getpane) or
  		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
  		// [`map.createPane`](#map-createpane) method.
  		//
  		// Every map has the following default panes that differ only in zIndex.
  		//
  		// @pane mapPane: HTMLElement = 'auto'
  		// Pane that contains all other map panes

  		this._mapPane = this.createPane('mapPane', this._container);
  		setPosition(this._mapPane, new Point(0, 0));

  		// @pane tilePane: HTMLElement = 200
  		// Pane for `GridLayer`s and `TileLayer`s
  		this.createPane('tilePane');
  		// @pane overlayPane: HTMLElement = 400
  		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
  		this.createPane('overlayPane');
  		// @pane shadowPane: HTMLElement = 500
  		// Pane for overlay shadows (e.g. `Marker` shadows)
  		this.createPane('shadowPane');
  		// @pane markerPane: HTMLElement = 600
  		// Pane for `Icon`s of `Marker`s
  		this.createPane('markerPane');
  		// @pane tooltipPane: HTMLElement = 650
  		// Pane for `Tooltip`s.
  		this.createPane('tooltipPane');
  		// @pane popupPane: HTMLElement = 700
  		// Pane for `Popup`s.
  		this.createPane('popupPane');

  		if (!this.options.markerZoomAnimation) {
  			addClass(panes.markerPane, 'leaflet-zoom-hide');
  			addClass(panes.shadowPane, 'leaflet-zoom-hide');
  		}
  	},


  	// private methods that modify map state

  	// @section Map state change events
  	_resetView: function (center, zoom, noMoveStart) {
  		setPosition(this._mapPane, new Point(0, 0));

  		var loading = !this._loaded;
  		this._loaded = true;
  		zoom = this._limitZoom(zoom);

  		this.fire('viewprereset');

  		var zoomChanged = this._zoom !== zoom;
  		this
  			._moveStart(zoomChanged, noMoveStart)
  			._move(center, zoom)
  			._moveEnd(zoomChanged);

  		// @event viewreset: Event
  		// Fired when the map needs to redraw its content (this usually happens
  		// on map zoom or load). Very useful for creating custom overlays.
  		this.fire('viewreset');

  		// @event load: Event
  		// Fired when the map is initialized (when its center and zoom are set
  		// for the first time).
  		if (loading) {
  			this.fire('load');
  		}
  	},

  	_moveStart: function (zoomChanged, noMoveStart) {
  		// @event zoomstart: Event
  		// Fired when the map zoom is about to change (e.g. before zoom animation).
  		// @event movestart: Event
  		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
  		if (zoomChanged) {
  			this.fire('zoomstart');
  		}
  		if (!noMoveStart) {
  			this.fire('movestart');
  		}
  		return this;
  	},

  	_move: function (center, zoom, data, supressEvent) {
  		if (zoom === undefined) {
  			zoom = this._zoom;
  		}
  		var zoomChanged = this._zoom !== zoom;

  		this._zoom = zoom;
  		this._lastCenter = center;
  		this._pixelOrigin = this._getNewPixelOrigin(center);

  		if (!supressEvent) {
  			// @event zoom: Event
  			// Fired repeatedly during any change in zoom level,
  			// including zoom and fly animations.
  			if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
  				this.fire('zoom', data);
  			}

  			// @event move: Event
  			// Fired repeatedly during any movement of the map,
  			// including pan and fly animations.
  			this.fire('move', data);
  		} else if (data && data.pinch) {	// Always fire 'zoom' if pinching because #3530
  			this.fire('zoom', data);
  		}
  		return this;
  	},

  	_moveEnd: function (zoomChanged) {
  		// @event zoomend: Event
  		// Fired when the map zoom changed, after any animations.
  		if (zoomChanged) {
  			this.fire('zoomend');
  		}

  		// @event moveend: Event
  		// Fired when the center of the map stops changing
  		// (e.g. user stopped dragging the map or after non-centered zoom).
  		return this.fire('moveend');
  	},

  	_stop: function () {
  		cancelAnimFrame(this._flyToFrame);
  		if (this._panAnim) {
  			this._panAnim.stop();
  		}
  		return this;
  	},

  	_rawPanBy: function (offset) {
  		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
  	},

  	_getZoomSpan: function () {
  		return this.getMaxZoom() - this.getMinZoom();
  	},

  	_panInsideMaxBounds: function () {
  		if (!this._enforcingBounds) {
  			this.panInsideBounds(this.options.maxBounds);
  		}
  	},

  	_checkIfLoaded: function () {
  		if (!this._loaded) {
  			throw new Error('Set map center and zoom first.');
  		}
  	},

  	// DOM event handling

  	// @section Interaction events
  	_initEvents: function (remove) {
  		this._targets = {};
  		this._targets[stamp(this._container)] = this;

  		var onOff = remove ? off : on;

  		// @event click: MouseEvent
  		// Fired when the user clicks (or taps) the map.
  		// @event dblclick: MouseEvent
  		// Fired when the user double-clicks (or double-taps) the map.
  		// @event mousedown: MouseEvent
  		// Fired when the user pushes the mouse button on the map.
  		// @event mouseup: MouseEvent
  		// Fired when the user releases the mouse button on the map.
  		// @event mouseover: MouseEvent
  		// Fired when the mouse enters the map.
  		// @event mouseout: MouseEvent
  		// Fired when the mouse leaves the map.
  		// @event mousemove: MouseEvent
  		// Fired while the mouse moves over the map.
  		// @event contextmenu: MouseEvent
  		// Fired when the user pushes the right mouse button on the map, prevents
  		// default browser context menu from showing if there are listeners on
  		// this event. Also fired on mobile when the user holds a single touch
  		// for a second (also called long press).
  		// @event keypress: KeyboardEvent
  		// Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
  		// @event keydown: KeyboardEvent
  		// Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
  		// the `keydown` event is fired for keys that produce a character value and for keys
  		// that do not produce a character value.
  		// @event keyup: KeyboardEvent
  		// Fired when the user releases a key from the keyboard while the map is focused.
  		onOff(this._container, 'click dblclick mousedown mouseup ' +
  			'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

  		if (this.options.trackResize) {
  			onOff(window, 'resize', this._onResize, this);
  		}

  		if (Browser.any3d && this.options.transform3DLimit) {
  			(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
  		}
  	},

  	_onResize: function () {
  		cancelAnimFrame(this._resizeRequest);
  		this._resizeRequest = requestAnimFrame(
  		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
  	},

  	_onScroll: function () {
  		this._container.scrollTop  = 0;
  		this._container.scrollLeft = 0;
  	},

  	_onMoveEnd: function () {
  		var pos = this._getMapPanePos();
  		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
  			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
  			// a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/
  			this._resetView(this.getCenter(), this.getZoom());
  		}
  	},

  	_findEventTargets: function (e, type) {
  		var targets = [],
  		    target,
  		    isHover = type === 'mouseout' || type === 'mouseover',
  		    src = e.target || e.srcElement,
  		    dragging = false;

  		while (src) {
  			target = this._targets[stamp(src)];
  			if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {
  				// Prevent firing click after you just dragged an object.
  				dragging = true;
  				break;
  			}
  			if (target && target.listens(type, true)) {
  				if (isHover && !isExternalTarget(src, e)) { break; }
  				targets.push(target);
  				if (isHover) { break; }
  			}
  			if (src === this._container) { break; }
  			src = src.parentNode;
  		}
  		if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
  			targets = [this];
  		}
  		return targets;
  	},

  	_isClickDisabled: function (el) {
  		while (el && el !== this._container) {
  			if (el['_leaflet_disable_click']) { return true; }
  			el = el.parentNode;
  		}
  	},

  	_handleDOMEvent: function (e) {
  		var el = (e.target || e.srcElement);
  		if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {
  			return;
  		}

  		var type = e.type;

  		if (type === 'mousedown') {
  			// prevents outline when clicking on keyboard-focusable element
  			preventOutline(el);
  		}

  		this._fireDOMEvent(e, type);
  	},

  	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

  	_fireDOMEvent: function (e, type, canvasTargets) {

  		if (e.type === 'click') {
  			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
  			// @event preclick: MouseEvent
  			// Fired before mouse click on the map (sometimes useful when you
  			// want something to happen on click before any existing click
  			// handlers start running).
  			var synth = extend({}, e);
  			synth.type = 'preclick';
  			this._fireDOMEvent(synth, synth.type, canvasTargets);
  		}

  		// Find the layer the event is propagating from and its parents.
  		var targets = this._findEventTargets(e, type);

  		if (canvasTargets) {
  			var filtered = []; // pick only targets with listeners
  			for (var i = 0; i < canvasTargets.length; i++) {
  				if (canvasTargets[i].listens(type, true)) {
  					filtered.push(canvasTargets[i]);
  				}
  			}
  			targets = filtered.concat(targets);
  		}

  		if (!targets.length) { return; }

  		if (type === 'contextmenu') {
  			preventDefault(e);
  		}

  		var target = targets[0];
  		var data = {
  			originalEvent: e
  		};

  		if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
  			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
  			data.containerPoint = isMarker ?
  				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
  			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
  			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
  		}

  		for (i = 0; i < targets.length; i++) {
  			targets[i].fire(type, data, true);
  			if (data.originalEvent._stopped ||
  				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
  		}
  	},

  	_draggableMoved: function (obj) {
  		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
  		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
  	},

  	_clearHandlers: function () {
  		for (var i = 0, len = this._handlers.length; i < len; i++) {
  			this._handlers[i].disable();
  		}
  	},

  	// @section Other Methods

  	// @method whenReady(fn: Function, context?: Object): this
  	// Runs the given function `fn` when the map gets initialized with
  	// a view (center and zoom) and at least one layer, or immediately
  	// if it's already initialized, optionally passing a function context.
  	whenReady: function (callback, context) {
  		if (this._loaded) {
  			callback.call(context || this, {target: this});
  		} else {
  			this.on('load', callback, context);
  		}
  		return this;
  	},


  	// private methods for getting map state

  	_getMapPanePos: function () {
  		return getPosition(this._mapPane) || new Point(0, 0);
  	},

  	_moved: function () {
  		var pos = this._getMapPanePos();
  		return pos && !pos.equals([0, 0]);
  	},

  	_getTopLeftPoint: function (center, zoom) {
  		var pixelOrigin = center && zoom !== undefined ?
  			this._getNewPixelOrigin(center, zoom) :
  			this.getPixelOrigin();
  		return pixelOrigin.subtract(this._getMapPanePos());
  	},

  	_getNewPixelOrigin: function (center, zoom) {
  		var viewHalf = this.getSize()._divideBy(2);
  		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
  	},

  	_latLngToNewLayerPoint: function (latlng, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return this.project(latlng, zoom)._subtract(topLeft);
  	},

  	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
  		var topLeft = this._getNewPixelOrigin(center, zoom);
  		return toBounds([
  			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
  			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
  		]);
  	},

  	// layer point of the current center
  	_getCenterLayerPoint: function () {
  		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
  	},

  	// offset of the specified place to the current center in pixels
  	_getCenterOffset: function (latlng) {
  		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
  	},

  	// adjust center for view to get inside bounds
  	_limitCenter: function (center, zoom, bounds) {

  		if (!bounds) { return center; }

  		var centerPoint = this.project(center, zoom),
  		    viewHalf = this.getSize().divideBy(2),
  		    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
  		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

  		// If offset is less than a pixel, ignore.
  		// This prevents unstable projections from getting into
  		// an infinite loop of tiny offsets.
  		if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
  			return center;
  		}

  		return this.unproject(centerPoint.add(offset), zoom);
  	},

  	// adjust offset for view to get inside bounds
  	_limitOffset: function (offset, bounds) {
  		if (!bounds) { return offset; }

  		var viewBounds = this.getPixelBounds(),
  		    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

  		return offset.add(this._getBoundsOffset(newBounds, bounds));
  	},

  	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
  	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
  		var projectedMaxBounds = toBounds(
  		        this.project(maxBounds.getNorthEast(), zoom),
  		        this.project(maxBounds.getSouthWest(), zoom)
  		    ),
  		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
  		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

  		    dx = this._rebound(minOffset.x, -maxOffset.x),
  		    dy = this._rebound(minOffset.y, -maxOffset.y);

  		return new Point(dx, dy);
  	},

  	_rebound: function (left, right) {
  		return left + right > 0 ?
  			Math.round(left - right) / 2 :
  			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
  	},

  	_limitZoom: function (zoom) {
  		var min = this.getMinZoom(),
  		    max = this.getMaxZoom(),
  		    snap = Browser.any3d ? this.options.zoomSnap : 1;
  		if (snap) {
  			zoom = Math.round(zoom / snap) * snap;
  		}
  		return Math.max(min, Math.min(max, zoom));
  	},

  	_onPanTransitionStep: function () {
  		this.fire('move');
  	},

  	_onPanTransitionEnd: function () {
  		removeClass(this._mapPane, 'leaflet-pan-anim');
  		this.fire('moveend');
  	},

  	_tryAnimatedPan: function (center, options) {
  		// difference between the new and current centers in pixels
  		var offset = this._getCenterOffset(center)._trunc();

  		// don't animate too far unless animate: true specified in options
  		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

  		this.panBy(offset, options);

  		return true;
  	},

  	_createAnimProxy: function () {

  		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
  		this._panes.mapPane.appendChild(proxy);

  		this.on('zoomanim', function (e) {
  			var prop = TRANSFORM,
  			    transform = this._proxy.style[prop];

  			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

  			// workaround for case when transform is the same and so transitionend event is not fired
  			if (transform === this._proxy.style[prop] && this._animatingZoom) {
  				this._onZoomTransitionEnd();
  			}
  		}, this);

  		this.on('load moveend', this._animMoveEnd, this);

  		this._on('unload', this._destroyAnimProxy, this);
  	},

  	_destroyAnimProxy: function () {
  		remove(this._proxy);
  		this.off('load moveend', this._animMoveEnd, this);
  		delete this._proxy;
  	},

  	_animMoveEnd: function () {
  		var c = this.getCenter(),
  		    z = this.getZoom();
  		setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
  	},

  	_catchTransitionEnd: function (e) {
  		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
  			this._onZoomTransitionEnd();
  		}
  	},

  	_nothingToAnimate: function () {
  		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
  	},

  	_tryAnimatedZoom: function (center, zoom, options) {

  		if (this._animatingZoom) { return true; }

  		options = options || {};

  		// don't animate if disabled, not supported or zoom difference is too large
  		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
  		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

  		// offset is the pixel coords of the zoom origin relative to the current center
  		var scale = this.getZoomScale(zoom),
  		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

  		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
  		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

  		requestAnimFrame(function () {
  			this
  			    ._moveStart(true, options.noMoveStart || false)
  			    ._animateZoom(center, zoom, true);
  		}, this);

  		return true;
  	},

  	_animateZoom: function (center, zoom, startAnim, noUpdate) {
  		if (!this._mapPane) { return; }

  		if (startAnim) {
  			this._animatingZoom = true;

  			// remember what center/zoom to set after animation
  			this._animateToCenter = center;
  			this._animateToZoom = zoom;

  			addClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		// @section Other Events
  		// @event zoomanim: ZoomAnimEvent
  		// Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
  		this.fire('zoomanim', {
  			center: center,
  			zoom: zoom,
  			noUpdate: noUpdate
  		});

  		if (!this._tempFireZoomEvent) {
  			this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
  		}

  		this._move(this._animateToCenter, this._animateToZoom, undefined, true);

  		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
  		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
  	},

  	_onZoomTransitionEnd: function () {
  		if (!this._animatingZoom) { return; }

  		if (this._mapPane) {
  			removeClass(this._mapPane, 'leaflet-zoom-anim');
  		}

  		this._animatingZoom = false;

  		this._move(this._animateToCenter, this._animateToZoom, undefined, true);

  		if (this._tempFireZoomEvent) {
  			this.fire('zoom');
  		}
  		delete this._tempFireZoomEvent;

  		this.fire('move');

  		this._moveEnd(true);
  	}
  });

  // @section

  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.
  function createMap(id, options) {
  	return new Map(id, options);
  }

  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */

  var Control = Class.extend({
  	// @section
  	// @aka Control Options
  	options: {
  		// @option position: String = 'topright'
  		// The position of the control (one of the map corners). Possible values are `'topleft'`,
  		// `'topright'`, `'bottomleft'` or `'bottomright'`
  		position: 'topright'
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	/* @section
  	 * Classes extending L.Control will inherit the following methods:
  	 *
  	 * @method getPosition: string
  	 * Returns the position of the control.
  	 */
  	getPosition: function () {
  		return this.options.position;
  	},

  	// @method setPosition(position: string): this
  	// Sets the position of the control.
  	setPosition: function (position) {
  		var map = this._map;

  		if (map) {
  			map.removeControl(this);
  		}

  		this.options.position = position;

  		if (map) {
  			map.addControl(this);
  		}

  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTMLElement that contains the control.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method addTo(map: Map): this
  	// Adds the control to the given map.
  	addTo: function (map) {
  		this.remove();
  		this._map = map;

  		var container = this._container = this.onAdd(map),
  		    pos = this.getPosition(),
  		    corner = map._controlCorners[pos];

  		addClass(container, 'leaflet-control');

  		if (pos.indexOf('bottom') !== -1) {
  			corner.insertBefore(container, corner.firstChild);
  		} else {
  			corner.appendChild(container);
  		}

  		this._map.on('unload', this.remove, this);

  		return this;
  	},

  	// @method remove: this
  	// Removes the control from the map it is currently active on.
  	remove: function () {
  		if (!this._map) {
  			return this;
  		}

  		remove(this._container);

  		if (this.onRemove) {
  			this.onRemove(this._map);
  		}

  		this._map.off('unload', this.remove, this);
  		this._map = null;

  		return this;
  	},

  	_refocusOnMap: function (e) {
  		// if map exists and event is not a keyboard event
  		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
  			this._map.getContainer().focus();
  		}
  	}
  });

  var control = function (options) {
  	return new Control(options);
  };

  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addControl(control: Control): this
  	// Adds the given control to the map
  	addControl: function (control) {
  		control.addTo(this);
  		return this;
  	},

  	// @method removeControl(control: Control): this
  	// Removes the given control from the map
  	removeControl: function (control) {
  		control.remove();
  		return this;
  	},

  	_initControlPos: function () {
  		var corners = this._controlCorners = {},
  		    l = 'leaflet-',
  		    container = this._controlContainer =
  		            create$1('div', l + 'control-container', this._container);

  		function createCorner(vSide, hSide) {
  			var className = l + vSide + ' ' + l + hSide;

  			corners[vSide + hSide] = create$1('div', className, container);
  		}

  		createCorner('top', 'left');
  		createCorner('top', 'right');
  		createCorner('bottom', 'left');
  		createCorner('bottom', 'right');
  	},

  	_clearControlPos: function () {
  		for (var i in this._controlCorners) {
  			remove(this._controlCorners[i]);
  		}
  		remove(this._controlContainer);
  		delete this._controlCorners;
  		delete this._controlContainer;
  	}
  });

  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
  	// @section
  	// @aka Control.Layers options
  	options: {
  		// @option collapsed: Boolean = true
  		// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
  		collapsed: true,
  		position: 'topright',

  		// @option autoZIndex: Boolean = true
  		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
  		autoZIndex: true,

  		// @option hideSingleBase: Boolean = false
  		// If `true`, the base layers in the control will be hidden when there is only one.
  		hideSingleBase: false,

  		// @option sortLayers: Boolean = false
  		// Whether to sort the layers. When `false`, layers will keep the order
  		// in which they were added to the control.
  		sortLayers: false,

  		// @option sortFunction: Function = *
  		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
  		// that will be used for sorting the layers, when `sortLayers` is `true`.
  		// The function receives both the `L.Layer` instances and their names, as in
  		// `sortFunction(layerA, layerB, nameA, nameB)`.
  		// By default, it sorts layers alphabetically by their name.
  		sortFunction: function (layerA, layerB, nameA, nameB) {
  			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
  		}
  	},

  	initialize: function (baseLayers, overlays, options) {
  		setOptions(this, options);

  		this._layerControlInputs = [];
  		this._layers = [];
  		this._lastZIndex = 0;
  		this._handlingClick = false;
  		this._preventClick = false;

  		for (var i in baseLayers) {
  			this._addLayer(baseLayers[i], i);
  		}

  		for (i in overlays) {
  			this._addLayer(overlays[i], i, true);
  		}
  	},

  	onAdd: function (map) {
  		this._initLayout();
  		this._update();

  		this._map = map;
  		map.on('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.on('add remove', this._onLayerChange, this);
  		}

  		return this._container;
  	},

  	addTo: function (map) {
  		Control.prototype.addTo.call(this, map);
  		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
  		return this._expandIfNotCollapsed();
  	},

  	onRemove: function () {
  		this._map.off('zoomend', this._checkDisabledLayers, this);

  		for (var i = 0; i < this._layers.length; i++) {
  			this._layers[i].layer.off('add remove', this._onLayerChange, this);
  		}
  	},

  	// @method addBaseLayer(layer: Layer, name: String): this
  	// Adds a base layer (radio button entry) with the given name to the control.
  	addBaseLayer: function (layer, name) {
  		this._addLayer(layer, name);
  		return (this._map) ? this._update() : this;
  	},

  	// @method addOverlay(layer: Layer, name: String): this
  	// Adds an overlay (checkbox entry) with the given name to the control.
  	addOverlay: function (layer, name) {
  		this._addLayer(layer, name, true);
  		return (this._map) ? this._update() : this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Remove the given layer from the control.
  	removeLayer: function (layer) {
  		layer.off('add remove', this._onLayerChange, this);

  		var obj = this._getLayer(stamp(layer));
  		if (obj) {
  			this._layers.splice(this._layers.indexOf(obj), 1);
  		}
  		return (this._map) ? this._update() : this;
  	},

  	// @method expand(): this
  	// Expand the control container if collapsed.
  	expand: function () {
  		addClass(this._container, 'leaflet-control-layers-expanded');
  		this._section.style.height = null;
  		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
  		if (acceptableHeight < this._section.clientHeight) {
  			addClass(this._section, 'leaflet-control-layers-scrollbar');
  			this._section.style.height = acceptableHeight + 'px';
  		} else {
  			removeClass(this._section, 'leaflet-control-layers-scrollbar');
  		}
  		this._checkDisabledLayers();
  		return this;
  	},

  	// @method collapse(): this
  	// Collapse the control container if expanded.
  	collapse: function () {
  		removeClass(this._container, 'leaflet-control-layers-expanded');
  		return this;
  	},

  	_initLayout: function () {
  		var className = 'leaflet-control-layers',
  		    container = this._container = create$1('div', className),
  		    collapsed = this.options.collapsed;

  		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
  		container.setAttribute('aria-haspopup', true);

  		disableClickPropagation(container);
  		disableScrollPropagation(container);

  		var section = this._section = create$1('section', className + '-list');

  		if (collapsed) {
  			this._map.on('click', this.collapse, this);

  			on(container, {
  				mouseenter: this._expandSafely,
  				mouseleave: this.collapse
  			}, this);
  		}

  		var link = this._layersLink = create$1('a', className + '-toggle', container);
  		link.href = '#';
  		link.title = 'Layers';
  		link.setAttribute('role', 'button');

  		on(link, {
  			keydown: function (e) {
  				if (e.keyCode === 13) {
  					this._expandSafely();
  				}
  			},
  			// Certain screen readers intercept the key event and instead send a click event
  			click: function (e) {
  				preventDefault(e);
  				this._expandSafely();
  			}
  		}, this);

  		if (!collapsed) {
  			this.expand();
  		}

  		this._baseLayersList = create$1('div', className + '-base', section);
  		this._separator = create$1('div', className + '-separator', section);
  		this._overlaysList = create$1('div', className + '-overlays', section);

  		container.appendChild(section);
  	},

  	_getLayer: function (id) {
  		for (var i = 0; i < this._layers.length; i++) {

  			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
  				return this._layers[i];
  			}
  		}
  	},

  	_addLayer: function (layer, name, overlay) {
  		if (this._map) {
  			layer.on('add remove', this._onLayerChange, this);
  		}

  		this._layers.push({
  			layer: layer,
  			name: name,
  			overlay: overlay
  		});

  		if (this.options.sortLayers) {
  			this._layers.sort(bind(function (a, b) {
  				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
  			}, this));
  		}

  		if (this.options.autoZIndex && layer.setZIndex) {
  			this._lastZIndex++;
  			layer.setZIndex(this._lastZIndex);
  		}

  		this._expandIfNotCollapsed();
  	},

  	_update: function () {
  		if (!this._container) { return this; }

  		empty(this._baseLayersList);
  		empty(this._overlaysList);

  		this._layerControlInputs = [];
  		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

  		for (i = 0; i < this._layers.length; i++) {
  			obj = this._layers[i];
  			this._addItem(obj);
  			overlaysPresent = overlaysPresent || obj.overlay;
  			baseLayersPresent = baseLayersPresent || !obj.overlay;
  			baseLayersCount += !obj.overlay ? 1 : 0;
  		}

  		// Hide base layers section if there's only one layer.
  		if (this.options.hideSingleBase) {
  			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
  			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
  		}

  		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

  		return this;
  	},

  	_onLayerChange: function (e) {
  		if (!this._handlingClick) {
  			this._update();
  		}

  		var obj = this._getLayer(stamp(e.target));

  		// @namespace Map
  		// @section Layer events
  		// @event baselayerchange: LayersControlEvent
  		// Fired when the base layer is changed through the [layers control](#control-layers).
  		// @event overlayadd: LayersControlEvent
  		// Fired when an overlay is selected through the [layers control](#control-layers).
  		// @event overlayremove: LayersControlEvent
  		// Fired when an overlay is deselected through the [layers control](#control-layers).
  		// @namespace Control.Layers
  		var type = obj.overlay ?
  			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
  			(e.type === 'add' ? 'baselayerchange' : null);

  		if (type) {
  			this._map.fire(type, obj);
  		}
  	},

  	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
  	_createRadioElement: function (name, checked) {

  		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
  				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

  		var radioFragment = document.createElement('div');
  		radioFragment.innerHTML = radioHtml;

  		return radioFragment.firstChild;
  	},

  	_addItem: function (obj) {
  		var label = document.createElement('label'),
  		    checked = this._map.hasLayer(obj.layer),
  		    input;

  		if (obj.overlay) {
  			input = document.createElement('input');
  			input.type = 'checkbox';
  			input.className = 'leaflet-control-layers-selector';
  			input.defaultChecked = checked;
  		} else {
  			input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
  		}

  		this._layerControlInputs.push(input);
  		input.layerId = stamp(obj.layer);

  		on(input, 'click', this._onInputClick, this);

  		var name = document.createElement('span');
  		name.innerHTML = ' ' + obj.name;

  		// Helps from preventing layer control flicker when checkboxes are disabled
  		// https://github.com/Leaflet/Leaflet/issues/2771
  		var holder = document.createElement('span');

  		label.appendChild(holder);
  		holder.appendChild(input);
  		holder.appendChild(name);

  		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
  		container.appendChild(label);

  		this._checkDisabledLayers();
  		return label;
  	},

  	_onInputClick: function () {
  		// expanding the control on mobile with a click can cause adding a layer - we don't want this
  		if (this._preventClick) {
  			return;
  		}

  		var inputs = this._layerControlInputs,
  		    input, layer;
  		var addedLayers = [],
  		    removedLayers = [];

  		this._handlingClick = true;

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;

  			if (input.checked) {
  				addedLayers.push(layer);
  			} else if (!input.checked) {
  				removedLayers.push(layer);
  			}
  		}

  		// Bugfix issue 2318: Should remove all old layers before readding new ones
  		for (i = 0; i < removedLayers.length; i++) {
  			if (this._map.hasLayer(removedLayers[i])) {
  				this._map.removeLayer(removedLayers[i]);
  			}
  		}
  		for (i = 0; i < addedLayers.length; i++) {
  			if (!this._map.hasLayer(addedLayers[i])) {
  				this._map.addLayer(addedLayers[i]);
  			}
  		}

  		this._handlingClick = false;

  		this._refocusOnMap();
  	},

  	_checkDisabledLayers: function () {
  		var inputs = this._layerControlInputs,
  		    input,
  		    layer,
  		    zoom = this._map.getZoom();

  		for (var i = inputs.length - 1; i >= 0; i--) {
  			input = inputs[i];
  			layer = this._getLayer(input.layerId).layer;
  			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
  			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

  		}
  	},

  	_expandIfNotCollapsed: function () {
  		if (this._map && !this.options.collapsed) {
  			this.expand();
  		}
  		return this;
  	},

  	_expandSafely: function () {
  		var section = this._section;
  		this._preventClick = true;
  		on(section, 'click', preventDefault);
  		this.expand();
  		var that = this;
  		setTimeout(function () {
  			off(section, 'click', preventDefault);
  			that._preventClick = false;
  		});
  	}

  });


  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
  var layers = function (baseLayers, overlays, options) {
  	return new Layers(baseLayers, overlays, options);
  };

  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */

  var Zoom = Control.extend({
  	// @section
  	// @aka Control.Zoom options
  	options: {
  		position: 'topleft',

  		// @option zoomInText: String = '<span aria-hidden="true">+</span>'
  		// The text set on the 'zoom in' button.
  		zoomInText: '<span aria-hidden="true">+</span>',

  		// @option zoomInTitle: String = 'Zoom in'
  		// The title set on the 'zoom in' button.
  		zoomInTitle: 'Zoom in',

  		// @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
  		// The text set on the 'zoom out' button.
  		zoomOutText: '<span aria-hidden="true">&#x2212;</span>',

  		// @option zoomOutTitle: String = 'Zoom out'
  		// The title set on the 'zoom out' button.
  		zoomOutTitle: 'Zoom out'
  	},

  	onAdd: function (map) {
  		var zoomName = 'leaflet-control-zoom',
  		    container = create$1('div', zoomName + ' leaflet-bar'),
  		    options = this.options;

  		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
  		        zoomName + '-in',  container, this._zoomIn);
  		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
  		        zoomName + '-out', container, this._zoomOut);

  		this._updateDisabled();
  		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
  	},

  	disable: function () {
  		this._disabled = true;
  		this._updateDisabled();
  		return this;
  	},

  	enable: function () {
  		this._disabled = false;
  		this._updateDisabled();
  		return this;
  	},

  	_zoomIn: function (e) {
  		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
  			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_zoomOut: function (e) {
  		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
  			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
  		}
  	},

  	_createButton: function (html, title, className, container, fn) {
  		var link = create$1('a', className, container);
  		link.innerHTML = html;
  		link.href = '#';
  		link.title = title;

  		/*
  		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
  		 */
  		link.setAttribute('role', 'button');
  		link.setAttribute('aria-label', title);

  		disableClickPropagation(link);
  		on(link, 'click', stop);
  		on(link, 'click', fn, this);
  		on(link, 'click', this._refocusOnMap, this);

  		return link;
  	},

  	_updateDisabled: function () {
  		var map = this._map,
  		    className = 'leaflet-disabled';

  		removeClass(this._zoomInButton, className);
  		removeClass(this._zoomOutButton, className);
  		this._zoomInButton.setAttribute('aria-disabled', 'false');
  		this._zoomOutButton.setAttribute('aria-disabled', 'false');

  		if (this._disabled || map._zoom === map.getMinZoom()) {
  			addClass(this._zoomOutButton, className);
  			this._zoomOutButton.setAttribute('aria-disabled', 'true');
  		}
  		if (this._disabled || map._zoom === map.getMaxZoom()) {
  			addClass(this._zoomInButton, className);
  			this._zoomInButton.setAttribute('aria-disabled', 'true');
  		}
  	}
  });

  // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.
  Map.mergeOptions({
  	zoomControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.zoomControl) {
  		// @section Controls
  		// @property zoomControl: Control.Zoom
  		// The default zoom control (only available if the
  		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
  		this.zoomControl = new Zoom();
  		this.addControl(this.zoomControl);
  	}
  });

  // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control
  var zoom = function (options) {
  	return new Zoom(options);
  };

  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */

  var Scale = Control.extend({
  	// @section
  	// @aka Control.Scale options
  	options: {
  		position: 'bottomleft',

  		// @option maxWidth: Number = 100
  		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
  		maxWidth: 100,

  		// @option metric: Boolean = True
  		// Whether to show the metric scale line (m/km).
  		metric: true,

  		// @option imperial: Boolean = True
  		// Whether to show the imperial scale line (mi/ft).
  		imperial: true

  		// @option updateWhenIdle: Boolean = false
  		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
  	},

  	onAdd: function (map) {
  		var className = 'leaflet-control-scale',
  		    container = create$1('div', className),
  		    options = this.options;

  		this._addScales(options, className + '-line', container);

  		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  		map.whenReady(this._update, this);

  		return container;
  	},

  	onRemove: function (map) {
  		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
  	},

  	_addScales: function (options, className, container) {
  		if (options.metric) {
  			this._mScale = create$1('div', className, container);
  		}
  		if (options.imperial) {
  			this._iScale = create$1('div', className, container);
  		}
  	},

  	_update: function () {
  		var map = this._map,
  		    y = map.getSize().y / 2;

  		var maxMeters = map.distance(
  			map.containerPointToLatLng([0, y]),
  			map.containerPointToLatLng([this.options.maxWidth, y]));

  		this._updateScales(maxMeters);
  	},

  	_updateScales: function (maxMeters) {
  		if (this.options.metric && maxMeters) {
  			this._updateMetric(maxMeters);
  		}
  		if (this.options.imperial && maxMeters) {
  			this._updateImperial(maxMeters);
  		}
  	},

  	_updateMetric: function (maxMeters) {
  		var meters = this._getRoundNum(maxMeters),
  		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

  		this._updateScale(this._mScale, label, meters / maxMeters);
  	},

  	_updateImperial: function (maxMeters) {
  		var maxFeet = maxMeters * 3.2808399,
  		    maxMiles, miles, feet;

  		if (maxFeet > 5280) {
  			maxMiles = maxFeet / 5280;
  			miles = this._getRoundNum(maxMiles);
  			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

  		} else {
  			feet = this._getRoundNum(maxFeet);
  			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
  		}
  	},

  	_updateScale: function (scale, text, ratio) {
  		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
  		scale.innerHTML = text;
  	},

  	_getRoundNum: function (num) {
  		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
  		    d = num / pow10;

  		d = d >= 10 ? 10 :
  		    d >= 5 ? 5 :
  		    d >= 3 ? 3 :
  		    d >= 2 ? 2 : 1;

  		return pow10 * d;
  	}
  });


  // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.
  var scale = function (options) {
  	return new Scale(options);
  };

  var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';


  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */

  var Attribution = Control.extend({
  	// @section
  	// @aka Control.Attribution options
  	options: {
  		position: 'bottomright',

  		// @option prefix: String|false = 'Leaflet'
  		// The HTML text shown before the attributions. Pass `false` to disable.
  		prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'
  	},

  	initialize: function (options) {
  		setOptions(this, options);

  		this._attributions = {};
  	},

  	onAdd: function (map) {
  		map.attributionControl = this;
  		this._container = create$1('div', 'leaflet-control-attribution');
  		disableClickPropagation(this._container);

  		// TODO ugly, refactor
  		for (var i in map._layers) {
  			if (map._layers[i].getAttribution) {
  				this.addAttribution(map._layers[i].getAttribution());
  			}
  		}

  		this._update();

  		map.on('layeradd', this._addAttribution, this);

  		return this._container;
  	},

  	onRemove: function (map) {
  		map.off('layeradd', this._addAttribution, this);
  	},

  	_addAttribution: function (ev) {
  		if (ev.layer.getAttribution) {
  			this.addAttribution(ev.layer.getAttribution());
  			ev.layer.once('remove', function () {
  				this.removeAttribution(ev.layer.getAttribution());
  			}, this);
  		}
  	},

  	// @method setPrefix(prefix: String|false): this
  	// The HTML text shown before the attributions. Pass `false` to disable.
  	setPrefix: function (prefix) {
  		this.options.prefix = prefix;
  		this._update();
  		return this;
  	},

  	// @method addAttribution(text: String): this
  	// Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
  	addAttribution: function (text) {
  		if (!text) { return this; }

  		if (!this._attributions[text]) {
  			this._attributions[text] = 0;
  		}
  		this._attributions[text]++;

  		this._update();

  		return this;
  	},

  	// @method removeAttribution(text: String): this
  	// Removes an attribution text.
  	removeAttribution: function (text) {
  		if (!text) { return this; }

  		if (this._attributions[text]) {
  			this._attributions[text]--;
  			this._update();
  		}

  		return this;
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		var attribs = [];

  		for (var i in this._attributions) {
  			if (this._attributions[i]) {
  				attribs.push(i);
  			}
  		}

  		var prefixAndAttribs = [];

  		if (this.options.prefix) {
  			prefixAndAttribs.push(this.options.prefix);
  		}
  		if (attribs.length) {
  			prefixAndAttribs.push(attribs.join(', '));
  		}

  		this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
  	}
  });

  // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.
  Map.mergeOptions({
  	attributionControl: true
  });

  Map.addInitHook(function () {
  	if (this.options.attributionControl) {
  		new Attribution().addTo(this);
  	}
  });

  // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.
  var attribution = function (options) {
  	return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;

  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;

  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */

  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
  	initialize: function (map) {
  		this._map = map;
  	},

  	// @method enable(): this
  	// Enables the handler
  	enable: function () {
  		if (this._enabled) { return this; }

  		this._enabled = true;
  		this.addHooks();
  		return this;
  	},

  	// @method disable(): this
  	// Disables the handler
  	disable: function () {
  		if (!this._enabled) { return this; }

  		this._enabled = false;
  		this.removeHooks();
  		return this;
  	},

  	// @method enabled(): Boolean
  	// Returns `true` if the handler is enabled
  	enabled: function () {
  		return !!this._enabled;
  	}

  	// @section Extension methods
  	// Classes inheriting from `Handler` must implement the two following methods:
  	// @method addHooks()
  	// Called when the handler is enabled, should add event hooks.
  	// @method removeHooks()
  	// Called when the handler is disabled, should remove the event hooks added previously.
  });

  // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.
  Handler.addTo = function (map, name) {
  	map.addHandler(name, this);
  	return this;
  };

  var Mixin = {Events: Events};

  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';

  var Draggable = Evented.extend({

  	options: {
  		// @section
  		// @aka Draggable options
  		// @option clickTolerance: Number = 3
  		// The max number of pixels a user can shift the mouse pointer during a click
  		// for it to be considered a valid click (as opposed to a mouse drag).
  		clickTolerance: 3
  	},

  	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
  	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
  	initialize: function (element, dragStartTarget, preventOutline, options) {
  		setOptions(this, options);

  		this._element = element;
  		this._dragStartTarget = dragStartTarget || element;
  		this._preventOutline = preventOutline;
  	},

  	// @method enable()
  	// Enables the dragging ability
  	enable: function () {
  		if (this._enabled) { return; }

  		on(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = true;
  	},

  	// @method disable()
  	// Disables the dragging ability
  	disable: function () {
  		if (!this._enabled) { return; }

  		// If we're currently dragging this draggable,
  		// disabling it counts as first ending the drag.
  		if (Draggable._dragging === this) {
  			this.finishDrag(true);
  		}

  		off(this._dragStartTarget, START, this._onDown, this);

  		this._enabled = false;
  		this._moved = false;
  	},

  	_onDown: function (e) {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }

  		this._moved = false;

  		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

  		if (e.touches && e.touches.length !== 1) {
  			// Finish dragging to avoid conflict with touchZoom
  			if (Draggable._dragging === this) {
  				this.finishDrag();
  			}
  			return;
  		}

  		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
  		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

  		if (this._preventOutline) {
  			preventOutline(this._element);
  		}

  		disableImageDrag();
  		disableTextSelection();

  		if (this._moving) { return; }

  		// @event down: Event
  		// Fired when a drag is about to start.
  		this.fire('down');

  		var first = e.touches ? e.touches[0] : e,
  		    sizedParent = getSizedParentNode(this._element);

  		this._startPoint = new Point(first.clientX, first.clientY);
  		this._startPos = getPosition(this._element);

  		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
  		this._parentScale = getScale(sizedParent);

  		var mouseevent = e.type === 'mousedown';
  		on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);
  		on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);
  	},

  	_onMove: function (e) {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }

  		if (e.touches && e.touches.length > 1) {
  			this._moved = true;
  			return;
  		}

  		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
  		    offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

  		if (!offset.x && !offset.y) { return; }
  		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

  		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
  		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
  		// and we can use the cached value for the scale.
  		offset.x /= this._parentScale.x;
  		offset.y /= this._parentScale.y;

  		preventDefault(e);

  		if (!this._moved) {
  			// @event dragstart: Event
  			// Fired when a drag starts
  			this.fire('dragstart');

  			this._moved = true;

  			addClass(document.body, 'leaflet-dragging');

  			this._lastTarget = e.target || e.srcElement;
  			// IE and Edge do not give the <use> element, so fetch it
  			// if necessary
  			if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
  				this._lastTarget = this._lastTarget.correspondingUseElement;
  			}
  			addClass(this._lastTarget, 'leaflet-drag-target');
  		}

  		this._newPos = this._startPos.add(offset);
  		this._moving = true;

  		this._lastEvent = e;
  		this._updatePosition();
  	},

  	_updatePosition: function () {
  		var e = {originalEvent: this._lastEvent};

  		// @event predrag: Event
  		// Fired continuously during dragging *before* each corresponding
  		// update of the element's position.
  		this.fire('predrag', e);
  		setPosition(this._element, this._newPos);

  		// @event drag: Event
  		// Fired continuously during dragging.
  		this.fire('drag', e);
  	},

  	_onUp: function () {
  		// Ignore the event if disabled; this happens in IE11
  		// under some circumstances, see #3666.
  		if (!this._enabled) { return; }
  		this.finishDrag();
  	},

  	finishDrag: function (noInertia) {
  		removeClass(document.body, 'leaflet-dragging');

  		if (this._lastTarget) {
  			removeClass(this._lastTarget, 'leaflet-drag-target');
  			this._lastTarget = null;
  		}

  		off(document, 'mousemove touchmove', this._onMove, this);
  		off(document, 'mouseup touchend touchcancel', this._onUp, this);

  		enableImageDrag();
  		enableTextSelection();

  		var fireDragend = this._moved && this._moving;

  		this._moving = false;
  		Draggable._dragging = false;

  		if (fireDragend) {
  			// @event dragend: DragEndEvent
  			// Fired when the drag ends.
  			this.fire('dragend', {
  				noInertia: noInertia,
  				distance: this._newPos.distanceTo(this._startPos)
  			});
  		}
  	}

  });

  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */
  function clipPolygon(points, bounds, round) {
  	var clippedPoints,
  	    edges = [1, 4, 2, 8],
  	    i, j, k,
  	    a, b,
  	    len, edge, p;

  	for (i = 0, len = points.length; i < len; i++) {
  		points[i]._code = _getBitCode(points[i], bounds);
  	}

  	// for each edge (left, bottom, right, top)
  	for (k = 0; k < 4; k++) {
  		edge = edges[k];
  		clippedPoints = [];

  		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
  			a = points[i];
  			b = points[j];

  			// if a is inside the clip window
  			if (!(a._code & edge)) {
  				// if b is outside the clip window (a->b goes out of screen)
  				if (b._code & edge) {
  					p = _getEdgeIntersection(b, a, edge, bounds, round);
  					p._code = _getBitCode(p, bounds);
  					clippedPoints.push(p);
  				}
  				clippedPoints.push(a);

  			// else if b is inside the clip window (a->b enters the screen)
  			} else if (!(b._code & edge)) {
  				p = _getEdgeIntersection(b, a, edge, bounds, round);
  				p._code = _getBitCode(p, bounds);
  				clippedPoints.push(p);
  			}
  		}
  		points = clippedPoints;
  	}

  	return points;
  }

  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.
   */
  function polygonCenter(latlngs, crs) {
  	var i, j, p1, p2, f, area, x, y, center;

  	if (!latlngs || latlngs.length === 0) {
  		throw new Error('latlngs not passed');
  	}

  	if (!isFlat(latlngs)) {
  		console.warn('latlngs are not flat! Only the first ring will be used');
  		latlngs = latlngs[0];
  	}

  	var centroidLatLng = toLatLng([0, 0]);

  	var bounds = toLatLngBounds(latlngs);
  	var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
  	// tests showed that below 1700 rounding errors are happening
  	if (areaBounds < 1700) {
  		// getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
  		centroidLatLng = centroid(latlngs);
  	}

  	var len = latlngs.length;
  	var points = [];
  	for (i = 0; i < len; i++) {
  		var latlng = toLatLng(latlngs[i]);
  		points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
  	}

  	area = x = y = 0;

  	// polygon centroid algorithm;
  	for (i = 0, j = len - 1; i < len; j = i++) {
  		p1 = points[i];
  		p2 = points[j];

  		f = p1.y * p2.x - p2.y * p1.x;
  		x += (p1.x + p2.x) * f;
  		y += (p1.y + p2.y) * f;
  		area += f * 3;
  	}

  	if (area === 0) {
  		// Polygon is so small that all points are on same pixel.
  		center = points[0];
  	} else {
  		center = [x / area, y / area];
  	}

  	var latlngCenter = crs.unproject(toPoint(center));
  	return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
  }

  /* @function centroid(latlngs: LatLng[]): LatLng
   * Returns the 'center of mass' of the passed LatLngs.
   */
  function centroid(coords) {
  	var latSum = 0;
  	var lngSum = 0;
  	var len = 0;
  	for (var i = 0; i < coords.length; i++) {
  		var latlng = toLatLng(coords[i]);
  		latSum += latlng.lat;
  		lngSum += latlng.lng;
  		len++;
  	}
  	return toLatLng([latSum / len, lngSum / len]);
  }

  var PolyUtil = {
    __proto__: null,
    clipPolygon: clipPolygon,
    polygonCenter: polygonCenter,
    centroid: centroid
  };

  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */

  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.

  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).
  function simplify(points, tolerance) {
  	if (!tolerance || !points.length) {
  		return points.slice();
  	}

  	var sqTolerance = tolerance * tolerance;

  	    // stage 1: vertex reduction
  	    points = _reducePoints(points, sqTolerance);

  	    // stage 2: Douglas-Peucker simplification
  	    points = _simplifyDP(points, sqTolerance);

  	return points;
  }

  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.
  function pointToSegmentDistance(p, p1, p2) {
  	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  }

  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.
  function closestPointOnSegment(p, p1, p2) {
  	return _sqClosestPointOnSegment(p, p1, p2);
  }

  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
  function _simplifyDP(points, sqTolerance) {

  	var len = points.length,
  	    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
  	    markers = new ArrayConstructor(len);

  	    markers[0] = markers[len - 1] = 1;

  	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

  	var i,
  	    newPoints = [];

  	for (i = 0; i < len; i++) {
  		if (markers[i]) {
  			newPoints.push(points[i]);
  		}
  	}

  	return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {

  	var maxSqDist = 0,
  	index, i, sqDist;

  	for (i = first + 1; i <= last - 1; i++) {
  		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

  		if (sqDist > maxSqDist) {
  			index = i;
  			maxSqDist = sqDist;
  		}
  	}

  	if (maxSqDist > sqTolerance) {
  		markers[index] = 1;

  		_simplifyDPStep(points, markers, sqTolerance, first, index);
  		_simplifyDPStep(points, markers, sqTolerance, index, last);
  	}
  }

  // reduce points that are too close to each other to a single point
  function _reducePoints(points, sqTolerance) {
  	var reducedPoints = [points[0]];

  	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
  		if (_sqDist(points[i], points[prev]) > sqTolerance) {
  			reducedPoints.push(points[i]);
  			prev = i;
  		}
  	}
  	if (prev < len - 1) {
  		reducedPoints.push(points[len - 1]);
  	}
  	return reducedPoints;
  }

  var _lastCode;

  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  function clipSegment(a, b, bounds, useLastCode, round) {
  	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
  	    codeB = _getBitCode(b, bounds),

  	    codeOut, p, newCode;

  	    // save 2nd code to avoid calculating it on the next segment
  	    _lastCode = codeB;

  	while (true) {
  		// if a,b is inside the clip window (trivial accept)
  		if (!(codeA | codeB)) {
  			return [a, b];
  		}

  		// if a,b is outside the clip window (trivial reject)
  		if (codeA & codeB) {
  			return false;
  		}

  		// other cases
  		codeOut = codeA || codeB;
  		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
  		newCode = _getBitCode(p, bounds);

  		if (codeOut === codeA) {
  			a = p;
  			codeA = newCode;
  		} else {
  			b = p;
  			codeB = newCode;
  		}
  	}
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
  	var dx = b.x - a.x,
  	    dy = b.y - a.y,
  	    min = bounds.min,
  	    max = bounds.max,
  	    x, y;

  	if (code & 8) { // top
  		x = a.x + dx * (max.y - a.y) / dy;
  		y = max.y;

  	} else if (code & 4) { // bottom
  		x = a.x + dx * (min.y - a.y) / dy;
  		y = min.y;

  	} else if (code & 2) { // right
  		x = max.x;
  		y = a.y + dy * (max.x - a.x) / dx;

  	} else if (code & 1) { // left
  		x = min.x;
  		y = a.y + dy * (min.x - a.x) / dx;
  	}

  	return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
  	var code = 0;

  	if (p.x < bounds.min.x) { // left
  		code |= 1;
  	} else if (p.x > bounds.max.x) { // right
  		code |= 2;
  	}

  	if (p.y < bounds.min.y) { // bottom
  		code |= 4;
  	} else if (p.y > bounds.max.y) { // top
  		code |= 8;
  	}

  	return code;
  }

  // square distance (to avoid unnecessary Math.sqrt calls)
  function _sqDist(p1, p2) {
  	var dx = p2.x - p1.x,
  	    dy = p2.y - p1.y;
  	return dx * dx + dy * dy;
  }

  // return closest point on segment or distance to that point
  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
  	var x = p1.x,
  	    y = p1.y,
  	    dx = p2.x - x,
  	    dy = p2.y - y,
  	    dot = dx * dx + dy * dy,
  	    t;

  	if (dot > 0) {
  		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

  		if (t > 1) {
  			x = p2.x;
  			y = p2.y;
  		} else if (t > 0) {
  			x += dx * t;
  			y += dy * t;
  		}
  	}

  	dx = p.x - x;
  	dy = p.y - y;

  	return sqDist ? dx * dx + dy * dy : new Point(x, y);
  }


  // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.
  function isFlat(latlngs) {
  	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
  }

  function _flat(latlngs) {
  	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
  	return isFlat(latlngs);
  }

  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.
   */
  function polylineCenter(latlngs, crs) {
  	var i, halfDist, segDist, dist, p1, p2, ratio, center;

  	if (!latlngs || latlngs.length === 0) {
  		throw new Error('latlngs not passed');
  	}

  	if (!isFlat(latlngs)) {
  		console.warn('latlngs are not flat! Only the first ring will be used');
  		latlngs = latlngs[0];
  	}

  	var centroidLatLng = toLatLng([0, 0]);

  	var bounds = toLatLngBounds(latlngs);
  	var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
  	// tests showed that below 1700 rounding errors are happening
  	if (areaBounds < 1700) {
  		// getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
  		centroidLatLng = centroid(latlngs);
  	}

  	var len = latlngs.length;
  	var points = [];
  	for (i = 0; i < len; i++) {
  		var latlng = toLatLng(latlngs[i]);
  		points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
  	}

  	for (i = 0, halfDist = 0; i < len - 1; i++) {
  		halfDist += points[i].distanceTo(points[i + 1]) / 2;
  	}

  	// The line is so small in the current view that all points are on the same pixel.
  	if (halfDist === 0) {
  		center = points[0];
  	} else {
  		for (i = 0, dist = 0; i < len - 1; i++) {
  			p1 = points[i];
  			p2 = points[i + 1];
  			segDist = p1.distanceTo(p2);
  			dist += segDist;

  			if (dist > halfDist) {
  				ratio = (dist - halfDist) / segDist;
  				center = [
  					p2.x - ratio * (p2.x - p1.x),
  					p2.y - ratio * (p2.y - p1.y)
  				];
  				break;
  			}
  		}
  	}

  	var latlngCenter = crs.unproject(toPoint(center));
  	return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
  }

  var LineUtil = {
    __proto__: null,
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat,
    polylineCenter: polylineCenter
  };

  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection â€” the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
  	project: function (latlng) {
  		return new Point(latlng.lng, latlng.lat);
  	},

  	unproject: function (point) {
  		return new LatLng(point.y, point.x);
  	},

  	bounds: new Bounds([-180, -90], [180, 90])
  };

  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection â€” more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
  	R: 6378137,
  	R_MINOR: 6356752.314245179,

  	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

  	project: function (latlng) {
  		var d = Math.PI / 180,
  		    r = this.R,
  		    y = latlng.lat * d,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    con = e * Math.sin(y);

  		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
  		y = -r * Math.log(Math.max(ts, 1E-10));

  		return new Point(latlng.lng * d * r, y);
  	},

  	unproject: function (point) {
  		var d = 180 / Math.PI,
  		    r = this.R,
  		    tmp = this.R_MINOR / r,
  		    e = Math.sqrt(1 - tmp * tmp),
  		    ts = Math.exp(-point.y / r),
  		    phi = Math.PI / 2 - 2 * Math.atan(ts);

  		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
  			con = e * Math.sin(phi);
  			con = Math.pow((1 - con) / (1 + con), e / 2);
  			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
  			phi += dphi;
  		}

  		return new LatLng(phi * d, point.x * d / r);
  	}
  };

  /*
   * @class Projection

   * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).

   * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid

   * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.

   * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.

   * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.

   */

  var index = {
    __proto__: null,
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */
  var EPSG3395 = extend({}, Earth, {
  	code: 'EPSG:3395',
  	projection: Mercator,

  	transformation: (function () {
  		var scale = 0.5 / (Math.PI * Mercator.R);
  		return toTransformation(scale, 0.5, -scale, 0.5);
  	}())
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
  	code: 'EPSG:4326',
  	projection: LonLat,
  	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });

  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
  	projection: LonLat,
  	transformation: toTransformation(1, 0, -1, 0),

  	scale: function (zoom) {
  		return Math.pow(2, zoom);
  	},

  	zoom: function (scale) {
  		return Math.log(scale) / Math.LN2;
  	},

  	distance: function (latlng1, latlng2) {
  		var dx = latlng2.lng - latlng1.lng,
  		    dy = latlng2.lat - latlng1.lat;

  		return Math.sqrt(dx * dx + dy * dy);
  	},

  	infinite: true
  });

  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;

  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */


  var Layer = Evented.extend({

  	// Classes extending `L.Layer` will inherit the following options:
  	options: {
  		// @option pane: String = 'overlayPane'
  		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
  		pane: 'overlayPane',

  		// @option attribution: String = null
  		// String to be shown in the attribution control, e.g. "Â© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
  		attribution: null,

  		bubblingMouseEvents: true
  	},

  	/* @section
  	 * Classes extending `L.Layer` will inherit the following methods:
  	 *
  	 * @method addTo(map: Map|LayerGroup): this
  	 * Adds the layer to the given map or layer group.
  	 */
  	addTo: function (map) {
  		map.addLayer(this);
  		return this;
  	},

  	// @method remove: this
  	// Removes the layer from the map it is currently active on.
  	remove: function () {
  		return this.removeFrom(this._map || this._mapToAdd);
  	},

  	// @method removeFrom(map: Map): this
  	// Removes the layer from the given map
  	//
  	// @alternative
  	// @method removeFrom(group: LayerGroup): this
  	// Removes the layer from the given `LayerGroup`
  	removeFrom: function (obj) {
  		if (obj) {
  			obj.removeLayer(this);
  		}
  		return this;
  	},

  	// @method getPane(name? : String): HTMLElement
  	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
  	getPane: function (name) {
  		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
  	},

  	addInteractiveTarget: function (targetEl) {
  		this._map._targets[stamp(targetEl)] = this;
  		return this;
  	},

  	removeInteractiveTarget: function (targetEl) {
  		delete this._map._targets[stamp(targetEl)];
  		return this;
  	},

  	// @method getAttribution: String
  	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
  	getAttribution: function () {
  		return this.options.attribution;
  	},

  	_layerAdd: function (e) {
  		var map = e.target;

  		// check in case layer gets added and then removed before the map is ready
  		if (!map.hasLayer(this)) { return; }

  		this._map = map;
  		this._zoomAnimated = map._zoomAnimated;

  		if (this.getEvents) {
  			var events = this.getEvents();
  			map.on(events, this);
  			this.once('remove', function () {
  				map.off(events, this);
  			}, this);
  		}

  		this.onAdd(map);

  		this.fire('add');
  		map.fire('layeradd', {layer: this});
  	}
  });

  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */


  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */
  Map.include({
  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the map
  	addLayer: function (layer) {
  		if (!layer._layerAdd) {
  			throw new Error('The provided object is not a Layer.');
  		}

  		var id = stamp(layer);
  		if (this._layers[id]) { return this; }
  		this._layers[id] = layer;

  		layer._mapToAdd = this;

  		if (layer.beforeAdd) {
  			layer.beforeAdd(this);
  		}

  		this.whenReady(layer._layerAdd, layer);

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the map.
  	removeLayer: function (layer) {
  		var id = stamp(layer);

  		if (!this._layers[id]) { return this; }

  		if (this._loaded) {
  			layer.onRemove(this);
  		}

  		delete this._layers[id];

  		if (this._loaded) {
  			this.fire('layerremove', {layer: layer});
  			layer.fire('remove');
  		}

  		layer._map = layer._mapToAdd = null;

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the map
  	hasLayer: function (layer) {
  		return stamp(layer) in this._layers;
  	},

  	/* @method eachLayer(fn: Function, context?: Object): this
  	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
  	 * ```
  	 * map.eachLayer(function(layer){
  	 *     layer.bindPopup('Hello');
  	 * });
  	 * ```
  	 */
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	_addLayers: function (layers) {
  		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

  		for (var i = 0, len = layers.length; i < len; i++) {
  			this.addLayer(layers[i]);
  		}
  	},

  	_addZoomLimit: function (layer) {
  		if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
  			this._zoomBoundLayers[stamp(layer)] = layer;
  			this._updateZoomLevels();
  		}
  	},

  	_removeZoomLimit: function (layer) {
  		var id = stamp(layer);

  		if (this._zoomBoundLayers[id]) {
  			delete this._zoomBoundLayers[id];
  			this._updateZoomLevels();
  		}
  	},

  	_updateZoomLevels: function () {
  		var minZoom = Infinity,
  		    maxZoom = -Infinity,
  		    oldZoomSpan = this._getZoomSpan();

  		for (var i in this._zoomBoundLayers) {
  			var options = this._zoomBoundLayers[i].options;

  			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
  			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
  		}

  		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
  		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

  		// @section Map state change events
  		// @event zoomlevelschange: Event
  		// Fired when the number of zoomlevels on the map is changed due
  		// to adding or removing a layer.
  		if (oldZoomSpan !== this._getZoomSpan()) {
  			this.fire('zoomlevelschange');
  		}

  		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
  			this.setZoom(this._layersMaxZoom);
  		}
  		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
  			this.setZoom(this._layersMinZoom);
  		}
  	}
  });

  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Interactive layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({

  	initialize: function (layers, options) {
  		setOptions(this, options);

  		this._layers = {};

  		var i, len;

  		if (layers) {
  			for (i = 0, len = layers.length; i < len; i++) {
  				this.addLayer(layers[i]);
  			}
  		}
  	},

  	// @method addLayer(layer: Layer): this
  	// Adds the given layer to the group.
  	addLayer: function (layer) {
  		var id = this.getLayerId(layer);

  		this._layers[id] = layer;

  		if (this._map) {
  			this._map.addLayer(layer);
  		}

  		return this;
  	},

  	// @method removeLayer(layer: Layer): this
  	// Removes the given layer from the group.
  	// @alternative
  	// @method removeLayer(id: Number): this
  	// Removes the layer with the given internal ID from the group.
  	removeLayer: function (layer) {
  		var id = layer in this._layers ? layer : this.getLayerId(layer);

  		if (this._map && this._layers[id]) {
  			this._map.removeLayer(this._layers[id]);
  		}

  		delete this._layers[id];

  		return this;
  	},

  	// @method hasLayer(layer: Layer): Boolean
  	// Returns `true` if the given layer is currently added to the group.
  	// @alternative
  	// @method hasLayer(id: Number): Boolean
  	// Returns `true` if the given internal ID is currently added to the group.
  	hasLayer: function (layer) {
  		var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
  		return layerId in this._layers;
  	},

  	// @method clearLayers(): this
  	// Removes all the layers from the group.
  	clearLayers: function () {
  		return this.eachLayer(this.removeLayer, this);
  	},

  	// @method invoke(methodName: String, â€¦): this
  	// Calls `methodName` on every layer contained in this group, passing any
  	// additional parameters. Has no effect if the layers contained do not
  	// implement `methodName`.
  	invoke: function (methodName) {
  		var args = Array.prototype.slice.call(arguments, 1),
  		    i, layer;

  		for (i in this._layers) {
  			layer = this._layers[i];

  			if (layer[methodName]) {
  				layer[methodName].apply(layer, args);
  			}
  		}

  		return this;
  	},

  	onAdd: function (map) {
  		this.eachLayer(map.addLayer, map);
  	},

  	onRemove: function (map) {
  		this.eachLayer(map.removeLayer, map);
  	},

  	// @method eachLayer(fn: Function, context?: Object): this
  	// Iterates over the layers of the group, optionally specifying context of the iterator function.
  	// ```js
  	// group.eachLayer(function (layer) {
  	// 	layer.bindPopup('Hello');
  	// });
  	// ```
  	eachLayer: function (method, context) {
  		for (var i in this._layers) {
  			method.call(context, this._layers[i]);
  		}
  		return this;
  	},

  	// @method getLayer(id: Number): Layer
  	// Returns the layer with the given internal ID.
  	getLayer: function (id) {
  		return this._layers[id];
  	},

  	// @method getLayers(): Layer[]
  	// Returns an array of all the layers added to the group.
  	getLayers: function () {
  		var layers = [];
  		this.eachLayer(layers.push, layers);
  		return layers;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
  	setZIndex: function (zIndex) {
  		return this.invoke('setZIndex', zIndex);
  	},

  	// @method getLayerId(layer: Layer): Number
  	// Returns the internal ID for a layer
  	getLayerId: function (layer) {
  		return stamp(layer);
  	}
  });


  // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.
  var layerGroup = function (layers, options) {
  	return new LayerGroup(layers, options);
  };

  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */

  var FeatureGroup = LayerGroup.extend({

  	addLayer: function (layer) {
  		if (this.hasLayer(layer)) {
  			return this;
  		}

  		layer.addEventParent(this);

  		LayerGroup.prototype.addLayer.call(this, layer);

  		// @event layeradd: LayerEvent
  		// Fired when a layer is added to this `FeatureGroup`
  		return this.fire('layeradd', {layer: layer});
  	},

  	removeLayer: function (layer) {
  		if (!this.hasLayer(layer)) {
  			return this;
  		}
  		if (layer in this._layers) {
  			layer = this._layers[layer];
  		}

  		layer.removeEventParent(this);

  		LayerGroup.prototype.removeLayer.call(this, layer);

  		// @event layerremove: LayerEvent
  		// Fired when a layer is removed from this `FeatureGroup`
  		return this.fire('layerremove', {layer: layer});
  	},

  	// @method setStyle(style: Path options): this
  	// Sets the given path options to each layer of the group that has a `setStyle` method.
  	setStyle: function (style) {
  		return this.invoke('setStyle', style);
  	},

  	// @method bringToFront(): this
  	// Brings the layer group to the top of all other layers
  	bringToFront: function () {
  		return this.invoke('bringToFront');
  	},

  	// @method bringToBack(): this
  	// Brings the layer group to the back of all other layers
  	bringToBack: function () {
  		return this.invoke('bringToBack');
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
  	getBounds: function () {
  		var bounds = new LatLngBounds();

  		for (var id in this._layers) {
  			var layer = this._layers[id];
  			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
  		}
  		return bounds;
  	}
  });

  // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.
  var featureGroup = function (layers, options) {
  	return new FeatureGroup(layers, options);
  };

  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */

  var Icon = Class.extend({

  	/* @section
  	 * @aka Icon options
  	 *
  	 * @option iconUrl: String = null
  	 * **(required)** The URL to the icon image (absolute or relative to your script path).
  	 *
  	 * @option iconRetinaUrl: String = null
  	 * The URL to a retina sized version of the icon image (absolute or relative to your
  	 * script path). Used for Retina screen devices.
  	 *
  	 * @option iconSize: Point = null
  	 * Size of the icon image in pixels.
  	 *
  	 * @option iconAnchor: Point = null
  	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  	 * will be aligned so that this point is at the marker's geographical location. Centered
  	 * by default if size is specified, also can be set in CSS with negative margins.
  	 *
  	 * @option popupAnchor: Point = [0, 0]
  	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
  	 *
  	 * @option tooltipAnchor: Point = [0, 0]
  	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
  	 *
  	 * @option shadowUrl: String = null
  	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
  	 *
  	 * @option shadowRetinaUrl: String = null
  	 *
  	 * @option shadowSize: Point = null
  	 * Size of the shadow image in pixels.
  	 *
  	 * @option shadowAnchor: Point = null
  	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  	 * as iconAnchor if not specified).
  	 *
  	 * @option className: String = ''
  	 * A custom class name to assign to both icon and shadow images. Empty by default.
  	 */

  	options: {
  		popupAnchor: [0, 0],
  		tooltipAnchor: [0, 0],

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
  	// Called internally when the icon has to be shown, returns a `<img>` HTML element
  	// styled according to the options.
  	createIcon: function (oldIcon) {
  		return this._createIcon('icon', oldIcon);
  	},

  	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
  	// As `createIcon`, but for the shadow beneath it.
  	createShadow: function (oldIcon) {
  		return this._createIcon('shadow', oldIcon);
  	},

  	_createIcon: function (name, oldIcon) {
  		var src = this._getIconUrl(name);

  		if (!src) {
  			if (name === 'icon') {
  				throw new Error('iconUrl not set in Icon options (see the docs).');
  			}
  			return null;
  		}

  		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
  		this._setIconStyles(img, name);

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		return img;
  	},

  	_setIconStyles: function (img, name) {
  		var options = this.options;
  		var sizeOption = options[name + 'Size'];

  		if (typeof sizeOption === 'number') {
  			sizeOption = [sizeOption, sizeOption];
  		}

  		var size = toPoint(sizeOption),
  		    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
  		            size && size.divideBy(2, true));

  		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

  		if (anchor) {
  			img.style.marginLeft = (-anchor.x) + 'px';
  			img.style.marginTop  = (-anchor.y) + 'px';
  		}

  		if (size) {
  			img.style.width  = size.x + 'px';
  			img.style.height = size.y + 'px';
  		}
  	},

  	_createImg: function (src, el) {
  		el = el || document.createElement('img');
  		el.src = src;
  		return el;
  	},

  	_getIconUrl: function (name) {
  		return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
  	}
  });


  // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.
  function icon(options) {
  	return new Icon(options);
  }

  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */

  var IconDefault = Icon.extend({

  	options: {
  		iconUrl:       'marker-icon.png',
  		iconRetinaUrl: 'marker-icon-2x.png',
  		shadowUrl:     'marker-shadow.png',
  		iconSize:    [25, 41],
  		iconAnchor:  [12, 41],
  		popupAnchor: [1, -34],
  		tooltipAnchor: [16, -28],
  		shadowSize:  [41, 41]
  	},

  	_getIconUrl: function (name) {
  		if (typeof IconDefault.imagePath !== 'string') {	// Deprecated, backwards-compatibility only
  			IconDefault.imagePath = this._detectIconPath();
  		}

  		// @option imagePath: String
  		// `Icon.Default` will try to auto-detect the location of the
  		// blue icon images. If you are placing these images in a non-standard
  		// way, set this option to point to the right path.
  		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
  	},

  	_stripUrl: function (path) {	// separate function to use in tests
  		var strip = function (str, re, idx) {
  			var match = re.exec(str);
  			return match && match[idx];
  		};
  		path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
  		return path && strip(path, /^(.*)marker-icon\.png$/, 1);
  	},

  	_detectIconPath: function () {
  		var el = create$1('div',  'leaflet-default-icon-path', document.body);
  		var path = getStyle(el, 'background-image') ||
  		           getStyle(el, 'backgroundImage');	// IE8

  		document.body.removeChild(el);
  		path = this._stripUrl(path);
  		if (path) { return path; }
  		var link = document.querySelector('link[href$="leaflet.css"]');
  		if (!link) { return ''; }
  		return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);
  	}
  });

  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */


  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
  	initialize: function (marker) {
  		this._marker = marker;
  	},

  	addHooks: function () {
  		var icon = this._marker._icon;

  		if (!this._draggable) {
  			this._draggable = new Draggable(icon, icon, true);
  		}

  		this._draggable.on({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).enable();

  		addClass(icon, 'leaflet-marker-draggable');
  	},

  	removeHooks: function () {
  		this._draggable.off({
  			dragstart: this._onDragStart,
  			predrag: this._onPreDrag,
  			drag: this._onDrag,
  			dragend: this._onDragEnd
  		}, this).disable();

  		if (this._marker._icon) {
  			removeClass(this._marker._icon, 'leaflet-marker-draggable');
  		}
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	_adjustPan: function (e) {
  		var marker = this._marker,
  		    map = marker._map,
  		    speed = this._marker.options.autoPanSpeed,
  		    padding = this._marker.options.autoPanPadding,
  		    iconPos = getPosition(marker._icon),
  		    bounds = map.getPixelBounds(),
  		    origin = map.getPixelOrigin();

  		var panBounds = toBounds(
  			bounds.min._subtract(origin).add(padding),
  			bounds.max._subtract(origin).subtract(padding)
  		);

  		if (!panBounds.contains(iconPos)) {
  			// Compute incremental movement
  			var movement = toPoint(
  				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
  				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

  				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
  				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
  			).multiplyBy(speed);

  			map.panBy(movement, {animate: false});

  			this._draggable._newPos._add(movement);
  			this._draggable._startPos._add(movement);

  			setPosition(marker._icon, this._draggable._newPos);
  			this._onDrag(e);

  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDragStart: function () {
  		// @section Dragging events
  		// @event dragstart: Event
  		// Fired when the user starts dragging the marker.

  		// @event movestart: Event
  		// Fired when the marker starts moving (because of dragging).

  		this._oldLatLng = this._marker.getLatLng();

  		// When using ES6 imports it could not be set when `Popup` was not imported as well
  		this._marker.closePopup && this._marker.closePopup();

  		this._marker
  			.fire('movestart')
  			.fire('dragstart');
  	},

  	_onPreDrag: function (e) {
  		if (this._marker.options.autoPan) {
  			cancelAnimFrame(this._panRequest);
  			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
  		}
  	},

  	_onDrag: function (e) {
  		var marker = this._marker,
  		    shadow = marker._shadow,
  		    iconPos = getPosition(marker._icon),
  		    latlng = marker._map.layerPointToLatLng(iconPos);

  		// update shadow position
  		if (shadow) {
  			setPosition(shadow, iconPos);
  		}

  		marker._latlng = latlng;
  		e.latlng = latlng;
  		e.oldLatLng = this._oldLatLng;

  		// @event drag: Event
  		// Fired repeatedly while the user drags the marker.
  		marker
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_onDragEnd: function (e) {
  		// @event dragend: DragEndEvent
  		// Fired when the user stops dragging the marker.

  		 cancelAnimFrame(this._panRequest);

  		// @event moveend: Event
  		// Fired when the marker stops moving (because of dragging).
  		delete this._oldLatLng;
  		this._marker
  		    .fire('moveend')
  		    .fire('dragend', e);
  	}
  });

  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({

  	// @section
  	// @aka Marker options
  	options: {
  		// @option icon: Icon = *
  		// Icon instance to use for rendering the marker.
  		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
  		// If not specified, a common instance of `L.Icon.Default` is used.
  		icon: new IconDefault(),

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option keyboard: Boolean = true
  		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
  		keyboard: true,

  		// @option title: String = ''
  		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
  		// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
  		title: '',

  		// @option alt: String = 'Marker'
  		// Text for the `alt` attribute of the icon image.
  		// [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
  		alt: 'Marker',

  		// @option zIndexOffset: Number = 0
  		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
  		zIndexOffset: 0,

  		// @option opacity: Number = 1.0
  		// The opacity of the marker.
  		opacity: 1,

  		// @option riseOnHover: Boolean = false
  		// If `true`, the marker will get on top of others when you hover the mouse over it.
  		riseOnHover: false,

  		// @option riseOffset: Number = 250
  		// The z-index offset used for the `riseOnHover` feature.
  		riseOffset: 250,

  		// @option pane: String = 'markerPane'
  		// `Map pane` where the markers icon will be added.
  		pane: 'markerPane',

  		// @option shadowPane: String = 'shadowPane'
  		// `Map pane` where the markers shadow will be added.
  		shadowPane: 'shadowPane',

  		// @option bubblingMouseEvents: Boolean = false
  		// When `true`, a mouse event on this marker will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: false,

  		// @option autoPanOnFocus: Boolean = true
  		// When `true`, the map will pan whenever the marker is focused (via
  		// e.g. pressing `tab` on the keyboard) to ensure the marker is
  		// visible within the map's bounds
  		autoPanOnFocus: true,

  		// @section Draggable marker options
  		// @option draggable: Boolean = false
  		// Whether the marker is draggable with mouse/touch or not.
  		draggable: false,

  		// @option autoPan: Boolean = false
  		// Whether to pan the map when dragging this marker near its edge or not.
  		autoPan: false,

  		// @option autoPanPadding: Point = Point(50, 50)
  		// Distance (in pixels to the left/right and to the top/bottom) of the
  		// map edge to start panning the map.
  		autoPanPadding: [50, 50],

  		// @option autoPanSpeed: Number = 10
  		// Number of pixels the map should pan by.
  		autoPanSpeed: 10
  	},

  	/* @section
  	 *
  	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  	 */

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

  		if (this._zoomAnimated) {
  			map.on('zoomanim', this._animateZoom, this);
  		}

  		this._initIcon();
  		this.update();
  	},

  	onRemove: function (map) {
  		if (this.dragging && this.dragging.enabled()) {
  			this.options.draggable = true;
  			this.dragging.removeHooks();
  		}
  		delete this.dragging;

  		if (this._zoomAnimated) {
  			map.off('zoomanim', this._animateZoom, this);
  		}

  		this._removeIcon();
  		this._removeShadow();
  	},

  	getEvents: function () {
  		return {
  			zoom: this.update,
  			viewreset: this.update
  		};
  	},

  	// @method getLatLng: LatLng
  	// Returns the current geographical position of the marker.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Changes the marker position to the given point.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.update();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method setZIndexOffset(offset: Number): this
  	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
  	setZIndexOffset: function (offset) {
  		this.options.zIndexOffset = offset;
  		return this.update();
  	},

  	// @method getIcon: Icon
  	// Returns the current icon used by the marker
  	getIcon: function () {
  		return this.options.icon;
  	},

  	// @method setIcon(icon: Icon): this
  	// Changes the marker icon.
  	setIcon: function (icon) {

  		this.options.icon = icon;

  		if (this._map) {
  			this._initIcon();
  			this.update();
  		}

  		if (this._popup) {
  			this.bindPopup(this._popup, this._popup.options);
  		}

  		return this;
  	},

  	getElement: function () {
  		return this._icon;
  	},

  	update: function () {

  		if (this._icon && this._map) {
  			var pos = this._map.latLngToLayerPoint(this._latlng).round();
  			this._setPos(pos);
  		}

  		return this;
  	},

  	_initIcon: function () {
  		var options = this.options,
  		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		var icon = options.icon.createIcon(this._icon),
  		    addIcon = false;

  		// if we're not reusing the icon, remove the old one and init new one
  		if (icon !== this._icon) {
  			if (this._icon) {
  				this._removeIcon();
  			}
  			addIcon = true;

  			if (options.title) {
  				icon.title = options.title;
  			}

  			if (icon.tagName === 'IMG') {
  				icon.alt = options.alt || '';
  			}
  		}

  		addClass(icon, classToAdd);

  		if (options.keyboard) {
  			icon.tabIndex = '0';
  			icon.setAttribute('role', 'button');
  		}

  		this._icon = icon;

  		if (options.riseOnHover) {
  			this.on({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		if (this.options.autoPanOnFocus) {
  			on(icon, 'focus', this._panOnFocus, this);
  		}

  		var newShadow = options.icon.createShadow(this._shadow),
  		    addShadow = false;

  		if (newShadow !== this._shadow) {
  			this._removeShadow();
  			addShadow = true;
  		}

  		if (newShadow) {
  			addClass(newShadow, classToAdd);
  			newShadow.alt = '';
  		}
  		this._shadow = newShadow;


  		if (options.opacity < 1) {
  			this._updateOpacity();
  		}


  		if (addIcon) {
  			this.getPane().appendChild(this._icon);
  		}
  		this._initInteraction();
  		if (newShadow && addShadow) {
  			this.getPane(options.shadowPane).appendChild(this._shadow);
  		}
  	},

  	_removeIcon: function () {
  		if (this.options.riseOnHover) {
  			this.off({
  				mouseover: this._bringToFront,
  				mouseout: this._resetZIndex
  			});
  		}

  		if (this.options.autoPanOnFocus) {
  			off(this._icon, 'focus', this._panOnFocus, this);
  		}

  		remove(this._icon);
  		this.removeInteractiveTarget(this._icon);

  		this._icon = null;
  	},

  	_removeShadow: function () {
  		if (this._shadow) {
  			remove(this._shadow);
  		}
  		this._shadow = null;
  	},

  	_setPos: function (pos) {

  		if (this._icon) {
  			setPosition(this._icon, pos);
  		}

  		if (this._shadow) {
  			setPosition(this._shadow, pos);
  		}

  		this._zIndex = pos.y + this.options.zIndexOffset;

  		this._resetZIndex();
  	},

  	_updateZIndex: function (offset) {
  		if (this._icon) {
  			this._icon.style.zIndex = this._zIndex + offset;
  		}
  	},

  	_animateZoom: function (opt) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

  		this._setPos(pos);
  	},

  	_initInteraction: function () {

  		if (!this.options.interactive) { return; }

  		addClass(this._icon, 'leaflet-interactive');

  		this.addInteractiveTarget(this._icon);

  		if (MarkerDrag) {
  			var draggable = this.options.draggable;
  			if (this.dragging) {
  				draggable = this.dragging.enabled();
  				this.dragging.disable();
  			}

  			this.dragging = new MarkerDrag(this);

  			if (draggable) {
  				this.dragging.enable();
  			}
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the opacity of the marker.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		if (this._map) {
  			this._updateOpacity();
  		}

  		return this;
  	},

  	_updateOpacity: function () {
  		var opacity = this.options.opacity;

  		if (this._icon) {
  			setOpacity(this._icon, opacity);
  		}

  		if (this._shadow) {
  			setOpacity(this._shadow, opacity);
  		}
  	},

  	_bringToFront: function () {
  		this._updateZIndex(this.options.riseOffset);
  	},

  	_resetZIndex: function () {
  		this._updateZIndex(0);
  	},

  	_panOnFocus: function () {
  		var map = this._map;
  		if (!map) { return; }

  		var iconOpts = this.options.icon.options;
  		var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
  		var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);

  		map.panInside(this._latlng, {
  			paddingTopLeft: anchor,
  			paddingBottomRight: size.subtract(anchor)
  		});
  	},

  	_getPopupAnchor: function () {
  		return this.options.icon.options.popupAnchor;
  	},

  	_getTooltipAnchor: function () {
  		return this.options.icon.options.tooltipAnchor;
  	}
  });


  // factory L.marker(latlng: LatLng, options? : Marker options)

  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.
  function marker(latlng, options) {
  	return new Marker(latlng, options);
  }

  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */

  var Path = Layer.extend({

  	// @section
  	// @aka Path options
  	options: {
  		// @option stroke: Boolean = true
  		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
  		stroke: true,

  		// @option color: String = '#3388ff'
  		// Stroke color
  		color: '#3388ff',

  		// @option weight: Number = 3
  		// Stroke width in pixels
  		weight: 3,

  		// @option opacity: Number = 1.0
  		// Stroke opacity
  		opacity: 1,

  		// @option lineCap: String= 'round'
  		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
  		lineCap: 'round',

  		// @option lineJoin: String = 'round'
  		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
  		lineJoin: 'round',

  		// @option dashArray: String = null
  		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashArray: null,

  		// @option dashOffset: String = null
  		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
  		dashOffset: null,

  		// @option fill: Boolean = depends
  		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
  		fill: false,

  		// @option fillColor: String = *
  		// Fill color. Defaults to the value of the [`color`](#path-color) option
  		fillColor: null,

  		// @option fillOpacity: Number = 0.2
  		// Fill opacity.
  		fillOpacity: 0.2,

  		// @option fillRule: String = 'evenodd'
  		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
  		fillRule: 'evenodd',

  		// className: '',

  		// Option inherited from "Interactive layer" abstract class
  		interactive: true,

  		// @option bubblingMouseEvents: Boolean = true
  		// When `true`, a mouse event on this path will trigger the same event on the map
  		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
  		bubblingMouseEvents: true
  	},

  	beforeAdd: function (map) {
  		// Renderer is set here because we need to call renderer.getEvents
  		// before this.getEvents.
  		this._renderer = map.getRenderer(this);
  	},

  	onAdd: function () {
  		this._renderer._initPath(this);
  		this._reset();
  		this._renderer._addPath(this);
  	},

  	onRemove: function () {
  		this._renderer._removePath(this);
  	},

  	// @method redraw(): this
  	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
  	redraw: function () {
  		if (this._map) {
  			this._renderer._updatePath(this);
  		}
  		return this;
  	},

  	// @method setStyle(style: Path options): this
  	// Changes the appearance of a Path based on the options in the `Path options` object.
  	setStyle: function (style) {
  		setOptions(this, style);
  		if (this._renderer) {
  			this._renderer._updateStyle(this);
  			if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
  				this._updateBounds();
  			}
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all path layers.
  	bringToFront: function () {
  		if (this._renderer) {
  			this._renderer._bringToFront(this);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all path layers.
  	bringToBack: function () {
  		if (this._renderer) {
  			this._renderer._bringToBack(this);
  		}
  		return this;
  	},

  	getElement: function () {
  		return this._path;
  	},

  	_reset: function () {
  		// defined in child classes
  		this._project();
  		this._update();
  	},

  	_clickTolerance: function () {
  		// used when doing hit detection for Canvas layers
  		return (this.options.stroke ? this.options.weight / 2 : 0) +
  		  (this._renderer.options.tolerance || 0);
  	}
  });

  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({

  	// @section
  	// @aka CircleMarker options
  	options: {
  		fill: true,

  		// @option radius: Number = 10
  		// Radius of the circle marker, in pixels
  		radius: 10
  	},

  	initialize: function (latlng, options) {
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);
  		this._radius = this.options.radius;
  	},

  	// @method setLatLng(latLng: LatLng): this
  	// Sets the position of a circle marker to a new location.
  	setLatLng: function (latlng) {
  		var oldLatLng = this._latlng;
  		this._latlng = toLatLng(latlng);
  		this.redraw();

  		// @event move: Event
  		// Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
  		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
  	},

  	// @method getLatLng(): LatLng
  	// Returns the current geographical position of the circle marker
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle marker. Units are in pixels.
  	setRadius: function (radius) {
  		this.options.radius = this._radius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of the circle
  	getRadius: function () {
  		return this._radius;
  	},

  	setStyle : function (options) {
  		var radius = options && options.radius || this._radius;
  		Path.prototype.setStyle.call(this, options);
  		this.setRadius(radius);
  		return this;
  	},

  	_project: function () {
  		this._point = this._map.latLngToLayerPoint(this._latlng);
  		this._updateBounds();
  	},

  	_updateBounds: function () {
  		var r = this._radius,
  		    r2 = this._radiusY || r,
  		    w = this._clickTolerance(),
  		    p = [r + w, r2 + w];
  		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
  	},

  	_update: function () {
  		if (this._map) {
  			this._updatePath();
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updateCircle(this);
  	},

  	_empty: function () {
  		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
  	}
  });


  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.
  function circleMarker(latlng, options) {
  	return new CircleMarker(latlng, options);
  }

  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */

  var Circle = CircleMarker.extend({

  	initialize: function (latlng, options, legacyOptions) {
  		if (typeof options === 'number') {
  			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
  			options = extend({}, legacyOptions, {radius: options});
  		}
  		setOptions(this, options);
  		this._latlng = toLatLng(latlng);

  		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

  		// @section
  		// @aka Circle options
  		// @option radius: Number; Radius of the circle, in meters.
  		this._mRadius = this.options.radius;
  	},

  	// @method setRadius(radius: Number): this
  	// Sets the radius of a circle. Units are in meters.
  	setRadius: function (radius) {
  		this._mRadius = radius;
  		return this.redraw();
  	},

  	// @method getRadius(): Number
  	// Returns the current radius of a circle. Units are in meters.
  	getRadius: function () {
  		return this._mRadius;
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		var half = [this._radius, this._radiusY || this._radius];

  		return new LatLngBounds(
  			this._map.layerPointToLatLng(this._point.subtract(half)),
  			this._map.layerPointToLatLng(this._point.add(half)));
  	},

  	setStyle: Path.prototype.setStyle,

  	_project: function () {

  		var lng = this._latlng.lng,
  		    lat = this._latlng.lat,
  		    map = this._map,
  		    crs = map.options.crs;

  		if (crs.distance === Earth.distance) {
  			var d = Math.PI / 180,
  			    latR = (this._mRadius / Earth.R) / d,
  			    top = map.project([lat + latR, lng]),
  			    bottom = map.project([lat - latR, lng]),
  			    p = top.add(bottom).divideBy(2),
  			    lat2 = map.unproject(p).lat,
  			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
  			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

  			if (isNaN(lngR) || lngR === 0) {
  				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
  			}

  			this._point = p.subtract(map.getPixelOrigin());
  			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
  			this._radiusY = p.y - top.y;

  		} else {
  			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

  			this._point = map.latLngToLayerPoint(this._latlng);
  			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
  		}

  		this._updateBounds();
  	}
  });

  // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.
  function circle(latlng, options, legacyOptions) {
  	return new Circle(latlng, options, legacyOptions);
  }

  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({

  	// @section
  	// @aka Polyline options
  	options: {
  		// @option smoothFactor: Number = 1.0
  		// How much to simplify the polyline on each zoom level. More means
  		// better performance and smoother look, and less means more accurate representation.
  		smoothFactor: 1.0,

  		// @option noClip: Boolean = false
  		// Disable polyline clipping.
  		noClip: false
  	},

  	initialize: function (latlngs, options) {
  		setOptions(this, options);
  		this._setLatLngs(latlngs);
  	},

  	// @method getLatLngs(): LatLng[]
  	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
  	getLatLngs: function () {
  		return this._latlngs;
  	},

  	// @method setLatLngs(latlngs: LatLng[]): this
  	// Replaces all the points in the polyline with the given array of geographical points.
  	setLatLngs: function (latlngs) {
  		this._setLatLngs(latlngs);
  		return this.redraw();
  	},

  	// @method isEmpty(): Boolean
  	// Returns `true` if the Polyline has no LatLngs.
  	isEmpty: function () {
  		return !this._latlngs.length;
  	},

  	// @method closestLayerPoint(p: Point): Point
  	// Returns the point closest to `p` on the Polyline.
  	closestLayerPoint: function (p) {
  		var minDistance = Infinity,
  		    minPoint = null,
  		    closest = _sqClosestPointOnSegment,
  		    p1, p2;

  		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
  			var points = this._parts[j];

  			for (var i = 1, len = points.length; i < len; i++) {
  				p1 = points[i - 1];
  				p2 = points[i];

  				var sqDist = closest(p, p1, p2, true);

  				if (sqDist < minDistance) {
  					minDistance = sqDist;
  					minPoint = closest(p, p1, p2);
  				}
  			}
  		}
  		if (minPoint) {
  			minPoint.distance = Math.sqrt(minDistance);
  		}
  		return minPoint;
  	},

  	// @method getCenter(): LatLng
  	// Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}
  		return polylineCenter(this._defaultShape(), this._map.options.crs);
  	},

  	// @method getBounds(): LatLngBounds
  	// Returns the `LatLngBounds` of the path.
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
  	// Adds a given point to the polyline. By default, adds to the first ring of
  	// the polyline in case of a multi-polyline, but can be overridden by passing
  	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
  	addLatLng: function (latlng, latlngs) {
  		latlngs = latlngs || this._defaultShape();
  		latlng = toLatLng(latlng);
  		latlngs.push(latlng);
  		this._bounds.extend(latlng);
  		return this.redraw();
  	},

  	_setLatLngs: function (latlngs) {
  		this._bounds = new LatLngBounds();
  		this._latlngs = this._convertLatLngs(latlngs);
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
  	},

  	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
  	_convertLatLngs: function (latlngs) {
  		var result = [],
  		    flat = isFlat(latlngs);

  		for (var i = 0, len = latlngs.length; i < len; i++) {
  			if (flat) {
  				result[i] = toLatLng(latlngs[i]);
  				this._bounds.extend(result[i]);
  			} else {
  				result[i] = this._convertLatLngs(latlngs[i]);
  			}
  		}

  		return result;
  	},

  	_project: function () {
  		var pxBounds = new Bounds();
  		this._rings = [];
  		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

  		if (this._bounds.isValid() && pxBounds.isValid()) {
  			this._rawPxBounds = pxBounds;
  			this._updateBounds();
  		}
  	},

  	_updateBounds: function () {
  		var w = this._clickTolerance(),
  		    p = new Point(w, w);

  		if (!this._rawPxBounds) {
  			return;
  		}

  		this._pxBounds = new Bounds([
  			this._rawPxBounds.min.subtract(p),
  			this._rawPxBounds.max.add(p)
  		]);
  	},

  	// recursively turns latlngs into a set of rings with projected coordinates
  	_projectLatlngs: function (latlngs, result, projectedBounds) {
  		var flat = latlngs[0] instanceof LatLng,
  		    len = latlngs.length,
  		    i, ring;

  		if (flat) {
  			ring = [];
  			for (i = 0; i < len; i++) {
  				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
  				projectedBounds.extend(ring[i]);
  			}
  			result.push(ring);
  		} else {
  			for (i = 0; i < len; i++) {
  				this._projectLatlngs(latlngs[i], result, projectedBounds);
  			}
  		}
  	},

  	// clip polyline by renderer bounds so that we have less to render for performance
  	_clipPoints: function () {
  		var bounds = this._renderer._bounds;

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		var parts = this._parts,
  		    i, j, k, len, len2, segment, points;

  		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
  			points = this._rings[i];

  			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
  				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

  				if (!segment) { continue; }

  				parts[k] = parts[k] || [];
  				parts[k].push(segment[0]);

  				// if segment goes out of screen, or it's the last one, it's the end of the line part
  				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
  					parts[k].push(segment[1]);
  					k++;
  				}
  			}
  		}
  	},

  	// simplify each clipped part of the polyline for performance
  	_simplifyPoints: function () {
  		var parts = this._parts,
  		    tolerance = this.options.smoothFactor;

  		for (var i = 0, len = parts.length; i < len; i++) {
  			parts[i] = simplify(parts[i], tolerance);
  		}
  	},

  	_update: function () {
  		if (!this._map) { return; }

  		this._clipPoints();
  		this._simplifyPoints();
  		this._updatePath();
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p, closed) {
  		var i, j, k, len, len2, part,
  		    w = this._clickTolerance();

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// hit detection for polylines
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				if (!closed && (j === 0)) { continue; }

  				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
  					return true;
  				}
  			}
  		}
  		return false;
  	}
  });

  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.
  function polyline(latlngs, options) {
  	return new Polyline(latlngs, options);
  }

  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
  Polyline._flat = _flat;

  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one â€” it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({

  	options: {
  		fill: true
  	},

  	isEmpty: function () {
  		return !this._latlngs.length || !this._latlngs[0].length;
  	},

  	// @method getCenter(): LatLng
  	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
  	getCenter: function () {
  		// throws error when not yet added to map as this center calculation requires projected coordinates
  		if (!this._map) {
  			throw new Error('Must add layer to map before using getCenter()');
  		}
  		return polygonCenter(this._defaultShape(), this._map.options.crs);
  	},

  	_convertLatLngs: function (latlngs) {
  		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
  		    len = result.length;

  		// remove last point if it equals first one
  		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
  			result.pop();
  		}
  		return result;
  	},

  	_setLatLngs: function (latlngs) {
  		Polyline.prototype._setLatLngs.call(this, latlngs);
  		if (isFlat(this._latlngs)) {
  			this._latlngs = [this._latlngs];
  		}
  	},

  	_defaultShape: function () {
  		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
  	},

  	_clipPoints: function () {
  		// polygons need a different clipping algorithm so we redefine that

  		var bounds = this._renderer._bounds,
  		    w = this.options.weight,
  		    p = new Point(w, w);

  		// increase clip padding by stroke width to avoid stroke on clip edges
  		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

  		this._parts = [];
  		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
  			return;
  		}

  		if (this.options.noClip) {
  			this._parts = this._rings;
  			return;
  		}

  		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
  			clipped = clipPolygon(this._rings[i], bounds, true);
  			if (clipped.length) {
  				this._parts.push(clipped);
  			}
  		}
  	},

  	_updatePath: function () {
  		this._renderer._updatePoly(this, true);
  	},

  	// Needed by the `Canvas` renderer for interactivity
  	_containsPoint: function (p) {
  		var inside = false,
  		    part, p1, p2, i, j, k, len, len2;

  		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

  		// ray casting algorithm for detecting if point is in polygon
  		for (i = 0, len = this._parts.length; i < len; i++) {
  			part = this._parts[i];

  			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
  				p1 = part[j];
  				p2 = part[k];

  				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
  					inside = !inside;
  				}
  			}
  		}

  		// also check if it's on polygon stroke
  		return inside || Polyline.prototype._containsPoint.call(this, p, true);
  	}

  });


  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
  function polygon(latlngs, options) {
  	return new Polygon(latlngs, options);
  }

  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */

  var GeoJSON = FeatureGroup.extend({

  	/* @section
  	 * @aka GeoJSON options
  	 *
  	 * @option pointToLayer: Function = *
  	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  	 * The default is to spawn a default `Marker`:
  	 * ```js
  	 * function(geoJsonPoint, latlng) {
  	 * 	return L.marker(latlng);
  	 * }
  	 * ```
  	 *
  	 * @option style: Function = *
  	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  	 * called internally when data is added.
  	 * The default value is to not override any defaults:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return {}
  	 * }
  	 * ```
  	 *
  	 * @option onEachFeature: Function = *
  	 * A `Function` that will be called once for each created `Feature`, after it has
  	 * been created and styled. Useful for attaching events and popups to features.
  	 * The default is to do nothing with the newly created layers:
  	 * ```js
  	 * function (feature, layer) {}
  	 * ```
  	 *
  	 * @option filter: Function = *
  	 * A `Function` that will be used to decide whether to include a feature or not.
  	 * The default is to include all features:
  	 * ```js
  	 * function (geoJsonFeature) {
  	 * 	return true;
  	 * }
  	 * ```
  	 * Note: dynamically changing the `filter` option will have effect only on newly
  	 * added data. It will _not_ re-evaluate already included features.
  	 *
  	 * @option coordsToLatLng: Function = *
  	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  	 * The default is the `coordsToLatLng` static method.
  	 *
  	 * @option markersInheritOptions: Boolean = false
  	 * Whether default Markers for "Point" type Features inherit from group options.
  	 */

  	initialize: function (geojson, options) {
  		setOptions(this, options);

  		this._layers = {};

  		if (geojson) {
  			this.addData(geojson);
  		}
  	},

  	// @method addData( <GeoJSON> data ): this
  	// Adds a GeoJSON object to the layer.
  	addData: function (geojson) {
  		var features = isArray(geojson) ? geojson : geojson.features,
  		    i, len, feature;

  		if (features) {
  			for (i = 0, len = features.length; i < len; i++) {
  				// only add this if geometry or geometries are set and not null
  				feature = features[i];
  				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
  					this.addData(feature);
  				}
  			}
  			return this;
  		}

  		var options = this.options;

  		if (options.filter && !options.filter(geojson)) { return this; }

  		var layer = geometryToLayer(geojson, options);
  		if (!layer) {
  			return this;
  		}
  		layer.feature = asFeature(geojson);

  		layer.defaultOptions = layer.options;
  		this.resetStyle(layer);

  		if (options.onEachFeature) {
  			options.onEachFeature(geojson, layer);
  		}

  		return this.addLayer(layer);
  	},

  	// @method resetStyle( <Path> layer? ): this
  	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
  	// If `layer` is omitted, the style of all features in the current layer is reset.
  	resetStyle: function (layer) {
  		if (layer === undefined) {
  			return this.eachLayer(this.resetStyle, this);
  		}
  		// reset any custom styles
  		layer.options = extend({}, layer.defaultOptions);
  		this._setLayerStyle(layer, this.options.style);
  		return this;
  	},

  	// @method setStyle( <Function> style ): this
  	// Changes styles of GeoJSON vector layers with the given style function.
  	setStyle: function (style) {
  		return this.eachLayer(function (layer) {
  			this._setLayerStyle(layer, style);
  		}, this);
  	},

  	_setLayerStyle: function (layer, style) {
  		if (layer.setStyle) {
  			if (typeof style === 'function') {
  				style = style(layer.feature);
  			}
  			layer.setStyle(style);
  		}
  	}
  });

  // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:

  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.
  function geometryToLayer(geojson, options) {

  	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
  	    coords = geometry ? geometry.coordinates : null,
  	    layers = [],
  	    pointToLayer = options && options.pointToLayer,
  	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
  	    latlng, latlngs, i, len;

  	if (!coords && !geometry) {
  		return null;
  	}

  	switch (geometry.type) {
  	case 'Point':
  		latlng = _coordsToLatLng(coords);
  		return _pointToLayer(pointToLayer, geojson, latlng, options);

  	case 'MultiPoint':
  		for (i = 0, len = coords.length; i < len; i++) {
  			latlng = _coordsToLatLng(coords[i]);
  			layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
  		}
  		return new FeatureGroup(layers);

  	case 'LineString':
  	case 'MultiLineString':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
  		return new Polyline(latlngs, options);

  	case 'Polygon':
  	case 'MultiPolygon':
  		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
  		return new Polygon(latlngs, options);

  	case 'GeometryCollection':
  		for (i = 0, len = geometry.geometries.length; i < len; i++) {
  			var geoLayer = geometryToLayer({
  				geometry: geometry.geometries[i],
  				type: 'Feature',
  				properties: geojson.properties
  			}, options);

  			if (geoLayer) {
  				layers.push(geoLayer);
  			}
  		}
  		return new FeatureGroup(layers);

  	case 'FeatureCollection':
  		for (i = 0, len = geometry.features.length; i < len; i++) {
  			var featureLayer = geometryToLayer(geometry.features[i], options);

  			if (featureLayer) {
  				layers.push(featureLayer);
  			}
  		}
  		return new FeatureGroup(layers);

  	default:
  		throw new Error('Invalid GeoJSON object.');
  	}
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
  	return pointToLayerFn ?
  		pointToLayerFn(geojson, latlng) :
  		new Marker(latlng, options && options.markersInheritOptions && options);
  }

  // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
  function coordsToLatLng(coords) {
  	return new LatLng(coords[1], coords[0], coords[2]);
  }

  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
  	var latlngs = [];

  	for (var i = 0, len = coords.length, latlng; i < len; i++) {
  		latlng = levelsDeep ?
  			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
  			(_coordsToLatLng || coordsToLatLng)(coords[i]);

  		latlngs.push(latlng);
  	}

  	return latlngs;
  }

  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngToCoords(latlng, precision) {
  	latlng = toLatLng(latlng);
  	return latlng.alt !== undefined ?
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
  		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  }

  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
  	var coords = [];

  	for (var i = 0, len = latlngs.length; i < len; i++) {
  		// Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion
  		coords.push(levelsDeep ?
  			latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) :
  			latLngToCoords(latlngs[i], precision));
  	}

  	if (!levelsDeep && closed && coords.length > 0) {
  		coords.push(coords[0].slice());
  	}

  	return coords;
  }

  function getFeature(layer, newGeometry) {
  	return layer.feature ?
  		extend({}, layer.feature, {geometry: newGeometry}) :
  		asFeature(newGeometry);
  }

  // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.
  function asFeature(geojson) {
  	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
  		return geojson;
  	}

  	return {
  		type: 'Feature',
  		properties: {},
  		geometry: geojson
  	};
  }

  var PointToGeoJSON = {
  	toGeoJSON: function (precision) {
  		return getFeature(this, {
  			type: 'Point',
  			coordinates: latLngToCoords(this.getLatLng(), precision)
  		});
  	}
  };

  // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
  Marker.include(PointToGeoJSON);

  // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON);


  // @namespace Polyline
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
  Polyline.include({
  	toGeoJSON: function (precision) {
  		var multi = !isFlat(this._latlngs);

  		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'LineString',
  			coordinates: coords
  		});
  	}
  });

  // @namespace Polygon
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
  Polygon.include({
  	toGeoJSON: function (precision) {
  		var holes = !isFlat(this._latlngs),
  		    multi = holes && !isFlat(this._latlngs[0]);

  		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

  		if (!holes) {
  			coords = [coords];
  		}

  		return getFeature(this, {
  			type: (multi ? 'Multi' : '') + 'Polygon',
  			coordinates: coords
  		});
  	}
  });


  // @namespace LayerGroup
  LayerGroup.include({
  	toMultiPoint: function (precision) {
  		var coords = [];

  		this.eachLayer(function (layer) {
  			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
  		});

  		return getFeature(this, {
  			type: 'MultiPoint',
  			coordinates: coords
  		});
  	},

  	// @method toGeoJSON(precision?: Number|false): Object
  	// Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  	// Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
  	toGeoJSON: function (precision) {

  		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

  		if (type === 'MultiPoint') {
  			return this.toMultiPoint(precision);
  		}

  		var isGeometryCollection = type === 'GeometryCollection',
  		    jsons = [];

  		this.eachLayer(function (layer) {
  			if (layer.toGeoJSON) {
  				var json = layer.toGeoJSON(precision);
  				if (isGeometryCollection) {
  					jsons.push(json.geometry);
  				} else {
  					var feature = asFeature(json);
  					// Squash nested feature collections
  					if (feature.type === 'FeatureCollection') {
  						jsons.push.apply(jsons, feature.features);
  					} else {
  						jsons.push(feature);
  					}
  				}
  			}
  		});

  		if (isGeometryCollection) {
  			return getFeature(this, {
  				geometries: jsons,
  				type: 'GeometryCollection'
  			});
  		}

  		return {
  			type: 'FeatureCollection',
  			features: jsons
  		};
  	}
  });

  // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.
  function geoJSON(geojson, options) {
  	return new GeoJSON(geojson, options);
  }

  // Backward compatibility.
  var geoJson = geoJSON;

  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({

  	// @section
  	// @aka ImageOverlay options
  	options: {
  		// @option opacity: Number = 1.0
  		// The opacity of the image overlay.
  		opacity: 1,

  		// @option alt: String = ''
  		// Text for the `alt` attribute of the image (useful for accessibility).
  		alt: '',

  		// @option interactive: Boolean = false
  		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
  		interactive: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the image.
  		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option errorOverlayUrl: String = ''
  		// URL to the overlay image to show in place of the overlay that failed to load.
  		errorOverlayUrl: '',

  		// @option zIndex: Number = 1
  		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
  		zIndex: 1,

  		// @option className: String = ''
  		// A custom class name to assign to the image. Empty by default.
  		className: ''
  	},

  	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
  		this._url = url;
  		this._bounds = toLatLngBounds(bounds);

  		setOptions(this, options);
  	},

  	onAdd: function () {
  		if (!this._image) {
  			this._initImage();

  			if (this.options.opacity < 1) {
  				this._updateOpacity();
  			}
  		}

  		if (this.options.interactive) {
  			addClass(this._image, 'leaflet-interactive');
  			this.addInteractiveTarget(this._image);
  		}

  		this.getPane().appendChild(this._image);
  		this._reset();
  	},

  	onRemove: function () {
  		remove(this._image);
  		if (this.options.interactive) {
  			this.removeInteractiveTarget(this._image);
  		}
  	},

  	// @method setOpacity(opacity: Number): this
  	// Sets the opacity of the overlay.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._image) {
  			this._updateOpacity();
  		}
  		return this;
  	},

  	setStyle: function (styleOpts) {
  		if (styleOpts.opacity) {
  			this.setOpacity(styleOpts.opacity);
  		}
  		return this;
  	},

  	// @method bringToFront(): this
  	// Brings the layer to the top of all overlays.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._image);
  		}
  		return this;
  	},

  	// @method bringToBack(): this
  	// Brings the layer to the bottom of all overlays.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._image);
  		}
  		return this;
  	},

  	// @method setUrl(url: String): this
  	// Changes the URL of the image.
  	setUrl: function (url) {
  		this._url = url;

  		if (this._image) {
  			this._image.src = url;
  		}
  		return this;
  	},

  	// @method setBounds(bounds: LatLngBounds): this
  	// Update the bounds that this ImageOverlay covers
  	setBounds: function (bounds) {
  		this._bounds = toLatLngBounds(bounds);

  		if (this._map) {
  			this._reset();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._reset,
  			viewreset: this._reset
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @method setZIndex(value: Number): this
  	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
  	setZIndex: function (value) {
  		this.options.zIndex = value;
  		this._updateZIndex();
  		return this;
  	},

  	// @method getBounds(): LatLngBounds
  	// Get the bounds that this ImageOverlay covers
  	getBounds: function () {
  		return this._bounds;
  	},

  	// @method getElement(): HTMLElement
  	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
  	// used by this overlay.
  	getElement: function () {
  		return this._image;
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'IMG';
  		var img = this._image = wasElementSupplied ? this._url : create$1('img');

  		addClass(img, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(img, this.options.className); }

  		img.onselectstart = falseFn;
  		img.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the ImageOverlay layer has loaded its image
  		img.onload = bind(this.fire, this, 'load');
  		img.onerror = bind(this._overlayOnError, this, 'error');

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		if (this.options.zIndex) {
  			this._updateZIndex();
  		}

  		if (wasElementSupplied) {
  			this._url = img.src;
  			return;
  		}

  		img.src = this._url;
  		img.alt = this.options.alt;
  	},

  	_animateZoom: function (e) {
  		var scale = this._map.getZoomScale(e.zoom),
  		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

  		setTransform(this._image, offset, scale);
  	},

  	_reset: function () {
  		var image = this._image,
  		    bounds = new Bounds(
  		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
  		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
  		    size = bounds.getSize();

  		setPosition(image, bounds.min);

  		image.style.width  = size.x + 'px';
  		image.style.height = size.y + 'px';
  	},

  	_updateOpacity: function () {
  		setOpacity(this._image, this.options.opacity);
  	},

  	_updateZIndex: function () {
  		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._image.style.zIndex = this.options.zIndex;
  		}
  	},

  	_overlayOnError: function () {
  		// @event error: Event
  		// Fired when the ImageOverlay layer fails to load its image
  		this.fire('error');

  		var errorUrl = this.options.errorOverlayUrl;
  		if (errorUrl && this._url !== errorUrl) {
  			this._url = errorUrl;
  			this._image.src = errorUrl;
  		}
  	},

  	// @method getCenter(): LatLng
  	// Returns the center of the ImageOverlay.
  	getCenter: function () {
  		return this._bounds.getCenter();
  	}
  });

  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.
  var imageOverlay = function (url, bounds, options) {
  	return new ImageOverlay(url, bounds, options);
  };

  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */

  var VideoOverlay = ImageOverlay.extend({

  	// @section
  	// @aka VideoOverlay options
  	options: {
  		// @option autoplay: Boolean = true
  		// Whether the video starts playing automatically when loaded.
  		// On some browsers autoplay will only work with `muted: true`
  		autoplay: true,

  		// @option loop: Boolean = true
  		// Whether the video will loop back to the beginning when played.
  		loop: true,

  		// @option keepAspectRatio: Boolean = true
  		// Whether the video will save aspect ratio after the projection.
  		// Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
  		keepAspectRatio: true,

  		// @option muted: Boolean = false
  		// Whether the video starts on mute when loaded.
  		muted: false,

  		// @option playsInline: Boolean = true
  		// Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
  		playsInline: true
  	},

  	_initImage: function () {
  		var wasElementSupplied = this._url.tagName === 'VIDEO';
  		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

  		addClass(vid, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(vid, this.options.className); }

  		vid.onselectstart = falseFn;
  		vid.onmousemove = falseFn;

  		// @event load: Event
  		// Fired when the video has finished loading the first frame
  		vid.onloadeddata = bind(this.fire, this, 'load');

  		if (wasElementSupplied) {
  			var sourceElements = vid.getElementsByTagName('source');
  			var sources = [];
  			for (var j = 0; j < sourceElements.length; j++) {
  				sources.push(sourceElements[j].src);
  			}

  			this._url = (sourceElements.length > 0) ? sources : [vid.src];
  			return;
  		}

  		if (!isArray(this._url)) { this._url = [this._url]; }

  		if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
  			vid.style['objectFit'] = 'fill';
  		}
  		vid.autoplay = !!this.options.autoplay;
  		vid.loop = !!this.options.loop;
  		vid.muted = !!this.options.muted;
  		vid.playsInline = !!this.options.playsInline;
  		for (var i = 0; i < this._url.length; i++) {
  			var source = create$1('source');
  			source.src = this._url[i];
  			vid.appendChild(source);
  		}
  	}

  	// @method getElement(): HTMLVideoElement
  	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
  	// used by this overlay.
  });


  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
  	return new VideoOverlay(video, bounds, options);
  }

  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */

  var SVGOverlay = ImageOverlay.extend({
  	_initImage: function () {
  		var el = this._image = this._url;

  		addClass(el, 'leaflet-image-layer');
  		if (this._zoomAnimated) { addClass(el, 'leaflet-zoom-animated'); }
  		if (this.options.className) { addClass(el, this.options.className); }

  		el.onselectstart = falseFn;
  		el.onmousemove = falseFn;
  	}

  	// @method getElement(): SVGElement
  	// Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
  	// used by this overlay.
  });


  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
  	return new SVGOverlay(el, bounds, options);
  }

  /*
   * @class DivOverlay
   * @inherits Interactive layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.
   */

  // @namespace DivOverlay
  var DivOverlay = Layer.extend({

  	// @section
  	// @aka DivOverlay options
  	options: {
  		// @option interactive: Boolean = false
  		// If true, the popup/tooltip will listen to the mouse events.
  		interactive: false,

  		// @option offset: Point = Point(0, 0)
  		// The offset of the overlay position.
  		offset: [0, 0],

  		// @option className: String = ''
  		// A custom CSS class name to assign to the overlay.
  		className: '',

  		// @option pane: String = undefined
  		// `Map pane` where the overlay will be added.
  		pane: undefined,

  		// @option content: String|HTMLElement|Function = ''
  		// Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
  		// passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
  		content: ''
  	},

  	initialize: function (options, source) {
  		if (options && (options instanceof LatLng || isArray(options))) {
  			this._latlng = toLatLng(options);
  			setOptions(this, source);
  		} else {
  			setOptions(this, options);
  			this._source = source;
  		}
  		if (this.options.content) {
  			this._content = this.options.content;
  		}
  	},

  	// @method openOn(map: Map): this
  	// Adds the overlay to the map.
  	// Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
  	openOn: function (map) {
  		map = arguments.length ? map : this._source._map; // experimental, not the part of public api
  		if (!map.hasLayer(this)) {
  			map.addLayer(this);
  		}
  		return this;
  	},

  	// @method close(): this
  	// Closes the overlay.
  	// Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
  	// and `layer.closePopup()`/`.closeTooltip()`.
  	close: function () {
  		if (this._map) {
  			this._map.removeLayer(this);
  		}
  		return this;
  	},

  	// @method toggle(layer?: Layer): this
  	// Opens or closes the overlay bound to layer depending on its current state.
  	// Argument may be omitted only for overlay bound to layer.
  	// Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
  	toggle: function (layer) {
  		if (this._map) {
  			this.close();
  		} else {
  			if (arguments.length) {
  				this._source = layer;
  			} else {
  				layer = this._source;
  			}
  			this._prepareOpen();

  			// open the overlay on the map
  			this.openOn(layer._map);
  		}
  		return this;
  	},

  	onAdd: function (map) {
  		this._zoomAnimated = map._zoomAnimated;

  		if (!this._container) {
  			this._initLayout();
  		}

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  		}

  		clearTimeout(this._removeTimeout);
  		this.getPane().appendChild(this._container);
  		this.update();

  		if (map._fadeAnimated) {
  			setOpacity(this._container, 1);
  		}

  		this.bringToFront();

  		if (this.options.interactive) {
  			addClass(this._container, 'leaflet-interactive');
  			this.addInteractiveTarget(this._container);
  		}
  	},

  	onRemove: function (map) {
  		if (map._fadeAnimated) {
  			setOpacity(this._container, 0);
  			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
  		} else {
  			remove(this._container);
  		}

  		if (this.options.interactive) {
  			removeClass(this._container, 'leaflet-interactive');
  			this.removeInteractiveTarget(this._container);
  		}
  	},

  	// @namespace DivOverlay
  	// @method getLatLng: LatLng
  	// Returns the geographical point of the overlay.
  	getLatLng: function () {
  		return this._latlng;
  	},

  	// @method setLatLng(latlng: LatLng): this
  	// Sets the geographical point where the overlay will open.
  	setLatLng: function (latlng) {
  		this._latlng = toLatLng(latlng);
  		if (this._map) {
  			this._updatePosition();
  			this._adjustPan();
  		}
  		return this;
  	},

  	// @method getContent: String|HTMLElement
  	// Returns the content of the overlay.
  	getContent: function () {
  		return this._content;
  	},

  	// @method setContent(htmlContent: String|HTMLElement|Function): this
  	// Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
  	// The function should return a `String` or `HTMLElement` to be used in the overlay.
  	setContent: function (content) {
  		this._content = content;
  		this.update();
  		return this;
  	},

  	// @method getElement: String|HTMLElement
  	// Returns the HTML container of the overlay.
  	getElement: function () {
  		return this._container;
  	},

  	// @method update: null
  	// Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
  	update: function () {
  		if (!this._map) { return; }

  		this._container.style.visibility = 'hidden';

  		this._updateContent();
  		this._updateLayout();
  		this._updatePosition();

  		this._container.style.visibility = '';

  		this._adjustPan();
  	},

  	getEvents: function () {
  		var events = {
  			zoom: this._updatePosition,
  			viewreset: this._updatePosition
  		};

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}
  		return events;
  	},

  	// @method isOpen: Boolean
  	// Returns `true` when the overlay is visible on the map.
  	isOpen: function () {
  		return !!this._map && this._map.hasLayer(this);
  	},

  	// @method bringToFront: this
  	// Brings this overlay in front of other overlays (in the same map pane).
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings this overlay to the back of other overlays (in the same map pane).
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  		}
  		return this;
  	},

  	// prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
  	_prepareOpen: function (latlng) {
  		var source = this._source;
  		if (!source._map) { return false; }

  		if (source instanceof FeatureGroup) {
  			source = null;
  			var layers = this._source._layers;
  			for (var id in layers) {
  				if (layers[id]._map) {
  					source = layers[id];
  					break;
  				}
  			}
  			if (!source) { return false; } // Unable to get source layer.

  			// set overlay source to this layer
  			this._source = source;
  		}

  		if (!latlng) {
  			if (source.getCenter) {
  				latlng = source.getCenter();
  			} else if (source.getLatLng) {
  				latlng = source.getLatLng();
  			} else if (source.getBounds) {
  				latlng = source.getBounds().getCenter();
  			} else {
  				throw new Error('Unable to get source layer LatLng.');
  			}
  		}
  		this.setLatLng(latlng);

  		if (this._map) {
  			// update the overlay (content, layout, etc...)
  			this.update();
  		}

  		return true;
  	},

  	_updateContent: function () {
  		if (!this._content) { return; }

  		var node = this._contentNode;
  		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

  		if (typeof content === 'string') {
  			node.innerHTML = content;
  		} else {
  			while (node.hasChildNodes()) {
  				node.removeChild(node.firstChild);
  			}
  			node.appendChild(content);
  		}

  		// @namespace DivOverlay
  		// @section DivOverlay events
  		// @event contentupdate: Event
  		// Fired when the content of the overlay is updated
  		this.fire('contentupdate');
  	},

  	_updatePosition: function () {
  		if (!this._map) { return; }

  		var pos = this._map.latLngToLayerPoint(this._latlng),
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (this._zoomAnimated) {
  			setPosition(this._container, pos.add(anchor));
  		} else {
  			offset = offset.add(pos).add(anchor);
  		}

  		var bottom = this._containerBottom = -offset.y,
  		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

  		// bottom position the overlay in case the height of the overlay changes (images loading etc)
  		this._container.style.bottom = bottom + 'px';
  		this._container.style.left = left + 'px';
  	},

  	_getAnchor: function () {
  		return [0, 0];
  	}

  });

  Map.include({
  	_initOverlay: function (OverlayClass, content, latlng, options) {
  		var overlay = content;
  		if (!(overlay instanceof OverlayClass)) {
  			overlay = new OverlayClass(options).setContent(content);
  		}
  		if (latlng) {
  			overlay.setLatLng(latlng);
  		}
  		return overlay;
  	}
  });


  Layer.include({
  	_initOverlay: function (OverlayClass, old, content, options) {
  		var overlay = content;
  		if (overlay instanceof OverlayClass) {
  			setOptions(overlay, options);
  			overlay._source = this;
  		} else {
  			overlay = (old && !options) ? old : new OverlayClass(options, this);
  			overlay.setContent(content);
  		}
  		return overlay;
  	}
  });

  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   *
   * A popup can be also standalone:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   * or
   * ```js
   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */


  // @namespace Popup
  var Popup = DivOverlay.extend({

  	// @section
  	// @aka Popup options
  	options: {
  		// @option pane: String = 'popupPane'
  		// `Map pane` where the popup will be added.
  		pane: 'popupPane',

  		// @option offset: Point = Point(0, 7)
  		// The offset of the popup position.
  		offset: [0, 7],

  		// @option maxWidth: Number = 300
  		// Max width of the popup, in pixels.
  		maxWidth: 300,

  		// @option minWidth: Number = 50
  		// Min width of the popup, in pixels.
  		minWidth: 50,

  		// @option maxHeight: Number = null
  		// If set, creates a scrollable container of the given height
  		// inside a popup if its content exceeds it.
  		// The scrollable container can be styled using the
  		// `leaflet-popup-scrolled` CSS class selector.
  		maxHeight: null,

  		// @option autoPan: Boolean = true
  		// Set it to `false` if you don't want the map to do panning animation
  		// to fit the opened popup.
  		autoPan: true,

  		// @option autoPanPaddingTopLeft: Point = null
  		// The margin between the popup and the top left corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingTopLeft: null,

  		// @option autoPanPaddingBottomRight: Point = null
  		// The margin between the popup and the bottom right corner of the map
  		// view after autopanning was performed.
  		autoPanPaddingBottomRight: null,

  		// @option autoPanPadding: Point = Point(5, 5)
  		// Equivalent of setting both top left and bottom right autopan padding to the same value.
  		autoPanPadding: [5, 5],

  		// @option keepInView: Boolean = false
  		// Set it to `true` if you want to prevent users from panning the popup
  		// off of the screen while it is open.
  		keepInView: false,

  		// @option closeButton: Boolean = true
  		// Controls the presence of a close button in the popup.
  		closeButton: true,

  		// @option autoClose: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the popup closing when another popup is opened.
  		autoClose: true,

  		// @option closeOnEscapeKey: Boolean = true
  		// Set it to `false` if you want to override the default behavior of
  		// the ESC key for closing of the popup.
  		closeOnEscapeKey: true,

  		// @option closeOnClick: Boolean = *
  		// Set it if you want to override the default behavior of the popup closing when user clicks
  		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

  		// @option className: String = ''
  		// A custom CSS class name to assign to the popup.
  		className: ''
  	},

  	// @namespace Popup
  	// @method openOn(map: Map): this
  	// Alternative to `map.openPopup(popup)`.
  	// Adds the popup to the map and closes the previous one.
  	openOn: function (map) {
  		map = arguments.length ? map : this._source._map; // experimental, not the part of public api

  		if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
  			map.removeLayer(map._popup);
  		}
  		map._popup = this;

  		return DivOverlay.prototype.openOn.call(this, map);
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupopen: PopupEvent
  		// Fired when a popup is opened in the map
  		map.fire('popupopen', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupopen: PopupEvent
  			// Fired when a popup bound to this layer is opened
  			this._source.fire('popupopen', {popup: this}, true);
  			// For non-path layers, we toggle the popup when clicking
  			// again the layer, so prevent the map to reopen it.
  			if (!(this._source instanceof Path)) {
  				this._source.on('preclick', stopPropagation);
  			}
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Popup events
  		// @event popupclose: PopupEvent
  		// Fired when a popup in the map is closed
  		map.fire('popupclose', {popup: this});

  		if (this._source) {
  			// @namespace Layer
  			// @section Popup events
  			// @event popupclose: PopupEvent
  			// Fired when a popup bound to this layer is closed
  			this._source.fire('popupclose', {popup: this}, true);
  			if (!(this._source instanceof Path)) {
  				this._source.off('preclick', stopPropagation);
  			}
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
  			events.preclick = this.close;
  		}

  		if (this.options.keepInView) {
  			events.moveend = this._adjustPan;
  		}

  		return events;
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-popup',
  		    container = this._container = create$1('div',
  			prefix + ' ' + (this.options.className || '') +
  			' leaflet-zoom-animated');

  		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
  		this._contentNode = create$1('div', prefix + '-content', wrapper);

  		disableClickPropagation(container);
  		disableScrollPropagation(this._contentNode);
  		on(container, 'contextmenu', stopPropagation);

  		this._tipContainer = create$1('div', prefix + '-tip-container', container);
  		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

  		if (this.options.closeButton) {
  			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
  			closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399
  			closeButton.setAttribute('aria-label', 'Close popup');
  			closeButton.href = '#close';
  			closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';

  			on(closeButton, 'click', function (ev) {
  				preventDefault(ev);
  				this.close();
  			}, this);
  		}
  	},

  	_updateLayout: function () {
  		var container = this._contentNode,
  		    style = container.style;

  		style.width = '';
  		style.whiteSpace = 'nowrap';

  		var width = container.offsetWidth;
  		width = Math.min(width, this.options.maxWidth);
  		width = Math.max(width, this.options.minWidth);

  		style.width = (width + 1) + 'px';
  		style.whiteSpace = '';

  		style.height = '';

  		var height = container.offsetHeight,
  		    maxHeight = this.options.maxHeight,
  		    scrolledClass = 'leaflet-popup-scrolled';

  		if (maxHeight && height > maxHeight) {
  			style.height = maxHeight + 'px';
  			addClass(container, scrolledClass);
  		} else {
  			removeClass(container, scrolledClass);
  		}

  		this._containerWidth = this._container.offsetWidth;
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
  		    anchor = this._getAnchor();
  		setPosition(this._container, pos.add(anchor));
  	},

  	_adjustPan: function () {
  		if (!this.options.autoPan) { return; }
  		if (this._map._panAnim) { this._map._panAnim.stop(); }

  		// We can endlessly recurse if keepInView is set and the view resets.
  		// Let's guard against that by exiting early if we're responding to our own autopan.
  		if (this._autopanning) {
  			this._autopanning = false;
  			return;
  		}

  		var map = this._map,
  		    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
  		    containerHeight = this._container.offsetHeight + marginBottom,
  		    containerWidth = this._containerWidth,
  		    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

  		layerPos._add(getPosition(this._container));

  		var containerPos = map.layerPointToContainerPoint(layerPos),
  		    padding = toPoint(this.options.autoPanPadding),
  		    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
  		    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
  		    size = map.getSize(),
  		    dx = 0,
  		    dy = 0;

  		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
  			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
  		}
  		if (containerPos.x - dx - paddingTL.x < 0) { // left
  			dx = containerPos.x - paddingTL.x;
  		}
  		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
  			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
  		}
  		if (containerPos.y - dy - paddingTL.y < 0) { // top
  			dy = containerPos.y - paddingTL.y;
  		}

  		// @namespace Map
  		// @section Popup events
  		// @event autopanstart: Event
  		// Fired when the map starts autopanning when opening a popup.
  		if (dx || dy) {
  			// Track that we're autopanning, as this function will be re-ran on moveend
  			if (this.options.keepInView) {
  				this._autopanning = true;
  			}

  			map
  			    .fire('autopanstart')
  			    .panBy([dx, dy]);
  		}
  	},

  	_getAnchor: function () {
  		// Where should we anchor the popup on the source layer?
  		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
  	}

  });

  // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.popup(latlng: LatLng, options?: Popup options)
  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.
  var popup = function (options, source) {
  	return new Popup(options, source);
  };


  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */
  Map.mergeOptions({
  	closePopupOnClick: true
  });


  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
  	// @method openPopup(popup: Popup): this
  	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
  	// @alternative
  	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
  	// Creates a popup with the specified content and options and opens it in the given point on a map.
  	openPopup: function (popup, latlng, options) {
  		this._initOverlay(Popup, popup, latlng, options)
  		  .openOn(this);

  		return this;
  	},

  	// @method closePopup(popup?: Popup): this
  	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
  	closePopup: function (popup) {
  		popup = arguments.length ? popup : this._popup;
  		if (popup) {
  			popup.close();
  		}
  		return this;
  	}
  });

  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */

  // @section Popup methods
  Layer.include({

  	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
  	// Binds a popup to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindPopup: function (content, options) {
  		this._popup = this._initOverlay(Popup, this._popup, content, options);
  		if (!this._popupHandlersAdded) {
  			this.on({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = true;
  		}

  		return this;
  	},

  	// @method unbindPopup(): this
  	// Removes the popup previously bound with `bindPopup`.
  	unbindPopup: function () {
  		if (this._popup) {
  			this.off({
  				click: this._openPopup,
  				keypress: this._onKeyPress,
  				remove: this.closePopup,
  				move: this._movePopup
  			});
  			this._popupHandlersAdded = false;
  			this._popup = null;
  		}
  		return this;
  	},

  	// @method openPopup(latlng?: LatLng): this
  	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
  	openPopup: function (latlng) {
  		if (this._popup) {
  			if (!(this instanceof FeatureGroup)) {
  				this._popup._source = this;
  			}
  			if (this._popup._prepareOpen(latlng || this._latlng)) {
  				// open the popup on the map
  				this._popup.openOn(this._map);
  			}
  		}
  		return this;
  	},

  	// @method closePopup(): this
  	// Closes the popup bound to this layer if it is open.
  	closePopup: function () {
  		if (this._popup) {
  			this._popup.close();
  		}
  		return this;
  	},

  	// @method togglePopup(): this
  	// Opens or closes the popup bound to this layer depending on its current state.
  	togglePopup: function () {
  		if (this._popup) {
  			this._popup.toggle(this);
  		}
  		return this;
  	},

  	// @method isPopupOpen(): boolean
  	// Returns `true` if the popup bound to this layer is currently open.
  	isPopupOpen: function () {
  		return (this._popup ? this._popup.isOpen() : false);
  	},

  	// @method setPopupContent(content: String|HTMLElement|Popup): this
  	// Sets the content of the popup bound to this layer.
  	setPopupContent: function (content) {
  		if (this._popup) {
  			this._popup.setContent(content);
  		}
  		return this;
  	},

  	// @method getPopup(): Popup
  	// Returns the popup bound to this layer.
  	getPopup: function () {
  		return this._popup;
  	},

  	_openPopup: function (e) {
  		if (!this._popup || !this._map) {
  			return;
  		}
  		// prevent map click
  		stop(e);

  		var target = e.layer || e.target;
  		if (this._popup._source === target && !(target instanceof Path)) {
  			// treat it like a marker and figure out
  			// if we should toggle it open/closed
  			if (this._map.hasLayer(this._popup)) {
  				this.closePopup();
  			} else {
  				this.openPopup(e.latlng);
  			}
  			return;
  		}
  		this._popup._source = target;
  		this.openPopup(e.latlng);
  	},

  	_movePopup: function (e) {
  		this._popup.setLatLng(e.latlng);
  	},

  	_onKeyPress: function (e) {
  		if (e.originalEvent.keyCode === 13) {
  			this._openPopup(e);
  		}
  	}
  });

  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   * If you want to just bind a tooltip to marker:
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Path overlays like polylines also have a `bindTooltip` method.
   *
   * A tooltip can be also standalone:
   *
   * ```js
   * var tooltip = L.tooltip()
   * 	.setLatLng(latlng)
   * 	.setContent('Hello world!<br />This is a nice tooltip.')
   * 	.addTo(map);
   * ```
   * or
   * ```js
   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})
   * 	.addTo(map);
   * ```
   *
   *
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */


  // @namespace Tooltip
  var Tooltip = DivOverlay.extend({

  	// @section
  	// @aka Tooltip options
  	options: {
  		// @option pane: String = 'tooltipPane'
  		// `Map pane` where the tooltip will be added.
  		pane: 'tooltipPane',

  		// @option offset: Point = Point(0, 0)
  		// Optional offset of the tooltip position.
  		offset: [0, 0],

  		// @option direction: String = 'auto'
  		// Direction where to open the tooltip. Possible values are: `right`, `left`,
  		// `top`, `bottom`, `center`, `auto`.
  		// `auto` will dynamically switch between `right` and `left` according to the tooltip
  		// position on the map.
  		direction: 'auto',

  		// @option permanent: Boolean = false
  		// Whether to open the tooltip permanently or only on mouseover.
  		permanent: false,

  		// @option sticky: Boolean = false
  		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
  		sticky: false,

  		// @option opacity: Number = 0.9
  		// Tooltip container opacity.
  		opacity: 0.9
  	},

  	onAdd: function (map) {
  		DivOverlay.prototype.onAdd.call(this, map);
  		this.setOpacity(this.options.opacity);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipopen: TooltipEvent
  		// Fired when a tooltip is opened in the map.
  		map.fire('tooltipopen', {tooltip: this});

  		if (this._source) {
  			this.addEventParent(this._source);

  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipopen: TooltipEvent
  			// Fired when a tooltip bound to this layer is opened.
  			this._source.fire('tooltipopen', {tooltip: this}, true);
  		}
  	},

  	onRemove: function (map) {
  		DivOverlay.prototype.onRemove.call(this, map);

  		// @namespace Map
  		// @section Tooltip events
  		// @event tooltipclose: TooltipEvent
  		// Fired when a tooltip in the map is closed.
  		map.fire('tooltipclose', {tooltip: this});

  		if (this._source) {
  			this.removeEventParent(this._source);

  			// @namespace Layer
  			// @section Tooltip events
  			// @event tooltipclose: TooltipEvent
  			// Fired when a tooltip bound to this layer is closed.
  			this._source.fire('tooltipclose', {tooltip: this}, true);
  		}
  	},

  	getEvents: function () {
  		var events = DivOverlay.prototype.getEvents.call(this);

  		if (!this.options.permanent) {
  			events.preclick = this.close;
  		}

  		return events;
  	},

  	_initLayout: function () {
  		var prefix = 'leaflet-tooltip',
  		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

  		this._contentNode = this._container = create$1('div', className);

  		this._container.setAttribute('role', 'tooltip');
  		this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));
  	},

  	_updateLayout: function () {},

  	_adjustPan: function () {},

  	_setPosition: function (pos) {
  		var subX, subY,
  		    map = this._map,
  		    container = this._container,
  		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
  		    tooltipPoint = map.layerPointToContainerPoint(pos),
  		    direction = this.options.direction,
  		    tooltipWidth = container.offsetWidth,
  		    tooltipHeight = container.offsetHeight,
  		    offset = toPoint(this.options.offset),
  		    anchor = this._getAnchor();

  		if (direction === 'top') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight;
  		} else if (direction === 'bottom') {
  			subX = tooltipWidth / 2;
  			subY = 0;
  		} else if (direction === 'center') {
  			subX = tooltipWidth / 2;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'right') {
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else if (direction === 'left') {
  			subX = tooltipWidth;
  			subY = tooltipHeight / 2;
  		} else if (tooltipPoint.x < centerPoint.x) {
  			direction = 'right';
  			subX = 0;
  			subY = tooltipHeight / 2;
  		} else {
  			direction = 'left';
  			subX = tooltipWidth + (offset.x + anchor.x) * 2;
  			subY = tooltipHeight / 2;
  		}

  		pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);

  		removeClass(container, 'leaflet-tooltip-right');
  		removeClass(container, 'leaflet-tooltip-left');
  		removeClass(container, 'leaflet-tooltip-top');
  		removeClass(container, 'leaflet-tooltip-bottom');
  		addClass(container, 'leaflet-tooltip-' + direction);
  		setPosition(container, pos);
  	},

  	_updatePosition: function () {
  		var pos = this._map.latLngToLayerPoint(this._latlng);
  		this._setPosition(pos);
  	},

  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;

  		if (this._container) {
  			setOpacity(this._container, opacity);
  		}
  	},

  	_animateZoom: function (e) {
  		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
  		this._setPosition(pos);
  	},

  	_getAnchor: function () {
  		// Where should we anchor the tooltip on the source layer?
  		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
  	}

  });

  // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)
  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.
  var tooltip = function (options, source) {
  	return new Tooltip(options, source);
  };

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({

  	// @method openTooltip(tooltip: Tooltip): this
  	// Opens the specified tooltip.
  	// @alternative
  	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
  	// Creates a tooltip with the specified content and options and open it.
  	openTooltip: function (tooltip, latlng, options) {
  		this._initOverlay(Tooltip, tooltip, latlng, options)
  		  .openOn(this);

  		return this;
  	},

  	// @method closeTooltip(tooltip: Tooltip): this
  	// Closes the tooltip given as parameter.
  	closeTooltip: function (tooltip) {
  		tooltip.close();
  		return this;
  	}

  });

  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */

  // @section Tooltip methods
  Layer.include({

  	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
  	// Binds a tooltip to the layer with the passed `content` and sets up the
  	// necessary event listeners. If a `Function` is passed it will receive
  	// the layer as the first argument and should return a `String` or `HTMLElement`.
  	bindTooltip: function (content, options) {

  		if (this._tooltip && this.isTooltipOpen()) {
  			this.unbindTooltip();
  		}

  		this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
  		this._initTooltipInteractions();

  		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
  			this.openTooltip();
  		}

  		return this;
  	},

  	// @method unbindTooltip(): this
  	// Removes the tooltip previously bound with `bindTooltip`.
  	unbindTooltip: function () {
  		if (this._tooltip) {
  			this._initTooltipInteractions(true);
  			this.closeTooltip();
  			this._tooltip = null;
  		}
  		return this;
  	},

  	_initTooltipInteractions: function (remove) {
  		if (!remove && this._tooltipHandlersAdded) { return; }
  		var onOff = remove ? 'off' : 'on',
  		    events = {
  			remove: this.closeTooltip,
  			move: this._moveTooltip
  		    };
  		if (!this._tooltip.options.permanent) {
  			events.mouseover = this._openTooltip;
  			events.mouseout = this.closeTooltip;
  			events.click = this._openTooltip;
  			if (this._map) {
  				this._addFocusListeners();
  			} else {
  				events.add = this._addFocusListeners;
  			}
  		} else {
  			events.add = this._openTooltip;
  		}
  		if (this._tooltip.options.sticky) {
  			events.mousemove = this._moveTooltip;
  		}
  		this[onOff](events);
  		this._tooltipHandlersAdded = !remove;
  	},

  	// @method openTooltip(latlng?: LatLng): this
  	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
  	openTooltip: function (latlng) {
  		if (this._tooltip) {
  			if (!(this instanceof FeatureGroup)) {
  				this._tooltip._source = this;
  			}
  			if (this._tooltip._prepareOpen(latlng)) {
  				// open the tooltip on the map
  				this._tooltip.openOn(this._map);

  				if (this.getElement) {
  					this._setAriaDescribedByOnLayer(this);
  				} else if (this.eachLayer) {
  					this.eachLayer(this._setAriaDescribedByOnLayer, this);
  				}
  			}
  		}
  		return this;
  	},

  	// @method closeTooltip(): this
  	// Closes the tooltip bound to this layer if it is open.
  	closeTooltip: function () {
  		if (this._tooltip) {
  			return this._tooltip.close();
  		}
  	},

  	// @method toggleTooltip(): this
  	// Opens or closes the tooltip bound to this layer depending on its current state.
  	toggleTooltip: function () {
  		if (this._tooltip) {
  			this._tooltip.toggle(this);
  		}
  		return this;
  	},

  	// @method isTooltipOpen(): boolean
  	// Returns `true` if the tooltip bound to this layer is currently open.
  	isTooltipOpen: function () {
  		return this._tooltip.isOpen();
  	},

  	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
  	// Sets the content of the tooltip bound to this layer.
  	setTooltipContent: function (content) {
  		if (this._tooltip) {
  			this._tooltip.setContent(content);
  		}
  		return this;
  	},

  	// @method getTooltip(): Tooltip
  	// Returns the tooltip bound to this layer.
  	getTooltip: function () {
  		return this._tooltip;
  	},

  	_addFocusListeners: function () {
  		if (this.getElement) {
  			this._addFocusListenersOnLayer(this);
  		} else if (this.eachLayer) {
  			this.eachLayer(this._addFocusListenersOnLayer, this);
  		}
  	},

  	_addFocusListenersOnLayer: function (layer) {
  		var el = typeof layer.getElement === 'function' && layer.getElement();
  		if (el) {
  			on(el, 'focus', function () {
  				this._tooltip._source = layer;
  				this.openTooltip();
  			}, this);
  			on(el, 'blur', this.closeTooltip, this);
  		}
  	},

  	_setAriaDescribedByOnLayer: function (layer) {
  		var el = typeof layer.getElement === 'function' && layer.getElement();
  		if (el) {
  			el.setAttribute('aria-describedby', this._tooltip._container.id);
  		}
  	},


  	_openTooltip: function (e) {
  		if (!this._tooltip || !this._map) {
  			return;
  		}

  		// If the map is moving, we will show the tooltip after it's done.
  		if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
  			this._openOnceFlag = true;
  			var that = this;
  			this._map.once('moveend', function () {
  				that._openOnceFlag = false;
  				that._openTooltip(e);
  			});
  			return;
  		}

  		this._tooltip._source = e.layer || e.target;

  		this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);
  	},

  	_moveTooltip: function (e) {
  		var latlng = e.latlng, containerPoint, layerPoint;
  		if (this._tooltip.options.sticky && e.originalEvent) {
  			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
  			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
  			latlng = this._map.layerPointToLatLng(layerPoint);
  		}
  		this._tooltip.setLatLng(latlng);
  	}
  });

  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
  	options: {
  		// @section
  		// @aka DivIcon options
  		iconSize: [12, 12], // also can be set through CSS

  		// iconAnchor: (Point),
  		// popupAnchor: (Point),

  		// @option html: String|HTMLElement = ''
  		// Custom HTML code to put inside the div element, empty by default. Alternatively,
  		// an instance of `HTMLElement`.
  		html: false,

  		// @option bgPos: Point = [0, 0]
  		// Optional relative position of the background, in pixels
  		bgPos: null,

  		className: 'leaflet-div-icon'
  	},

  	createIcon: function (oldIcon) {
  		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
  		    options = this.options;

  		if (options.html instanceof Element) {
  			empty(div);
  			div.appendChild(options.html);
  		} else {
  			div.innerHTML = options.html !== false ? options.html : '';
  		}

  		if (options.bgPos) {
  			var bgPos = toPoint(options.bgPos);
  			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
  		}
  		this._setIconStyles(div, 'icon');

  		return div;
  	},

  	createShadow: function () {
  		return null;
  	}
  });

  // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.
  function divIcon(options) {
  	return new DivIcon(options);
  }

  Icon.Default = IconDefault;

  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */


  var GridLayer = Layer.extend({

  	// @section
  	// @aka GridLayer options
  	options: {
  		// @option tileSize: Number|Point = 256
  		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
  		tileSize: 256,

  		// @option opacity: Number = 1.0
  		// Opacity of the tiles. Can be used in the `createTile()` function.
  		opacity: 1,

  		// @option updateWhenIdle: Boolean = (depends)
  		// Load new tiles only when panning ends.
  		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
  		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
  		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
  		updateWhenIdle: Browser.mobile,

  		// @option updateWhenZooming: Boolean = true
  		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
  		updateWhenZooming: true,

  		// @option updateInterval: Number = 200
  		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
  		updateInterval: 200,

  		// @option zIndex: Number = 1
  		// The explicit zIndex of the tile layer.
  		zIndex: 1,

  		// @option bounds: LatLngBounds = undefined
  		// If set, tiles will only be loaded inside the set `LatLngBounds`.
  		bounds: null,

  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = undefined
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: undefined,

  		// @option maxNativeZoom: Number = undefined
  		// Maximum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
  		// from `maxNativeZoom` level and auto-scaled.
  		maxNativeZoom: undefined,

  		// @option minNativeZoom: Number = undefined
  		// Minimum zoom number the tile source has available. If it is specified,
  		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
  		// from `minNativeZoom` level and auto-scaled.
  		minNativeZoom: undefined,

  		// @option noWrap: Boolean = false
  		// Whether the layer is wrapped around the antimeridian. If `true`, the
  		// GridLayer will only be displayed once at low zoom levels. Has no
  		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
  		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
  		// tiles outside the CRS limits.
  		noWrap: false,

  		// @option pane: String = 'tilePane'
  		// `Map pane` where the grid layer will be added.
  		pane: 'tilePane',

  		// @option className: String = ''
  		// A custom class name to assign to the tile layer. Empty by default.
  		className: '',

  		// @option keepBuffer: Number = 2
  		// When panning the map, keep this many rows and columns of tiles before unloading them.
  		keepBuffer: 2
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  	},

  	onAdd: function () {
  		this._initContainer();

  		this._levels = {};
  		this._tiles = {};

  		this._resetView(); // implicit _update() call
  	},

  	beforeAdd: function (map) {
  		map._addZoomLimit(this);
  	},

  	onRemove: function (map) {
  		this._removeAllTiles();
  		remove(this._container);
  		map._removeZoomLimit(this);
  		this._container = null;
  		this._tileZoom = undefined;
  	},

  	// @method bringToFront: this
  	// Brings the tile layer to the top of all tile layers.
  	bringToFront: function () {
  		if (this._map) {
  			toFront(this._container);
  			this._setAutoZIndex(Math.max);
  		}
  		return this;
  	},

  	// @method bringToBack: this
  	// Brings the tile layer to the bottom of all tile layers.
  	bringToBack: function () {
  		if (this._map) {
  			toBack(this._container);
  			this._setAutoZIndex(Math.min);
  		}
  		return this;
  	},

  	// @method getContainer: HTMLElement
  	// Returns the HTML element that contains the tiles for this layer.
  	getContainer: function () {
  		return this._container;
  	},

  	// @method setOpacity(opacity: Number): this
  	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
  	setOpacity: function (opacity) {
  		this.options.opacity = opacity;
  		this._updateOpacity();
  		return this;
  	},

  	// @method setZIndex(zIndex: Number): this
  	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
  	setZIndex: function (zIndex) {
  		this.options.zIndex = zIndex;
  		this._updateZIndex();

  		return this;
  	},

  	// @method isLoading: Boolean
  	// Returns `true` if any tile in the grid layer has not finished loading.
  	isLoading: function () {
  		return this._loading;
  	},

  	// @method redraw: this
  	// Causes the layer to clear all the tiles and request them again.
  	redraw: function () {
  		if (this._map) {
  			this._removeAllTiles();
  			var tileZoom = this._clampZoom(this._map.getZoom());
  			if (tileZoom !== this._tileZoom) {
  				this._tileZoom = tileZoom;
  				this._updateLevels();
  			}
  			this._update();
  		}
  		return this;
  	},

  	getEvents: function () {
  		var events = {
  			viewprereset: this._invalidateAll,
  			viewreset: this._resetView,
  			zoom: this._resetView,
  			moveend: this._onMoveEnd
  		};

  		if (!this.options.updateWhenIdle) {
  			// update tiles on move, but not more often than once per given interval
  			if (!this._onMove) {
  				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
  			}

  			events.move = this._onMove;
  		}

  		if (this._zoomAnimated) {
  			events.zoomanim = this._animateZoom;
  		}

  		return events;
  	},

  	// @section Extension methods
  	// Layers extending `GridLayer` shall reimplement the following method.
  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, must be overridden by classes extending `GridLayer`.
  	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  	// is specified, it must be called when the tile has finished loading and drawing.
  	createTile: function () {
  		return document.createElement('div');
  	},

  	// @section
  	// @method getTileSize: Point
  	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
  	getTileSize: function () {
  		var s = this.options.tileSize;
  		return s instanceof Point ? s : new Point(s, s);
  	},

  	_updateZIndex: function () {
  		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
  			this._container.style.zIndex = this.options.zIndex;
  		}
  	},

  	_setAutoZIndex: function (compare) {
  		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

  		var layers = this.getPane().children,
  		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

  		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

  			zIndex = layers[i].style.zIndex;

  			if (layers[i] !== this._container && zIndex) {
  				edgeZIndex = compare(edgeZIndex, +zIndex);
  			}
  		}

  		if (isFinite(edgeZIndex)) {
  			this.options.zIndex = edgeZIndex + compare(-1, 1);
  			this._updateZIndex();
  		}
  	},

  	_updateOpacity: function () {
  		if (!this._map) { return; }

  		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
  		if (Browser.ielt9) { return; }

  		setOpacity(this._container, this.options.opacity);

  		var now = +new Date(),
  		    nextFrame = false,
  		    willPrune = false;

  		for (var key in this._tiles) {
  			var tile = this._tiles[key];
  			if (!tile.current || !tile.loaded) { continue; }

  			var fade = Math.min(1, (now - tile.loaded) / 200);

  			setOpacity(tile.el, fade);
  			if (fade < 1) {
  				nextFrame = true;
  			} else {
  				if (tile.active) {
  					willPrune = true;
  				} else {
  					this._onOpaqueTile(tile);
  				}
  				tile.active = true;
  			}
  		}

  		if (willPrune && !this._noPrune) { this._pruneTiles(); }

  		if (nextFrame) {
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		}
  	},

  	_onOpaqueTile: falseFn,

  	_initContainer: function () {
  		if (this._container) { return; }

  		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
  		this._updateZIndex();

  		if (this.options.opacity < 1) {
  			this._updateOpacity();
  		}

  		this.getPane().appendChild(this._container);
  	},

  	_updateLevels: function () {

  		var zoom = this._tileZoom,
  		    maxZoom = this.options.maxZoom;

  		if (zoom === undefined) { return undefined; }

  		for (var z in this._levels) {
  			z = Number(z);
  			if (this._levels[z].el.children.length || z === zoom) {
  				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
  				this._onUpdateLevel(z);
  			} else {
  				remove(this._levels[z].el);
  				this._removeTilesAtZoom(z);
  				this._onRemoveLevel(z);
  				delete this._levels[z];
  			}
  		}

  		var level = this._levels[zoom],
  		    map = this._map;

  		if (!level) {
  			level = this._levels[zoom] = {};

  			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
  			level.el.style.zIndex = maxZoom;

  			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
  			level.zoom = zoom;

  			this._setZoomTransform(level, map.getCenter(), map.getZoom());

  			// force the browser to consider the newly added element for transition
  			falseFn(level.el.offsetWidth);

  			this._onCreateLevel(level);
  		}

  		this._level = level;

  		return level;
  	},

  	_onUpdateLevel: falseFn,

  	_onRemoveLevel: falseFn,

  	_onCreateLevel: falseFn,

  	_pruneTiles: function () {
  		if (!this._map) {
  			return;
  		}

  		var key, tile;

  		var zoom = this._map.getZoom();
  		if (zoom > this.options.maxZoom ||
  			zoom < this.options.minZoom) {
  			this._removeAllTiles();
  			return;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			tile.retain = tile.current;
  		}

  		for (key in this._tiles) {
  			tile = this._tiles[key];
  			if (tile.current && !tile.active) {
  				var coords = tile.coords;
  				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
  					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
  				}
  			}
  		}

  		for (key in this._tiles) {
  			if (!this._tiles[key].retain) {
  				this._removeTile(key);
  			}
  		}
  	},

  	_removeTilesAtZoom: function (zoom) {
  		for (var key in this._tiles) {
  			if (this._tiles[key].coords.z !== zoom) {
  				continue;
  			}
  			this._removeTile(key);
  		}
  	},

  	_removeAllTiles: function () {
  		for (var key in this._tiles) {
  			this._removeTile(key);
  		}
  	},

  	_invalidateAll: function () {
  		for (var z in this._levels) {
  			remove(this._levels[z].el);
  			this._onRemoveLevel(Number(z));
  			delete this._levels[z];
  		}
  		this._removeAllTiles();

  		this._tileZoom = undefined;
  	},

  	_retainParent: function (x, y, z, minZoom) {
  		var x2 = Math.floor(x / 2),
  		    y2 = Math.floor(y / 2),
  		    z2 = z - 1,
  		    coords2 = new Point(+x2, +y2);
  		coords2.z = +z2;

  		var key = this._tileCoordsToKey(coords2),
  		    tile = this._tiles[key];

  		if (tile && tile.active) {
  			tile.retain = true;
  			return true;

  		} else if (tile && tile.loaded) {
  			tile.retain = true;
  		}

  		if (z2 > minZoom) {
  			return this._retainParent(x2, y2, z2, minZoom);
  		}

  		return false;
  	},

  	_retainChildren: function (x, y, z, maxZoom) {

  		for (var i = 2 * x; i < 2 * x + 2; i++) {
  			for (var j = 2 * y; j < 2 * y + 2; j++) {

  				var coords = new Point(i, j);
  				coords.z = z + 1;

  				var key = this._tileCoordsToKey(coords),
  				    tile = this._tiles[key];

  				if (tile && tile.active) {
  					tile.retain = true;
  					continue;

  				} else if (tile && tile.loaded) {
  					tile.retain = true;
  				}

  				if (z + 1 < maxZoom) {
  					this._retainChildren(i, j, z + 1, maxZoom);
  				}
  			}
  		}
  	},

  	_resetView: function (e) {
  		var animating = e && (e.pinch || e.flyTo);
  		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
  	},

  	_animateZoom: function (e) {
  		this._setView(e.center, e.zoom, true, e.noUpdate);
  	},

  	_clampZoom: function (zoom) {
  		var options = this.options;

  		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
  			return options.minNativeZoom;
  		}

  		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
  			return options.maxNativeZoom;
  		}

  		return zoom;
  	},

  	_setView: function (center, zoom, noPrune, noUpdate) {
  		var tileZoom = Math.round(zoom);
  		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
  		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
  			tileZoom = undefined;
  		} else {
  			tileZoom = this._clampZoom(tileZoom);
  		}

  		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

  		if (!noUpdate || tileZoomChanged) {

  			this._tileZoom = tileZoom;

  			if (this._abortLoading) {
  				this._abortLoading();
  			}

  			this._updateLevels();
  			this._resetGrid();

  			if (tileZoom !== undefined) {
  				this._update(center);
  			}

  			if (!noPrune) {
  				this._pruneTiles();
  			}

  			// Flag to prevent _updateOpacity from pruning tiles during
  			// a zoom anim or a pinch gesture
  			this._noPrune = !!noPrune;
  		}

  		this._setZoomTransforms(center, zoom);
  	},

  	_setZoomTransforms: function (center, zoom) {
  		for (var i in this._levels) {
  			this._setZoomTransform(this._levels[i], center, zoom);
  		}
  	},

  	_setZoomTransform: function (level, center, zoom) {
  		var scale = this._map.getZoomScale(zoom, level.zoom),
  		    translate = level.origin.multiplyBy(scale)
  		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

  		if (Browser.any3d) {
  			setTransform(level.el, translate, scale);
  		} else {
  			setPosition(level.el, translate);
  		}
  	},

  	_resetGrid: function () {
  		var map = this._map,
  		    crs = map.options.crs,
  		    tileSize = this._tileSize = this.getTileSize(),
  		    tileZoom = this._tileZoom;

  		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
  		if (bounds) {
  			this._globalTileRange = this._pxBoundsToTileRange(bounds);
  		}

  		this._wrapX = crs.wrapLng && !this.options.noWrap && [
  			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
  			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
  		];
  		this._wrapY = crs.wrapLat && !this.options.noWrap && [
  			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
  			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
  		];
  	},

  	_onMoveEnd: function () {
  		if (!this._map || this._map._animatingZoom) { return; }

  		this._update();
  	},

  	_getTiledPixelBounds: function (center) {
  		var map = this._map,
  		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
  		    scale = map.getZoomScale(mapZoom, this._tileZoom),
  		    pixelCenter = map.project(center, this._tileZoom).floor(),
  		    halfSize = map.getSize().divideBy(scale * 2);

  		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
  	},

  	// Private method to load tiles in the grid's active zoom level according to map bounds
  	_update: function (center) {
  		var map = this._map;
  		if (!map) { return; }
  		var zoom = this._clampZoom(map.getZoom());

  		if (center === undefined) { center = map.getCenter(); }
  		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

  		var pixelBounds = this._getTiledPixelBounds(center),
  		    tileRange = this._pxBoundsToTileRange(pixelBounds),
  		    tileCenter = tileRange.getCenter(),
  		    queue = [],
  		    margin = this.options.keepBuffer,
  		    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
  		                              tileRange.getTopRight().add([margin, -margin]));

  		// Sanity check: panic if the tile range contains Infinity somewhere.
  		if (!(isFinite(tileRange.min.x) &&
  		      isFinite(tileRange.min.y) &&
  		      isFinite(tileRange.max.x) &&
  		      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

  		for (var key in this._tiles) {
  			var c = this._tiles[key].coords;
  			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
  				this._tiles[key].current = false;
  			}
  		}

  		// _update just loads more tiles. If the tile zoom level differs too much
  		// from the map's, let _setView reset levels and prune old tiles.
  		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

  		// create a queue of coordinates to load tiles from
  		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
  			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
  				var coords = new Point(i, j);
  				coords.z = this._tileZoom;

  				if (!this._isValidTile(coords)) { continue; }

  				var tile = this._tiles[this._tileCoordsToKey(coords)];
  				if (tile) {
  					tile.current = true;
  				} else {
  					queue.push(coords);
  				}
  			}
  		}

  		// sort tile queue to load tiles in order of their distance to center
  		queue.sort(function (a, b) {
  			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
  		});

  		if (queue.length !== 0) {
  			// if it's the first batch of tiles to load
  			if (!this._loading) {
  				this._loading = true;
  				// @event loading: Event
  				// Fired when the grid layer starts loading tiles.
  				this.fire('loading');
  			}

  			// create DOM fragment to append tiles in one batch
  			var fragment = document.createDocumentFragment();

  			for (i = 0; i < queue.length; i++) {
  				this._addTile(queue[i], fragment);
  			}

  			this._level.el.appendChild(fragment);
  		}
  	},

  	_isValidTile: function (coords) {
  		var crs = this._map.options.crs;

  		if (!crs.infinite) {
  			// don't load tile if it's out of bounds and not wrapped
  			var bounds = this._globalTileRange;
  			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
  			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
  		}

  		if (!this.options.bounds) { return true; }

  		// don't load tile if it doesn't intersect the bounds in options
  		var tileBounds = this._tileCoordsToBounds(coords);
  		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
  	},

  	_keyToBounds: function (key) {
  		return this._tileCoordsToBounds(this._keyToTileCoords(key));
  	},

  	_tileCoordsToNwSe: function (coords) {
  		var map = this._map,
  		    tileSize = this.getTileSize(),
  		    nwPoint = coords.scaleBy(tileSize),
  		    sePoint = nwPoint.add(tileSize),
  		    nw = map.unproject(nwPoint, coords.z),
  		    se = map.unproject(sePoint, coords.z);
  		return [nw, se];
  	},

  	// converts tile coordinates to its geographical bounds
  	_tileCoordsToBounds: function (coords) {
  		var bp = this._tileCoordsToNwSe(coords),
  		    bounds = new LatLngBounds(bp[0], bp[1]);

  		if (!this.options.noWrap) {
  			bounds = this._map.wrapLatLngBounds(bounds);
  		}
  		return bounds;
  	},
  	// converts tile coordinates to key for the tile cache
  	_tileCoordsToKey: function (coords) {
  		return coords.x + ':' + coords.y + ':' + coords.z;
  	},

  	// converts tile cache key to coordinates
  	_keyToTileCoords: function (key) {
  		var k = key.split(':'),
  		    coords = new Point(+k[0], +k[1]);
  		coords.z = +k[2];
  		return coords;
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		remove(tile.el);

  		delete this._tiles[key];

  		// @event tileunload: TileEvent
  		// Fired when a tile is removed (e.g. when a tile goes off the screen).
  		this.fire('tileunload', {
  			tile: tile.el,
  			coords: this._keyToTileCoords(key)
  		});
  	},

  	_initTile: function (tile) {
  		addClass(tile, 'leaflet-tile');

  		var tileSize = this.getTileSize();
  		tile.style.width = tileSize.x + 'px';
  		tile.style.height = tileSize.y + 'px';

  		tile.onselectstart = falseFn;
  		tile.onmousemove = falseFn;

  		// update opacity on tiles in IE7-8 because of filter inheritance problems
  		if (Browser.ielt9 && this.options.opacity < 1) {
  			setOpacity(tile, this.options.opacity);
  		}
  	},

  	_addTile: function (coords, container) {
  		var tilePos = this._getTilePos(coords),
  		    key = this._tileCoordsToKey(coords);

  		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

  		this._initTile(tile);

  		// if createTile is defined with a second argument ("done" callback),
  		// we know that tile is async and will be ready later; otherwise
  		if (this.createTile.length < 2) {
  			// mark tile as ready, but delay one frame for opacity animation to happen
  			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
  		}

  		setPosition(tile, tilePos);

  		// save tile in cache
  		this._tiles[key] = {
  			el: tile,
  			coords: coords,
  			current: true
  		};

  		container.appendChild(tile);
  		// @event tileloadstart: TileEvent
  		// Fired when a tile is requested and starts loading.
  		this.fire('tileloadstart', {
  			tile: tile,
  			coords: coords
  		});
  	},

  	_tileReady: function (coords, err, tile) {
  		if (err) {
  			// @event tileerror: TileErrorEvent
  			// Fired when there is an error loading a tile.
  			this.fire('tileerror', {
  				error: err,
  				tile: tile,
  				coords: coords
  			});
  		}

  		var key = this._tileCoordsToKey(coords);

  		tile = this._tiles[key];
  		if (!tile) { return; }

  		tile.loaded = +new Date();
  		if (this._map._fadeAnimated) {
  			setOpacity(tile.el, 0);
  			cancelAnimFrame(this._fadeFrame);
  			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
  		} else {
  			tile.active = true;
  			this._pruneTiles();
  		}

  		if (!err) {
  			addClass(tile.el, 'leaflet-tile-loaded');

  			// @event tileload: TileEvent
  			// Fired when a tile loads.
  			this.fire('tileload', {
  				tile: tile.el,
  				coords: coords
  			});
  		}

  		if (this._noTilesToLoad()) {
  			this._loading = false;
  			// @event load: Event
  			// Fired when the grid layer loaded all visible tiles.
  			this.fire('load');

  			if (Browser.ielt9 || !this._map._fadeAnimated) {
  				requestAnimFrame(this._pruneTiles, this);
  			} else {
  				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
  				// to trigger a pruning.
  				setTimeout(bind(this._pruneTiles, this), 250);
  			}
  		}
  	},

  	_getTilePos: function (coords) {
  		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
  	},

  	_wrapCoords: function (coords) {
  		var newCoords = new Point(
  			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
  			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
  		newCoords.z = coords.z;
  		return newCoords;
  	},

  	_pxBoundsToTileRange: function (bounds) {
  		var tileSize = this.getTileSize();
  		return new Bounds(
  			bounds.min.unscaleBy(tileSize).floor(),
  			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
  	},

  	_noTilesToLoad: function () {
  		for (var key in this._tiles) {
  			if (!this._tiles[key].loaded) { return false; }
  		}
  		return true;
  	}
  });

  // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.
  function gridLayer(options) {
  	return new GridLayer(options);
  }

  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` â€” zoom level, `{x}` and `{y}` â€” tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({

  	// @section
  	// @aka TileLayer options
  	options: {
  		// @option minZoom: Number = 0
  		// The minimum zoom level down to which this layer will be displayed (inclusive).
  		minZoom: 0,

  		// @option maxZoom: Number = 18
  		// The maximum zoom level up to which this layer will be displayed (inclusive).
  		maxZoom: 18,

  		// @option subdomains: String|String[] = 'abc'
  		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
  		subdomains: 'abc',

  		// @option errorTileUrl: String = ''
  		// URL to the tile image to show in place of the tile that failed to load.
  		errorTileUrl: '',

  		// @option zoomOffset: Number = 0
  		// The zoom number used in tile URLs will be offset with this value.
  		zoomOffset: 0,

  		// @option tms: Boolean = false
  		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
  		tms: false,

  		// @option zoomReverse: Boolean = false
  		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
  		zoomReverse: false,

  		// @option detectRetina: Boolean = false
  		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
  		detectRetina: false,

  		// @option crossOrigin: Boolean|String = false
  		// Whether the crossOrigin attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
  		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
  		crossOrigin: false,

  		// @option referrerPolicy: Boolean|String = false
  		// Whether the referrerPolicy attribute will be added to the tiles.
  		// If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
  		// This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
  		// (e.g. to validate an API token).
  		// Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
  		referrerPolicy: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		options = setOptions(this, options);

  		// detecting retina displays, adjusting tileSize and zoom levels
  		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

  			options.tileSize = Math.floor(options.tileSize / 2);

  			if (!options.zoomReverse) {
  				options.zoomOffset++;
  				options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
  			} else {
  				options.zoomOffset--;
  				options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
  			}

  			options.minZoom = Math.max(0, options.minZoom);
  		} else if (!options.zoomReverse) {
  			// make sure maxZoom is gte minZoom
  			options.maxZoom = Math.max(options.minZoom, options.maxZoom);
  		} else {
  			// make sure minZoom is lte maxZoom
  			options.minZoom = Math.min(options.maxZoom, options.minZoom);
  		}

  		if (typeof options.subdomains === 'string') {
  			options.subdomains = options.subdomains.split('');
  		}

  		this.on('tileunload', this._onTileRemove);
  	},

  	// @method setUrl(url: String, noRedraw?: Boolean): this
  	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
  	// If the URL does not change, the layer will not be redrawn unless
  	// the noRedraw parameter is set to false.
  	setUrl: function (url, noRedraw) {
  		if (this._url === url && noRedraw === undefined) {
  			noRedraw = true;
  		}

  		this._url = url;

  		if (!noRedraw) {
  			this.redraw();
  		}
  		return this;
  	},

  	// @method createTile(coords: Object, done?: Function): HTMLElement
  	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
  	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
  	// callback is called when the tile has been loaded.
  	createTile: function (coords, done) {
  		var tile = document.createElement('img');

  		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
  		on(tile, 'error', bind(this._tileOnError, this, done, tile));

  		if (this.options.crossOrigin || this.options.crossOrigin === '') {
  			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
  		}

  		// for this new option we follow the documented behavior
  		// more closely by only setting the property when string
  		if (typeof this.options.referrerPolicy === 'string') {
  			tile.referrerPolicy = this.options.referrerPolicy;
  		}

  		// The alt attribute is set to the empty string,
  		// allowing screen readers to ignore the decorative image tiles.
  		// https://www.w3.org/WAI/tutorials/images/decorative/
  		// https://www.w3.org/TR/html-aria/#el-img-empty-alt
  		tile.alt = '';

  		tile.src = this.getTileUrl(coords);

  		return tile;
  	},

  	// @section Extension methods
  	// @uninheritable
  	// Layers extending `TileLayer` might reimplement the following method.
  	// @method getTileUrl(coords: Object): String
  	// Called only internally, returns the URL for a tile given its coordinates.
  	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
  	getTileUrl: function (coords) {
  		var data = {
  			r: Browser.retina ? '@2x' : '',
  			s: this._getSubdomain(coords),
  			x: coords.x,
  			y: coords.y,
  			z: this._getZoomForUrl()
  		};
  		if (this._map && !this._map.options.crs.infinite) {
  			var invertedY = this._globalTileRange.max.y - coords.y;
  			if (this.options.tms) {
  				data['y'] = invertedY;
  			}
  			data['-y'] = invertedY;
  		}

  		return template(this._url, extend(data, this.options));
  	},

  	_tileOnLoad: function (done, tile) {
  		// For https://github.com/Leaflet/Leaflet/issues/3332
  		if (Browser.ielt9) {
  			setTimeout(bind(done, this, null, tile), 0);
  		} else {
  			done(null, tile);
  		}
  	},

  	_tileOnError: function (done, tile, e) {
  		var errorUrl = this.options.errorTileUrl;
  		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
  			tile.src = errorUrl;
  		}
  		done(e, tile);
  	},

  	_onTileRemove: function (e) {
  		e.tile.onload = null;
  	},

  	_getZoomForUrl: function () {
  		var zoom = this._tileZoom,
  		maxZoom = this.options.maxZoom,
  		zoomReverse = this.options.zoomReverse,
  		zoomOffset = this.options.zoomOffset;

  		if (zoomReverse) {
  			zoom = maxZoom - zoom;
  		}

  		return zoom + zoomOffset;
  	},

  	_getSubdomain: function (tilePoint) {
  		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
  		return this.options.subdomains[index];
  	},

  	// stops loading all tiles in the background layer
  	_abortLoading: function () {
  		var i, tile;
  		for (i in this._tiles) {
  			if (this._tiles[i].coords.z !== this._tileZoom) {
  				tile = this._tiles[i].el;

  				tile.onload = falseFn;
  				tile.onerror = falseFn;

  				if (!tile.complete) {
  					tile.src = emptyImageUrl;
  					var coords = this._tiles[i].coords;
  					remove(tile);
  					delete this._tiles[i];
  					// @event tileabort: TileEvent
  					// Fired when a tile was loading but is now not wanted.
  					this.fire('tileabort', {
  						tile: tile,
  						coords: coords
  					});
  				}
  			}
  		}
  	},

  	_removeTile: function (key) {
  		var tile = this._tiles[key];
  		if (!tile) { return; }

  		// Cancels any pending http requests associated with the tile
  		tile.el.setAttribute('src', emptyImageUrl);

  		return GridLayer.prototype._removeTile.call(this, key);
  	},

  	_tileReady: function (coords, err, tile) {
  		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
  			return;
  		}

  		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
  	}
  });


  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
  	return new TileLayer(url, options);
  }

  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data Â© 2012 IEM Nexrad"
   * });
   * ```
   */

  var TileLayerWMS = TileLayer.extend({

  	// @section
  	// @aka TileLayer.WMS options
  	// If any custom options not documented here are used, they will be sent to the
  	// WMS server as extra parameters in each request URL. This can be useful for
  	// [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
  	defaultWmsParams: {
  		service: 'WMS',
  		request: 'GetMap',

  		// @option layers: String = ''
  		// **(required)** Comma-separated list of WMS layers to show.
  		layers: '',

  		// @option styles: String = ''
  		// Comma-separated list of WMS styles.
  		styles: '',

  		// @option format: String = 'image/jpeg'
  		// WMS image format (use `'image/png'` for layers with transparency).
  		format: 'image/jpeg',

  		// @option transparent: Boolean = false
  		// If `true`, the WMS service will return images with transparency.
  		transparent: false,

  		// @option version: String = '1.1.1'
  		// Version of the WMS service to use
  		version: '1.1.1'
  	},

  	options: {
  		// @option crs: CRS = null
  		// Coordinate Reference System to use for the WMS requests, defaults to
  		// map CRS. Don't change this if you're not sure what it means.
  		crs: null,

  		// @option uppercase: Boolean = false
  		// If `true`, WMS request parameter keys will be uppercase.
  		uppercase: false
  	},

  	initialize: function (url, options) {

  		this._url = url;

  		var wmsParams = extend({}, this.defaultWmsParams);

  		// all keys that are not TileLayer options go to WMS params
  		for (var i in options) {
  			if (!(i in this.options)) {
  				wmsParams[i] = options[i];
  			}
  		}

  		options = setOptions(this, options);

  		var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
  		var tileSize = this.getTileSize();
  		wmsParams.width = tileSize.x * realRetina;
  		wmsParams.height = tileSize.y * realRetina;

  		this.wmsParams = wmsParams;
  	},

  	onAdd: function (map) {

  		this._crs = this.options.crs || map.options.crs;
  		this._wmsVersion = parseFloat(this.wmsParams.version);

  		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
  		this.wmsParams[projectionKey] = this._crs.code;

  		TileLayer.prototype.onAdd.call(this, map);
  	},

  	getTileUrl: function (coords) {

  		var tileBounds = this._tileCoordsToNwSe(coords),
  		    crs = this._crs,
  		    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
  		    min = bounds.min,
  		    max = bounds.max,
  		    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
  		    [min.y, min.x, max.y, max.x] :
  		    [min.x, min.y, max.x, max.y]).join(','),
  		    url = TileLayer.prototype.getTileUrl.call(this, coords);
  		return url +
  			getParamString(this.wmsParams, url, this.options.uppercase) +
  			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
  	},

  	// @method setParams(params: Object, noRedraw?: Boolean): this
  	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
  	setParams: function (params, noRedraw) {

  		extend(this.wmsParams, params);

  		if (!noRedraw) {
  			this.redraw();
  		}

  		return this;
  	}
  });


  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
  function tileLayerWMS(url, options) {
  	return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;

  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({

  	// @section
  	// @aka Renderer options
  	options: {
  		// @option padding: Number = 0.1
  		// How much to extend the clip area around the map view (relative to its size)
  		// e.g. 0.1 would be 10% of map view in each direction
  		padding: 0.1
  	},

  	initialize: function (options) {
  		setOptions(this, options);
  		stamp(this);
  		this._layers = this._layers || {};
  	},

  	onAdd: function () {
  		if (!this._container) {
  			this._initContainer(); // defined by renderer implementations

  			// always keep transform-origin as 0 0
  			addClass(this._container, 'leaflet-zoom-animated');
  		}

  		this.getPane().appendChild(this._container);
  		this._update();
  		this.on('update', this._updatePaths, this);
  	},

  	onRemove: function () {
  		this.off('update', this._updatePaths, this);
  		this._destroyContainer();
  	},

  	getEvents: function () {
  		var events = {
  			viewreset: this._reset,
  			zoom: this._onZoom,
  			moveend: this._update,
  			zoomend: this._onZoomEnd
  		};
  		if (this._zoomAnimated) {
  			events.zoomanim = this._onAnimZoom;
  		}
  		return events;
  	},

  	_onAnimZoom: function (ev) {
  		this._updateTransform(ev.center, ev.zoom);
  	},

  	_onZoom: function () {
  		this._updateTransform(this._map.getCenter(), this._map.getZoom());
  	},

  	_updateTransform: function (center, zoom) {
  		var scale = this._map.getZoomScale(zoom, this._zoom),
  		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
  		    currentCenterPoint = this._map.project(this._center, zoom),

  		    topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)
  				  .subtract(this._map._getNewPixelOrigin(center, zoom));

  		if (Browser.any3d) {
  			setTransform(this._container, topLeftOffset, scale);
  		} else {
  			setPosition(this._container, topLeftOffset);
  		}
  	},

  	_reset: function () {
  		this._update();
  		this._updateTransform(this._center, this._zoom);

  		for (var id in this._layers) {
  			this._layers[id]._reset();
  		}
  	},

  	_onZoomEnd: function () {
  		for (var id in this._layers) {
  			this._layers[id]._project();
  		}
  	},

  	_updatePaths: function () {
  		for (var id in this._layers) {
  			this._layers[id]._update();
  		}
  	},

  	_update: function () {
  		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
  		// Subclasses are responsible of firing the 'update' event.
  		var p = this.options.padding,
  		    size = this._map.getSize(),
  		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

  		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

  		this._center = this._map.getCenter();
  		this._zoom = this._map.getZoom();
  	}
  });

  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({

  	// @section
  	// @aka Canvas options
  	options: {
  		// @option tolerance: Number = 0
  		// How much to extend the click tolerance around a path/object on the map.
  		tolerance: 0
  	},

  	getEvents: function () {
  		var events = Renderer.prototype.getEvents.call(this);
  		events.viewprereset = this._onViewPreReset;
  		return events;
  	},

  	_onViewPreReset: function () {
  		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
  		this._postponeUpdatePaths = true;
  	},

  	onAdd: function () {
  		Renderer.prototype.onAdd.call(this);

  		// Redraw vectors since canvas is cleared upon removal,
  		// in case of removing the renderer itself from the map.
  		this._draw();
  	},

  	_initContainer: function () {
  		var container = this._container = document.createElement('canvas');

  		on(container, 'mousemove', this._onMouseMove, this);
  		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
  		on(container, 'mouseout', this._handleMouseOut, this);
  		container['_leaflet_disable_events'] = true;

  		this._ctx = container.getContext('2d');
  	},

  	_destroyContainer: function () {
  		cancelAnimFrame(this._redrawRequest);
  		delete this._ctx;
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  	},

  	_updatePaths: function () {
  		if (this._postponeUpdatePaths) { return; }

  		var layer;
  		this._redrawBounds = null;
  		for (var id in this._layers) {
  			layer = this._layers[id];
  			layer._update();
  		}
  		this._redraw();
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    container = this._container,
  		    size = b.getSize(),
  		    m = Browser.retina ? 2 : 1;

  		setPosition(container, b.min);

  		// set canvas size (also clearing it); use double size on retina
  		container.width = m * size.x;
  		container.height = m * size.y;
  		container.style.width = size.x + 'px';
  		container.style.height = size.y + 'px';

  		if (Browser.retina) {
  			this._ctx.scale(2, 2);
  		}

  		// translate so we use the same path coordinates after canvas element moves
  		this._ctx.translate(-b.min.x, -b.min.y);

  		// Tell paths to redraw themselves
  		this.fire('update');
  	},

  	_reset: function () {
  		Renderer.prototype._reset.call(this);

  		if (this._postponeUpdatePaths) {
  			this._postponeUpdatePaths = false;
  			this._updatePaths();
  		}
  	},

  	_initPath: function (layer) {
  		this._updateDashArray(layer);
  		this._layers[stamp(layer)] = layer;

  		var order = layer._order = {
  			layer: layer,
  			prev: this._drawLast,
  			next: null
  		};
  		if (this._drawLast) { this._drawLast.next = order; }
  		this._drawLast = order;
  		this._drawFirst = this._drawFirst || this._drawLast;
  	},

  	_addPath: function (layer) {
  		this._requestRedraw(layer);
  	},

  	_removePath: function (layer) {
  		var order = layer._order;
  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			this._drawLast = prev;
  		}
  		if (prev) {
  			prev.next = next;
  		} else {
  			this._drawFirst = next;
  		}

  		delete layer._order;

  		delete this._layers[stamp(layer)];

  		this._requestRedraw(layer);
  	},

  	_updatePath: function (layer) {
  		// Redraw the union of the layer's old pixel
  		// bounds and the new pixel bounds.
  		this._extendRedrawBounds(layer);
  		layer._project();
  		layer._update();
  		// The redraw will extend the redraw bounds
  		// with the new pixel bounds.
  		this._requestRedraw(layer);
  	},

  	_updateStyle: function (layer) {
  		this._updateDashArray(layer);
  		this._requestRedraw(layer);
  	},

  	_updateDashArray: function (layer) {
  		if (typeof layer.options.dashArray === 'string') {
  			var parts = layer.options.dashArray.split(/[, ]+/),
  			    dashArray = [],
  			    dashValue,
  			    i;
  			for (i = 0; i < parts.length; i++) {
  				dashValue = Number(parts[i]);
  				// Ignore dash array containing invalid lengths
  				if (isNaN(dashValue)) { return; }
  				dashArray.push(dashValue);
  			}
  			layer.options._dashArray = dashArray;
  		} else {
  			layer.options._dashArray = layer.options.dashArray;
  		}
  	},

  	_requestRedraw: function (layer) {
  		if (!this._map) { return; }

  		this._extendRedrawBounds(layer);
  		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
  	},

  	_extendRedrawBounds: function (layer) {
  		if (layer._pxBounds) {
  			var padding = (layer.options.weight || 0) + 1;
  			this._redrawBounds = this._redrawBounds || new Bounds();
  			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
  			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
  		}
  	},

  	_redraw: function () {
  		this._redrawRequest = null;

  		if (this._redrawBounds) {
  			this._redrawBounds.min._floor();
  			this._redrawBounds.max._ceil();
  		}

  		this._clear(); // clear layers in redraw bounds
  		this._draw(); // draw layers

  		this._redrawBounds = null;
  	},

  	_clear: function () {
  		var bounds = this._redrawBounds;
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
  		} else {
  			this._ctx.save();
  			this._ctx.setTransform(1, 0, 0, 1, 0, 0);
  			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
  			this._ctx.restore();
  		}
  	},

  	_draw: function () {
  		var layer, bounds = this._redrawBounds;
  		this._ctx.save();
  		if (bounds) {
  			var size = bounds.getSize();
  			this._ctx.beginPath();
  			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
  			this._ctx.clip();
  		}

  		this._drawing = true;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
  				layer._updatePath();
  			}
  		}

  		this._drawing = false;

  		this._ctx.restore();  // Restore state before clipping.
  	},

  	_updatePoly: function (layer, closed) {
  		if (!this._drawing) { return; }

  		var i, j, len2, p,
  		    parts = layer._parts,
  		    len = parts.length,
  		    ctx = this._ctx;

  		if (!len) { return; }

  		ctx.beginPath();

  		for (i = 0; i < len; i++) {
  			for (j = 0, len2 = parts[i].length; j < len2; j++) {
  				p = parts[i][j];
  				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
  			}
  			if (closed) {
  				ctx.closePath();
  			}
  		}

  		this._fillStroke(ctx, layer);

  		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
  	},

  	_updateCircle: function (layer) {

  		if (!this._drawing || layer._empty()) { return; }

  		var p = layer._point,
  		    ctx = this._ctx,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

  		if (s !== 1) {
  			ctx.save();
  			ctx.scale(1, s);
  		}

  		ctx.beginPath();
  		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

  		if (s !== 1) {
  			ctx.restore();
  		}

  		this._fillStroke(ctx, layer);
  	},

  	_fillStroke: function (ctx, layer) {
  		var options = layer.options;

  		if (options.fill) {
  			ctx.globalAlpha = options.fillOpacity;
  			ctx.fillStyle = options.fillColor || options.color;
  			ctx.fill(options.fillRule || 'evenodd');
  		}

  		if (options.stroke && options.weight !== 0) {
  			if (ctx.setLineDash) {
  				ctx.setLineDash(layer.options && layer.options._dashArray || []);
  			}
  			ctx.globalAlpha = options.opacity;
  			ctx.lineWidth = options.weight;
  			ctx.strokeStyle = options.color;
  			ctx.lineCap = options.lineCap;
  			ctx.lineJoin = options.lineJoin;
  			ctx.stroke();
  		}
  	},

  	// Canvas obviously doesn't have mouse events for individual drawn objects,
  	// so we emulate that by calculating what's under the mouse on mousemove/click manually

  	_onClick: function (e) {
  		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {
  					clickedLayer = layer;
  				}
  			}
  		}
  		this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
  	},

  	_onMouseMove: function (e) {
  		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

  		var point = this._map.mouseEventToLayerPoint(e);
  		this._handleMouseHover(e, point);
  	},


  	_handleMouseOut: function (e) {
  		var layer = this._hoveredLayer;
  		if (layer) {
  			// if we're leaving the layer, fire mouseout
  			removeClass(this._container, 'leaflet-interactive');
  			this._fireEvent([layer], e, 'mouseout');
  			this._hoveredLayer = null;
  			this._mouseHoverThrottled = false;
  		}
  	},

  	_handleMouseHover: function (e, point) {
  		if (this._mouseHoverThrottled) {
  			return;
  		}

  		var layer, candidateHoveredLayer;

  		for (var order = this._drawFirst; order; order = order.next) {
  			layer = order.layer;
  			if (layer.options.interactive && layer._containsPoint(point)) {
  				candidateHoveredLayer = layer;
  			}
  		}

  		if (candidateHoveredLayer !== this._hoveredLayer) {
  			this._handleMouseOut(e);

  			if (candidateHoveredLayer) {
  				addClass(this._container, 'leaflet-interactive'); // change cursor
  				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
  				this._hoveredLayer = candidateHoveredLayer;
  			}
  		}

  		this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);

  		this._mouseHoverThrottled = true;
  		setTimeout(bind(function () {
  			this._mouseHoverThrottled = false;
  		}, this), 32);
  	},

  	_fireEvent: function (layers, e, type) {
  		this._map._fireDOMEvent(e, type || e.type, layers);
  	},

  	_bringToFront: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (next) {
  			next.prev = prev;
  		} else {
  			// Already last
  			return;
  		}
  		if (prev) {
  			prev.next = next;
  		} else if (next) {
  			// Update first entry unless this is the
  			// single entry
  			this._drawFirst = next;
  		}

  		order.prev = this._drawLast;
  		this._drawLast.next = order;

  		order.next = null;
  		this._drawLast = order;

  		this._requestRedraw(layer);
  	},

  	_bringToBack: function (layer) {
  		var order = layer._order;

  		if (!order) { return; }

  		var next = order.next;
  		var prev = order.prev;

  		if (prev) {
  			prev.next = next;
  		} else {
  			// Already first
  			return;
  		}
  		if (next) {
  			next.prev = prev;
  		} else if (prev) {
  			// Update last entry unless this is the
  			// single entry
  			this._drawLast = prev;
  		}

  		order.prev = null;

  		order.next = this._drawFirst;
  		this._drawFirst.prev = order;
  		this._drawFirst = order;

  		this._requestRedraw(layer);
  	}
  });

  // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.
  function canvas(options) {
  	return Browser.canvas ? new Canvas(options) : null;
  }

  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = (function () {
  	try {
  		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
  		return function (name) {
  			return document.createElement('<lvml:' + name + ' class="lvml">');
  		};
  	} catch (e) {
  		// Do not return fn from catch block so `e` can be garbage collected
  		// See https://github.com/Leaflet/Leaflet/pull/7279
  	}
  	return function (name) {
  		return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
  	};
  })();


  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */

  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
  var vmlMixin = {

  	_initContainer: function () {
  		this._container = create$1('div', 'leaflet-vml-container');
  	},

  	_update: function () {
  		if (this._map._animatingZoom) { return; }
  		Renderer.prototype._update.call(this);
  		this.fire('update');
  	},

  	_initPath: function (layer) {
  		var container = layer._container = vmlCreate('shape');

  		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

  		container.coordsize = '1 1';

  		layer._path = vmlCreate('path');
  		container.appendChild(layer._path);

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		var container = layer._container;
  		this._container.appendChild(container);

  		if (layer.options.interactive) {
  			layer.addInteractiveTarget(container);
  		}
  	},

  	_removePath: function (layer) {
  		var container = layer._container;
  		remove(container);
  		layer.removeInteractiveTarget(container);
  		delete this._layers[stamp(layer)];
  	},

  	_updateStyle: function (layer) {
  		var stroke = layer._stroke,
  		    fill = layer._fill,
  		    options = layer.options,
  		    container = layer._container;

  		container.stroked = !!options.stroke;
  		container.filled = !!options.fill;

  		if (options.stroke) {
  			if (!stroke) {
  				stroke = layer._stroke = vmlCreate('stroke');
  			}
  			container.appendChild(stroke);
  			stroke.weight = options.weight + 'px';
  			stroke.color = options.color;
  			stroke.opacity = options.opacity;

  			if (options.dashArray) {
  				stroke.dashStyle = isArray(options.dashArray) ?
  				    options.dashArray.join(' ') :
  				    options.dashArray.replace(/( *, *)/g, ' ');
  			} else {
  				stroke.dashStyle = '';
  			}
  			stroke.endcap = options.lineCap.replace('butt', 'flat');
  			stroke.joinstyle = options.lineJoin;

  		} else if (stroke) {
  			container.removeChild(stroke);
  			layer._stroke = null;
  		}

  		if (options.fill) {
  			if (!fill) {
  				fill = layer._fill = vmlCreate('fill');
  			}
  			container.appendChild(fill);
  			fill.color = options.fillColor || options.color;
  			fill.opacity = options.fillOpacity;

  		} else if (fill) {
  			container.removeChild(fill);
  			layer._fill = null;
  		}
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point.round(),
  		    r = Math.round(layer._radius),
  		    r2 = Math.round(layer._radiusY || r);

  		this._setPath(layer, layer._empty() ? 'M0 0' :
  			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
  	},

  	_setPath: function (layer, path) {
  		layer._path.v = path;
  	},

  	_bringToFront: function (layer) {
  		toFront(layer._container);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._container);
  	}
  };

  var create = Browser.vml ? vmlCreate : svgCreate;

  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({

  	_initContainer: function () {
  		this._container = create('svg');

  		// makes it possible to click through svg root; we'll reset it back in individual paths
  		this._container.setAttribute('pointer-events', 'none');

  		this._rootGroup = create('g');
  		this._container.appendChild(this._rootGroup);
  	},

  	_destroyContainer: function () {
  		remove(this._container);
  		off(this._container);
  		delete this._container;
  		delete this._rootGroup;
  		delete this._svgSize;
  	},

  	_update: function () {
  		if (this._map._animatingZoom && this._bounds) { return; }

  		Renderer.prototype._update.call(this);

  		var b = this._bounds,
  		    size = b.getSize(),
  		    container = this._container;

  		// set size of svg-container if changed
  		if (!this._svgSize || !this._svgSize.equals(size)) {
  			this._svgSize = size;
  			container.setAttribute('width', size.x);
  			container.setAttribute('height', size.y);
  		}

  		// movement: update container viewBox so that we don't have to change coordinates of individual layers
  		setPosition(container, b.min);
  		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

  		this.fire('update');
  	},

  	// methods below are called by vector layers implementations

  	_initPath: function (layer) {
  		var path = layer._path = create('path');

  		// @namespace Path
  		// @option className: String = null
  		// Custom class name set on an element. Only for SVG renderer.
  		if (layer.options.className) {
  			addClass(path, layer.options.className);
  		}

  		if (layer.options.interactive) {
  			addClass(path, 'leaflet-interactive');
  		}

  		this._updateStyle(layer);
  		this._layers[stamp(layer)] = layer;
  	},

  	_addPath: function (layer) {
  		if (!this._rootGroup) { this._initContainer(); }
  		this._rootGroup.appendChild(layer._path);
  		layer.addInteractiveTarget(layer._path);
  	},

  	_removePath: function (layer) {
  		remove(layer._path);
  		layer.removeInteractiveTarget(layer._path);
  		delete this._layers[stamp(layer)];
  	},

  	_updatePath: function (layer) {
  		layer._project();
  		layer._update();
  	},

  	_updateStyle: function (layer) {
  		var path = layer._path,
  		    options = layer.options;

  		if (!path) { return; }

  		if (options.stroke) {
  			path.setAttribute('stroke', options.color);
  			path.setAttribute('stroke-opacity', options.opacity);
  			path.setAttribute('stroke-width', options.weight);
  			path.setAttribute('stroke-linecap', options.lineCap);
  			path.setAttribute('stroke-linejoin', options.lineJoin);

  			if (options.dashArray) {
  				path.setAttribute('stroke-dasharray', options.dashArray);
  			} else {
  				path.removeAttribute('stroke-dasharray');
  			}

  			if (options.dashOffset) {
  				path.setAttribute('stroke-dashoffset', options.dashOffset);
  			} else {
  				path.removeAttribute('stroke-dashoffset');
  			}
  		} else {
  			path.setAttribute('stroke', 'none');
  		}

  		if (options.fill) {
  			path.setAttribute('fill', options.fillColor || options.color);
  			path.setAttribute('fill-opacity', options.fillOpacity);
  			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
  		} else {
  			path.setAttribute('fill', 'none');
  		}
  	},

  	_updatePoly: function (layer, closed) {
  		this._setPath(layer, pointsToPath(layer._parts, closed));
  	},

  	_updateCircle: function (layer) {
  		var p = layer._point,
  		    r = Math.max(Math.round(layer._radius), 1),
  		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
  		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

  		// drawing a circle with two half-arcs
  		var d = layer._empty() ? 'M0 0' :
  			'M' + (p.x - r) + ',' + p.y +
  			arc + (r * 2) + ',0 ' +
  			arc + (-r * 2) + ',0 ';

  		this._setPath(layer, d);
  	},

  	_setPath: function (layer, path) {
  		layer._path.setAttribute('d', path);
  	},

  	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
  	_bringToFront: function (layer) {
  		toFront(layer._path);
  	},

  	_bringToBack: function (layer) {
  		toBack(layer._path);
  	}
  });

  if (Browser.vml) {
  	SVG.include(vmlMixin);
  }

  // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.
  function svg(options) {
  	return Browser.svg || Browser.vml ? new SVG(options) : null;
  }

  Map.include({
  	// @namespace Map; @method getRenderer(layer: Path): Renderer
  	// Returns the instance of `Renderer` that should be used to render the given
  	// `Path`. It will ensure that the `renderer` options of the map and paths
  	// are respected, and that the renderers do exist on the map.
  	getRenderer: function (layer) {
  		// @namespace Path; @option renderer: Renderer
  		// Use this specific instance of `Renderer` for this path. Takes
  		// precedence over the map's [default renderer](#map-renderer).
  		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

  		if (!renderer) {
  			renderer = this._renderer = this._createRenderer();
  		}

  		if (!this.hasLayer(renderer)) {
  			this.addLayer(renderer);
  		}
  		return renderer;
  	},

  	_getPaneRenderer: function (name) {
  		if (name === 'overlayPane' || name === undefined) {
  			return false;
  		}

  		var renderer = this._paneRenderers[name];
  		if (renderer === undefined) {
  			renderer = this._createRenderer({pane: name});
  			this._paneRenderers[name] = renderer;
  		}
  		return renderer;
  	},

  	_createRenderer: function (options) {
  		// @namespace Map; @option preferCanvas: Boolean = false
  		// Whether `Path`s should be rendered on a `Canvas` renderer.
  		// By default, all `Path`s are rendered in a `SVG` renderer.
  		return (this.options.preferCanvas && canvas(options)) || svg(options);
  	}
  });

  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */


  var Rectangle = Polygon.extend({
  	initialize: function (latLngBounds, options) {
  		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  	},

  	// @method setBounds(latLngBounds: LatLngBounds): this
  	// Redraws the rectangle with the passed bounds.
  	setBounds: function (latLngBounds) {
  		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  	},

  	_boundsToLatLngs: function (latLngBounds) {
  		latLngBounds = toLatLngBounds(latLngBounds);
  		return [
  			latLngBounds.getSouthWest(),
  			latLngBounds.getNorthWest(),
  			latLngBounds.getNorthEast(),
  			latLngBounds.getSouthEast()
  		];
  	}
  });


  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
  function rectangle(latLngBounds, options) {
  	return new Rectangle(latLngBounds, options);
  }

  SVG.create = create;
  SVG.pointsToPath = pointsToPath;

  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;

  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option boxZoom: Boolean = true
  	// Whether the map can be zoomed to a rectangular area specified by
  	// dragging the mouse while pressing the shift key.
  	boxZoom: true
  });

  var BoxZoom = Handler.extend({
  	initialize: function (map) {
  		this._map = map;
  		this._container = map._container;
  		this._pane = map._panes.overlayPane;
  		this._resetStateTimeout = 0;
  		map.on('unload', this._destroy, this);
  	},

  	addHooks: function () {
  		on(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	removeHooks: function () {
  		off(this._container, 'mousedown', this._onMouseDown, this);
  	},

  	moved: function () {
  		return this._moved;
  	},

  	_destroy: function () {
  		remove(this._pane);
  		delete this._pane;
  	},

  	_resetState: function () {
  		this._resetStateTimeout = 0;
  		this._moved = false;
  	},

  	_clearDeferredResetState: function () {
  		if (this._resetStateTimeout !== 0) {
  			clearTimeout(this._resetStateTimeout);
  			this._resetStateTimeout = 0;
  		}
  	},

  	_onMouseDown: function (e) {
  		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

  		// Clear the deferred resetState if it hasn't executed yet, otherwise it
  		// will interrupt the interaction and orphan a box element in the container.
  		this._clearDeferredResetState();
  		this._resetState();

  		disableTextSelection();
  		disableImageDrag();

  		this._startPoint = this._map.mouseEventToContainerPoint(e);

  		on(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseMove: function (e) {
  		if (!this._moved) {
  			this._moved = true;

  			this._box = create$1('div', 'leaflet-zoom-box', this._container);
  			addClass(this._container, 'leaflet-crosshair');

  			this._map.fire('boxzoomstart');
  		}

  		this._point = this._map.mouseEventToContainerPoint(e);

  		var bounds = new Bounds(this._point, this._startPoint),
  		    size = bounds.getSize();

  		setPosition(this._box, bounds.min);

  		this._box.style.width  = size.x + 'px';
  		this._box.style.height = size.y + 'px';
  	},

  	_finish: function () {
  		if (this._moved) {
  			remove(this._box);
  			removeClass(this._container, 'leaflet-crosshair');
  		}

  		enableTextSelection();
  		enableImageDrag();

  		off(document, {
  			contextmenu: stop,
  			mousemove: this._onMouseMove,
  			mouseup: this._onMouseUp,
  			keydown: this._onKeyDown
  		}, this);
  	},

  	_onMouseUp: function (e) {
  		if ((e.which !== 1) && (e.button !== 1)) { return; }

  		this._finish();

  		if (!this._moved) { return; }
  		// Postpone to next JS tick so internal click event handling
  		// still see it as "moved".
  		this._clearDeferredResetState();
  		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

  		var bounds = new LatLngBounds(
  		        this._map.containerPointToLatLng(this._startPoint),
  		        this._map.containerPointToLatLng(this._point));

  		this._map
  			.fitBounds(bounds)
  			.fire('boxzoomend', {boxZoomBounds: bounds});
  	},

  	_onKeyDown: function (e) {
  		if (e.keyCode === 27) {
  			this._finish();
  			this._clearDeferredResetState();
  			this._resetState();
  		}
  	}
  });

  // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.
  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */

  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
  	// @option doubleClickZoom: Boolean|String = true
  	// Whether the map can be zoomed in by double clicking on it and
  	// zoomed out by double clicking while holding shift. If passed
  	// `'center'`, double-click zoom will zoom to the center of the
  	//  view regardless of where the mouse was.
  	doubleClickZoom: true
  });

  var DoubleClickZoom = Handler.extend({
  	addHooks: function () {
  		this._map.on('dblclick', this._onDoubleClick, this);
  	},

  	removeHooks: function () {
  		this._map.off('dblclick', this._onDoubleClick, this);
  	},

  	_onDoubleClick: function (e) {
  		var map = this._map,
  		    oldZoom = map.getZoom(),
  		    delta = map.options.zoomDelta,
  		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

  		if (map.options.doubleClickZoom === 'center') {
  			map.setZoom(zoom);
  		} else {
  			map.setZoomAround(e.containerPoint, zoom);
  		}
  	}
  });

  // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.
  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @option dragging: Boolean = true
  	// Whether the map is draggable with mouse/touch or not.
  	dragging: true,

  	// @section Panning Inertia Options
  	// @option inertia: Boolean = *
  	// If enabled, panning of the map will have an inertia effect where
  	// the map builds momentum while dragging and continues moving in
  	// the same direction for some time. Feels especially nice on touch
  	// devices. Enabled by default.
  	inertia: true,

  	// @option inertiaDeceleration: Number = 3000
  	// The rate with which the inertial movement slows down, in pixels/secondÂ².
  	inertiaDeceleration: 3400, // px/s^2

  	// @option inertiaMaxSpeed: Number = Infinity
  	// Max speed of the inertial movement, in pixels/second.
  	inertiaMaxSpeed: Infinity, // px/s

  	// @option easeLinearity: Number = 0.2
  	easeLinearity: 0.2,

  	// TODO refactor, move to CRS
  	// @option worldCopyJump: Boolean = false
  	// With this option enabled, the map tracks when you pan to another "copy"
  	// of the world and seamlessly jumps to the original one so that all overlays
  	// like markers and vector layers are still visible.
  	worldCopyJump: false,

  	// @option maxBoundsViscosity: Number = 0.0
  	// If `maxBounds` is set, this option will control how solid the bounds
  	// are when dragging the map around. The default value of `0.0` allows the
  	// user to drag outside the bounds at normal speed, higher values will
  	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
  	// solid, preventing the user from dragging outside the bounds.
  	maxBoundsViscosity: 0.0
  });

  var Drag = Handler.extend({
  	addHooks: function () {
  		if (!this._draggable) {
  			var map = this._map;

  			this._draggable = new Draggable(map._mapPane, map._container);

  			this._draggable.on({
  				dragstart: this._onDragStart,
  				drag: this._onDrag,
  				dragend: this._onDragEnd
  			}, this);

  			this._draggable.on('predrag', this._onPreDragLimit, this);
  			if (map.options.worldCopyJump) {
  				this._draggable.on('predrag', this._onPreDragWrap, this);
  				map.on('zoomend', this._onZoomEnd, this);

  				map.whenReady(this._onZoomEnd, this);
  			}
  		}
  		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
  		this._draggable.enable();
  		this._positions = [];
  		this._times = [];
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-grab');
  		removeClass(this._map._container, 'leaflet-touch-drag');
  		this._draggable.disable();
  	},

  	moved: function () {
  		return this._draggable && this._draggable._moved;
  	},

  	moving: function () {
  		return this._draggable && this._draggable._moving;
  	},

  	_onDragStart: function () {
  		var map = this._map;

  		map._stop();
  		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
  			var bounds = toLatLngBounds(this._map.options.maxBounds);

  			this._offsetLimit = toBounds(
  				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
  				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
  					.add(this._map.getSize()));

  			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
  		} else {
  			this._offsetLimit = null;
  		}

  		map
  		    .fire('movestart')
  		    .fire('dragstart');

  		if (map.options.inertia) {
  			this._positions = [];
  			this._times = [];
  		}
  	},

  	_onDrag: function (e) {
  		if (this._map.options.inertia) {
  			var time = this._lastTime = +new Date(),
  			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

  			this._positions.push(pos);
  			this._times.push(time);

  			this._prunePositions(time);
  		}

  		this._map
  		    .fire('move', e)
  		    .fire('drag', e);
  	},

  	_prunePositions: function (time) {
  		while (this._positions.length > 1 && time - this._times[0] > 50) {
  			this._positions.shift();
  			this._times.shift();
  		}
  	},

  	_onZoomEnd: function () {
  		var pxCenter = this._map.getSize().divideBy(2),
  		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

  		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
  		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
  	},

  	_viscousLimit: function (value, threshold) {
  		return value - (value - threshold) * this._viscosity;
  	},

  	_onPreDragLimit: function () {
  		if (!this._viscosity || !this._offsetLimit) { return; }

  		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

  		var limit = this._offsetLimit;
  		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
  		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
  		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
  		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

  		this._draggable._newPos = this._draggable._startPos.add(offset);
  	},

  	_onPreDragWrap: function () {
  		// TODO refactor to be able to adjust map pane position after zoom
  		var worldWidth = this._worldWidth,
  		    halfWidth = Math.round(worldWidth / 2),
  		    dx = this._initialWorldOffset,
  		    x = this._draggable._newPos.x,
  		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
  		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
  		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

  		this._draggable._absPos = this._draggable._newPos.clone();
  		this._draggable._newPos.x = newX;
  	},

  	_onDragEnd: function (e) {
  		var map = this._map,
  		    options = map.options,

  		    noInertia = !options.inertia || e.noInertia || this._times.length < 2;

  		map.fire('dragend', e);

  		if (noInertia) {
  			map.fire('moveend');

  		} else {
  			this._prunePositions(+new Date());

  			var direction = this._lastPos.subtract(this._positions[0]),
  			    duration = (this._lastTime - this._times[0]) / 1000,
  			    ease = options.easeLinearity,

  			    speedVector = direction.multiplyBy(ease / duration),
  			    speed = speedVector.distanceTo([0, 0]),

  			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
  			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

  			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
  			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

  			if (!offset.x && !offset.y) {
  				map.fire('moveend');

  			} else {
  				offset = map._limitOffset(offset, map.options.maxBounds);

  				requestAnimFrame(function () {
  					map.panBy(offset, {
  						duration: decelerationDuration,
  						easeLinearity: ease,
  						noMoveStart: true,
  						animate: true
  					});
  				});
  			}
  		}
  	}
  });

  // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).
  Map.addInitHook('addHandler', 'dragging', Drag);

  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */

  // @namespace Map
  // @section Keyboard Navigation Options
  Map.mergeOptions({
  	// @option keyboard: Boolean = true
  	// Makes the map focusable and allows users to navigate the map with keyboard
  	// arrows and `+`/`-` keys.
  	keyboard: true,

  	// @option keyboardPanDelta: Number = 80
  	// Amount of pixels to pan when pressing an arrow key.
  	keyboardPanDelta: 80
  });

  var Keyboard = Handler.extend({

  	keyCodes: {
  		left:    [37],
  		right:   [39],
  		down:    [40],
  		up:      [38],
  		zoomIn:  [187, 107, 61, 171],
  		zoomOut: [189, 109, 54, 173]
  	},

  	initialize: function (map) {
  		this._map = map;

  		this._setPanDelta(map.options.keyboardPanDelta);
  		this._setZoomDelta(map.options.zoomDelta);
  	},

  	addHooks: function () {
  		var container = this._map._container;

  		// make the container focusable by tabbing
  		if (container.tabIndex <= 0) {
  			container.tabIndex = '0';
  		}

  		on(container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.on({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	removeHooks: function () {
  		this._removeHooks();

  		off(this._map._container, {
  			focus: this._onFocus,
  			blur: this._onBlur,
  			mousedown: this._onMouseDown
  		}, this);

  		this._map.off({
  			focus: this._addHooks,
  			blur: this._removeHooks
  		}, this);
  	},

  	_onMouseDown: function () {
  		if (this._focused) { return; }

  		var body = document.body,
  		    docEl = document.documentElement,
  		    top = body.scrollTop || docEl.scrollTop,
  		    left = body.scrollLeft || docEl.scrollLeft;

  		this._map._container.focus();

  		window.scrollTo(left, top);
  	},

  	_onFocus: function () {
  		this._focused = true;
  		this._map.fire('focus');
  	},

  	_onBlur: function () {
  		this._focused = false;
  		this._map.fire('blur');
  	},

  	_setPanDelta: function (panDelta) {
  		var keys = this._panKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.left.length; i < len; i++) {
  			keys[codes.left[i]] = [-1 * panDelta, 0];
  		}
  		for (i = 0, len = codes.right.length; i < len; i++) {
  			keys[codes.right[i]] = [panDelta, 0];
  		}
  		for (i = 0, len = codes.down.length; i < len; i++) {
  			keys[codes.down[i]] = [0, panDelta];
  		}
  		for (i = 0, len = codes.up.length; i < len; i++) {
  			keys[codes.up[i]] = [0, -1 * panDelta];
  		}
  	},

  	_setZoomDelta: function (zoomDelta) {
  		var keys = this._zoomKeys = {},
  		    codes = this.keyCodes,
  		    i, len;

  		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
  			keys[codes.zoomIn[i]] = zoomDelta;
  		}
  		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
  			keys[codes.zoomOut[i]] = -zoomDelta;
  		}
  	},

  	_addHooks: function () {
  		on(document, 'keydown', this._onKeyDown, this);
  	},

  	_removeHooks: function () {
  		off(document, 'keydown', this._onKeyDown, this);
  	},

  	_onKeyDown: function (e) {
  		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

  		var key = e.keyCode,
  		    map = this._map,
  		    offset;

  		if (key in this._panKeys) {
  			if (!map._panAnim || !map._panAnim._inProgress) {
  				offset = this._panKeys[key];
  				if (e.shiftKey) {
  					offset = toPoint(offset).multiplyBy(3);
  				}

  				if (map.options.maxBounds) {
  					offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
  				}

  				if (map.options.worldCopyJump) {
  					var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
  					map.panTo(newLatLng);
  				} else {
  					map.panBy(offset);
  				}
  			}
  		} else if (key in this._zoomKeys) {
  			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

  		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
  			map.closePopup();

  		} else {
  			return;
  		}

  		stop(e);
  	}
  });

  // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.
  Map.addInitHook('addHandler', 'keyboard', Keyboard);

  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Mouse wheel options
  	// @option scrollWheelZoom: Boolean|String = true
  	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
  	// it will zoom to the center of the view regardless of where the mouse was.
  	scrollWheelZoom: true,

  	// @option wheelDebounceTime: Number = 40
  	// Limits the rate at which a wheel can fire (in milliseconds). By default
  	// user can't zoom via wheel more often than once per 40 ms.
  	wheelDebounceTime: 40,

  	// @option wheelPxPerZoomLevel: Number = 60
  	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
  	// mean a change of one full zoom level. Smaller values will make wheel-zooming
  	// faster (and vice versa).
  	wheelPxPerZoomLevel: 60
  });

  var ScrollWheelZoom = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'wheel', this._onWheelScroll, this);

  		this._delta = 0;
  	},

  	removeHooks: function () {
  		off(this._map._container, 'wheel', this._onWheelScroll, this);
  	},

  	_onWheelScroll: function (e) {
  		var delta = getWheelDelta(e);

  		var debounce = this._map.options.wheelDebounceTime;

  		this._delta += delta;
  		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

  		if (!this._startTime) {
  			this._startTime = +new Date();
  		}

  		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

  		clearTimeout(this._timer);
  		this._timer = setTimeout(bind(this._performZoom, this), left);

  		stop(e);
  	},

  	_performZoom: function () {
  		var map = this._map,
  		    zoom = map.getZoom(),
  		    snap = this._map.options.zoomSnap || 0;

  		map._stop(); // stop panning and fly animations if any

  		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
  		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
  		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
  		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
  		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

  		this._delta = 0;
  		this._startTime = null;

  		if (!delta) { return; }

  		if (map.options.scrollWheelZoom === 'center') {
  			map.setZoom(zoom + delta);
  		} else {
  			map.setZoomAround(this._lastMousePos, zoom + delta);
  		}
  	}
  });

  // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.
  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

  /*
   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,
   * which otherwise is not fired by mobile Safari.
   */

  var tapHoldDelay = 600;

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option tapHold: Boolean
  	// Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
  	tapHold: Browser.touchNative && Browser.safari && Browser.mobile,

  	// @option tapTolerance: Number = 15
  	// The max number of pixels a user can shift his finger during touch
  	// for it to be considered a valid tap.
  	tapTolerance: 15
  });

  var TapHold = Handler.extend({
  	addHooks: function () {
  		on(this._map._container, 'touchstart', this._onDown, this);
  	},

  	removeHooks: function () {
  		off(this._map._container, 'touchstart', this._onDown, this);
  	},

  	_onDown: function (e) {
  		clearTimeout(this._holdTimeout);
  		if (e.touches.length !== 1) { return; }

  		var first = e.touches[0];
  		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

  		this._holdTimeout = setTimeout(bind(function () {
  			this._cancel();
  			if (!this._isTapValid()) { return; }

  			// prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events
  			on(document, 'touchend', preventDefault);
  			on(document, 'touchend touchcancel', this._cancelClickPrevent);
  			this._simulateEvent('contextmenu', first);
  		}, this), tapHoldDelay);

  		on(document, 'touchend touchcancel contextmenu', this._cancel, this);
  		on(document, 'touchmove', this._onMove, this);
  	},

  	_cancelClickPrevent: function cancelClickPrevent() {
  		off(document, 'touchend', preventDefault);
  		off(document, 'touchend touchcancel', cancelClickPrevent);
  	},

  	_cancel: function () {
  		clearTimeout(this._holdTimeout);
  		off(document, 'touchend touchcancel contextmenu', this._cancel, this);
  		off(document, 'touchmove', this._onMove, this);
  	},

  	_onMove: function (e) {
  		var first = e.touches[0];
  		this._newPos = new Point(first.clientX, first.clientY);
  	},

  	_isTapValid: function () {
  		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
  	},

  	_simulateEvent: function (type, e) {
  		var simulatedEvent = new MouseEvent(type, {
  			bubbles: true,
  			cancelable: true,
  			view: window,
  			// detail: 1,
  			screenX: e.screenX,
  			screenY: e.screenY,
  			clientX: e.clientX,
  			clientY: e.clientY,
  			// button: 2,
  			// buttons: 2
  		});

  		simulatedEvent._simulated = true;

  		e.target.dispatchEvent(simulatedEvent);
  	}
  });

  // @section Handlers
  // @property tapHold: Handler
  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).
  Map.addInitHook('addHandler', 'tapHold', TapHold);

  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
  	// @section Touch interaction options
  	// @option touchZoom: Boolean|String = *
  	// Whether the map can be zoomed by touch-dragging with two fingers. If
  	// passed `'center'`, it will zoom to the center of the view regardless of
  	// where the touch events (fingers) were. Enabled for touch-capable web
  	// browsers.
  	touchZoom: Browser.touch,

  	// @option bounceAtZoomLimits: Boolean = true
  	// Set it to false if you don't want the map to zoom beyond min/max zoom
  	// and then bounce back when pinch-zooming.
  	bounceAtZoomLimits: true
  });

  var TouchZoom = Handler.extend({
  	addHooks: function () {
  		addClass(this._map._container, 'leaflet-touch-zoom');
  		on(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	removeHooks: function () {
  		removeClass(this._map._container, 'leaflet-touch-zoom');
  		off(this._map._container, 'touchstart', this._onTouchStart, this);
  	},

  	_onTouchStart: function (e) {
  		var map = this._map;
  		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

  		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

  		this._centerPoint = map.getSize()._divideBy(2);
  		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
  		if (map.options.touchZoom !== 'center') {
  			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
  		}

  		this._startDist = p1.distanceTo(p2);
  		this._startZoom = map.getZoom();

  		this._moved = false;
  		this._zooming = true;

  		map._stop();

  		on(document, 'touchmove', this._onTouchMove, this);
  		on(document, 'touchend touchcancel', this._onTouchEnd, this);

  		preventDefault(e);
  	},

  	_onTouchMove: function (e) {
  		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

  		var map = this._map,
  		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
  		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
  		    scale = p1.distanceTo(p2) / this._startDist;

  		this._zoom = map.getScaleZoom(scale, this._startZoom);

  		if (!map.options.bounceAtZoomLimits && (
  			(this._zoom < map.getMinZoom() && scale < 1) ||
  			(this._zoom > map.getMaxZoom() && scale > 1))) {
  			this._zoom = map._limitZoom(this._zoom);
  		}

  		if (map.options.touchZoom === 'center') {
  			this._center = this._startLatLng;
  			if (scale === 1) { return; }
  		} else {
  			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
  			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
  			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
  			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
  		}

  		if (!this._moved) {
  			map._moveStart(true, false);
  			this._moved = true;
  		}

  		cancelAnimFrame(this._animRequest);

  		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false}, undefined);
  		this._animRequest = requestAnimFrame(moveFn, this, true);

  		preventDefault(e);
  	},

  	_onTouchEnd: function () {
  		if (!this._moved || !this._zooming) {
  			this._zooming = false;
  			return;
  		}

  		this._zooming = false;
  		cancelAnimFrame(this._animRequest);

  		off(document, 'touchmove', this._onTouchMove, this);
  		off(document, 'touchend touchcancel', this._onTouchEnd, this);

  		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
  		if (this._map.options.zoomAnimation) {
  			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
  		} else {
  			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
  		}
  	}
  });

  // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.
  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.TapHold = TapHold;
  Map.TouchZoom = TouchZoom;

  exports.Bounds = Bounds;
  exports.Browser = Browser;
  exports.CRS = CRS;
  exports.Canvas = Canvas;
  exports.Circle = Circle;
  exports.CircleMarker = CircleMarker;
  exports.Class = Class;
  exports.Control = Control;
  exports.DivIcon = DivIcon;
  exports.DivOverlay = DivOverlay;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.Draggable = Draggable;
  exports.Evented = Evented;
  exports.FeatureGroup = FeatureGroup;
  exports.GeoJSON = GeoJSON;
  exports.GridLayer = GridLayer;
  exports.Handler = Handler;
  exports.Icon = Icon;
  exports.ImageOverlay = ImageOverlay;
  exports.LatLng = LatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.LineUtil = LineUtil;
  exports.Map = Map;
  exports.Marker = Marker;
  exports.Mixin = Mixin;
  exports.Path = Path;
  exports.Point = Point;
  exports.PolyUtil = PolyUtil;
  exports.Polygon = Polygon;
  exports.Polyline = Polyline;
  exports.Popup = Popup;
  exports.PosAnimation = PosAnimation;
  exports.Projection = index;
  exports.Rectangle = Rectangle;
  exports.Renderer = Renderer;
  exports.SVG = SVG;
  exports.SVGOverlay = SVGOverlay;
  exports.TileLayer = TileLayer;
  exports.Tooltip = Tooltip;
  exports.Transformation = Transformation;
  exports.Util = Util;
  exports.VideoOverlay = VideoOverlay;
  exports.bind = bind;
  exports.bounds = toBounds;
  exports.canvas = canvas;
  exports.circle = circle;
  exports.circleMarker = circleMarker;
  exports.control = control;
  exports.divIcon = divIcon;
  exports.extend = extend;
  exports.featureGroup = featureGroup;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.gridLayer = gridLayer;
  exports.icon = icon;
  exports.imageOverlay = imageOverlay;
  exports.latLng = toLatLng;
  exports.latLngBounds = toLatLngBounds;
  exports.layerGroup = layerGroup;
  exports.map = createMap;
  exports.marker = marker;
  exports.point = toPoint;
  exports.polygon = polygon;
  exports.polyline = polyline;
  exports.popup = popup;
  exports.rectangle = rectangle;
  exports.setOptions = setOptions;
  exports.stamp = stamp;
  exports.svg = svg;
  exports.svgOverlay = svgOverlay;
  exports.tileLayer = tileLayer;
  exports.tooltip = tooltip;
  exports.transformation = toTransformation;
  exports.version = version;
  exports.videoOverlay = videoOverlay;

  var oldL = window.L;
  exports.noConflict = function() {
  	window.L = oldL;
  	return this;
  }
  // Always export us to window global (see #2364)
  window.L = exports;

}));


},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.nodeVersion = exports.isWorker = exports.isBrowser = exports.global = exports.document = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
const window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
const global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
const document_ = globals.document || {};
exports.document = document_;
const isBrowser = Boolean(typeof process !== 'object' || String(process) !== '[object process]' || true);
exports.isBrowser = isBrowser;
const isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/option-utils/merge-loader-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLoaderOptions = mergeLoaderOptions;
function mergeLoaderOptions(baseOptions, newOptions) {
  const options = {
    ...baseOptions
  };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === 'object') {
      options[key] = options[key] || {};
      Object.assign(options[key], newOptions[key]);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const DEFAULT_VERSION = 'latest';
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : DEFAULT_VERSION;
exports.VERSION = VERSION;
if (typeof "3.4.6" === 'undefined') {
  console.error('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.nodeVersion = exports.isWorker = exports.isMobile = exports.isBrowser = exports.global = exports.document = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
const window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
const global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
const document_ = globals.document || {};
exports.document = document_;
const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || true;
exports.isBrowser = isBrowser;
const isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
exports.isMobile = isMobile;
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;
},{"process":"node_modules/process/browser.js"}],"node_modules/@babel/runtime/helpers/esm/typeof.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _typeof;
function _typeof(obj) {
  "@babel/helpers - typeof";

  return exports.default = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
},{}],"node_modules/@babel/runtime/helpers/esm/toPrimitive.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toPrimitive;
var _typeof2 = _interopRequireDefault(require("./typeof.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toPrimitive(input, hint) {
  if ((0, _typeof2.default)(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if ((0, _typeof2.default)(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
},{"./typeof.js":"node_modules/@babel/runtime/helpers/esm/typeof.js"}],"node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toPropertyKey;
var _typeof2 = _interopRequireDefault(require("./typeof.js"));
var _toPrimitive = _interopRequireDefault(require("./toPrimitive.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toPropertyKey(arg) {
  var key = (0, _toPrimitive.default)(arg, "string");
  return (0, _typeof2.default)(key) === "symbol" ? key : String(key);
}
},{"./typeof.js":"node_modules/@babel/runtime/helpers/esm/typeof.js","./toPrimitive.js":"node_modules/@babel/runtime/helpers/esm/toPrimitive.js"}],"node_modules/@babel/runtime/helpers/esm/defineProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _defineProperty;
var _toPropertyKey = _interopRequireDefault(require("./toPropertyKey.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) {
  key = (0, _toPropertyKey.default)(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
},{"./toPropertyKey.js":"node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _assert = require("../env-utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WorkerJob {
  constructor(jobName, workerThread) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "workerThread", void 0);
    (0, _defineProperty2.default)(this, "isRunning", true);
    (0, _defineProperty2.default)(this, "result", void 0);
    (0, _defineProperty2.default)(this, "_resolve", () => {});
    (0, _defineProperty2.default)(this, "_reject", () => {});
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: 'loaders.gl',
      type,
      payload
    });
  }
  done(value) {
    (0, _assert.assert)(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error) {
    (0, _assert.assert)(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
}
exports.default = WorkerJob;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parentPort = exports.Worker = exports.NodeWorkerType = exports.NodeWorker = void 0;
class Worker {
  terminate() {}
}
exports.NodeWorkerType = exports.NodeWorker = exports.Worker = Worker;
const parentPort = null;
exports.parentPort = parentPort;
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadableWorkerURL = getLoadableWorkerURL;
var _assert = require("../env-utils/assert");
const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
  (0, _assert.assert)(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  (0, _assert.assert)(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransferList = getTransferList;
exports.getTransferListForWriter = getTransferListForWriter;
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : undefined;
  const transfersSet = transfers || new Set();
  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === 'object') {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === undefined ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
function getTransferListForWriter(object) {
  if (object === null) {
    return {};
  }
  const clone = Object.assign({}, object);
  Object.keys(clone).forEach(key => {
    if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
      clone[key] = getTransferListForWriter(object[key]);
    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {
      clone[key] = {};
    } else {
      clone[key] = object[key];
    }
  });
  return clone;
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _worker_threads = require("../node/worker_threads");
var _globals = require("../env-utils/globals");
var _assert = require("../env-utils/assert");
var _getLoadableWorkerUrl = require("../worker-utils/get-loadable-worker-url");
var _getTransferList = require("../worker-utils/get-transfer-list");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NOOP = () => {};
class WorkerThread {
  static isSupported() {
    return typeof Worker !== 'undefined' && _globals.isBrowser || typeof _worker_threads.NodeWorker !== 'undefined' && !_globals.isBrowser;
  }
  constructor(props) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "terminated", false);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "onMessage", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadableURL", '');
    const {
      name,
      source,
      url
    } = props;
    (0, _assert.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = error => console.log(error);
    this.worker = _globals.isBrowser ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data, transferList) {
    transferList = transferList || (0, _getTransferList.getTransferList)(data);
    this.worker.postMessage(data, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = 'Failed to load ';
    message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
    if (event.message) {
      message += "".concat(event.message, " in ");
    }
    if (event.lineno) {
      message += ":".concat(event.lineno, ":").concat(event.colno);
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = (0, _getLoadableWorkerUrl.getLoadableWorkerURL)({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });
    worker.onmessage = event => {
      if (!event.data) {
        this.onError(new Error('No data received'));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = error => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = event => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(':/') || this.url.startsWith('/');
      const url = absolute ? this.url : "./".concat(this.url);
      worker = new _worker_threads.NodeWorker(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new _worker_threads.NodeWorker(this.source, {
        eval: true
      });
    } else {
      throw new Error('no worker');
    }
    worker.on('message', data => {
      this.onMessage(data);
    });
    worker.on('error', error => {
      this.onError(error);
    });
    worker.on('exit', code => {});
    return worker;
  }
}
exports.default = WorkerThread;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node/worker_threads":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js","../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../worker-utils/get-loadable-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js","../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _globals = require("../env-utils/globals");
var _workerThread = _interopRequireDefault(require("./worker-thread"));
var _workerJob = _interopRequireDefault(require("./worker-job"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WorkerPool {
  static isSupported() {
    return _workerThread.default.isSupported();
  }
  constructor(props) {
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", () => {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    if (props.name !== undefined) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name) {
    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);
    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);
    const startPromise = new Promise(onStart => {
      this.jobQueue.push({
        name,
        onMessage,
        onError,
        onStart
      });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: 'Starting job',
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new _workerJob.default(queuedJob.name, workerThread);
      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = error => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new _workerThread.default({
        name,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
exports.default = WorkerPool;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","./worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","./worker-job":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _workerPool = _interopRequireDefault(require("./worker-pool"));
var _workerThread = _interopRequireDefault(require("./worker-thread"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {}
};
class WorkerFarm {
  static isSupported() {
    return _workerThread.default.isSupported();
  }
  static getWorkerFarm() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  constructor(props) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "workerPools", new Map());
    this.props = {
      ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = new Map();
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = new Map();
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new _workerPool.default({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
exports.default = WorkerFarm;
(0, _defineProperty2.default)(WorkerFarm, "_workerFarm", void 0);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./worker-pool":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","./worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getTransferList = require("../worker-utils/get-transfer-list");
function getParentPort() {
  let parentPort;
  try {
    eval('globalThis.parentPort = require(\'worker_threads\').parentPort');
    parentPort = globalThis.parentPort;
  } catch {}
  return parentPort;
}
const onMessageWrapperMap = new Map();
class WorkerBody {
  static inWorkerThread() {
    return typeof self !== 'undefined' || Boolean(getParentPort());
  }
  static set onmessage(onMessage) {
    function handleMessage(message) {
      const parentPort = getParentPort();
      const {
        type,
        payload
      } = parentPort ? message : message.data;
      onMessage(type, payload);
    }
    const parentPort = getParentPort();
    if (parentPort) {
      parentPort.on('message', handleMessage);
      parentPort.on('exit', () => console.debug('Node worker closing'));
    } else {
      globalThis.onmessage = handleMessage;
    }
  }
  static addEventListener(onMessage) {
    let onMessageWrapper = onMessageWrapperMap.get(onMessage);
    if (!onMessageWrapper) {
      onMessageWrapper = message => {
        if (!isKnownMessage(message)) {
          return;
        }
        const parentPort = getParentPort();
        const {
          type,
          payload
        } = parentPort ? message : message.data;
        onMessage(type, payload);
      };
    }
    const parentPort = getParentPort();
    if (parentPort) {
      console.error('not implemented');
    } else {
      globalThis.addEventListener('message', onMessageWrapper);
    }
  }
  static removeEventListener(onMessage) {
    const onMessageWrapper = onMessageWrapperMap.get(onMessage);
    onMessageWrapperMap.delete(onMessage);
    const parentPort = getParentPort();
    if (parentPort) {
      console.error('not implemented');
    } else {
      globalThis.removeEventListener('message', onMessageWrapper);
    }
  }
  static postMessage(type, payload) {
    const data = {
      source: 'loaders.gl',
      type,
      payload
    };
    const transferList = (0, _getTransferList.getTransferList)(payload);
    const parentPort = getParentPort();
    if (parentPort) {
      parentPort.postMessage(data, transferList);
    } else {
      globalThis.postMessage(data, transferList);
    }
  }
}
exports.default = WorkerBody;
function isKnownMessage(message) {
  const {
    type,
    data
  } = message;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}
},{"../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorkerName = getWorkerName;
exports.getWorkerURL = getWorkerURL;
var _assert = require("../env-utils/assert");
var _version = require("../env-utils/version");
const NPM_TAG = 'latest';
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : NPM_TAG;
function getWorkerName(worker) {
  const warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;
  if (!url && worker.id === 'compression') {
    url = options.workerUrl;
  }
  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }
  if (!url) {
    let version = worker.version;
    if (version === 'latest') {
      version = NPM_TAG;
    }
    const versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }
  (0, _assert.assert)(url);
  return url;
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canProcessOnWorker = canProcessOnWorker;
exports.processOnWorker = processOnWorker;
var _workerFarm = _interopRequireDefault(require("../worker-farm/worker-farm"));
var _getWorkerUrl = require("./get-worker-url");
var _getTransferList = require("../worker-utils/get-transfer-list");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function canProcessOnWorker(worker, options) {
  if (!_workerFarm.default.isSupported()) {
    return false;
  }
  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function processOnWorker(worker, data) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const name = (0, _getWorkerUrl.getWorkerName)(worker);
  const workerFarm = _workerFarm.default.getWorkerFarm(options);
  const {
    source
  } = options;
  const workerPoolProps = {
    name,
    source
  };
  if (!source) {
    workerPoolProps.url = (0, _getWorkerUrl.getWorkerURL)(worker, options);
  }
  const workerPool = workerFarm.getWorkerPool(workerPoolProps);
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(jobName, onMessage.bind(null, context));
  const transferableOptions = (0, _getTransferList.getTransferListForWriter)(options);
  job.postMessage('process', {
    input: data,
    options: transferableOptions
  });
  const result = await job.result;
  return result.result;
}
async function onMessage(context, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;
    case 'error':
      job.error(new Error(payload.error));
      break;
    case 'process':
      const {
        id,
        input,
        options
      } = payload;
      try {
        if (!context.process) {
          job.postMessage('error', {
            id,
            error: 'Worker not set up to process on main thread'
          });
          return;
        }
        const result = await context.process(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("process-on-worker: unknown message ".concat(type));
  }
}
},{"../worker-farm/worker-farm":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","./get-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js","../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let _Symbol$asyncIterator;
_Symbol$asyncIterator = Symbol.asyncIterator;
class AsyncQueue {
  constructor() {
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }
  [_Symbol$asyncIterator]() {
    return this;
  }
  push(value) {
    return this.enqueue(value);
  }
  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }
    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }
      const settler = this._settlers.shift();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.push(value);
    }
  }
  close() {
    while (this._settlers.length > 0) {
      const settler = this._settlers.shift();
      settler.resolve({
        done: true
      });
    }
    this._closed = true;
  }
  next() {
    if (this._values.length > 0) {
      const value = this._values.shift();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({
        done: false,
        value
      });
    }
    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }
      return Promise.resolve({
        done: true,
        value: undefined
      });
    }
    return new Promise((resolve, reject) => {
      this._settlers.push({
        resolve,
        reject
      });
    });
  }
}
exports.default = AsyncQueue;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;
var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));
var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let requestId = 0;
let inputBatches;
let options;
function createWorker(process, processInBatches) {
  if (!_workerBody.default.inWorkerThread()) {
    return;
  }
  const context = {
    process: processOnMainThread
  };
  _workerBody.default.onmessage = async (type, payload) => {
    try {
      switch (type) {
        case 'process':
          if (!process) {
            throw new Error('Worker does not support atomic processing');
          }
          const result = await process(payload.input, payload.options || {}, context);
          _workerBody.default.postMessage('done', {
            result
          });
          break;
        case 'process-in-batches':
          if (!processInBatches) {
            throw new Error('Worker does not support batched processing');
          }
          inputBatches = new _asyncQueue.default();
          options = payload.options || {};
          const resultIterator = processInBatches(inputBatches, options, context);
          for await (const batch of resultIterator) {
            _workerBody.default.postMessage('output-batch', {
              result: batch
            });
          }
          _workerBody.default.postMessage('done', {});
          break;
        case 'input-batch':
          inputBatches.push(payload.input);
          break;
        case 'input-done':
          inputBatches.close();
          break;
        default:
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : '';
      _workerBody.default.postMessage('error', {
        error: message
      });
    }
  };
}
function processOnMainThread(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise((resolve, reject) => {
    const id = requestId++;
    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }
      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);
          resolve(payload.result);
          break;
        case 'error':
          _workerBody.default.removeEventListener(onMessage);
          reject(payload.error);
          break;
        default:
      }
    };
    _workerBody.default.addEventListener(onMessage);
    const payload = {
      id,
      input: arrayBuffer,
      options
    };
    _workerBody.default.postMessage('process', payload);
  });
}
},{"../async-queue/async-queue":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js","../worker-farm/worker-body":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateWorkerVersion = validateWorkerVersion;
var _assert = require("../env-utils/assert");
var _version = require("../env-utils/version");
function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _version.VERSION;
  (0, _assert.assert)(worker, 'no worker provided');
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLibraryUrl = getLibraryUrl;
exports.loadLibrary = loadLibrary;
var _globals = require("../env-utils/globals");
var node = _interopRequireWildcard(require("../node/require-utils.node"));
var _assert = require("../env-utils/assert");
var _version = require("../env-utils/version");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const LATEST = 'latest';
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : LATEST;
const loadLibraryPromises = {};
async function loadLibrary(libraryUrl) {
  let moduleName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }
  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }
  if (!_globals.isBrowser) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }
  if (options.CDN) {
    (0, _assert.assert)(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }
  if (_globals.isWorker) {
    return "../src/libs/".concat(library);
  }
  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }
  if (!_globals.isBrowser) {
    try {
      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));
    } catch {
      return null;
    }
  }
  if (_globals.isWorker) {
    return importScripts(libraryUrl);
  }
  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!_globals.isBrowser) {
    return node.requireFromString && node.requireFromString(scriptSource, id);
  }
  if (_globals.isWorker) {
    eval.call(_globals.global, scriptSource);
    return null;
  }
  const script = document.createElement('script');
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}
},{"../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../node/require-utils.node":"node_modules/parcel-bundler/src/builtins/_empty.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function () {
    return _asyncQueue.default;
  }
});
Object.defineProperty(exports, "ChildProcessProxy", {
  enumerable: true,
  get: function () {
    return _childProcessProxy.default;
  }
});
exports.NullWorker = void 0;
Object.defineProperty(exports, "WorkerBody", {
  enumerable: true,
  get: function () {
    return _workerBody.default;
  }
});
Object.defineProperty(exports, "WorkerFarm", {
  enumerable: true,
  get: function () {
    return _workerFarm.default;
  }
});
Object.defineProperty(exports, "WorkerJob", {
  enumerable: true,
  get: function () {
    return _workerJob.default;
  }
});
Object.defineProperty(exports, "WorkerPool", {
  enumerable: true,
  get: function () {
    return _workerPool.default;
  }
});
Object.defineProperty(exports, "WorkerThread", {
  enumerable: true,
  get: function () {
    return _workerThread.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "canProcessOnWorker", {
  enumerable: true,
  get: function () {
    return _processOnWorker.canProcessOnWorker;
  }
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function () {
    return _createWorker.createWorker;
  }
});
Object.defineProperty(exports, "getLibraryUrl", {
  enumerable: true,
  get: function () {
    return _libraryUtils.getLibraryUrl;
  }
});
Object.defineProperty(exports, "getTransferList", {
  enumerable: true,
  get: function () {
    return _getTransferList.getTransferList;
  }
});
Object.defineProperty(exports, "getTransferListForWriter", {
  enumerable: true,
  get: function () {
    return _getTransferList.getTransferListForWriter;
  }
});
Object.defineProperty(exports, "getWorkerURL", {
  enumerable: true,
  get: function () {
    return _getWorkerUrl.getWorkerURL;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "loadLibrary", {
  enumerable: true,
  get: function () {
    return _libraryUtils.loadLibrary;
  }
});
Object.defineProperty(exports, "processOnWorker", {
  enumerable: true,
  get: function () {
    return _processOnWorker.processOnWorker;
  }
});
Object.defineProperty(exports, "validateWorkerVersion", {
  enumerable: true,
  get: function () {
    return _validateWorkerVersion.validateWorkerVersion;
  }
});
var _version = require("./lib/env-utils/version");
var _assert = require("./lib/env-utils/assert");
var _globals = require("./lib/env-utils/globals");
var _workerJob = _interopRequireDefault(require("./lib/worker-farm/worker-job"));
var _workerThread = _interopRequireDefault(require("./lib/worker-farm/worker-thread"));
var _workerFarm = _interopRequireDefault(require("./lib/worker-farm/worker-farm"));
var _workerPool = _interopRequireDefault(require("./lib/worker-farm/worker-pool"));
var _workerBody = _interopRequireDefault(require("./lib/worker-farm/worker-body"));
var _processOnWorker = require("./lib/worker-api/process-on-worker");
var _createWorker = require("./lib/worker-api/create-worker");
var _getWorkerUrl = require("./lib/worker-api/get-worker-url");
var _validateWorkerVersion = require("./lib/worker-api/validate-worker-version");
var _getTransferList = require("./lib/worker-utils/get-transfer-list");
var _libraryUtils = require("./lib/library-utils/library-utils");
var _asyncQueue = _interopRequireDefault(require("./lib/async-queue/async-queue"));
var _childProcessProxy = _interopRequireDefault(require("./lib/process-utils/child-process-proxy"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _version.VERSION,
  options: {
    null: {}
  }
};
exports.NullWorker = NullWorker;
},{"./lib/env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js","./lib/env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","./lib/env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","./lib/worker-farm/worker-job":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js","./lib/worker-farm/worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","./lib/worker-farm/worker-farm":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","./lib/worker-farm/worker-pool":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","./lib/worker-farm/worker-body":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js","./lib/worker-api/process-on-worker":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js","./lib/worker-api/create-worker":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js","./lib/worker-api/get-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js","./lib/worker-api/validate-worker-version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js","./lib/worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js","./lib/library-utils/library-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js","./lib/async-queue/async-queue":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js","./lib/process-utils/child-process-proxy":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoaderWorker = createLoaderWorker;
var _workerUtils = require("@loaders.gl/worker-utils");
let requestId = 0;
function createLoaderWorker(loader) {
  if (!_workerUtils.WorkerBody.inWorkerThread()) {
    return;
  }
  _workerUtils.WorkerBody.onmessage = async (type, payload) => {
    switch (type) {
      case 'process':
        try {
          const {
            input,
            options = {},
            context = {}
          } = payload;
          const result = await parseData({
            loader,
            arrayBuffer: input,
            options,
            context: {
              ...context,
              parse: parseOnMainThread
            }
          });
          _workerUtils.WorkerBody.postMessage('done', {
            result
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : '';
          _workerUtils.WorkerBody.postMessage('error', {
            error: message
          });
        }
        break;
      default:
    }
  };
}
function parseOnMainThread(arrayBuffer, options) {
  return new Promise((resolve, reject) => {
    const id = requestId++;
    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }
      switch (type) {
        case 'done':
          _workerUtils.WorkerBody.removeEventListener(onMessage);
          resolve(payload.result);
          break;
        case 'error':
          _workerUtils.WorkerBody.removeEventListener(onMessage);
          reject(payload.error);
          break;
        default:
      }
    };
    _workerUtils.WorkerBody.addEventListener(onMessage);
    const payload = {
      id,
      input: arrayBuffer,
      options
    };
    _workerUtils.WorkerBody.postMessage('process', payload);
  });
}
async function parseData(_ref) {
  let {
    loader,
    arrayBuffer,
    options,
    context
  } = _ref;
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arrayBuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arrayBuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error("Could not load data with ".concat(loader.name, " loader"));
  }
  options = {
    ...options,
    modules: loader && loader.options && loader.options.modules || {},
    worker: false
  };
  return await parser(data, {
    ...options
  }, context, loader);
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canParseWithWorker = canParseWithWorker;
exports.parseWithWorker = parseWithWorker;
var _workerUtils = require("@loaders.gl/worker-utils");
function canParseWithWorker(loader, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }
  if (!_workerUtils.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = (0, _workerUtils.getWorkerURL)(loader, options);
  const workerFarm = _workerUtils.WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));
  job.postMessage('process', {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;
    case 'error':
      job.error(new Error(payload.error));
      break;
    case 'process':
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canEncodeWithWorker = canEncodeWithWorker;
var _workerUtils = require("@loaders.gl/worker-utils");
var _globals = require("../env-utils/globals");
function canEncodeWithWorker(writer, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }
  if (!_globals.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return writer.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","../env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstCharacters = getFirstCharacters;
exports.getMagicString = getMagicString;
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseJSON = parseJSON;
var _getFirstCharacters = require("../binary-utils/get-first-characters");
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat((0, _getFirstCharacters.getFirstCharacters)(string), "\""));
  }
}
},{"../binary-utils/get-first-characters":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareArrayBuffers = compareArrayBuffers;
exports.concatenateArrayBuffers = concatenateArrayBuffers;
exports.concatenateTypedArrays = concatenateTypedArrays;
exports.sliceArrayBuffer = sliceArrayBuffer;
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }
  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;
exports.padToNBytes = padToNBytes;
var _assert = require("../env-utils/assert");
function padToNBytes(byteLength, padding) {
  (0, _assert.assert)(byteLength >= 0);
  (0, _assert.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  let byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
},{"../env-utils/assert":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyBinaryToDataView = copyBinaryToDataView;
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;
exports.copyStringToDataView = copyStringToDataView;
exports.padStringToByteAlignment = padStringToByteAlignment;
var _memoryCopyUtils = require("./memory-copy-utils");
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}
function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}
function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }
  return byteOffset + byteLength;
}
function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = (0, _memoryCopyUtils.padToNBytes)(sourceBuffer.byteLength, padding);
  const padLength = paddedLength - sourceBuffer.byteLength;
  if (dataView) {
    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);
    for (let i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}
function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  const stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}
},{"./memory-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeLineIterator = makeLineIterator;
exports.makeNumberedLineIterator = makeNumberedLineIterator;
exports.makeTextDecoderIterator = makeTextDecoderIterator;
exports.makeTextEncoderIterator = makeTextEncoderIterator;
function makeTextDecoderIterator(arrayBufferIterator) {
  try {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return async function* () {
      const textDecoder = new TextDecoder(undefined, options);
      for await (const arrayBuffer of arrayBufferIterator) {
        yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
          stream: true
        });
      }
    }();
  } catch (e) {
    return Promise.reject(e);
  }
}
async function* makeTextEncoderIterator(textIterator) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}
async function* makeLineIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }
  if (previous.length > 0) {
    yield previous;
  }
}
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {
      counter,
      line
    };
    counter++;
  }
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatenateArrayBuffersAsync = concatenateArrayBuffersAsync;
exports.concatenateStringsAsync = concatenateStringsAsync;
exports.forEach = forEach;
var _arrayBufferUtils = require("../binary-utils/array-buffer-utils");
async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return (0, _arrayBufferUtils.concatenateArrayBuffers)(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
  const strings = [];
  for await (const chunk of asyncIterator) {
    strings.push(chunk);
  }
  return strings.join('');
}
},{"../binary-utils/array-buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stat {
  constructor(name, type) {
    this.name = void 0;
    this.type = void 0;
    this.sampleSize = 1;
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    this.name = name;
    this.type = type;
    this.reset();
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  incrementCount() {
    this.addCount(1);
    return this;
  }
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  timeStart() {
    this._startTime = (0, _hiResTimestamp.default)();
    this._timerPending = true;
    return this;
  }
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime((0, _hiResTimestamp.default)() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1000) : 0;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
}
exports.default = Stat;
},{"../utils/hi-res-timestamp.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _stat = _interopRequireDefault(require("./stat.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stats {
  constructor(options) {
    this.id = void 0;
    this.stats = {};
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  get(name) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
    return this._getOrCreate({
      name,
      type
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const stat of Object.values(this.stats)) {
      stat.reset();
    }
    return this;
  }
  forEach(fn) {
    for (const stat of Object.values(this.stats)) {
      fn(stat);
    }
  }
  getTable() {
    const table = {};
    this.forEach(stat => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    stats.forEach(stat => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    const {
      name,
      type
    } = stat;
    let result = this.stats[name];
    if (!result) {
      if (stat instanceof _stat.default) {
        result = stat;
      } else {
        result = new _stat.default(name, type);
      }
      this.stats[name] = result;
    }
    return result;
  }
}
exports.default = Stats;
},{"./stat.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _stat.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.default;
  }
});
var _stats = _interopRequireDefault(require("./lib/stats.js"));
var _stat = _interopRequireDefault(require("./lib/stat.js"));
var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/stats.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stats.js","./lib/stat.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js","./utils/hi-res-timestamp.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _stats = require("@probe.gl/stats");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
const DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};
class RequestScheduler {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "activeRequestCount", 0);
    (0, _defineProperty2.default)(this, "requestQueue", []);
    (0, _defineProperty2.default)(this, "requestMap", new Map());
    (0, _defineProperty2.default)(this, "deferredUpdate", null);
    this.props = {
      ...DEFAULT_PROPS,
      ...props
    };
    this.stats = new _stats.Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }
  scheduleRequest(handle) {
    let getPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => 0;
    if (!this.props.throttleRequests) {
      return Promise.resolve({
        done: () => {}
      });
    }
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }
    const request = {
      handle,
      priority: 0,
      getPriority
    };
    const promise = new Promise(resolve => {
      request.resolve = resolve;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }
  _issueRequest(request) {
    const {
      handle,
      resolve
    } = request;
    let isDone = false;
    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        this._issueNewRequests();
      }
    };
    this.activeRequestCount++;
    return resolve ? resolve({
      done
    }) : Promise.resolve({
      done
    });
  }
  _issueNewRequests() {
    if (!this.deferredUpdate) {
      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }
  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (freeSlots === 0) {
      return;
    }
    this._updateAllRequests();
    for (let i = 0; i < freeSlots; ++i) {
      const request = this.requestQueue.shift();
      if (request) {
        this._issueRequest(request);
      }
    }
  }
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }
    requestQueue.sort((a, b) => a.priority - b.priority);
  }
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
}
exports.default = RequestScheduler;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/stats":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAliases = addAliases;
exports.getPathPrefix = getPathPrefix;
exports.resolvePath = resolvePath;
exports.setPathPrefix = setPathPrefix;
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }
  return filename;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckJSONLoader = exports.JSONLoader = void 0;
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : 'latest';
const JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync,
  parse: async arrayBuffer => parseTextSync(new TextDecoder().decode(arrayBuffer)),
  options: {}
};
exports.JSONLoader = JSONLoader;
function parseTextSync(text) {
  return JSON.parse(text);
}
const _typecheckJSONLoader = JSONLoader;
exports._typecheckJSONLoader = _typecheckJSONLoader;
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;
exports.toBuffer = toBuffer;
function toArrayBuffer(buffer) {
  return buffer;
}
function toBuffer(binaryData) {
  throw new Error('Buffer not supported in browser');
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBuffer = isBuffer;
exports.toArrayBuffer = toArrayBuffer;
exports.toBuffer = toBuffer;
var node = _interopRequireWildcard(require("../node/buffer"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function isBuffer(value) {
  return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
  return node.toBuffer ? node.toBuffer(data) : data;
}
function toArrayBuffer(data) {
  if (isBuffer(data)) {
    return node.toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error('toArrayBuffer');
}
},{"../node/buffer":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify1 = promisify1;
exports.promisify2 = promisify2;
exports.promisify3 = promisify3;
function promisify1(fn) {
  return args => new Promise((resolve, reject) => fn(args, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
}
function promisify2(fn) {
  return (arg1, arg2) => new Promise((resolve, reject) => fn(arg1, arg2, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
}
function promisify3(fn) {
  return (arg1, arg2, arg3) => new Promise((resolve, reject) => fn(arg1, arg2, arg3, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCWD = getCWD;
function getCWD() {
  var _window$location;
  if (typeof process !== 'undefined' && typeof process.cwd !== 'undefined') {
    return process.cwd();
  }
  const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
  return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf('/') + 1)) || '';
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
exports.filename = filename;
exports.join = join;
exports.resolve = resolve;
var _getCwd = require("./get-cwd");
function filename(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = '/';
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }
    return part;
  });
  return parts.join(separator);
}
function resolve() {
  const paths = [];
  for (let _i = 0; _i < arguments.length; _i++) {
    paths[_i] = _i < 0 || arguments.length <= _i ? undefined : arguments[_i];
  }
  let resolvedPath = '';
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === undefined) {
        cwd = (0, _getCwd.getCWD)();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = "".concat(path, "/").concat(resolvedPath);
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return "/".concat(resolvedPath);
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return '.';
}
const SLASH = 47;
const DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = '';
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (; j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? '' : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += '/..';
          } else {
            res = '..';
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += "/".concat(slice);
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
},{"./get-cwd":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js"}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._readToArrayBuffer = _readToArrayBuffer;
exports.writeFileSync = exports.writeFile = exports.stat = exports.readdir = exports.readFileSync = exports.readFile = exports.read = exports.open = exports.isSupported = exports.fstat = exports.createWriteStream = exports.close = void 0;
var _fs = _interopRequireDefault(require("fs"));
var _buffer = require("./buffer");
var _promisify = require("./promisify");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let readdir;
exports.readdir = readdir;
let stat;
exports.stat = stat;
let readFile;
exports.readFile = readFile;
let readFileSync;
exports.readFileSync = readFileSync;
let writeFile;
exports.writeFile = writeFile;
let writeFileSync;
exports.writeFileSync = writeFileSync;
let open;
exports.open = open;
let close;
exports.close = close;
let read;
exports.read = read;
let fstat;
exports.fstat = fstat;
let createWriteStream;
exports.createWriteStream = createWriteStream;
let isSupported = Boolean(_fs.default);
exports.isSupported = isSupported;
try {
  exports.readdir = readdir = (0, _promisify.promisify2)(_fs.default.readdir);
  exports.stat = stat = (0, _promisify.promisify2)(_fs.default.stat);
  exports.readFile = readFile = _fs.default.readFile;
  exports.readFileSync = readFileSync = _fs.default.readFileSync;
  exports.writeFile = writeFile = (0, _promisify.promisify3)(_fs.default.writeFile);
  exports.writeFileSync = writeFileSync = _fs.default.writeFileSync;
  exports.open = open = _fs.default.open;
  exports.close = close = fd => new Promise((resolve, reject) => _fs.default.close(fd, err => err ? reject(err) : resolve()));
  exports.read = read = _fs.default.read;
  exports.fstat = fstat = _fs.default.fstat;
  exports.createWriteStream = createWriteStream = _fs.default.createWriteStream;
  exports.isSupported = isSupported = Boolean(_fs.default);
} catch {}
async function _readToArrayBuffer(fd, start, length) {
  const buffer = Buffer.alloc(length);
  const {
    bytesRead
  } = await read(fd, buffer, 0, length, start);
  if (bytesRead !== length) {
    throw new Error('fs.read failed');
  }
  return (0, _buffer.toArrayBuffer)(buffer);
}
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js","./buffer":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js","./promisify":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = exports.Transform = void 0;
var _stream = _interopRequireDefault(require("stream"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let Transform;
exports.Transform = Transform;
const isSupported = Boolean(_stream.default);
exports.isSupported = isSupported;
try {
  exports.Transform = Transform = _stream.default.Transform;
} catch {}
},{"stream":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/readable-file.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeReadableFile = makeReadableFile;
function makeReadableFile(data) {
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    return {
      read: async (start, length) => Buffer.from(data, start, length),
      close: async () => {},
      size: arrayBuffer.byteLength
    };
  }
  const blob = data;
  return {
    read: async (start, length) => {
      const arrayBuffer = await blob.slice(start, start + length).arrayBuffer();
      return Buffer.from(arrayBuffer);
    },
    close: async () => {},
    size: blob.size
  };
}
},{"buffer":"node_modules/buffer/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeWritableFile = makeWritableFile;
var _globals = require("../env-utils/globals");
var fs = _interopRequireWildcard(require("../node/fs"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function makeWritableFile(pathOrStream, options) {
  if (_globals.isBrowser) {
    return {
      write: async () => {},
      close: async () => {}
    };
  }
  const outputStream = typeof pathOrStream === 'string' ? fs.createWriteStream(pathOrStream, options) : pathOrStream;
  return {
    write: async buffer => new Promise((resolve, reject) => {
      outputStream.write(buffer, err => err ? reject(err) : resolve());
    }),
    close: () => new Promise((resolve, reject) => {
      outputStream.close(err => err ? reject(err) : resolve());
    })
  };
}
},{"../env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js","../node/fs":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var fs = _interopRequireWildcard(require("../node/fs"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class NodeFileSystem {
  constructor(options) {
    this.fetch = options._fetch;
  }
  async readdir() {
    let dirname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
    let options = arguments.length > 1 ? arguments[1] : undefined;
    return await fs.readdir(dirname, options);
  }
  async stat(path, options) {
    const info = await fs.stat(path, options);
    return {
      size: Number(info.size),
      isDirectory: () => false,
      info
    };
  }
  async fetch(path, options) {
    const fallbackFetch = options.fetch || this.fetch;
    return fallbackFetch(path, options);
  }
  async open(path, flags, mode) {
    return await fs.open(path, flags);
  }
  async close(fd) {
    return await fs.close(fd);
  }
  async fstat(fd) {
    const info = await fs.fstat(fd);
    return info;
  }
  async read(fd, _ref) {
    let {
      buffer = null,
      offset = 0,
      length = buffer.byteLength,
      position = null
    } = _ref;
    let totalBytesRead = 0;
    while (totalBytesRead < length) {
      const {
        bytesRead
      } = await fs.read(fd, buffer, offset + totalBytesRead, length - totalBytesRead, position + totalBytesRead);
      totalBytesRead += bytesRead;
    }
    return {
      bytesRead: totalBytesRead,
      buffer
    };
  }
}
exports.default = NodeFileSystem;
},{"../node/fs":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function () {
    return _jsonLoader.JSONLoader;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function () {
    return _requestScheduler.default;
  }
});
Object.defineProperty(exports, "_NodeFileSystem", {
  enumerable: true,
  get: function () {
    return _nodeFilesystem.default;
  }
});
Object.defineProperty(exports, "_addAliases", {
  enumerable: true,
  get: function () {
    return _fileAliases.addAliases;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "canEncodeWithWorker", {
  enumerable: true,
  get: function () {
    return _encodeWithWorker.canEncodeWithWorker;
  }
});
Object.defineProperty(exports, "canParseWithWorker", {
  enumerable: true,
  get: function () {
    return _parseWithWorker.canParseWithWorker;
  }
});
Object.defineProperty(exports, "compareArrayBuffers", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.compareArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffers", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.concatenateArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function () {
    return _asyncIteration.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "concatenateTypedArrays", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.concatenateTypedArrays;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "createLoaderWorker", {
  enumerable: true,
  get: function () {
    return _createLoaderWorker.createLoaderWorker;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function () {
    return _asyncIteration.forEach;
  }
});
exports.fs = void 0;
Object.defineProperty(exports, "getFirstCharacters", {
  enumerable: true,
  get: function () {
    return _getFirstCharacters.getFirstCharacters;
  }
});
Object.defineProperty(exports, "getMagicString", {
  enumerable: true,
  get: function () {
    return _getFirstCharacters.getMagicString;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function () {
    return _fileAliases.getPathPrefix;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isBuffer", {
  enumerable: true,
  get: function () {
    return _memoryConversionUtils.isBuffer;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeReadableFile", {
  enumerable: true,
  get: function () {
    return _readableFile.makeReadableFile;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeWritableFile", {
  enumerable: true,
  get: function () {
    return _writableFile.makeWritableFile;
  }
});
Object.defineProperty(exports, "mergeLoaderOptions", {
  enumerable: true,
  get: function () {
    return _mergeLoaderOptions.mergeLoaderOptions;
  }
});
Object.defineProperty(exports, "nodeVersion", {
  enumerable: true,
  get: function () {
    return _globals.nodeVersion;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "padToNBytes", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.padToNBytes;
  }
});
Object.defineProperty(exports, "parseJSON", {
  enumerable: true,
  get: function () {
    return _parseJson.parseJSON;
  }
});
Object.defineProperty(exports, "parseWithWorker", {
  enumerable: true,
  get: function () {
    return _parseWithWorker.parseWithWorker;
  }
});
exports.path = void 0;
Object.defineProperty(exports, "promisify1", {
  enumerable: true,
  get: function () {
    return _promisify.promisify1;
  }
});
Object.defineProperty(exports, "promisify2", {
  enumerable: true,
  get: function () {
    return _promisify.promisify2;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function () {
    return _fileAliases.resolvePath;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _fileAliases.setPathPrefix;
  }
});
Object.defineProperty(exports, "sliceArrayBuffer", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.sliceArrayBuffer;
  }
});
exports.stream = void 0;
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function () {
    return _memoryConversionUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "toBuffer", {
  enumerable: true,
  get: function () {
    return _memoryConversionUtils.toBuffer;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
var _assert = require("./lib/env-utils/assert");
var _globals = require("./lib/env-utils/globals");
var _mergeLoaderOptions = require("./lib/option-utils/merge-loader-options");
var _createLoaderWorker = require("./lib/worker-loader-utils/create-loader-worker");
var _parseWithWorker = require("./lib/worker-loader-utils/parse-with-worker");
var _encodeWithWorker = require("./lib/worker-loader-utils/encode-with-worker");
var _parseJson = require("./lib/parser-utils/parse-json");
var _arrayBufferUtils = require("./lib/binary-utils/array-buffer-utils");
var _memoryCopyUtils = require("./lib/binary-utils/memory-copy-utils");
var _dataviewCopyUtils = require("./lib/binary-utils/dataview-copy-utils");
var _getFirstCharacters = require("./lib/binary-utils/get-first-characters");
var _textIterators = require("./lib/iterators/text-iterators");
var _asyncIteration = require("./lib/iterators/async-iteration");
var _requestScheduler = _interopRequireDefault(require("./lib/request-utils/request-scheduler"));
var _fileAliases = require("./lib/path-utils/file-aliases");
var _jsonLoader = require("./json-loader");
var _memoryConversionUtils = require("./lib/binary-utils/memory-conversion-utils");
var _promisify = require("./lib/node/promisify");
var path = _interopRequireWildcard(require("./lib/path-utils/path"));
exports.path = path;
var fs = _interopRequireWildcard(require("./lib/node/fs"));
exports.fs = fs;
var stream = _interopRequireWildcard(require("./lib/node/stream"));
exports.stream = stream;
var _readableFile = require("./lib/filesystems/readable-file");
var _writableFile = require("./lib/filesystems/writable-file");
var _nodeFilesystem = _interopRequireDefault(require("./lib/filesystems/node-filesystem"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/env-utils/assert":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js","./lib/env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js","./lib/option-utils/merge-loader-options":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/option-utils/merge-loader-options.js","./lib/worker-loader-utils/create-loader-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js","./lib/worker-loader-utils/parse-with-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js","./lib/worker-loader-utils/encode-with-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js","./lib/parser-utils/parse-json":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js","./lib/binary-utils/array-buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js","./lib/binary-utils/memory-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js","./lib/binary-utils/dataview-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js","./lib/binary-utils/get-first-characters":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js","./lib/iterators/text-iterators":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js","./lib/iterators/async-iteration":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js","./lib/request-utils/request-scheduler":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js","./lib/path-utils/file-aliases":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js","./json-loader":"node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js","./lib/binary-utils/memory-conversion-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js","./lib/node/promisify":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js","./lib/path-utils/path":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js","./lib/node/fs":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js","./lib/node/stream":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js","./lib/filesystems/readable-file":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/readable-file.js","./lib/filesystems/writable-file":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js","./lib/filesystems/node-filesystem":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js"}],"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isWritableNodeStream = exports.isWritableDOMStream = exports.isResponse = exports.isReadableStream = exports.isReadableNodeStream = exports.isReadableDOMStream = exports.isPureObject = exports.isPromise = exports.isObject = exports.isIterator = exports.isIterable = exports.isFile = exports.isBuffer = exports.isBlob = exports.isAsyncIterable = void 0;
const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';
exports.isObject = isObject;
const isPureObject = x => isObject(x) && x.constructor === {}.constructor;
exports.isPureObject = isPureObject;
const isPromise = x => isObject(x) && isFunction(x.then);
exports.isPromise = isPromise;
const isIterable = x => x && typeof x[Symbol.iterator] === 'function';
exports.isIterable = isIterable;
const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';
exports.isAsyncIterable = isAsyncIterable;
const isIterator = x => x && isFunction(x.next);
exports.isIterator = isIterator;
const isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
exports.isResponse = isResponse;
const isFile = x => typeof File !== 'undefined' && x instanceof File;
exports.isFile = isFile;
const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;
exports.isBlob = isBlob;
const isBuffer = x => x && typeof x === 'object' && x.isBuffer;
exports.isBuffer = isBuffer;
const isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
exports.isWritableDOMStream = isWritableDOMStream;
const isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
exports.isReadableDOMStream = isReadableDOMStream;
const isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
exports.isWritableNodeStream = isWritableNodeStream;
const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
exports.isReadableNodeStream = isReadableNodeStream;
const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);
exports.isReadableStream = isReadableStream;
const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);
exports.isWritableStream = isWritableStream;
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIMEType = parseMIMEType;
exports.parseMIMETypeFromURL = parseMIMETypeFromURL;
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function parseMIMEType(mimeString) {
  const matches = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches) {
    return matches[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches = DATA_URL_PATTERN.exec(url);
  if (matches) {
    return matches[1];
  }
  return '';
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractQueryString = extractQueryString;
exports.stripQueryString = stripQueryString;
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches = url.match(QUERY_STRING_PATTERN);
  return matches && matches[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourceContentLength = getResourceContentLength;
exports.getResourceMIMEType = getResourceMIMEType;
exports.getResourceUrl = getResourceUrl;
var _isType = require("../../javascript-utils/is-type");
var _mimeTypeUtils = require("./mime-type-utils");
var _urlUtils = require("./url-utils");
function getResourceUrl(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const response = resource;
    return response.url;
  }
  if ((0, _isType.isBlob)(resource)) {
    const blob = resource;
    return blob.name || '';
  }
  if (typeof resource === 'string') {
    return resource;
  }
  return '';
}
function getResourceMIMEType(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get('content-type') || '';
    const noQueryUrl = (0, _urlUtils.stripQueryString)(response.url);
    return (0, _mimeTypeUtils.parseMIMEType)(contentTypeHeader) || (0, _mimeTypeUtils.parseMIMETypeFromURL)(noQueryUrl);
  }
  if ((0, _isType.isBlob)(resource)) {
    const blob = resource;
    return blob.type || '';
  }
  if (typeof resource === 'string') {
    return (0, _mimeTypeUtils.parseMIMETypeFromURL)(resource);
  }
  return '';
}
function getResourceContentLength(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const response = resource;
    return response.headers['content-length'] || -1;
  }
  if ((0, _isType.isBlob)(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === 'string') {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./mime-type-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js","./url-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkResponse = checkResponse;
exports.checkResponseSync = checkResponseSync;
exports.makeResponse = makeResponse;
var _isType = require("../../javascript-utils/is-type");
var _resourceUtils = require("./resource-utils");
async function makeResponse(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = (0, _resourceUtils.getResourceContentLength)(resource);
  if (contentLength >= 0) {
    headers['content-length'] = String(contentLength);
  }
  const url = (0, _resourceUtils.getResourceUrl)(resource);
  const type = (0, _resourceUtils.getResourceMIMEType)(resource);
  if (type) {
    headers['content-type'] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers['x-first-bytes'] = initialDataUrl;
  }
  if (typeof resource === 'string') {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, 'url', {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
function checkResponseSync(response) {
  if (!response.ok) {
    let message = "".concat(response.status, " ").concat(response.statusText);
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
  try {
    const contentType = response.headers.get('Content-Type');
    let text = response.statusText;
    if (contentType.includes('application/json')) {
      text += " ".concat(await response.text());
    }
    message += text;
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
  } catch (error) {}
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === 'string') {
    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = event => {
        var _event$target;
        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return "data:base64,".concat(base64);
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _responseUtils = require("../utils/response-utils");
async function fetchFile(url, options) {
  if (typeof url === 'string') {
    url = (0, _loaderUtils.resolvePath)(url);
    let fetchOptions = options;
    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {
      fetchOptions = options.fetch;
    }
    return await fetch(url, fetchOptions);
  }
  return await (0, _responseUtils.makeResponse)(url);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../utils/response-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readArrayBuffer = readArrayBuffer;
exports.readBlob = readBlob;
var _loaderUtils = require("@loaders.gl/loader-utils");
async function readArrayBuffer(file, start, length) {
  if (typeof file === 'number') {
    return await _loaderUtils.fs._readToArrayBuffer(file, start, length);
  }
  if (!(file instanceof Blob)) {
    file = new Blob([file]);
  }
  const slice = file.slice(start, start + length);
  return await readBlob(slice);
}
async function readBlob(blob) {
  return await new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.onload = event => {
      var _event$target;
      return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
    };
    fileReader.onerror = error => reject(error);
    fileReader.readAsArrayBuffer(blob);
  });
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
function readFileSync(url) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = (0, _loaderUtils.resolvePath)(url);
  if (!_loaderUtils.isBrowser) {
    const buffer = _loaderUtils.fs.readFileSync(url, options);
    return typeof buffer !== 'string' ? (0, _loaderUtils.toArrayBuffer)(buffer) : buffer;
  }
  if (!options.nothrow) {
    (0, _loaderUtils.assert)(false);
  }
  return null;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
async function writeFile(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);
  if (!_loaderUtils.isBrowser) {
    await _loaderUtils.fs.writeFile(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }
  (0, _loaderUtils.assert)(false);
}
function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);
  if (!_loaderUtils.isBrowser) {
    _loaderUtils.fs.writeFileSync(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }
  (0, _loaderUtils.assert)(false);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;
function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }
  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions['electron'])) {
    return true;
  }
  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }
  return false;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;
var _isElectron = _interopRequireDefault(require("./is-electron.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !true;
  return !isNode || (0, _isElectron.default)();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
},{"./is-electron.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js","process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.process = exports.navigator = exports.global = exports.document = exports.console = void 0;
const global_ = globalThis;
exports.global = global_;
const self_ = globalThis.self || globalThis.window || globalThis.global;
exports.self = self_;
const window_ = globalThis.window || globalThis.self || globalThis.global;
exports.window = window_;
const document_ = globalThis.document || {};
exports.document = document_;
const process_ = globalThis.process || {};
exports.process = process_;
const console_ = globalThis.console;
exports.console = console_;
const navigator_ = globalThis.navigator || {};
exports.navigator = navigator_;
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
exports.isBrowser = void 0;
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
var _isBrowser = _interopRequireDefault(require("../lib/is-browser.js"));
var _globals = require("../lib/globals.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
const isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;
},{"../lib/is-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js","../lib/globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js","process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/get-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBrowser;
exports.isMobile = isMobile;
var _isBrowser = _interopRequireDefault(require("./is-browser.js"));
var _isElectron = _interopRequireDefault(require("./is-electron.js"));
var _globals = require("./globals.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = globalThis;
function isMobile() {
  return typeof window.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }
  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }
  const userAgent = mockUserAgent || _globals.navigator.userAgent || '';
  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  if (isMSIE || isTrident) {
    return 'IE';
  }
  if (window.chrome) {
    return 'Chrome';
  }
  if (window.safari) {
    return 'Safari';
  }
  if (window.mozInnerScreenX) {
    return 'Firefox';
  }
  return 'Unknown';
}
},{"./is-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js","./is-electron.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js","./globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals2.window;
  }
});
var _globals = require("./utils/globals.js");
var _globals2 = require("./lib/globals.js");
var _isBrowser = _interopRequireWildcard(require("./lib/is-browser.js"));
var _getBrowser = _interopRequireWildcard(require("./lib/get-browser.js"));
var _isElectron = _interopRequireDefault(require("./lib/is-electron.js"));
var _assert = _interopRequireDefault(require("./utils/assert.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./utils/globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js","./lib/globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js","./lib/is-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js","./lib/get-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/get-browser.js","./lib/is-electron.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js","./utils/assert.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/assert.js","process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorage = void 0;
function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
class LocalStorage {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    this.storage = void 0;
    this.id = void 0;
    this.config = void 0;
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
}
exports.LocalStorage = LocalStorage;
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatImage = formatImage;
exports.formatTime = formatTime;
exports.formatValue = formatValue;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = options;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, options);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
function formatArrayValue(v, options) {
  const {
    maxElts = 16,
    size = 1
  } = options;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], options);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}
function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');
  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }
  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;
exports.addColor = addColor;
var _env = require("@probe.gl/env");
let COLOR;
exports.COLOR = COLOR;
(function (COLOR) {
  COLOR[COLOR["BLACK"] = 30] = "BLACK";
  COLOR[COLOR["RED"] = 31] = "RED";
  COLOR[COLOR["GREEN"] = 32] = "GREEN";
  COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
  COLOR[COLOR["BLUE"] = 34] = "BLUE";
  COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
  COLOR[COLOR["CYAN"] = 36] = "CYAN";
  COLOR[COLOR["WHITE"] = 37] = "WHITE";
  COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (exports.COLOR = COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor(color) {
  if (typeof color !== 'string') {
    return color;
  }
  color = color.toUpperCase();
  return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
  if (!_env.isBrowser && typeof string === 'string') {
    if (color) {
      const colorCode = getColor(color);
      string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      const colorCode = getColor(background);
      string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}
},{"@probe.gl/env":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === 'function') {
      if (!predefined.find(name => key === name)) {
        object[key] = value.bind(obj);
      }
    }
  }
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiResTimestamp = getHiResTimestamp;
var _env = require("@probe.gl/env");
function getHiResTimestamp() {
  let timestamp;
  if ((0, _env.isBrowser)() && _env.window.performance) {
    var _window$performance, _window$performance$n;
    timestamp = _env.window === null || _env.window === void 0 ? void 0 : (_window$performance = _env.window.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ('hrtime' in _env.process) {
    var _process$hrtime;
    const timeParts = _env.process === null || _env.process === void 0 ? void 0 : (_process$hrtime = _env.process.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(_env.process);
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"@probe.gl/env":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Log = void 0;
exports.normalizeArguments = normalizeArguments;
var _env = require("@probe.gl/env");
var _localStorage = require("./utils/local-storage.js");
var _formatters = require("./utils/formatters.js");
var _color = require("./utils/color.js");
var _autobind = require("./utils/autobind.js");
var _assert = _interopRequireDefault(require("./utils/assert.js"));
var _hiResTimestamp = require("./utils/hi-res-timestamp.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const originalConsole = {
  debug: (0, _env.isBrowser)() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop() {}
const cache = {};
const ONCE = {
  once: true
};
class Log {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    };
    this.id = void 0;
    this.VERSION = _env.VERSION;
    this._startTs = (0, _hiResTimestamp.getHiResTimestamp)();
    this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
    this._storage = void 0;
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new _localStorage.LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    (0, _assert.default)(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = '',
      scale = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }
    return (0, _env.isBrowser)() ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      (0, _assert.default)(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache[tag]) {
          cache[tag] = (0, _hiResTimestamp.getHiResTimestamp)();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
}
exports.Log = Log;
Log.VERSION = _env.VERSION;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;
    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  (0, _assert.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {}
  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case 'object':
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  (0, _assert.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref2;
  console.warn('removed');
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref3;
  if (typeof image === 'string') {
    const img = new Image();
    img.onload = () => {
      const args = (0, _formatters.formatImage)(img, message, scale);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || '';
  if (element.toLowerCase() === 'img') {
    console.log(...(0, _formatters.formatImage)(image, message, scale));
    return noop;
  }
  if (element.toLowerCase() === 'canvas') {
    const img = new Image();
    img.onload = () => console.log(...(0, _formatters.formatImage)(img, message, scale));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }
  return 'empty';
}
},{"@probe.gl/env":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js","./utils/local-storage.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js","./utils/formatters.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js","./utils/color.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js","./utils/autobind.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js","./utils/assert.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js","./utils/hi-res-timestamp.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/init.js":[function(require,module,exports) {
globalThis.probe = {};

},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _localStorage.LocalStorage;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.Log;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _autobind.autobind;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.getHiResTimestamp;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _formatters.rightPad;
  }
});
var _log = require("./log.js");
var _color = require("./utils/color.js");
var _formatters = require("./utils/formatters.js");
var _autobind = require("./utils/autobind.js");
var _localStorage = require("./utils/local-storage.js");
var _hiResTimestamp = require("./utils/hi-res-timestamp.js");
require("./init.js");
var _default = new _log.Log({
  id: '@probe.gl/log'
});
exports.default = _default;
},{"./log.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js","./utils/color.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js","./utils/formatters.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js","./utils/autobind.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js","./utils/local-storage.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js","./utils/hi-res-timestamp.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js","./init.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/init.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.probeLog = exports.NullLog = exports.ConsoleLog = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _log = require("@probe.gl/log");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const probeLog = new _log.Log({
  id: 'loaders.gl'
});
exports.probeLog = probeLog;
class NullLog {
  log() {
    return () => {};
  }
  info() {
    return () => {};
  }
  warn() {
    return () => {};
  }
  error() {
    return () => {};
  }
}
exports.NullLog = NullLog;
class ConsoleLog {
  constructor() {
    (0, _defineProperty2.default)(this, "console", void 0);
    this.console = console;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.console.log.bind(this.console, ...args);
  }
  info() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.console.info.bind(this.console, ...args);
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.console.warn.bind(this.console, ...args);
  }
  error() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.console.error.bind(this.console, ...args);
  }
}
exports.ConsoleLog = ConsoleLog;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/log":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVED_LOADER_OPTIONS = exports.DEFAULT_LOADER_OPTIONS = void 0;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _loggers = require("./loggers");
const DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers.ConsoleLog(),
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: _loaderUtils.isBrowser,
  _nodeWorkers: false,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
exports.DEFAULT_LOADER_OPTIONS = DEFAULT_LOADER_OPTIONS;
const REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
exports.REMOVED_LOADER_OPTIONS = REMOVED_LOADER_OPTIONS;
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./loggers":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlobalLoaderOptions = void 0;
exports.getGlobalLoaderState = getGlobalLoaderState;
exports.normalizeOptions = normalizeOptions;
exports.setGlobalOptions = setGlobalOptions;
var _isType = require("../../javascript-utils/is-type");
var _loggers = require("./loggers");
var _optionDefaults = require("./option-defaults");
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
const getGlobalLoaderOptions = () => {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || {
    ..._optionDefaults.DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
};
exports.getGlobalLoaderOptions = getGlobalLoaderOptions;
function setGlobalOptions(options) {
  const state = getGlobalLoaderState();
  const globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _optionDefaults.DEFAULT_LOADER_OPTIONS, _optionDefaults.REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || 'Top level';
  const prefix = id ? "".concat(id, ".") : '';
  for (const key in options) {
    const isSubOptions = !id && (0, _isType.isObject)(options[key]);
    const isBaseUriOption = key === 'baseUri' && !id;
    const isWorkerUrlOption = key === 'workerUrl' && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = '';
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers.NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if ((0, _isType.isPureObject)(value) && (0, _isType.isPureObject)(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./loggers":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js","./option-defaults":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getLoaderOptions", {
  enumerable: true,
  get: function () {
    return _optionUtils.getGlobalLoaderOptions;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function () {
    return _optionUtils.setGlobalOptions;
  }
});
var _optionUtils = require("../loader-utils/option-utils");
},{"../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;
var _loaderUtils = require("@loaders.gl/loader-utils");
function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  (0, _loaderUtils.assert)(loader, 'null loader');
  (0, _loaderUtils.assert)(isLoaderObject(loader), 'invalid loader');
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._unregisterLoaders = _unregisterLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;
exports.registerLoaders = registerLoaders;
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _optionUtils = require("../loader-utils/option-utils");
const getGlobalLoaderRegistry = () => {
  const state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);
    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
  const state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = [];
}
},{"../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = void 0;
var _log = require("@probe.gl/log");
const log = new _log.Log({
  id: 'loaders.gl'
});
exports.log = log;
},{"@probe.gl/log":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectLoader = selectLoader;
exports.selectLoaderSync = selectLoaderSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _log = require("../utils/log");
var _resourceUtils = require("../utils/resource-utils");
var _registerLoaders = require("./register-loaders");
var _isType = require("../../javascript-utils/is-type");
var _urlUtils = require("../utils/url-utils");
const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if ((0, _isType.isBlob)(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return (0, _normalizeLoader.normalizeLoader)(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...(0, _registerLoaders.getRegisteredLoaders)());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const type = (0, _resourceUtils.getResourceMIMEType)(data);
  const testUrl = (0, _urlUtils.stripQueryString)(url) || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = '';
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? "matched url ".concat(testUrl) : '');
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? "matched MIME type ".concat(type) : '');
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data)) : '');
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  reason = reason || (loader ? "matched fallback MIME type ".concat(type) : '');
  if (reason) {
    var _loader;
    _log.log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const type = (0, _resourceUtils.getResourceMIMEType)(data);
  let message = 'No valid loader found (';
  message += url ? "".concat(_loaderUtils.path.filename(url), ", ") : 'no url provided, ';
  message += "MIME type: ".concat(type ? "\"".concat(type, "\"") : 'not provided', ", ");
  const firstCharacters = data ? getFirstCharacters(data) : '';
  message += firstCharacters ? " first bytes: \"".concat(firstCharacters, "\"") : 'first bytes: not available';
  message += ')';
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    (0, _normalizeLoader.normalizeLoader)(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === "application/x.".concat(loader.id)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0, _loaderUtils.compareArrayBuffers)(test, data, test.byteLength);
  }
  switch (typeof test) {
    case 'function':
      return test(data, loader);
    case 'string':
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../utils/log":"node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./register-loaders":"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../utils/url-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStringIterator = makeStringIterator;
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeArrayBufferIterator = makeArrayBufferIterator;
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function makeArrayBufferIterator(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function* () {
    const {
      chunkSize = DEFAULT_CHUNK_SIZE
    } = options;
    let byteOffset = 0;
    while (byteOffset < arrayBuffer.byteLength) {
      const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
      const chunk = new ArrayBuffer(chunkByteLength);
      const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
      const chunkArray = new Uint8Array(chunk);
      chunkArray.set(sourceArray);
      byteOffset += chunkByteLength;
      yield chunk;
    }
  }();
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBlobIterator = makeBlobIterator;
const DEFAULT_CHUNK_SIZE = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStreamIterator = makeStreamIterator;
var _loaderUtils = require("@loaders.gl/loader-utils");
function makeStreamIterator(stream, options) {
  return _loaderUtils.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield (0, _loaderUtils.toArrayBuffer)(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield (0, _loaderUtils.toArrayBuffer)(chunk);
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeIterator = makeIterator;
var _makeStringIterator = require("./make-string-iterator");
var _makeArrayBufferIterator = require("./make-array-buffer-iterator");
var _makeBlobIterator = require("./make-blob-iterator");
var _makeStreamIterator = require("./make-stream-iterator");
var _isType = require("../../javascript-utils/is-type");
function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0, _makeStringIterator.makeStringIterator)(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return (0, _makeArrayBufferIterator.makeArrayBufferIterator)(data, options);
  }
  if ((0, _isType.isBlob)(data)) {
    return (0, _makeBlobIterator.makeBlobIterator)(data, options);
  }
  if ((0, _isType.isReadableStream)(data)) {
    return (0, _makeStreamIterator.makeStreamIterator)(data, options);
  }
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    return (0, _makeStreamIterator.makeStreamIterator)(response.body, options);
  }
  throw new Error('makeIterator');
}
},{"./make-string-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js","./make-array-buffer-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js","./make-blob-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js","./make-stream-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getAsyncIterableFromData = getAsyncIterableFromData;
exports.getReadableStream = getReadableStream;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _isType = require("../../javascript-utils/is-type");
var _makeIterator = require("../../iterators/make-iterator/make-iterator");
var _responseUtils = require("../utils/response-utils");
const ERR_DATA = 'Cannot convert supplied data type';
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }
  if ((0, _isType.isBuffer)(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if ((0, _isType.isBlob)(data)) {
    data = await (0, _responseUtils.makeResponse)(data);
  }
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    await (0, _responseUtils.checkResponse)(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if ((0, _isType.isReadableStream)(data)) {
    data = (0, _makeIterator.makeIterator)(data, options);
  }
  if ((0, _isType.isIterable)(data) || (0, _isType.isAsyncIterable)(data)) {
    return (0, _loaderUtils.concatenateArrayBuffersAsync)(data);
  }
  throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
  if ((0, _isType.isIterator)(data)) {
    return data;
  }
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    await (0, _responseUtils.checkResponse)(response);
    const body = await response.body;
    return (0, _makeIterator.makeIterator)(body, options);
  }
  if ((0, _isType.isBlob)(data) || (0, _isType.isReadableStream)(data)) {
    return (0, _makeIterator.makeIterator)(data, options);
  }
  if ((0, _isType.isAsyncIterable)(data)) {
    return data[Symbol.asyncIterator]();
  }
  return getIterableFromData(data);
}
async function getReadableStream(data) {
  if ((0, _isType.isReadableStream)(data)) {
    return data;
  }
  if ((0, _isType.isResponse)(data)) {
    return data.body;
  }
  const response = await (0, _responseUtils.makeResponse)(data);
  return response.body;
}
function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return function* oneChunk() {
      yield data.buffer;
    }();
  }
  if (data instanceof ArrayBuffer) {
    return function* oneChunk() {
      yield data;
    }();
  }
  if ((0, _isType.isIterator)(data)) {
    return data;
  }
  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }
  throw new Error(ERR_DATA);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../../iterators/make-iterator/make-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","../utils/response-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFetchFunction = getFetchFunction;
var _isType = require("../../javascript-utils/is-type");
var _fetchFile = require("../fetch/fetch-file");
var _optionUtils = require("./option-utils");
function getFetchFunction(options, context) {
  const globalOptions = (0, _optionUtils.getGlobalLoaderOptions)();
  const fetchOptions = options || globalOptions;
  if (typeof fetchOptions.fetch === 'function') {
    return fetchOptions.fetch;
  }
  if ((0, _isType.isObject)(fetchOptions.fetch)) {
    return url => (0, _fetchFile.fetchFile)(url, fetchOptions);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return _fetchFile.fetchFile;
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoaderContext = getLoaderContext;
exports.getLoadersFromContext = getLoadersFromContext;
var _getFetchFunction = require("./get-fetch-function");
var _urlUtils = require("../utils/url-utils");
var _loaderUtils = require("@loaders.gl/loader-utils");
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: (0, _getFetchFunction.getFetchFunction)(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = (0, _urlUtils.stripQueryString)(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = (0, _urlUtils.extractQueryString)(newContext.url);
    newContext.filename = _loaderUtils.path.filename(baseUrl);
    newContext.baseUrl = _loaderUtils.path.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}
},{"./get-fetch-function":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js","../utils/url-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
var _workerUtils = require("@loaders.gl/worker-utils");
var _loaderUtils = require("@loaders.gl/loader-utils");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _isType = require("../../javascript-utils/is-type");
var _optionUtils = require("../loader-utils/option-utils");
var _getData = require("../loader-utils/get-data");
var _loaderContext = require("../loader-utils/loader-context");
var _resourceUtils = require("../utils/resource-utils");
var _selectLoader = require("./select-loader");
async function parse(data, loaders, options, context) {
  (0, _workerUtils.assert)(!context || typeof context === 'object');
  if (loaders && !Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const typedLoaders = loaders;
  const candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  const loader = await (0, _selectLoader.selectLoader)(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders, url);
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parse,
    loaders: candidateLoaders
  }, options, context || null);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  (0, _workerUtils.validateWorkerVersion)(loader);
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data = await (0, _getData.getArrayBufferOrStringFromData)(data, loader, options);
  if (loader.parseTextSync && typeof data === 'string') {
    options.dataType = 'text';
    return loader.parseTextSync(data, options, context, loader);
  }
  if ((0, _loaderUtils.canParseWithWorker)(loader, options)) {
    return await (0, _loaderUtils.parseWithWorker)(loader, data, options, context, parse);
  }
  if (loader.parseText && typeof data === 'string') {
    return await loader.parseText(data, options, context, loader);
  }
  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }
  (0, _workerUtils.assert)(!loader.parseSync);
  throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _selectLoader = require("./select-loader");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _optionUtils = require("../loader-utils/option-utils");
var _getData = require("../loader-utils/get-data");
var _loaderContext = require("../loader-utils/loader-context");
var _resourceUtils = require("../utils/resource-utils");
function parseSync(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || typeof context === 'object');
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  options = options || {};
  const typedLoaders = loaders;
  const candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  const loader = (0, _selectLoader.selectLoaderSync)(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders);
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const parse = () => {
    throw new Error('parseSync called parse (which is async');
  };
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parseSync,
    parse,
    loaders: loaders
  }, options, context || null);
  return parseWithLoaderSync(loader, data, options, context);
}
function parseWithLoaderSync(loader, data, options, context) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader, options);
  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options);
  }
  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }
  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ''));
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInBatches = parseInBatches;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _optionUtils = require("../loader-utils/option-utils");
var _loaderContext = require("../loader-utils/loader-context");
var _getData = require("../loader-utils/get-data");
var _resourceUtils = require("../utils/resource-utils");
var _selectLoader = require("./select-loader");
var _parse = require("./parse");
async function parseInBatches(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || typeof context === 'object');
  const loaderArray = Array.isArray(loaders) ? loaders : undefined;
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const loader = await (0, _selectLoader.selectLoader)(data, loaders, options);
  if (!loader) {
    return null;
  }
  options = (0, _optionUtils.normalizeOptions)(options, loader, loaderArray, url);
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parseInBatches,
    parse: _parse.parse,
    loaders: loaderArray
  }, options, context || null);
  return await parseWithLoaderInBatches(loader, data, options, context);
}
async function parseWithLoaderInBatches(loader, data, options, context) {
  const outputIterator = await parseToOutputIterator(loader, data, options, context);
  if (!options.metadata) {
    return outputIterator;
  }
  const metadataBatch = {
    batchType: 'metadata',
    metadata: {
      _loader: loader,
      _context: context
    },
    data: [],
    bytesUsed: 0
  };
  async function* makeMetadataBatchIterator(iterator) {
    yield metadataBatch;
    yield* iterator;
  }
  return makeMetadataBatchIterator(outputIterator);
}
async function parseToOutputIterator(loader, data, options, context) {
  const inputIterator = await (0, _getData.getAsyncIterableFromData)(data, options);
  const transformedIterator = await applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);
  if (loader.parseInBatches) {
    return loader.parseInBatches(transformedIterator, options, context);
  }
  async function* parseChunkInBatches() {
    const arrayBuffer = await (0, _loaderUtils.concatenateArrayBuffersAsync)(transformedIterator);
    const parsedData = await (0, _parse.parse)(arrayBuffer, loader, {
      ...options,
      mimeType: loader.mimeTypes[0]
    }, context);
    const batch = {
      mimeType: loader.mimeTypes[0],
      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',
      batchType: 'data',
      data: parsedData,
      length: Array.isArray(parsedData) ? parsedData.length : 1
    };
    yield batch;
  }
  return parseChunkInBatches();
}
async function applyInputTransforms(inputIterator) {
  let transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let iteratorChain = inputIterator;
  for await (const transformBatches of transforms) {
    iteratorChain = transformBatches(iteratorChain);
  }
  return iteratorChain;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","./parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;
var _isType = require("../../javascript-utils/is-type");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _getFetchFunction = require("../loader-utils/get-fetch-function");
var _parse = require("./parse");
async function load(url, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  const fetch = (0, _getFetchFunction.getFetchFunction)(options);
  let data = url;
  if (typeof url === 'string') {
    data = await fetch(url);
  }
  if ((0, _isType.isBlob)(url)) {
    data = await fetch(url);
  }
  return await (0, _parse.parse)(data, loaders, options);
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/get-fetch-function":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js","./parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _getFetchFunction = require("../loader-utils/get-fetch-function");
var _parseInBatches = require("./parse-in-batches");
function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = null;
  }
  const fetch = (0, _getFetchFunction.getFetchFunction)(options || {});
  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch);
  }
  const promises = files.map(file => loadOneFileInBatches(file, loaders, options, fetch));
  return promises;
}
async function loadOneFileInBatches(file, loaders, options, fetch) {
  if (typeof file === 'string') {
    const url = file;
    const response = await fetch(url);
    return await (0, _parseInBatches.parseInBatches)(response, loaders, options);
  }
  return await (0, _parseInBatches.parseInBatches)(file, loaders, options);
}
},{"../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/get-fetch-function":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js","./parse-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeInBatches = encodeInBatches;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeURLtoURL = encodeURLtoURL;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _workerUtils = require("@loaders.gl/worker-utils");
var _writeFile = require("../fetch/write-file");
var _fetchFile = require("../fetch/fetch-file");
var _loaderOptions = require("./loader-options");
async function encode(data, writer, options) {
  const globalOptions = (0, _loaderOptions.getLoaderOptions)();
  options = {
    ...globalOptions,
    ...options
  };
  if ((0, _loaderUtils.canEncodeWithWorker)(writer, options)) {
    return await (0, _workerUtils.processOnWorker)(writer, data, options);
  }
  if (writer.encode) {
    return await writer.encode(data, options);
  }
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  if (writer.encodeText) {
    return new TextEncoder().encode(await writer.encodeText(data, options));
  }
  if (writer.encodeInBatches) {
    const batches = encodeInBatches(data, writer, options);
    const chunks = [];
    for await (const batch of batches) {
      chunks.push(batch);
    }
    return (0, _loaderUtils.concatenateArrayBuffers)(...chunks);
  }
  if (!_loaderUtils.isBrowser && writer.encodeURLtoURL) {
    const tmpInputFilename = getTemporaryFilename('input');
    await (0, _writeFile.writeFile)(tmpInputFilename, data);
    const tmpOutputFilename = getTemporaryFilename('output');
    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);
    const response = await (0, _fetchFile.fetchFile)(outputFilename);
    return response.arrayBuffer();
  }
  throw new Error('Writer could not encode data');
}
function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error('Writer could not synchronously encode data');
}
async function encodeText(data, writer, options) {
  if (writer.text && writer.encodeText) {
    return await writer.encodeText(data, options);
  }
  if (writer.text && (writer.encode || writer.encodeInBatches)) {
    const arrayBuffer = await encode(data, writer, options);
    return new TextDecoder().decode(arrayBuffer);
  }
  throw new Error('Writer could not encode data as text');
}
function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    const dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }
  throw new Error('Writer could not encode data in batches');
}
async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {
  inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
  outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);
  if (_loaderUtils.isBrowser || !writer.encodeURLtoURL) {
    throw new Error();
  }
  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);
  return outputFilename;
}
function getIterator(data) {
  const dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}
function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","../fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","../fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./loader-options":"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/save.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;
var _encode = require("./encode");
var _writeFile = require("../fetch/write-file");
async function save(data, url, writer, options) {
  const encodedData = await (0, _encode.encode)(data, writer, options);
  return await (0, _writeFile.writeFile)(url, encodedData);
}
function saveSync(data, url, writer, options) {
  const encodedData = (0, _encode.encodeSync)(data, writer, options);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}
},{"./encode":"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","../fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStream = makeStream;
function makeStream(source, options) {
  const iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream({
    type: 'bytes',
    async pull(controller) {
      try {
        const {
          done,
          value
        } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(new Uint8Array(value));
        }
      } catch (error) {
        controller.error(error);
      }
    },
    async cancel() {
      var _iterator$return;
      await (iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));
    }
  }, {
    highWaterMark: 2 ** 24,
    ...options
  });
}
},{}],"node_modules/@loaders.gl/core/dist/esm/null-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullWorkerLoader = exports.NullLoader = void 0;
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : 'latest';
const NullWorkerLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  worker: true,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  tests: [() => false],
  options: {
    null: {}
  }
};
exports.NullWorkerLoader = NullWorkerLoader;
function parseSync(arrayBuffer, options, context) {
  if (!options.null.echoParameters) return null;
  context = context && JSON.parse(JSON.stringify(context));
  return {
    arrayBuffer,
    options,
    context
  };
}
const NullLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  parse: async (arrayBuffer, options, context) => parseSync(arrayBuffer, options, context),
  parseSync,
  parseInBatches: async function* generator(asyncIterator, options, context) {
    for await (const batch of asyncIterator) {
      yield parseSync(batch, options, context);
    }
  },
  tests: [() => false],
  options: {
    null: {
      echoParameters: false
    }
  }
};
exports.NullLoader = NullLoader;
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchProgress;
async function fetchProgress(response, onProgress) {
  let onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
  let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};
  response = await response;
  if (!response.ok) {
    return response;
  }
  const body = response.body;
  if (!body) {
    return response;
  }
  const contentLength = response.headers.get('content-length') || 0;
  const totalBytes = contentLength ? parseInt(contentLength) : 0;
  if (!(totalBytes > 0)) {
    return response;
  }
  if (typeof ReadableStream === 'undefined' || !body.getReader) {
    return response;
  }
  const progressStream = new ReadableStream({
    async start(controller) {
      const reader = body.getReader();
      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
    }
  });
  return new Response(progressStream);
}
async function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
  try {
    const {
      done,
      value
    } = await reader.read();
    if (done) {
      onDone();
      controller.close();
      return;
    }
    loadedBytes += value.byteLength;
    const percent = Math.round(loadedBytes / totalBytes * 100);
    onProgress(percent, {
      loadedBytes,
      totalBytes
    });
    controller.enqueue(value);
    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
  } catch (error) {
    controller.error(error);
    onError(error);
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class BrowserFileSystem {
  constructor(files, options) {
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "files", {});
    (0, _defineProperty2.default)(this, "lowerCaseFiles", {});
    (0, _defineProperty2.default)(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;
    for (let i = 0; i < files.length; ++i) {
      const file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }
    this.fetch = this.fetch.bind(this);
  }
  async fetch(path, options) {
    if (path.includes('://')) {
      return this._fetch(path, options);
    }
    const file = this.files[path];
    if (!file) {
      return new Response(path, {
        status: 400,
        statusText: 'NOT FOUND'
      });
    }
    const headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
    const range = headers.get('Range');
    const bytes = range && /bytes=($1)-($2)/.exec(range);
    if (bytes) {
      const start = parseInt(bytes[1]);
      const end = parseInt(bytes[2]);
      const data = await file.slice(start, end).arrayBuffer();
      const response = new Response(data);
      Object.defineProperty(response, 'url', {
        value: path
      });
      return response;
    }
    const response = new Response(file);
    Object.defineProperty(response, 'url', {
      value: path
    });
    return response;
  }
  async readdir(dirname) {
    const files = [];
    for (const path in this.files) {
      files.push(path);
    }
    return files;
  }
  async stat(path, options) {
    const file = this.files[path];
    if (!file) {
      throw new Error(path);
    }
    return {
      size: file.size
    };
  }
  async unlink(path) {
    delete this.files[path];
    delete this.lowerCaseFiles[path];
    this.usedFiles[path] = true;
  }
  async open(pathname, flags, mode) {
    return this.files[pathname];
  }
  async read(fd, buffer) {
    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : buffer.byteLength;
    let position = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    const file = fd;
    const startPosition = 0;
    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();
    return {
      bytesRead: length,
      buffer: arrayBuffer
    };
  }
  async close(fd) {}
  _getFile(path, used) {
    const file = this.files[path] || this.lowerCaseFiles[path];
    if (file && used) {
      this.usedFiles[path] = true;
    }
    return file;
  }
}
exports.default = BrowserFileSystem;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@loaders.gl/core/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function () {
    return _loaderUtils.JSONLoader;
  }
});
Object.defineProperty(exports, "NullLoader", {
  enumerable: true,
  get: function () {
    return _nullLoader.NullLoader;
  }
});
Object.defineProperty(exports, "NullWorkerLoader", {
  enumerable: true,
  get: function () {
    return _nullLoader.NullWorkerLoader;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function () {
    return _loaderUtils.RequestScheduler;
  }
});
Object.defineProperty(exports, "_BrowserFileSystem", {
  enumerable: true,
  get: function () {
    return _browserFilesystem.default;
  }
});
Object.defineProperty(exports, "_fetchProgress", {
  enumerable: true,
  get: function () {
    return _fetchProgress.default;
  }
});
Object.defineProperty(exports, "_unregisterLoaders", {
  enumerable: true,
  get: function () {
    return _registerLoaders._unregisterLoaders;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _loaderUtils.assert;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function () {
    return _loaderUtils.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _loaderUtils.document;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function () {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function () {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function () {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeText", {
  enumerable: true,
  get: function () {
    return _encode.encodeText;
  }
});
Object.defineProperty(exports, "encodeURLtoURL", {
  enumerable: true,
  get: function () {
    return _encode.encodeURLtoURL;
  }
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function () {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function () {
    return _loaderUtils.forEach;
  }
});
Object.defineProperty(exports, "getLoaderOptions", {
  enumerable: true,
  get: function () {
    return _loaderOptions.getLoaderOptions;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function () {
    return _loaderUtils.getPathPrefix;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _loaderUtils.global;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function () {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _loaderUtils.isBrowser;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function () {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function () {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function () {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isPureObject", {
  enumerable: true,
  get: function () {
    return _isType.isPureObject;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function () {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isResponse", {
  enumerable: true,
  get: function () {
    return _isType.isResponse;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _loaderUtils.isWorker;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function () {
    return _isType.isWritableStream;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function () {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function () {
    return _loadInBatches.loadInBatches;
  }
});
Object.defineProperty(exports, "makeIterator", {
  enumerable: true,
  get: function () {
    return _makeIterator.makeIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeStream", {
  enumerable: true,
  get: function () {
    return _makeNodeStream.makeStream;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function () {
    return _parseInBatches.parseInBatches;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function () {
    return _parseSync.parseSync;
  }
});
Object.defineProperty(exports, "readArrayBuffer", {
  enumerable: true,
  get: function () {
    return _readArrayBuffer.readArrayBuffer;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function () {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function () {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function () {
    return _loaderUtils.resolvePath;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function () {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function () {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "selectLoader", {
  enumerable: true,
  get: function () {
    return _selectLoader.selectLoader;
  }
});
Object.defineProperty(exports, "selectLoaderSync", {
  enumerable: true,
  get: function () {
    return _selectLoader.selectLoaderSync;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _loaderUtils.self;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function () {
    return _loaderOptions.setLoaderOptions;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loaderUtils.setPathPrefix;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _loaderUtils.window;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function () {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function () {
    return _writeFile.writeFileSync;
  }
});
var _fetchFile = require("./lib/fetch/fetch-file");
var _readArrayBuffer = require("./lib/fetch/read-array-buffer");
var _readFile = require("./lib/fetch/read-file");
var _writeFile = require("./lib/fetch/write-file");
var _loaderOptions = require("./lib/api/loader-options");
var _registerLoaders = require("./lib/api/register-loaders");
var _selectLoader = require("./lib/api/select-loader");
var _parse = require("./lib/api/parse");
var _parseSync = require("./lib/api/parse-sync");
var _parseInBatches = require("./lib/api/parse-in-batches");
var _load = require("./lib/api/load");
var _loadInBatches = require("./lib/api/load-in-batches");
var _encode = require("./lib/api/encode");
var _save = require("./lib/api/save");
var _loaderUtils = require("@loaders.gl/loader-utils");
var _makeIterator = require("./iterators/make-iterator/make-iterator");
var _makeNodeStream = require("./iterators/make-stream/make-node-stream");
var _nullLoader = require("./null-loader");
var _fetchProgress = _interopRequireDefault(require("./lib/progress/fetch-progress"));
var _browserFilesystem = _interopRequireDefault(require("./lib/filesystems/browser-filesystem"));
var _isType = require("./javascript-utils/is-type");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./lib/fetch/read-array-buffer":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js","./lib/fetch/read-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js","./lib/fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","./lib/api/loader-options":"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js","./lib/api/register-loaders":"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","./lib/api/select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","./lib/api/parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js","./lib/api/parse-sync":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js","./lib/api/parse-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js","./lib/api/load":"node_modules/@loaders.gl/core/dist/esm/lib/api/load.js","./lib/api/load-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js","./lib/api/encode":"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","./lib/api/save":"node_modules/@loaders.gl/core/dist/esm/lib/api/save.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./iterators/make-iterator/make-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","./iterators/make-stream/make-node-stream":"node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js","./null-loader":"node_modules/@loaders.gl/core/dist/esm/null-loader.js","./lib/progress/fetch-progress":"node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js","./lib/filesystems/browser-filesystem":"node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js","./javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : 'latest';
exports.VERSION = VERSION;
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultImageType = getDefaultImageType;
exports.isImageTypeSupported = isImageTypeSupported;
var _loaderUtils = require("@loaders.gl/loader-utils");
const {
  _parseImageNode
} = globalThis;
const IMAGE_SUPPORTED = typeof Image !== 'undefined';
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
const DATA_SUPPORTED = _loaderUtils.isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;
    case 'image':
      return IMAGE_SUPPORTED;
    case 'data':
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return 'imagebitmap';
  }
  if (IMAGE_SUPPORTED) {
    return 'image';
  }
  if (DATA_SUPPORTED) {
    return 'data';
  }
  throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteImage = deleteImage;
exports.getImageData = getImageData;
exports.getImageSize = getImageSize;
exports.getImageType = getImageType;
exports.isImage = isImage;
function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}
function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;
    default:
  }
}
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error('Not an image');
  }
  return format;
}
function getImageSize(image) {
  return getImageData(image);
}
function getImageData(image) {
  switch (getImageType(image)) {
    case 'data':
      return image;
    case 'image':
    case 'imagebitmap':
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (!context) {
        throw new Error('getImageData');
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error('getImageData');
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }
  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'image';
  }
  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    return 'data';
  }
  return null;
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBlob = getBlob;
exports.getBlobOrSVGDataUrl = getBlobOrSVGDataUrl;
exports.isSVG = isSVG;
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error('SVG cannot be parsed directly to imagebitmap');
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToImage;
exports.loadToImage = loadToImage;
var _svgUtils = require("./svg-utils");
async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = (0, _svgUtils.getBlobOrSVGDataUrl)(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error) {
      reject(error);
    }
  });
}
},{"./svg-utils":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToImageBitmap;
var _svgUtils = require("./svg-utils");
var _parseToImage = _interopRequireDefault(require("./parse-to-image"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if ((0, _svgUtils.isSVG)(url)) {
    const image = await (0, _parseToImage.default)(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = (0, _svgUtils.getBlob)(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob) {
  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
},{"./svg-utils":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js","./parse-to-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeMajorBrand = decodeMajorBrand;
exports.getISOBMFFMediaType = getISOBMFFMediaType;
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, 'ftyp', 4)) {
    return null;
  }
  if ((buffer[8] & 0x60) === 0x00) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace('\0', ' ').trim();
  switch (brandMajor) {
    case 'avif':
    case 'avis':
      return {
        extension: 'avif',
        mimeType: 'image/avif'
      };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map(character => character.charCodeAt(0));
}
function checkString(buffer, header) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const headerBytes = stringToBytes(header);
  for (let i = 0; i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset]) {
      return false;
    }
  }
  return true;
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBinaryImageMetadata = getBinaryImageMetadata;
exports.getBmpMetadata = getBmpMetadata;
var _parseIsobmffBinary = require("./parse-isobmff-binary");
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = (0, _parseIsobmffBinary.getISOBMFFMediaType)(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: 'image/png',
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: 'image/gif',
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: 'image/bmp',
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
  if (!isJpeg) {
    return null;
  }
  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: 'image/jpeg',
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error('toDataView');
}
},{"./parse-isobmff-binary":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToNodeImage;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _binaryImageApi = require("../category-api/binary-image-api");
async function parseToNodeImage(arrayBuffer, options) {
  const {
    mimeType
  } = (0, _binaryImageApi.getBinaryImageMetadata)(arrayBuffer) || {};
  const _parseImageNode = globalThis._parseImageNode;
  (0, _loaderUtils.assert)(_parseImageNode);
  return await _parseImageNode(arrayBuffer, mimeType);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseImage;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _imageType = require("../category-api/image-type");
var _parsedImageApi = require("../category-api/parsed-image-api");
var _parseToImage = _interopRequireDefault(require("./parse-to-image"));
var _parseToImageBitmap = _interopRequireDefault(require("./parse-to-image-bitmap"));
var _parseToNodeImage = _interopRequireDefault(require("./parse-to-node-image"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || 'auto';
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case 'imagebitmap':
      image = await (0, _parseToImageBitmap.default)(arrayBuffer, options, url);
      break;
    case 'image':
      image = await (0, _parseToImage.default)(arrayBuffer, options, url);
      break;
    case 'data':
      image = await (0, _parseToNodeImage.default)(arrayBuffer, options);
      break;
    default:
      (0, _loaderUtils.assert)(false);
  }
  if (imageType === 'data') {
    image = (0, _parsedImageApi.getImageData)(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case 'auto':
    case 'data':
      return (0, _imageType.getDefaultImageType)();
    default:
      (0, _imageType.isImageTypeSupported)(type);
      return type;
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../category-api/image-type":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./parse-to-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js","./parse-to-image-bitmap":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js","./parse-to-node-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js"}],"node_modules/@loaders.gl/images/dist/esm/image-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckImageLoader = exports.ImageLoader = void 0;
var _version = require("./lib/utils/version");
var _parseImage = _interopRequireDefault(require("./lib/parsers/parse-image"));
var _binaryImageApi = require("./lib/category-api/binary-image-api");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg', 'avif'];
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: 'auto',
    decode: true
  }
};
const ImageLoader = {
  id: 'image',
  module: 'images',
  name: 'Images',
  version: _version.VERSION,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _parseImage.default,
  tests: [arrayBuffer => Boolean((0, _binaryImageApi.getBinaryImageMetadata)(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};
exports.ImageLoader = ImageLoader;
const _typecheckImageLoader = ImageLoader;
exports._typecheckImageLoader = _typecheckImageLoader;
},{"./lib/utils/version":"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","./lib/parsers/parse-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","./lib/category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeImage = encodeImage;
var _parsedImageApi = require("../category-api/parsed-image-api");
const {
  _encodeImageNode
} = globalThis;
async function encodeImage(image, options) {
  options = options || {};
  options.image = options.image || {};
  return _encodeImageNode ? _encodeImageNode(image, {
    type: options.image.mimeType
  }) : encodeImageInBrowser(image, options);
}
let qualityParamSupported = true;
async function encodeImageInBrowser(image, options) {
  const {
    mimeType,
    jpegQuality
  } = options.image;
  const {
    width,
    height
  } = (0, _parsedImageApi.getImageSize)(image);
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  drawImageToCanvas(image, canvas);
  const blob = await new Promise(resolve => {
    if (jpegQuality && qualityParamSupported) {
      try {
        canvas.toBlob(resolve, mimeType, jpegQuality);
        return;
      } catch (error) {
        qualityParamSupported = false;
      }
    }
    canvas.toBlob(resolve, mimeType);
  });
  if (!blob) {
    throw new Error('image encoding failed');
  }
  return await blob.arrayBuffer();
}
function drawImageToCanvas(image, canvas) {
  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    const context = canvas.getContext('bitmaprenderer');
    if (context) {
      context.transferFromImageBitmap(image);
      return canvas;
    }
  }
  const context = canvas.getContext('2d');
  if (image.data) {
    const clampedArray = new Uint8ClampedArray(image.data);
    const imageData = new ImageData(clampedArray, image.width, image.height);
    context.putImageData(imageData, 0, 0);
    return canvas;
  }
  context.drawImage(image, 0, 0);
  return canvas;
}
},{"../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/image-writer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageWriter = void 0;
var _version = require("./lib/utils/version");
var _encodeImage = require("./lib/encoders/encode-image");
const ImageWriter = {
  name: 'Images',
  id: 'image',
  module: 'images',
  version: _version.VERSION,
  extensions: ['jpeg'],
  options: {
    image: {
      mimeType: 'image/png',
      jpegQuality: null
    }
  },
  encode: _encodeImage.encodeImage
};
exports.ImageWriter = ImageWriter;
},{"./lib/utils/version":"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","./lib/encoders/encode-image":"node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSupportedImageFormats = getSupportedImageFormats;
exports.isImageFormatSupported = isImageFormatSupported;
var _loaderUtils = require("@loaders.gl/loader-utils");
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/tiff', 'image/svg', 'image/svg+xml', 'image/bmp', 'image/vnd.microsoft.icon'];
const mimeTypeSupportedPromise = null;
async function getSupportedImageFormats() {
  if (mimeTypeSupportedPromise) {
    return await mimeTypeSupportedPromise;
  }
  const supportedMimeTypes = new Set();
  for (const mimeType of MIME_TYPES) {
    const supported = _loaderUtils.isBrowser ? await checkBrowserImageFormatSupportAsync(mimeType) : checkNodeImageFormatSupport(mimeType);
    if (supported) {
      supportedMimeTypes.add(mimeType);
    }
  }
  return supportedMimeTypes;
}
const mimeTypeSupportedSync = {};
function isImageFormatSupported(mimeType) {
  if (mimeTypeSupportedSync[mimeType] === undefined) {
    const supported = _loaderUtils.isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
    mimeTypeSupportedSync[mimeType] = supported;
  }
  return mimeTypeSupportedSync[mimeType];
}
function checkNodeImageFormatSupport(mimeType) {
  const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];
  const {
    _parseImageNode,
    _imageFormatsNode = NODE_FORMAT_SUPPORT
  } = globalThis;
  return Boolean(_parseImageNode) && _imageFormatsNode.includes(mimeType);
}
function checkBrowserImageFormatSupport(mimeType) {
  switch (mimeType) {
    case 'image/avif':
    case 'image/webp':
      return testBrowserImageFormatSupport(mimeType);
    default:
      return true;
  }
}
const TEST_IMAGE = {
  'image/avif': 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',
  'image/webp': 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'
};
async function checkBrowserImageFormatSupportAsync(mimeType) {
  const dataURL = TEST_IMAGE[mimeType];
  return dataURL ? await testBrowserImageFormatSupportAsync(dataURL) : true;
}
function testBrowserImageFormatSupport(mimeType) {
  try {
    const element = document.createElement('canvas');
    const dataURL = element.toDataURL(mimeType);
    return dataURL.indexOf("data:".concat(mimeType)) === 0;
  } catch {
    return false;
  }
}
async function testBrowserImageFormatSupportAsync(testImageDataURL) {
  return new Promise(resolve => {
    const image = new Image();
    image.src = testImageDataURL;
    image.onload = () => resolve(image.height > 0);
    image.onerror = () => resolve(false);
  });
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateUrl = generateUrl;
var _loaderUtils = require("@loaders.gl/loader-utils");
function generateUrl(getUrl, options, urlOptions) {
  let url = getUrl;
  if (typeof getUrl === 'function') {
    url = getUrl({
      ...options,
      ...urlOptions
    });
  }
  (0, _loaderUtils.assert)(typeof url === 'string');
  const {
    baseUrl
  } = options;
  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === '/' ? "".concat(baseUrl).concat(url) : "".concat(baseUrl, "/").concat(url);
  }
  return (0, _loaderUtils.resolvePath)(url);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asyncDeepMap = asyncDeepMap;
exports.mapSubtree = mapSubtree;
const isObject = value => value && typeof value === 'object';
async function asyncDeepMap(tree, func) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return await mapSubtree(tree, func, options);
}
async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }
  if (isObject(object)) {
    return await mapObject(object, func, options);
  }
  const url = object;
  return await func(url, options);
}
async function mapObject(object, func, options) {
  const promises = [];
  const values = {};
  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then(value => {
      values[key] = value;
    });
    promises.push(promise);
  }
  await Promise.all(promises);
  return values;
}
async function mapArray(urlArray, func) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const promises = urlArray.map(url => mapSubtree(url, func, options));
  return await Promise.all(promises);
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepLoad = deepLoad;
exports.shallowLoad = shallowLoad;
var _asyncDeepMap = require("./async-deep-map");
async function deepLoad(urlTree, load, options) {
  return await (0, _asyncDeepMap.asyncDeepMap)(urlTree, url => shallowLoad(url, load, options));
}
async function shallowLoad(url, load, options) {
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}
},{"./async-deep-map":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImageUrls = getImageUrls;
exports.getMipLevels = getMipLevels;
exports.loadImage = loadImage;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _parseImage = _interopRequireDefault(require("../parsers/parse-image"));
var _parsedImageApi = require("../category-api/parsed-image-api");
var _generateUrl = require("./generate-url");
var _deepLoad = require("./deep-load");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function loadImage(getUrl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const imageUrls = await getImageUrls(getUrl, options);
  return await (0, _deepLoad.deepLoad)(imageUrls, _parseImage.default, options);
}
async function getImageUrls(getUrl, options) {
  let urlOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const mipLevels = options && options.image && options.image.mipLevels || 0;
  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : (0, _generateUrl.generateUrl)(getUrl, options, urlOptions);
}
async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];
  if (mipLevels === 'auto') {
    const url = (0, _generateUrl.generateUrl)(getUrl, options, {
      ...urlOptions,
      lod: 0
    });
    const image = await (0, _deepLoad.shallowLoad)(url, _parseImage.default, options);
    const {
      width,
      height
    } = (0, _parsedImageApi.getImageSize)(image);
    mipLevels = getMipLevels({
      width,
      height
    });
    urls.push(url);
  }
  (0, _loaderUtils.assert)(mipLevels > 0);
  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = (0, _generateUrl.generateUrl)(getUrl, options, {
      ...urlOptions,
      lod: mipLevel
    });
    urls.push(url);
  }
  return urls;
}
function getMipLevels(_ref) {
  let {
    width,
    height
  } = _ref;
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../parsers/parse-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./generate-url":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js","./deep-load":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js"}],"node_modules/@loaders.gl/images/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ImageLoader", {
  enumerable: true,
  get: function () {
    return _imageLoader.ImageLoader;
  }
});
Object.defineProperty(exports, "ImageWriter", {
  enumerable: true,
  get: function () {
    return _imageWriter.ImageWriter;
  }
});
Object.defineProperty(exports, "getBinaryImageMetadata", {
  enumerable: true,
  get: function () {
    return _binaryImageApi.getBinaryImageMetadata;
  }
});
Object.defineProperty(exports, "getDefaultImageType", {
  enumerable: true,
  get: function () {
    return _imageType.getDefaultImageType;
  }
});
Object.defineProperty(exports, "getImageData", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageData;
  }
});
Object.defineProperty(exports, "getImageSize", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageSize;
  }
});
Object.defineProperty(exports, "getImageType", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageType;
  }
});
Object.defineProperty(exports, "getSupportedImageFormats", {
  enumerable: true,
  get: function () {
    return _imageFormat.getSupportedImageFormats;
  }
});
Object.defineProperty(exports, "isImage", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.isImage;
  }
});
Object.defineProperty(exports, "isImageFormatSupported", {
  enumerable: true,
  get: function () {
    return _imageFormat.isImageFormatSupported;
  }
});
Object.defineProperty(exports, "isImageTypeSupported", {
  enumerable: true,
  get: function () {
    return _imageType.isImageTypeSupported;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadImage.loadImage;
  }
});
var _imageLoader = require("./image-loader");
var _imageWriter = require("./image-writer");
var _binaryImageApi = require("./lib/category-api/binary-image-api");
var _imageType = require("./lib/category-api/image-type");
var _parsedImageApi = require("./lib/category-api/parsed-image-api");
var _imageFormat = require("./lib/category-api/image-format");
var _loadImage = require("./lib/texture-api/load-image");
},{"./image-loader":"node_modules/@loaders.gl/images/dist/esm/image-loader.js","./image-writer":"node_modules/@loaders.gl/images/dist/esm/image-writer.js","./lib/category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js","./lib/category-api/image-type":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","./lib/category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./lib/category-api/image-format":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js","./lib/texture-api/load-image":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js"}],"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;
function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }
  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions['electron'])) {
    return true;
  }
  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }
  return false;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;
var _isElectron = _interopRequireDefault(require("./is-electron"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !true;
  return !isNode || (0, _isElectron.default)();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
},{"./is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.process = exports.global = exports.document = exports.console = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: typeof process === 'object' && process
};
const global_ = globalThis;
exports.global = global_;
const self_ = globals.self || globals.window || globals.global;
exports.self = self_;
const window_ = globals.window || globals.self || globals.global;
exports.window = window_;
const document_ = globals.document || {};
exports.document = document_;
const process_ = globals.process || {};
exports.process = process_;
const console_ = console;
exports.console = console_;
},{"process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
exports.isBrowser = void 0;
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
var _isBrowser = _interopRequireDefault(require("../lib/is-browser"));
var _globals = require("../lib/globals");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
const isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;
},{"../lib/is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","../lib/globals":"node_modules/@probe.gl/env/dist/esm/lib/globals.js","process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/get-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBrowser;
exports.isMobile = isMobile;
var _isBrowser = _interopRequireDefault(require("./is-browser"));
var _isElectron = _interopRequireDefault(require("./is-electron"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = globalThis;
function isMobile() {
  return typeof window.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }
  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }
  const navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  const userAgent = mockUserAgent || navigator_.userAgent || '';
  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  if (isMSIE || isTrident) {
    return 'IE';
  }
  if (window.chrome) {
    return 'Chrome';
  }
  if (window.safari) {
    return 'Safari';
  }
  if (window.mozInnerScreenX) {
    return 'Firefox';
  }
  return 'Unknown';
}
},{"./is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","./is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js"}],"node_modules/@probe.gl/env/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@probe.gl/env/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals2.window;
  }
});
var _globals = require("./utils/globals");
var _globals2 = require("./lib/globals");
var _isBrowser = _interopRequireWildcard(require("./lib/is-browser"));
var _getBrowser = _interopRequireWildcard(require("./lib/get-browser"));
var _isElectron = _interopRequireDefault(require("./lib/is-electron"));
var _assert = _interopRequireDefault(require("./utils/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./utils/globals":"node_modules/@probe.gl/env/dist/esm/utils/globals.js","./lib/globals":"node_modules/@probe.gl/env/dist/esm/lib/globals.js","./lib/is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","./lib/get-browser":"node_modules/@probe.gl/env/dist/esm/lib/get-browser.js","./lib/is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","./utils/assert":"node_modules/@probe.gl/env/dist/esm/utils/assert.js","process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorage = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
class LocalStorage {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _defineProperty2.default)(this, "storage", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "config", void 0);
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
}
exports.LocalStorage = LocalStorage;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@probe.gl/log/dist/esm/utils/formatters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatImage = formatImage;
exports.formatTime = formatTime;
exports.formatValue = formatValue;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}
function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');
  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }
  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;
exports.addColor = addColor;
var _env = require("@probe.gl/env");
let COLOR;
exports.COLOR = COLOR;
(function (COLOR) {
  COLOR[COLOR["BLACK"] = 30] = "BLACK";
  COLOR[COLOR["RED"] = 31] = "RED";
  COLOR[COLOR["GREEN"] = 32] = "GREEN";
  COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
  COLOR[COLOR["BLUE"] = 34] = "BLUE";
  COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
  COLOR[COLOR["CYAN"] = 36] = "CYAN";
  COLOR[COLOR["WHITE"] = 37] = "WHITE";
  COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (exports.COLOR = COLOR = {}));
function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}
function addColor(string, color, background) {
  if (!_env.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@probe.gl/log/dist/esm/utils/autobind.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  for (const key of propNames) {
    if (typeof obj[key] === 'function') {
      if (!predefined.find(name => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiResTimestamp = getHiResTimestamp;
var _env = require("@probe.gl/env");
function getHiResTimestamp() {
  let timestamp;
  if (_env.isBrowser && 'performance' in _env.window) {
    var _window$performance, _window$performance$n;
    timestamp = _env.window === null || _env.window === void 0 ? void 0 : (_window$performance = _env.window.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ('hrtime' in _env.process) {
    var _process$hrtime;
    const timeParts = _env.process === null || _env.process === void 0 ? void 0 : (_process$hrtime = _env.process.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(_env.process);
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@probe.gl/log/dist/esm/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Log = void 0;
exports.normalizeArguments = normalizeArguments;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _env = require("@probe.gl/env");
var _localStorage = require("./utils/local-storage");
var _formatters = require("./utils/formatters");
var _color = require("./utils/color");
var _autobind = require("./utils/autobind");
var _assert = _interopRequireDefault(require("./utils/assert"));
var _hiResTimestamp = require("./utils/hi-res-timestamp");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const originalConsole = {
  debug: _env.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};
function noop() {}
const cache = {};
const ONCE = {
  once: true
};
class Log {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    };
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "VERSION", _env.VERSION);
    (0, _defineProperty2.default)(this, "_startTs", (0, _hiResTimestamp.getHiResTimestamp)());
    (0, _defineProperty2.default)(this, "_deltaTs", (0, _hiResTimestamp.getHiResTimestamp)());
    (0, _defineProperty2.default)(this, "_storage", void 0);
    (0, _defineProperty2.default)(this, "userData", {});
    (0, _defineProperty2.default)(this, "LOG_THROTTLE_TIMEOUT", 0);
    this.id = id;
    this.userData = {};
    this._storage = new _localStorage.LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    (0, _assert.default)(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = '',
      scale = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }
    return _env.isBrowser ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      (0, _assert.default)(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
      const tag = opts.tag || opts.message;
      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = (0, _hiResTimestamp.getHiResTimestamp)();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
}
exports.Log = Log;
(0, _defineProperty2.default)(Log, "VERSION", _env.VERSION);
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;
    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  (0, _assert.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {}
  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case 'object':
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  (0, _assert.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref2;
  console.warn('removed');
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref3;
  if (typeof image === 'string') {
    const img = new Image();
    img.onload = () => {
      const args = (0, _formatters.formatImage)(img, message, scale);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || '';
  if (element.toLowerCase() === 'img') {
    console.log(...(0, _formatters.formatImage)(image, message, scale));
    return noop;
  }
  if (element.toLowerCase() === 'canvas') {
    const img = new Image();
    img.onload = () => console.log(...(0, _formatters.formatImage)(img, message, scale));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }
  return 'empty';
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","./utils/local-storage":"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","./utils/formatters":"node_modules/@probe.gl/log/dist/esm/utils/formatters.js","./utils/color":"node_modules/@probe.gl/log/dist/esm/utils/color.js","./utils/autobind":"node_modules/@probe.gl/log/dist/esm/utils/autobind.js","./utils/assert":"node_modules/@probe.gl/log/dist/esm/utils/assert.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@probe.gl/log/dist/esm/init.js":[function(require,module,exports) {
globalThis.probe = {};

},{}],"node_modules/@probe.gl/log/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _localStorage.LocalStorage;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.Log;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _autobind.autobind;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.getHiResTimestamp;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _formatters.rightPad;
  }
});
var _log = require("./log");
var _color = require("./utils/color");
var _formatters = require("./utils/formatters");
var _autobind = require("./utils/autobind");
var _localStorage = require("./utils/local-storage");
var _hiResTimestamp = require("./utils/hi-res-timestamp");
require("./init");
var _default = new _log.Log({
  id: '@probe.gl/log'
});
exports.default = _default;
},{"./log":"node_modules/@probe.gl/log/dist/esm/log.js","./utils/color":"node_modules/@probe.gl/log/dist/esm/utils/color.js","./utils/formatters":"node_modules/@probe.gl/log/dist/esm/utils/formatters.js","./utils/autobind":"node_modules/@probe.gl/log/dist/esm/utils/autobind.js","./utils/local-storage":"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js","./init":"node_modules/@probe.gl/log/dist/esm/init.js"}],"node_modules/@deck.gl/core/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _log = require("@probe.gl/log");
var _default = new _log.Log({
  id: 'deck'
});
exports.default = _default;
},{"@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/debug/loggers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoggers = void 0;
const logState = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
};
const LOG_LEVEL_MAJOR_UPDATE = 1;
const LOG_LEVEL_MINOR_UPDATE = 2;
const LOG_LEVEL_UPDATE_DETAIL = 3;
const LOG_LEVEL_INFO = 4;
const LOG_LEVEL_DRAW = 2;
const getLoggers = log => ({
  'layer.changeFlag': (layer, key, flags) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
  },
  'layer.initialize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
  },
  'layer.update': (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter(key => flags[key]).join(', ')))();
    } else {
      log.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
    }
  },
  'layer.matched': (layer, changed) => {
    if (changed) {
      log.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
    }
  },
  'layer.finalize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
  },
  'compositeLayer.renderLayers': (layer, updated, subLayers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
    } else {
      log.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
    }
  },
  'layerManager.setLayers': (layerManager, updated, layers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
    }
  },
  'layerManager.activateViewport': (layerManager, viewport) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();
  },
  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
  },
  'attributeManager.updateStart': attributeManager => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  'attributeManager.updateEnd': (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
    for (const updateMessage of logState.attributeUpdateMessages) {
      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }
    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  'attribute.updateStart': attribute => {
    logState.attributeUpdateStart = Date.now();
  },
  'attribute.allocate': (attribute, numInstances) => {
    const message = "".concat(attribute.id, " allocated ").concat(numInstances);
    logState.attributeUpdateMessages.push(message);
  },
  'attribute.updateEnd': (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
    logState.attributeUpdateMessages.push(message);
  },
  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {
    const {
      pass,
      redrawReason,
      stats
    } = opts;
    for (const status of renderStats) {
      const {
        totalCount,
        visibleCount,
        compositeCount,
        pickableCount
      } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
      if (stats) {
        stats.get('Redraw Layers').add(visibleCount);
      }
    }
  }
});
exports.getLoggers = getLoggers;
},{}],"node_modules/@deck.gl/core/dist/esm/debug/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debug;
exports.register = register;
var _log = _interopRequireDefault(require("../utils/log"));
var _loggers = require("./loggers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let loggers = {};
if ("development" !== 'production') {
  loggers = (0, _loggers.getLoggers)(_log.default);
}
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (_log.default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","./loggers":"node_modules/@deck.gl/core/dist/esm/debug/loggers.js"}],"node_modules/@deck.gl/core/dist/esm/utils/json-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === '{' && lastChar === '}' || firstChar === '[' && lastChar === ']';
}
var _default = {
  id: 'JSON',
  name: 'JSON',
  module: '',
  version: '',
  options: {},
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json', 'application/geo+json'],
  testText: isJSON,
  parseTextSync: JSON.parse
};
exports.default = _default;
},{}],"node_modules/@deck.gl/core/dist/esm/lib/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
var _core = require("@loaders.gl/core");
var _images = require("@loaders.gl/images");
var _log = _interopRequireDefault(require("../utils/log"));
var _debug = require("../debug");
var _jsonLoader = _interopRequireDefault(require("../utils/json-loader"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function checkVersion() {
  const version = typeof "8.9.4" !== 'undefined' ? "8.9.4" : globalThis.DECK_VERSION || 'untranspiled source';
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version) {
    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
  }
  if (!existingVersion) {
    _log.default.log(1, "deck.gl ".concat(version))();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version,
      version,
      log: _log.default,
      _registerLoggers: _debug.register
    };
    (0, _core.registerLoaders)([_jsonLoader.default, [_images.ImageLoader, {
      imagebitmap: {
        premultiplyAlpha: 'none'
      }
    }]]);
  }
  return version;
}
const VERSION = checkVersion();
exports.VERSION = VERSION;
},{"@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js","@loaders.gl/images":"node_modules/@loaders.gl/images/dist/esm/index.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/json-loader":"node_modules/@deck.gl/core/dist/esm/utils/json-loader.js"}],"node_modules/@deck.gl/core/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNIT = exports.PROJECTION_MODE = exports.OPERATION = exports.EVENTS = exports.COORDINATE_SYSTEM = void 0;
var _log = _interopRequireDefault(require("../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const COORDINATE_SYSTEM = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
exports.COORDINATE_SYSTEM = COORDINATE_SYSTEM;
Object.defineProperty(COORDINATE_SYSTEM, 'IDENTITY', {
  get: () => {
    _log.default.deprecated('COORDINATE_SYSTEM.IDENTITY', 'COORDINATE_SYSTEM.CARTESIAN')();
    return 0;
  }
});
const PROJECTION_MODE = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
};
exports.PROJECTION_MODE = PROJECTION_MODE;
const UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
exports.UNIT = UNIT;
const EVENTS = {
  click: {
    handler: 'onClick'
  },
  panstart: {
    handler: 'onDragStart'
  },
  panmove: {
    handler: 'onDrag'
  },
  panend: {
    handler: 'onDragEnd'
  }
};
exports.EVENTS = EVENTS;
const OPERATION = {
  DRAW: 'draw',
  MASK: 'mask',
  TERRAIN: 'terrain'
};
exports.OPERATION = OPERATION;
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = void 0;
var _log = require("@probe.gl/log");
const log = new _log.Log({
  id: 'luma.gl'
});
exports.log = log;
},{"@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERR_WEBGL2 = exports.ERR_WEBGL = void 0;
exports.assertWebGL2Context = assertWebGL2Context;
exports.assertWebGLContext = assertWebGLContext;
exports.getWebGL2Context = getWebGL2Context;
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;
var _assert = require("./assert");
const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
const ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  (0, _assert.assert)(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  (0, _assert.assert)(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}
},{"./assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillVertexArrayObject = polyfillVertexArrayObject;
const glErrorShadow = {};
function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}
function log(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}
function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== undefined) {
    error(opt_msg);
  }
}
function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);
    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }
    return 0;
  };
}
const WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
  const gl = ext.gl;
  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;
  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);
  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }
  this.maxAttrib = 0;
};
WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = 5126;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;
  this.cached = '';
  this.recache();
};
WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(':');
};
const OESVertexArrayObject = function OESVertexArrayObject(gl) {
  const self = this;
  this.gl = gl;
  wrapGLError(gl);
  const original = this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  };
  gl.getParameter = function getParameter(pname) {
    if (pname === self.VERTEX_ARRAY_BINDING_OES) {
      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
        return null;
      }
      return self.currentVertexArrayObject;
    }
    return original.getParameter.apply(this, arguments);
  };
  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };
  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };
  gl.bindBuffer = function bindBuffer(target, buffer) {
    switch (target) {
      case 34962:
        self.currentArrayBuffer = buffer;
        break;
      case 34963:
        self.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;
      default:
    }
    return original.bindBuffer.apply(this, arguments);
  };
  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self.currentVertexArrayObject;
    const attrib = vao.attribs[index];
    switch (pname) {
      case 34975:
        return attrib.buffer;
      case 34338:
        return attrib.enabled;
      case 34339:
        return attrib.size;
      case 34340:
        return attrib.stride;
      case 34341:
        return attrib.type;
      case 34922:
        return attrib.normalized;
      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };
  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self.currentArrayBuffer;
    attrib.size = size;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };
  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, 'OES_vertex_array_object');
  }
  if (gl.canvas) {
    gl.canvas.addEventListener('webglcontextrestored', () => {
      log('OESVertexArrayObject emulation library context restored');
      self.reset_();
    }, true);
  }
  this.reset_();
};
OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;
OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== undefined;
  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }
  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(34921);
  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];
  this.bindVertexArrayOES(null);
};
OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};
OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};
OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }
  return false;
};
OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;
  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(1282, 'bindVertexArrayOES: attempt to bind deleted arrayObject');
    return;
  }
  const original = this.original;
  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;
  if (oldVAO === newVAO) {
    return;
  }
  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
  }
  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }
    if (attrib.enabled) {
      let bufferChanged = false;
      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, 34962, attrib.buffer);
          currentBinding = attrib.buffer;
        }
        bufferChanged = true;
      }
      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      }
    }
  }
  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
  }
};
function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === 'function') {
    return;
  }
  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf('OES_vertex_array_object') < 0) {
      list.push('OES_vertex_array_object');
    }
    return list;
  };
  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== 'OES_vertex_array_object') {
      return null;
    }
    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameterPolyfill = getParameterPolyfill;
var _webglChecks = require("../utils/webgl-checks");
const OES_element_index = 'OES_element_index';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const GL_DONT_CARE = 0x1100;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const GL_UNMASKED_VENDOR_WEBGL = 0x9245;
const GL_UNMASKED_RENDERER_WEBGL = 0x9246;
const getWebGL2ValueOrZero = gl => !(0, _webglChecks.isWebGL2)(gl) ? 0 : undefined;
const WEBGL_PARAMETERS = {
  [3074]: gl => !(0, _webglChecks.isWebGL2)(gl) ? 36064 : undefined,
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => !(0, _webglChecks.isWebGL2)(gl) ? GL_DONT_CARE : undefined,
  [35977]: getWebGL2ValueOrZero,
  [32937]: getWebGL2ValueOrZero,
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = (0, _webglChecks.isWebGL2)(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
  },
  [32883]: getWebGL2ValueOrZero,
  [35071]: getWebGL2ValueOrZero,
  [37447]: getWebGL2ValueOrZero,
  [36063]: (gl, getParameter) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return undefined;
  },
  [35379]: getWebGL2ValueOrZero,
  [35374]: getWebGL2ValueOrZero,
  [35377]: getWebGL2ValueOrZero,
  [34852]: gl => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return undefined;
  },
  [36203]: gl => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
  [33001]: gl => gl.getExtension(OES_element_index) ? 16777216 : 65535,
  [33000]: gl => 16777216,
  [37157]: getWebGL2ValueOrZero,
  [35373]: getWebGL2ValueOrZero,
  [35657]: getWebGL2ValueOrZero,
  [36183]: getWebGL2ValueOrZero,
  [37137]: getWebGL2ValueOrZero,
  [34045]: getWebGL2ValueOrZero,
  [35978]: getWebGL2ValueOrZero,
  [35979]: getWebGL2ValueOrZero,
  [35968]: getWebGL2ValueOrZero,
  [35376]: getWebGL2ValueOrZero,
  [35375]: getWebGL2ValueOrZero,
  [35659]: getWebGL2ValueOrZero,
  [37154]: getWebGL2ValueOrZero,
  [35371]: getWebGL2ValueOrZero,
  [35658]: getWebGL2ValueOrZero,
  [35076]: getWebGL2ValueOrZero,
  [35077]: getWebGL2ValueOrZero,
  [35380]: getWebGL2ValueOrZero
};
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}
},{"../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBGL2_CONTEXT_POLYFILLS = exports.WEBGL2_CONTEXT_OVERRIDES = void 0;
var _assert = require("../utils/assert");
var _webglChecks = require("../utils/webgl-checks");
var _getParameterPolyfill = require("./get-parameter-polyfill");
const OES_vertex_array_object = 'OES_vertex_array_object';
const ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';
function getExtensionData(gl, extension) {
  return {
    webgl2: (0, _webglChecks.isWebGL2)(gl),
    ext: gl.getExtension(extension)
  };
}
const WEBGL2_CONTEXT_POLYFILLS = {
  [OES_vertex_array_object]: {
    meta: {
      suffix: 'OES'
    },
    createVertexArray: () => {
      (0, _assert.assert)(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {},
    bindVertexArray: () => {},
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: 'ANGLE'
    },
    vertexAttribDivisor(location, divisor) {
      (0, _assert.assert)(divisor === 0, 'WebGL instanced rendering not supported');
    },
    drawElementsInstanced: () => {},
    drawArraysInstanced: () => {}
  },
  [WEBGL_draw_buffers]: {
    meta: {
      suffix: 'WEBGL'
    },
    drawBuffers: () => {
      (0, _assert.assert)(false);
    }
  },
  [EXT_disjoint_timer_query]: {
    meta: {
      suffix: 'EXT'
    },
    createQuery: () => {
      (0, _assert.assert)(false);
    },
    deleteQuery: () => {
      (0, _assert.assert)(false);
    },
    beginQuery: () => {
      (0, _assert.assert)(false);
    },
    endQuery: () => {},
    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: () => {}
  }
};
exports.WEBGL2_CONTEXT_POLYFILLS = WEBGL2_CONTEXT_POLYFILLS;
const WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: (gl, originalFunc, attachment) => {
    if ((0, _webglChecks.isWebGL2)(gl)) {
      originalFunc(attachment);
    } else {}
  },
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    const {
      webgl2,
      ext
    } = getExtensionData(gl, ANGLE_instanced_arrays);
    let result;
    switch (pname) {
      case 35069:
        result = !webgl2 ? false : undefined;
        break;
      case 35070:
        result = !webgl2 && !ext ? 0 : undefined;
        break;
      default:
    }
    return result !== undefined ? result : originalFunc(location, pname);
  },
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      switch (pname) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
        default:
      }
    }
    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);
        default:
      }
    }
    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        const {
          extensions
        } = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
      default:
    }
    return originalFunc(target, pname);
  },
  getParameter: _getParameterPolyfill.getParameterPolyfill,
  hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }
};
exports.WEBGL2_CONTEXT_OVERRIDES = WEBGL2_CONTEXT_OVERRIDES;
},{"../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","./get-parameter-polyfill":"node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillContext = polyfillContext;
var _polyfillVertexArrayObject = require("./polyfill-vertex-array-object");
var _assert = require("../utils/assert");
var _polyfillTable = require("./polyfill-table");
function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;
  if (!luma.polyfilled) {
    (0, _polyfillVertexArrayObject.polyfillVertexArrayObject)(gl);
    initializeExtensions(gl);
    installPolyfills(gl, _polyfillTable.WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }
  return gl;
}
globalThis.polyfillContext = polyfillContext;
function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}
function installOverrides(gl, _ref) {
  let {
    target,
    target2
  } = _ref;
  Object.keys(_polyfillTable.WEBGL2_CONTEXT_OVERRIDES).forEach(key => {
    if (typeof _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key] === 'function') {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};
      const polyfill = _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}
function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== 'overrides') {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}
function polyfillExtension(gl, _ref2) {
  let {
    extension,
    target,
    target2
  } = _ref2;
  const defaults = _polyfillTable.WEBGL2_CONTEXT_POLYFILLS[extension];
  (0, _assert.assert)(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ''
  } = meta;
  const ext = gl.getExtension(extension);
  for (const key of Object.keys(defaults)) {
    const extKey = "".concat(key).concat(suffix);
    let polyfill = null;
    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {
      polyfill = function () {
        return ext[extKey](...arguments);
      };
    } else if (typeof defaults[key] === 'function') {
      polyfill = defaults[key].bind(target);
    }
    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
},{"./polyfill-vertex-array-object":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","./polyfill-table":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js"}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GL_PARAMETER_SETTERS = exports.GL_PARAMETER_GETTERS = exports.GL_PARAMETER_DEFAULTS = exports.GL_HOOKED_SETTERS = exports.GL_COMPOSITE_PARAMETER_SETTERS = void 0;
var _webglChecks = require("../utils/webgl-checks");
const GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  [2930]: true,
  [3024]: true,
  [36006]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32938]: 1.0,
  [32939]: false,
  [3089]: false,
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 0xffffffff,
  [36005]: 0xffffffff,
  [2962]: 519,
  [2967]: 0,
  [2963]: 0xffffffff,
  [34816]: 519,
  [36003]: 0,
  [36004]: 0xffffffff,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  [2978]: [0, 0, 1024, 1024],
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
exports.GL_PARAMETER_DEFAULTS = GL_PARAMETER_DEFAULTS;
const enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
const hint = (gl, value, key) => gl.hint(key, value);
const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
const drawFramebuffer = (gl, value) => {
  const target = (0, _webglChecks.isWebGL2)(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};
const readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(36008, value);
};
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}
const GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: 'blendEquation',
  [34877]: 'blendEquation',
  [32969]: 'blendFunc',
  [32968]: 'blendFunc',
  [32971]: 'blendFunc',
  [32970]: 'blendFunc',
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [36006]: drawFramebuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: 'polygonOffset',
  [10752]: 'polygonOffset',
  [35977]: enable,
  [32938]: 'sampleCoverage',
  [32939]: 'sampleCoverage',
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: 'stencilFuncFront',
  [2967]: 'stencilFuncFront',
  [2963]: 'stencilFuncFront',
  [34816]: 'stencilFuncBack',
  [36003]: 'stencilFuncBack',
  [36004]: 'stencilFuncBack',
  [2964]: 'stencilOpFront',
  [2965]: 'stencilOpFront',
  [2966]: 'stencilOpFront',
  [34817]: 'stencilOpBack',
  [34818]: 'stencilOpBack',
  [34819]: 'stencilOpBack',
  [2978]: (gl, value) => gl.viewport(...value),
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [36010]: readFramebuffer,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
exports.GL_PARAMETER_SETTERS = GL_PARAMETER_SETTERS;
function getValue(glEnum, values, cache) {
  return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}
const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache) => gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),
  blendFunc: (gl, values, cache) => gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),
  polygonOffset: (gl, values, cache) => gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),
  sampleCoverage: (gl, values, cache) => gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),
  stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),
  stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),
  stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),
  stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))
};
exports.GL_COMPOSITE_PARAMETER_SETTERS = GL_COMPOSITE_PARAMETER_SETTERS;
const GL_HOOKED_SETTERS = {
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint) => update({
    [pname]: hint
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });
      case 36009:
        return update({
          [36006]: framebuffer
        });
      case 36008:
        return update({
          [36010]: framebuffer
        });
      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [32938]: value,
    [32939]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: [x, y, width, height]
  })
};
exports.GL_HOOKED_SETTERS = GL_HOOKED_SETTERS;
const isEnabled = (gl, key) => gl.isEnabled(key);
const GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};
exports.GL_PARAMETER_GETTERS = GL_PARAMETER_GETTERS;
},{"../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepArrayEqual = deepArrayEqual;
exports.isObjectEmpty = isObjectEmpty;
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popContextState = popContextState;
exports.pushContextState = pushContextState;
exports.trackContextState = trackContextState;
var _webglParameterTables = require("./webgl-parameter-tables");
var _unifiedParameterApi = require("./unified-parameter-api");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get() {
    const pname = arguments.length <= 0 ? undefined : arguments[0];
    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...arguments);
    }
    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
  };
  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}
class GLState {
  constructor(gl) {
    let {
      copyState = false,
      log = () => {}
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? (0, _unifiedParameterApi.getParameters)(gl) : Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  push() {
    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.stateStack.push({});
  }
  pop() {
    (0, _assert.assert)(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    (0, _unifiedParameterApi.setParameters)(this.gl, oldValues);
    this.stateStack.pop();
  }
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
    for (const key in values) {
      (0, _assert.assert)(key !== undefined);
      const value = values[key];
      const cached = this.cache[key];
      if (!(0, _utils.deepArrayEqual)(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return {
      valueChanged,
      oldValue
    };
  }
}
function trackContextState(gl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    enable = true,
    copyState
  } = options;
  (0, _assert.assert)(copyState !== undefined);
  if (!gl.state) {
    const {
      polyfillContext
    } = globalThis;
    if (polyfillContext) {
      polyfillContext(gl);
    }
    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);
    for (const key in _webglParameterTables.GL_HOOKED_SETTERS) {
      const setter = _webglParameterTables.GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }
  gl.state.enable = enable;
  return gl;
}
function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }
  gl.state.push();
}
function popContextState(gl) {
  (0, _assert.assert)(gl.state);
  gl.state.pop();
}
},{"./webgl-parameter-tables":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js","./unified-parameter-api":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameters = getParameters;
exports.resetParameters = resetParameters;
exports.setParameters = setParameters;
exports.withParameters = withParameters;
var _webglParameterTables = require("./webgl-parameter-tables");
var _trackContextState = require("./track-context-state");
var _assert = require("../utils/assert");
var _webglChecks = require("../utils/webgl-checks");
var _utils = require("../utils/utils");
function setParameters(gl, values) {
  (0, _assert.assert)((0, _webglChecks.isWebGL)(gl), 'setParameters requires a WebGL context');
  if ((0, _utils.isObjectEmpty)(values)) {
    return;
  }
  const compositeSetters = {};
  for (const key in values) {
    const glConstant = Number(key);
    const setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }
  const cache = gl.state && gl.state.cache;
  if (cache) {
    for (const key in compositeSetters) {
      const compositeSetter = _webglParameterTables.GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, values, cache);
    }
  }
}
function getParameters(gl, parameters) {
  parameters = parameters || _webglParameterTables.GL_PARAMETER_DEFAULTS;
  if (typeof parameters === 'number') {
    const key = parameters;
    const getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetParameters(gl) {
  setParameters(gl, _webglParameterTables.GL_PARAMETER_DEFAULTS);
}
function withParameters(gl, parameters, func) {
  if ((0, _utils.isObjectEmpty)(parameters)) {
    return func(gl);
  }
  const {
    nocatch = true
  } = parameters;
  (0, _trackContextState.pushContextState)(gl);
  setParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    (0, _trackContextState.popContextState)(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      (0, _trackContextState.popContextState)(gl);
    }
  }
  return value;
}
},{"./webgl-parameter-tables":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js","./track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","../utils/utils":"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssToDevicePixels = cssToDevicePixels;
exports.cssToDeviceRatio = cssToDeviceRatio;
exports.getDevicePixelRatio = getDevicePixelRatio;
function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;
  if (gl.canvas && luma) {
    const cachedSize = luma.canvasSizeInfo;
    const clientWidth = 'clientWidth' in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }
  return 1;
}
function cssToDevicePixels(gl, cssPixel) {
  let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/context/context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGLContext = createGLContext;
exports.getContextDebugInfo = getContextDebugInfo;
exports.instrumentGLContext = instrumentGLContext;
exports.resizeGLContext = resizeGLContext;
var _env = require("@probe.gl/env");
var _trackContextState = require("../state-tracker/track-context-state");
var _log = require("../utils/log");
var _assert = require("../utils/assert");
var _devicePixels = require("../utils/device-pixels");
var _webglChecks = require("../utils/webgl-checks");
const isBrowser = (0, _env.isBrowser)();
const isPage = isBrowser && typeof document !== 'undefined';
const CONTEXT_DEFAULTS = {
  webgl2: true,
  webgl1: true,
  throwOnError: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};
function createGLContext() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  (0, _assert.assert)(isBrowser, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    console.error(message);
    return null;
  }
  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);
  if (!gl) {
    return null;
  }
  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
function instrumentGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!gl || gl._instrumented) {
    return gl;
  }
  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug
  } = options;
  if (manageState) {
    (0, _trackContextState.trackContextState)(gl, {
      copyState: false,
      log: function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _log.log.log(1, ...args)();
      }
    });
  }
  if (isBrowser && debug) {
    if (!globalThis.makeDebugContext) {
      _log.log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = globalThis.makeDebugContext(gl, options);
      _log.log.level = Math.max(_log.log.level, 1);
    }
  }
  gl._instrumented = true;
  return gl;
}
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
function resizeGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (gl.canvas) {
    const devicePixelRatio = (0, _devicePixels.getDevicePixelRatio)(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }
  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');
  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}
function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;
  const onCreateError = error => errorMessage = error.statusMessage || errorMessage;
  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;
  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }
  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);
  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', " context: ").concat(errorMessage || 'Unknown error'));
  }
  if (options.onContextLost) {
    canvas.addEventListener('webglcontextlost', options.onContextLost, false);
  }
  if (options.onContextRestored) {
    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);
  }
  return gl;
}
function getCanvas(_ref) {
  let {
    canvas,
    width = 800,
    height = 600,
    onError
  } = _ref;
  let targetCanvas;
  if (typeof canvas === 'string') {
    const isPageLoaded = isPage && document.readyState === 'complete';
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement('canvas');
    targetCanvas.id = 'lumagl-canvas';
    targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
    targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%';
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }
  return targetCanvas;
}
function logInfo(gl) {
  const webGL = (0, _webglChecks.isWebGL2)(gl) ? 'WebGL2' : 'WebGL1';
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
  const debug = gl.debug ? ' debug' : '';
  _log.log.info(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}
function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return 2;
  }
  return 1;
}
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;
  if (!clientWidth || !clientHeight) {
    _log.log.log(1, 'Canvas clientWidth/clientHeight is 0')();
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _log.log.warn("Device pixel ratio clamped")();
      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }
    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","../state-tracker/track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","../utils/log":"node_modules/@luma.gl/gltools/dist/esm/utils/log.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/device-pixels":"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assertWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGL2Context;
  }
});
Object.defineProperty(exports, "assertWebGLContext", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGLContext;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "cssToDevicePixels", {
  enumerable: true,
  get: function () {
    return _devicePixels.cssToDevicePixels;
  }
});
Object.defineProperty(exports, "cssToDeviceRatio", {
  enumerable: true,
  get: function () {
    return _devicePixels.cssToDeviceRatio;
  }
});
Object.defineProperty(exports, "getContextDebugInfo", {
  enumerable: true,
  get: function () {
    return _context.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.getParameters;
  }
});
Object.defineProperty(exports, "getWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.getWebGL2Context;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.log;
  }
});
Object.defineProperty(exports, "polyfillContext", {
  enumerable: true,
  get: function () {
    return _polyfillContext.polyfillContext;
  }
});
Object.defineProperty(exports, "popContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.popContextState;
  }
});
Object.defineProperty(exports, "pushContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.pushContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.resetParameters;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function () {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.setParameters;
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.trackContextState;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.withParameters;
  }
});
var _log = require("./utils/log");
var _webglChecks = require("./utils/webgl-checks");
var _polyfillContext = require("./polyfill/polyfill-context");
var _unifiedParameterApi = require("./state-tracker/unified-parameter-api");
var _trackContextState = require("./state-tracker/track-context-state");
var _context = require("./context/context");
var _devicePixels = require("./utils/device-pixels");
},{"./utils/log":"node_modules/@luma.gl/gltools/dist/esm/utils/log.js","./utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","./polyfill/polyfill-context":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js","./state-tracker/unified-parameter-api":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js","./state-tracker/track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","./context/context":"node_modules/@luma.gl/gltools/dist/esm/context/context.js","./utils/device-pixels":"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js"}],"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/stats/dist/esm/lib/stat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stat {
  constructor(name, type) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "sampleSize", 1);
    (0, _defineProperty2.default)(this, "time", void 0);
    (0, _defineProperty2.default)(this, "count", void 0);
    (0, _defineProperty2.default)(this, "samples", void 0);
    (0, _defineProperty2.default)(this, "lastTiming", void 0);
    (0, _defineProperty2.default)(this, "lastSampleTime", void 0);
    (0, _defineProperty2.default)(this, "lastSampleCount", void 0);
    (0, _defineProperty2.default)(this, "_count", 0);
    (0, _defineProperty2.default)(this, "_time", 0);
    (0, _defineProperty2.default)(this, "_samples", 0);
    (0, _defineProperty2.default)(this, "_startTime", 0);
    (0, _defineProperty2.default)(this, "_timerPending", false);
    this.name = name;
    this.type = type;
    this.reset();
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  incrementCount() {
    this.addCount(1);
    return this;
  }
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  timeStart() {
    this._startTime = (0, _hiResTimestamp.default)();
    this._timerPending = true;
    return this;
  }
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime((0, _hiResTimestamp.default)() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1000) : 0;
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
}
exports.default = Stat;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/hi-res-timestamp":"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@probe.gl/stats/dist/esm/lib/stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _stat = _interopRequireDefault(require("./stat"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stats {
  constructor(options) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "stats", {});
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  get(name) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
    return this._getOrCreate({
      name,
      type
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const key in this.stats) {
      this.stats[key].reset();
    }
    return this;
  }
  forEach(fn) {
    for (const key in this.stats) {
      fn(this.stats[key]);
    }
  }
  getTable() {
    const table = {};
    this.forEach(stat => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    stats.forEach(stat => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    if (!stat || !stat.name) {
      return null;
    }
    const {
      name,
      type
    } = stat;
    if (!this.stats[name]) {
      if (stat instanceof _stat.default) {
        this.stats[name] = stat;
      } else {
        this.stats[name] = new _stat.default(name, type);
      }
    }
    return this.stats[name];
  }
}
exports.default = Stats;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./stat":"node_modules/@probe.gl/stats/dist/esm/lib/stat.js"}],"node_modules/@probe.gl/stats/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _stat.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.default;
  }
});
var _stats = _interopRequireDefault(require("./lib/stats"));
var _stat = _interopRequireDefault(require("./lib/stat"));
var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/stats":"node_modules/@probe.gl/stats/dist/esm/lib/stats.js","./lib/stat":"node_modules/@probe.gl/stats/dist/esm/lib/stat.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@luma.gl/webgl/dist/esm/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lumaStats = exports.default = exports.StatsManager = void 0;
var _gltools = require("@luma.gl/gltools");
var _stats = require("@probe.gl/stats");
var _env = require("@probe.gl/env");
const VERSION = typeof "8.5.20" !== 'undefined' ? "8.5.20" : 'untranspiled source';
const STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';
class StatsManager {
  constructor() {
    this.stats = new Map();
  }
  get(name) {
    if (!this.stats.has(name)) {
      this.stats.set(name, new _stats.Stats({
        id: name
      }));
    }
    return this.stats.get(name);
  }
}
exports.StatsManager = StatsManager;
const lumaStats = new StatsManager();
exports.lumaStats = lumaStats;
if (globalThis.luma && globalThis.luma.VERSION !== VERSION) {
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION));
}
if (!globalThis.luma) {
  if ((0, _env.isBrowser)()) {
    _gltools.log.log(1, "luma.gl ".concat(VERSION, " - ").concat(STARTUP_MESSAGE))();
  }
  globalThis.luma = globalThis.luma || {
    VERSION,
    version: VERSION,
    log: _gltools.log,
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}
var _default = globalThis.luma;
exports.default = _default;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cancelAnimationFrame = cancelAnimationFrame;
exports.requestAnimationFrame = requestAnimationFrame;
function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKey = getKey;
exports.getKeyType = getKeyType;
exports.getKeyValue = getKeyValue;
var _assert = require("../utils/assert");
function getKeyValue(gl, name) {
  if (typeof name !== 'string') {
    return name;
  }
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }
  name = name.replace(/^.*\./, '');
  const value = gl[name];
  (0, _assert.assert)(value !== undefined, "Accessing undefined constant GL.".concat(name));
  return value;
}
function getKey(gl, value) {
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }
  return String(value);
}
function getKeyType(gl, value) {
  (0, _assert.assert)(value !== undefined, 'undefined key');
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }
  return String(value);
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectEmpty = isObjectEmpty;
exports.isPowerOfTwo = isPowerOfTwo;
exports.uid = uid;
var _assert = require("./assert");
const uidCounters = {};
function uid() {
  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return "".concat(id, "-").concat(count);
}
function isPowerOfTwo(n) {
  (0, _assert.assert)(typeof n === 'number', 'Input must be a number');
  return n && (n & n - 1) === 0;
}
function isObjectEmpty(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}
},{"./assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stubRemovedMethods = stubRemovedMethods;
var _gltools = require("@luma.gl/gltools");
function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach(methodName => {
    if (prototype.methodName) {
      return;
    }
    prototype[methodName] = () => {
      _gltools.log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
      throw new Error(methodName);
    };
  });
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _init = require("../init");
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
var _stubMethods = require("../utils/stub-methods");
const ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';
class Resource {
  get [Symbol.toStringTag]() {
    return 'Resource';
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGLContext)(gl);
    const {
      id,
      userData = {}
    } = opts;
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || (0, _utils.uid)(this[Symbol.toStringTag]);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;
    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }
    this.byteLength = 0;
    this._addStats();
  }
  toString() {
    return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const children = this._handle && this._deleteHandle(this._handle);
    if (this._handle) {
      this._removeStats();
    }
    this._handle = null;
    if (children && deleteChildren) {
      children.filter(Boolean).forEach(child => child.delete());
    }
    return this;
  }
  bind() {
    let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;
    if (typeof funcOrHandle !== 'function') {
      this._bindHandle(funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this._bindHandle(this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(pname) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    pname = (0, _constantsToKeys.getKeyValue)(this.gl, pname);
    (0, _assert.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }
    return this._getParameter(pname, opts);
  }
  getParameters() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      parameters,
      keys
    } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);
    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (parameterAvailable) {
        const key = keys ? (0, _constantsToKeys.getKey)(this.gl, pname) : pname;
        values[key] = this.getParameter(pname, options);
        if (keys && parameter.type === 'GLenum') {
          values[key] = (0, _constantsToKeys.getKey)(this.gl, values[key]);
        }
      }
    }
    return values;
  }
  setParameter(pname, value) {
    pname = (0, _constantsToKeys.getKeyValue)(this.gl, pname);
    (0, _assert.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        throw new Error('Parameter not available on this platform');
      }
      if (parameter.type === 'GLenum') {
        value = (0, _constantsToKeys.getKeyValue)(value);
      }
    }
    this._setParameter(pname, value);
    return this;
  }
  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }
    return this;
  }
  stubRemovedMethods(className, version, methodNames) {
    return (0, _stubMethods.stubRemovedMethods)(this, className, version, methodNames);
  }
  initialize(opts) {}
  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getParameter(pname, opts) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _context() {
    this.gl.luma = this.gl.luma || {};
    return this.gl.luma;
  }
  _addStats() {
    const name = this[Symbol.toStringTag];
    const stats = _init.lumaStats.get('Resource Counts');
    stats.get('Resources Created').incrementCount();
    stats.get("".concat(name, "s Created")).incrementCount();
    stats.get("".concat(name, "s Active")).incrementCount();
  }
  _removeStats() {
    const name = this[Symbol.toStringTag];
    const stats = _init.lumaStats.get('Resource Counts');
    stats.get("".concat(name, "s Active")).decrementCount();
  }
  _trackAllocatedMemory(bytes) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
    this._trackAllocatedMemoryForContext(bytes, name);
    this._trackAllocatedMemoryForContext(bytes, name, this.gl.canvas && this.gl.canvas.id);
    this.byteLength = bytes;
  }
  _trackAllocatedMemoryForContext(bytes) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    const stats = _init.lumaStats.get("Memory Usage".concat(id));
    stats.get('GPU Memory').addCount(bytes);
    stats.get("".concat(name, " Memory")).addCount(bytes);
  }
  _trackDeallocatedMemory() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
    this._trackDeallocatedMemoryForContext(name);
    this._trackDeallocatedMemoryForContext(name, this.gl.canvas && this.gl.canvas.id);
    this.byteLength = 0;
  }
  _trackDeallocatedMemoryForContext() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
    let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const stats = _init.lumaStats.get("Memory Usage".concat(id));
    stats.get('GPU Memory').subtractCount(this.byteLength);
    stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
  }
}
exports.default = Resource;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../init":"node_modules/@luma.gl/webgl/dist/esm/init.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","../utils/stub-methods":"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flipRows = flipRows;
exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
exports.scalePixels = scalePixels;
const ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType) {
  let {
    clamped = true
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}
function flipRows(_ref) {
  let {
    data,
    width,
    height,
    bytesPerPixel = 4,
    temp
  } = _ref;
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);
  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}
function scalePixels(_ref2) {
  let {
    data,
    width,
    height
  } = _ref2;
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }
  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkProps = checkProps;
var _gltools = require("@luma.gl/gltools");
function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : 'N/A';
      _gltools.log.removed("".concat(className, ".").concat(propName), replacement)();
    }
  }
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      _gltools.log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
    }
  }
  let newProps = null;
  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      _gltools.log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }
  return newProps || props;
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_ACCESSOR_VALUES = void 0;
var _typedArrayUtils = require("../webgl-utils/typed-array-utils");
var _assert = require("../utils/assert");
var _checkProps = require("../utils/check-props");
const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
exports.DEFAULT_ACCESSOR_VALUES = DEFAULT_ACCESSOR_VALUES;
const PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};
class Accessor {
  static getBytesPerElement(accessor) {
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(accessor) {
    (0, _assert.assert)(accessor.size);
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }
  static resolve() {
    for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
      accessors[_key] = arguments[_key];
    }
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }
  constructor() {
    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }
    accessors.forEach(accessor => this._assign(accessor));
    Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }
  _assign() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    props = (0, _checkProps.checkProps)('Accessor', props, PROP_CHECKS);
    if (props.type !== undefined) {
      this.type = props.type;
      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }
    if (props.size !== undefined) {
      this.size = props.size;
    }
    if (props.offset !== undefined) {
      this.offset = props.offset;
    }
    if (props.stride !== undefined) {
      this.stride = props.stride;
    }
    if (props.normalized !== undefined) {
      this.normalized = props.normalized;
    }
    if (props.integer !== undefined) {
      this.integer = props.integer;
    }
    if (props.divisor !== undefined) {
      this.divisor = props.divisor;
    }
    if (props.buffer !== undefined) {
      this.buffer = props.buffer;
    }
    if (props.index !== undefined) {
      if (typeof props.index === 'boolean') {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }
    if (props.instanced !== undefined) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== undefined) {
      this.divisor = props.isInstanced ? 1 : 0;
    }
    return this;
  }
}
exports.default = Accessor;
},{"../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/check-props":"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _accessor = _interopRequireDefault(require("./accessor"));
var _typedArrayUtils = require("../webgl-utils/typed-array-utils");
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
var _checkProps = require("../utils/check-props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEBUG_DATA_LENGTH = 10;
const DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};
const PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  deprecatedProps: DEPRECATED_PROPS
};
const PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};
class Buffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Buffer';
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, props);
    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);
    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
    this.initialize(props);
    Object.seal(this);
  }
  getElementCount() {
    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / _accessor.default.getBytesPerElement(accessor));
  }
  getVertexCount() {
    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / _accessor.default.getBytesPerVertex(accessor));
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }
    if (Number.isFinite(props)) {
      props = {
        byteLength: props
      };
    }
    props = (0, _checkProps.checkProps)('Buffer', props, PROP_CHECKS_INITIALIZE);
    this.usage = props.usage || 35044;
    this.debugData = null;
    this.setAccessor(Object.assign({}, props, props.accessor));
    if (props.data) {
      this._setData(props.data, props.offset, props.byteLength);
    } else {
      this._setByteLength(props.byteLength || 0);
    }
    return this;
  }
  setProps(props) {
    props = (0, _checkProps.checkProps)('Buffer', props, PROP_CHECKS_SET_PROPS);
    if ('accessor' in props) {
      this.setAccessor(props.accessor);
    }
    return this;
  }
  setAccessor(accessor) {
    accessor = Object.assign({}, accessor);
    delete accessor.buffer;
    this.accessor = new _accessor.default(accessor);
    return this;
  }
  reallocate(byteLength) {
    if (byteLength > this.byteLength) {
      this._setByteLength(byteLength);
      return true;
    }
    this.bytesUsed = byteLength;
    return false;
  }
  setData(props) {
    return this.initialize(props);
  }
  subData(props) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }
    const {
      data,
      offset = 0,
      srcOffset = 0
    } = props;
    const byteLength = props.byteLength || props.length;
    (0, _assert.assert)(data);
    const target = this.gl.webgl2 ? 36663 : this.target;
    this.gl.bindBuffer(target, this.handle);
    if (srcOffset !== 0 || byteLength !== undefined) {
      (0, _gltools.assertWebGL2Context)(this.gl);
      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(target, offset, data);
    }
    this.gl.bindBuffer(target, null);
    this.debugData = null;
    this._inferType(data);
    return this;
  }
  copyData(_ref) {
    let {
      sourceBuffer,
      readOffset = 0,
      writeOffset = 0,
      size
    } = _ref;
    const {
      gl
    } = this;
    (0, _gltools.assertWebGL2Context)(gl);
    gl.bindBuffer(36662, sourceBuffer.handle);
    gl.bindBuffer(36663, this.handle);
    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
    gl.bindBuffer(36662, null);
    gl.bindBuffer(36663, null);
    this.debugData = null;
    return this;
  }
  getData() {
    let {
      dstData = null,
      srcByteOffset = 0,
      dstOffset = 0,
      length = 0
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _gltools.assertWebGL2Context)(this.gl);
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
    const dstElementOffset = dstOffset;
    let dstAvailableElementCount;
    let dstElementCount;
    if (dstData) {
      dstElementCount = dstData.length;
      dstAvailableElementCount = dstElementCount - dstElementOffset;
    } else {
      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
      dstElementCount = dstElementOffset + dstAvailableElementCount;
    }
    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
    length = length || copyElementCount;
    (0, _assert.assert)(length <= copyElementCount);
    dstData = dstData || new ArrayType(dstElementCount);
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
    this.gl.bindBuffer(36662, null);
    return dstData;
  }
  bind() {
    let {
      target = this.target,
      index = this.accessor && this.accessor.index,
      offset = 0,
      size
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (target === 35345 || target === 35982) {
      if (size !== undefined) {
        this.gl.bindBufferRange(target, index, this.handle, offset, size);
      } else {
        (0, _assert.assert)(offset === 0);
        this.gl.bindBufferBase(target, index, this.handle);
      }
    } else {
      this.gl.bindBuffer(target, this.handle);
    }
    return this;
  }
  unbind() {
    let {
      target = this.target,
      index = this.accessor && this.accessor.index
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const isIndexedBuffer = target === 35345 || target === 35982;
    if (isIndexedBuffer) {
      this.gl.bindBufferBase(target, index, null);
    } else {
      this.gl.bindBuffer(target, null);
    }
    return this;
  }
  getDebugData() {
    if (!this.debugData) {
      this.debugData = this.getData({
        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
      });
      return {
        data: this.debugData,
        changed: true
      };
    }
    return {
      data: this.debugData,
      changed: false
    };
  }
  invalidateDebugData() {
    this.debugData = null;
  }
  _setData(data) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;
    (0, _assert.assert)(ArrayBuffer.isView(data));
    this._trackDeallocatedMemory();
    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, byteLength, this.usage);
    this.gl.bufferSubData(target, offset, data);
    this.gl.bindBuffer(target, null);
    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
    this.bytesUsed = byteLength;
    this._trackAllocatedMemory(byteLength);
    const type = (0, _typedArrayUtils.getGLTypeFromTypedArray)(data);
    (0, _assert.assert)(type);
    this.setAccessor(new _accessor.default(this.accessor, {
      type
    }));
    return this;
  }
  _setByteLength(byteLength) {
    let usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
    (0, _assert.assert)(byteLength >= 0);
    this._trackDeallocatedMemory();
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data, usage);
    this.gl.bindBuffer(target, null);
    this.usage = usage;
    this.debugData = null;
    this.bytesUsed = byteLength;
    this._trackAllocatedMemory(byteLength);
    return this;
  }
  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }
  _getAvailableElementCount(srcByteOffset) {
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
    return this.getElementCount() - sourceElementOffset;
  }
  _inferType(data) {
    if (!this.accessor.type) {
      this.setAccessor(new _accessor.default(this.accessor, {
        type: (0, _typedArrayUtils.getGLTypeFromTypedArray)(data)
      }));
    }
  }
  _createHandle() {
    return this.gl.createBuffer();
  }
  _deleteHandle() {
    this.gl.deleteBuffer(this.handle);
    this._trackDeallocatedMemory();
  }
  _getParameter(pname) {
    this.gl.bindBuffer(this.target, this.handle);
    const value = this.gl.getBufferParameter(this.target, pname);
    this.gl.bindBuffer(this.target, null);
    return value;
  }
  get type() {
    _gltools.log.deprecated('Buffer.type', 'Buffer.accessor.type')();
    return this.accessor.type;
  }
  get bytes() {
    _gltools.log.deprecated('Buffer.bytes', 'Buffer.byteLength')();
    return this.byteLength;
  }
  setByteLength(byteLength) {
    _gltools.log.deprecated('setByteLength', 'reallocate')();
    return this.reallocate(byteLength);
  }
  updateAccessor(opts) {
    _gltools.log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();
    this.accessor = new _accessor.default(this.accessor, opts);
    return this;
  }
}
exports.default = Buffer;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/check-props":"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TYPE_SIZES = exports.TEXTURE_FORMATS = exports.DATA_FORMAT_CHANNELS = void 0;
exports.isFormatSupported = isFormatSupported;
exports.isLinearFilteringSupported = isLinearFilteringSupported;
var _gltools = require("@luma.gl/gltools");
const TEXTURE_FORMATS = {
  [6407]: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  [6408]: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  [6406]: {
    dataFormat: 6406,
    types: [5121]
  },
  [6409]: {
    dataFormat: 6409,
    types: [5121]
  },
  [6410]: {
    dataFormat: 6410,
    types: [5121]
  },
  [33326]: {
    dataFormat: 6403,
    types: [5126],
    gl2: true
  },
  [33328]: {
    dataFormat: 33319,
    types: [5126],
    gl2: true
  },
  [34837]: {
    dataFormat: 6407,
    types: [5126],
    gl2: true
  },
  [34836]: {
    dataFormat: 6408,
    types: [5126],
    gl2: true
  }
};
exports.TEXTURE_FORMATS = TEXTURE_FORMATS;
const DATA_FORMAT_CHANNELS = {
  [6403]: 1,
  [36244]: 1,
  [33319]: 2,
  [33320]: 2,
  [6407]: 3,
  [36248]: 3,
  [6408]: 4,
  [36249]: 4,
  [6402]: 1,
  [34041]: 1,
  [6406]: 1,
  [6409]: 1,
  [6410]: 2
};
exports.DATA_FORMAT_CHANNELS = DATA_FORMAT_CHANNELS;
const TYPE_SIZES = {
  [5126]: 4,
  [5125]: 4,
  [5124]: 4,
  [5123]: 2,
  [5122]: 2,
  [5131]: 2,
  [5120]: 1,
  [5121]: 1
};
exports.TYPE_SIZES = TYPE_SIZES;
function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (info.gl1 === undefined && info.gl2 === undefined) {
    return true;
  }
  const value = (0, _gltools.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}
function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension('OES_texture_float_linear');
    case 5131:
      return gl.getExtension('OES_texture_half_float_linear');
    default:
      return true;
  }
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _resource = _interopRequireDefault(require("./resource"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _textureFormats = require("./texture-formats");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NPOT_MIN_FILTERS = [9729, 9728];
const WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};
class Texture extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Texture';
  }
  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      format,
      linearFiltering
    } = opts;
    let supported = true;
    if (format) {
      supported = supported && (0, _textureFormats.isFormatSupported)(gl, format);
      supported = supported && (!linearFiltering || (0, _textureFormats.isLinearFilteringSupported)(gl, format));
    }
    return supported;
  }
  constructor(gl, props) {
    const {
      id = (0, _utils.uid)('texture'),
      handle,
      target
    } = props;
    super(gl, {
      id,
      handle
    });
    this.target = target;
    this.textureUnit = undefined;
    this.loaded = false;
    this.width = undefined;
    this.height = undefined;
    this.depth = undefined;
    this.format = undefined;
    this.type = undefined;
    this.dataFormat = undefined;
    this.border = undefined;
    this.textureUnit = undefined;
    this.mipmaps = undefined;
  }
  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let data = props.data;
    if (data instanceof Promise) {
      data.then(resolvedImageData => this.initialize(Object.assign({}, props, {
        pixels: resolvedImageData,
        data: resolvedImageData
      })));
      return this;
    }
    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;
    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data.addEventListener('loadeddata', () => this.initialize(props));
      return this;
    }
    const {
      pixels = null,
      format = 6408,
      border = 0,
      recreate = false,
      parameters = {},
      pixelStore = {},
      textureUnit = undefined
    } = props;
    if (!data) {
      data = pixels;
    }
    let {
      width,
      height,
      dataFormat,
      type,
      compressed = false,
      mipmaps = true
    } = props;
    const {
      depth = 0
    } = props;
    ({
      width,
      height,
      compressed,
      dataFormat,
      type
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.format = format;
    this.type = type;
    this.dataFormat = dataFormat;
    this.border = border;
    this.textureUnit = textureUnit;
    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(33984 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }
    if (mipmaps && this._isNPOT()) {
      _gltools.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      mipmaps = false;
      this._updateForNPOT(parameters);
    }
    this.mipmaps = mipmaps;
    this.setImageData({
      data,
      width,
      height,
      depth,
      format,
      type,
      dataFormat,
      border,
      mipmaps,
      parameters: pixelStore,
      compressed
    });
    if (mipmaps) {
      this.generateMipmap();
    }
    this.setParameters(parameters);
    if (recreate) {
      this.data = data;
    }
    if (isVideo) {
      this._video = {
        video: data,
        parameters,
        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
      };
    }
    return this;
  }
  update() {
    if (this._video) {
      const {
        video,
        parameters,
        lastTime
      } = this._video;
      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }
      this.setSubImageData({
        data: video,
        parameters
      });
      if (this.mipmaps) {
        this.generateMipmap();
      }
      this._video.lastTime = video.currentTime;
    }
  }
  resize(_ref) {
    let {
      height,
      width,
      mipmaps = false
    } = _ref;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        border: this.border,
        mipmaps
      });
    }
    return this;
  }
  generateMipmap() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this._isNPOT()) {
      _gltools.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      return this;
    }
    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }
  setImageData(options) {
    this._trackDeallocatedMemory('Texture');
    const {
      target = this.target,
      pixels = null,
      level = 0,
      format = this.format,
      border = this.border,
      offset = 0,
      parameters = {}
    } = options;
    let {
      data = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;
    if (!data) {
      data = pixels;
    }
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    const {
      gl
    } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({
      data,
      dataType
    } = this._getDataType({
      data,
      compressed
    }));
    let gl2;
    let compressedTextureSize = 0;
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      switch (dataType) {
        case 'null':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          break;
        case 'typed-array':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
          break;
        case 'buffer':
          gl2 = (0, _gltools.assertWebGL2Context)(gl);
          gl2.bindBuffer(35052, data.handle || data);
          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
          break;
        case 'browser-object':
          if ((0, _gltools.isWebGL2)(gl)) {
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          } else {
            gl.texImage2D(target, level, format, dataFormat, type, data);
          }
          break;
        case 'compressed':
          for (const [levelIndex, levelData] of data.entries()) {
            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
            compressedTextureSize += levelData.levelSize;
          }
          break;
        default:
          (0, _assert.assert)(false, 'Unknown image data type');
      }
    });
    if (dataType === 'compressed') {
      this._trackAllocatedMemory(compressedTextureSize, 'Texture');
    } else if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
    }
    this.loaded = true;
    return this;
  }
  setSubImageData(_ref2) {
    let {
      target = this.target,
      pixels = null,
      data = null,
      x = 0,
      y = 0,
      width = this.width,
      height = this.height,
      level = 0,
      format = this.format,
      type = this.type,
      dataFormat = this.dataFormat,
      compressed = false,
      offset = 0,
      border = this.border,
      parameters = {}
    } = _ref2;
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    (0, _assert.assert)(this.depth === 0, 'texSubImage not supported for 3D textures');
    if (!data) {
      data = pixels;
    }
    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }
    if (data instanceof _buffer.default) {
      data = data.handle;
    }
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
      } else if (data instanceof WebGLBuffer) {
        const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
        gl2.bindBuffer(35052, data);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        gl2.bindBuffer(35052, null);
      } else if ((0, _gltools.isWebGL2)(this.gl)) {
        const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
      }
    });
    this.gl.bindTexture(this.target, null);
  }
  copyFramebuffer() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();
    return null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind() {
    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
    const {
      gl
    } = this;
    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }
  unbind() {
    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
    const {
      gl
    } = this;
    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, null);
    return textureUnit;
  }
  _getDataType(_ref3) {
    let {
      data,
      compressed = false
    } = _ref3;
    if (compressed) {
      return {
        data,
        dataType: 'compressed'
      };
    }
    if (data === null) {
      return {
        data,
        dataType: 'null'
      };
    }
    if (ArrayBuffer.isView(data)) {
      return {
        data,
        dataType: 'typed-array'
      };
    }
    if (data instanceof _buffer.default) {
      return {
        data: data.handle,
        dataType: 'buffer'
      };
    }
    if (data instanceof WebGLBuffer) {
      return {
        data,
        dataType: 'buffer'
      };
    }
    return {
      data,
      dataType: 'browser-object'
    };
  }
  _deduceParameters(opts) {
    const {
      format,
      data
    } = opts;
    let {
      width,
      height,
      dataFormat,
      type,
      compressed
    } = opts;
    const textureFormat = _textureFormats.TEXTURE_FORMATS[format];
    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
    type = type || textureFormat && textureFormat.types[0];
    compressed = compressed || textureFormat && textureFormat.compressed;
    ({
      width,
      height
    } = this._deduceImageSize(data, width, height));
    return {
      dataFormat,
      type,
      compressed,
      width,
      height,
      format,
      data
    };
  }
  _deduceImageSize(data, width, height) {
    let size;
    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
      size = {
        width: data.naturalWidth,
        height: data.naturalHeight
      };
    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
      size = {
        width: data.videoWidth,
        height: data.videoHeight
      };
    } else if (!data) {
      size = {
        width: width >= 0 ? width : 1,
        height: height >= 0 ? height : 1
      };
    } else {
      size = {
        width,
        height
      };
    }
    (0, _assert.assert)(size, 'Could not deduced texture size');
    (0, _assert.assert)(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
    (0, _assert.assert)(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
    return size;
  }
  _createHandle() {
    return this.gl.createTexture();
  }
  _deleteHandle() {
    this.gl.deleteTexture(this.handle);
    this._trackDeallocatedMemory('Texture');
  }
  _getParameter(pname) {
    switch (pname) {
      case 4096:
        return this.width;
      case 4097:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const value = this.gl.getTexParameter(this.target, pname);
        this.gl.bindTexture(this.target, null);
        return value;
    }
  }
  _setParameter(pname, param) {
    this.gl.bindTexture(this.target, this.handle);
    param = this._getNPOTParam(pname, param);
    switch (pname) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, pname, param);
        break;
      case 4096:
      case 4097:
        (0, _assert.assert)(false);
        break;
      default:
        this.gl.texParameteri(this.target, pname, param);
        break;
    }
    this.gl.bindTexture(this.target, null);
    return this;
  }
  _isNPOT() {
    if ((0, _gltools.isWebGL2)(this.gl)) {
      return false;
    }
    if (!this.width || !this.height) {
      return false;
    }
    return !(0, _utils.isPowerOfTwo)(this.width) || !(0, _utils.isPowerOfTwo)(this.height);
  }
  _updateForNPOT(parameters) {
    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
    }
    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
    }
    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
  }
  _getNPOTParam(pname, param) {
    if (this._isNPOT()) {
      switch (pname) {
        case 10241:
          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
            param = 9729;
          }
          break;
        case 10242:
        case 10243:
          if (param !== 33071) {
            param = 33071;
          }
          break;
        default:
          break;
      }
    }
    return param;
  }
}
exports.default = Texture;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./texture-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFile = loadFile;
exports.loadImage = loadImage;
exports.setPathPrefix = setPathPrefix;
var _assert = require("../utils/assert");
let pathPrefix = '';
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function loadFile(url) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assert.assert)(typeof url === 'string');
  url = pathPrefix + url;
  const dataType = options.dataType || 'text';
  return fetch(url, options).then(res => res[dataType]());
}
function loadImage(url, opts) {
  (0, _assert.assert)(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _texture = _interopRequireDefault(require("./texture"));
var _loadFile = require("../utils/load-file");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Texture2D extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'Texture2D';
  }
  static isSupported(gl, opts) {
    return _texture.default.isSupported(gl, opts);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGLContext)(gl);
    if (props instanceof Promise || typeof props === 'string') {
      props = {
        data: props
      };
    }
    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {
        data: (0, _loadFile.loadImage)(props.data)
      });
    }
    super(gl, Object.assign({}, props, {
      target: 3553
    }));
    this.initialize(props);
    Object.seal(this);
  }
}
exports.default = Texture2D;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils/load-file":"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _texture = _interopRequireDefault(require("./texture"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const FACES = [34069, 34070, 34071, 34072, 34073, 34074];
class TextureCube extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'TextureCube';
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGLContext)(gl);
    super(gl, Object.assign({}, props, {
      target: 34067
    }));
    this.initialize(props);
    Object.seal(this);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      mipmaps = true,
      parameters = {}
    } = props;
    this.opts = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;
      if (mipmaps) {
        this.generateMipmap(props);
      }
      this.setParameters(parameters);
    });
    return this;
  }
  subImage(_ref) {
    let {
      face,
      data,
      x = 0,
      y = 0,
      mipmapLevel = 0
    } = _ref;
    return this._subImage({
      target: face,
      data,
      x,
      y,
      mipmapLevel
    });
  }
  async setCubeMapImageData(_ref2) {
    let {
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = _ref2;
    const {
      gl
    } = this;
    const imageDataMap = pixels || data;
    const resolvedFaces = await Promise.all(FACES.map(face => {
      const facePixels = imageDataMap[face];
      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
    }));
    this.bind();
    FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
        _gltools.log.warn("".concat(this.id, " has mipmap and multiple LODs."))();
      }
      resolvedFaces[index].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });
    this.unbind();
  }
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = options;
    const {
      gl
    } = this;
    const imageData = pixels || data;
    this.bind();
    if (imageData instanceof Promise) {
      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }
    return this;
  }
}
exports.default = TextureCube;
TextureCube.FACES = FACES;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _texture = _interopRequireDefault(require("./texture"));
var _textureFormats = require("./texture-formats");
var _buffer = _interopRequireDefault(require("./buffer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Texture3D extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'Texture3D';
  }
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGL2Context)(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    super(gl, props);
    this.initialize(props);
    Object.seal(this);
  }
  setImageData(_ref) {
    let {
      level = 0,
      dataFormat = 6408,
      width,
      height,
      depth = 1,
      border = 0,
      format,
      type = 5121,
      offset = 0,
      data,
      parameters = {}
    } = _ref;
    this._trackDeallocatedMemory('Texture');
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
      }
      if (data instanceof _buffer.default) {
        this.gl.bindBuffer(35052, data.handle);
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
      }
    });
    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');
    }
    this.loaded = true;
    return this;
  }
}
exports.default = Texture3D;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./texture-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';
var _default = {
  [33189]: {
    bpp: 2
  },
  [33190]: {
    gl2: true,
    bpp: 3
  },
  [36012]: {
    gl2: true,
    bpp: 4
  },
  [36168]: {
    bpp: 1
  },
  [34041]: {
    bpp: 4
  },
  [35056]: {
    gl2: true,
    bpp: 4
  },
  [36013]: {
    gl2: true,
    bpp: 5
  },
  [32854]: {
    bpp: 2
  },
  [36194]: {
    bpp: 2
  },
  [32855]: {
    bpp: 2
  },
  [33321]: {
    gl2: true,
    bpp: 1
  },
  [33330]: {
    gl2: true,
    bpp: 1
  },
  [33329]: {
    gl2: true,
    bpp: 1
  },
  [33332]: {
    gl2: true,
    bpp: 2
  },
  [33331]: {
    gl2: true,
    bpp: 2
  },
  [33334]: {
    gl2: true,
    bpp: 4
  },
  [33333]: {
    gl2: true,
    bpp: 4
  },
  [33323]: {
    gl2: true,
    bpp: 2
  },
  [33336]: {
    gl2: true,
    bpp: 2
  },
  [33335]: {
    gl2: true,
    bpp: 2
  },
  [33338]: {
    gl2: true,
    bpp: 4
  },
  [33337]: {
    gl2: true,
    bpp: 4
  },
  [33340]: {
    gl2: true,
    bpp: 8
  },
  [33339]: {
    gl2: true,
    bpp: 8
  },
  [32849]: {
    gl2: true,
    bpp: 3
  },
  [32856]: {
    gl2: true,
    bpp: 4
  },
  [32857]: {
    gl2: true,
    bpp: 4
  },
  [36220]: {
    gl2: true,
    bpp: 4
  },
  [36238]: {
    gl2: true,
    bpp: 4
  },
  [36975]: {
    gl2: true,
    bpp: 4
  },
  [36214]: {
    gl2: true,
    bpp: 8
  },
  [36232]: {
    gl2: true,
    bpp: 8
  },
  [36226]: {
    gl2: true,
    bpp: 16
  },
  [36208]: {
    gl2: true,
    bpp: 16
  },
  [33325]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 2
  },
  [33327]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [34842]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [33326]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [33328]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [34836]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 16
  },
  [35898]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }
};
exports.default = _default;
},{}],"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _renderbufferFormats = _interopRequireDefault(require("./renderbuffer-formats"));
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isFormatSupported(gl, format, formats) {
  const info = formats[format];
  if (!info) {
    return false;
  }
  const value = (0, _gltools.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  if (typeof value === 'string') {
    return gl.getExtension(value);
  }
  return value;
}
class Renderbuffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Renderbuffer';
  }
  static isSupported(gl) {
    let {
      format
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      format: null
    };
    return !format || isFormatSupported(gl, format, _renderbufferFormats.default);
  }
  static getSamplesForFormat(gl, _ref) {
    let {
      format
    } = _ref;
    return gl.getInternalformatParameter(36161, format, 32937);
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.initialize(opts);
    Object.seal(this);
  }
  initialize(_ref2) {
    let {
      format,
      width = 1,
      height = 1,
      samples = 0
    } = _ref2;
    (0, _assert.assert)(format, 'Needs format');
    this._trackDeallocatedMemory();
    this.gl.bindRenderbuffer(36161, this.handle);
    if (samples !== 0 && (0, _gltools.isWebGL2)(this.gl)) {
      this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
    } else {
      this.gl.renderbufferStorage(36161, format, width, height);
    }
    this.format = format;
    this.width = width;
    this.height = height;
    this.samples = samples;
    this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * _renderbufferFormats.default[this.format].bpp);
    return this;
  }
  resize(_ref3) {
    let {
      width,
      height
    } = _ref3;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        samples: this.samples
      });
    }
    return this;
  }
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);
    this._trackDeallocatedMemory();
  }
  _bindHandle(handle) {
    this.gl.bindRenderbuffer(36161, handle);
  }
  _syncHandle(handle) {
    this.format = this.getParameter(36164);
    this.width = this.getParameter(36162);
    this.height = this.getParameter(36163);
    this.samples = this.getParameter(36011);
  }
  _getParameter(pname) {
    this.gl.bindRenderbuffer(36161, this.handle);
    const value = this.gl.getRenderbufferParameter(36161, pname);
    return value;
  }
}
exports.default = Renderbuffer;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./renderbuffer-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearBuffer = clearBuffer;
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_COLOR = 0x1800;
const GL_DEPTH = 0x1801;
const GL_STENCIL = 0x1802;
const GL_DEPTH_STENCIL = 0x84f9;
const ERR_ARGUMENTS = 'clear: bad arguments';
function clear(gl) {
  let {
    framebuffer = null,
    color = null,
    depth = null,
    stencil = null
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  (0, _assert.assert)(clearFlags !== 0, ERR_ARGUMENTS);
  (0, _gltools.withParameters)(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
function clearBuffer(gl) {
  let {
    framebuffer = null,
    buffer = GL_COLOR,
    drawBuffer = 0,
    value = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _gltools.assertWebGL2Context)(gl);
  (0, _gltools.withParameters)(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;
          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;
          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }
        break;
      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;
      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;
      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;
      default:
        (0, _assert.assert)(false, ERR_ARGUMENTS);
    }
  });
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glFormatToComponents = glFormatToComponents;
exports.glTypeToBytes = glTypeToBytes;
var _assert = require("../utils/assert");
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blit = blit;
exports.copyToDataUrl = copyToDataUrl;
exports.copyToImage = copyToImage;
exports.copyToTexture = copyToTexture;
exports.readPixelsToArray = readPixelsToArray;
exports.readPixelsToBuffer = readPixelsToBuffer;
var _buffer = _interopRequireDefault(require("./buffer"));
var _framebuffer = _interopRequireDefault(require("./framebuffer"));
var _texture = _interopRequireDefault(require("./texture"));
var _gltools = require("@luma.gl/gltools");
var _typedArrayUtils = require("../webgl-utils/typed-array-utils");
var _formatUtils = require("../webgl-utils/format-utils");
var _textureUtils = require("../webgl-utils/texture-utils");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function readPixelsToArray(source) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }
  (0, _assert.assert)(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || (0, _typedArrayUtils.getGLTypeFromTypedArray)(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function readPixelsToBuffer(source, _ref) {
  let {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    target = null,
    targetByteOffset = 0,
    sourceWidth,
    sourceHeight,
    sourceType
  } = _ref;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const gl2 = (0, _gltools.assertWebGL2Context)(framebuffer.gl);
  sourceType = sourceType || (target ? target.type : 5121);
  if (!target) {
    const components = (0, _formatUtils.glFormatToComponents)(sourceFormat);
    const byteCount = (0, _formatUtils.glTypeToBytes)(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer.default(gl2, {
      byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }
  target.bind({
    target: 35051
  });
  (0, _gltools.withParameters)(gl2, {
    framebuffer
  }, () => {
    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function copyToDataUrl(source) {
  let {
    sourceAttachment = 36064,
    targetMaxHeight = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let data = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;
  while (height > targetMaxHeight) {
    ({
      data,
      width,
      height
    } = (0, _typedArrayUtils.scalePixels)({
      data,
      width,
      height
    }));
  }
  (0, _typedArrayUtils.flipRows)({
    data,
    width,
    height
  });
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d');
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}
function copyToImage(source) {
  let {
    sourceAttachment = 36064,
    targetImage = null
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const dataUrl = copyToDataUrl(source, {
    sourceAttachment
  });
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}
function copyToTexture(source, target) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  (0, _assert.assert)(target);
  let texture = null;
  if (target instanceof _texture.default) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }
  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        const gl2 = (0, _gltools.assertWebGL2Context)(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return texture;
}
function blit(source, target) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    sourceX0 = 0,
    sourceY0 = 0,
    targetX0 = 0,
    targetY0 = 0,
    color = true,
    depth = false,
    stencil = false,
    filter = 9728
  } = options;
  let {
    sourceX1,
    sourceY1,
    targetX1,
    targetY1,
    sourceAttachment = 36064,
    mask = 0
  } = options;
  const {
    framebuffer: srcFramebuffer,
    deleteFramebuffer: deleteSrcFramebuffer
  } = getFramebuffer(source);
  const {
    framebuffer: dstFramebuffer,
    deleteFramebuffer: deleteDstFramebuffer
  } = getFramebuffer(target);
  (0, _assert.assert)(srcFramebuffer);
  (0, _assert.assert)(dstFramebuffer);
  const {
    gl,
    handle,
    width,
    height,
    readBuffer
  } = dstFramebuffer;
  const gl2 = (0, _gltools.assertWebGL2Context)(gl);
  if (!srcFramebuffer.handle && sourceAttachment === 36064) {
    sourceAttachment = 1028;
  }
  if (color) {
    mask |= 16384;
  }
  if (depth) {
    mask |= 256;
  }
  if (stencil) {
    mask |= 1024;
  }
  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    if (mask & (256 | 1024)) {
      mask = 16384;
      _gltools.log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }
  (0, _assert.assert)(mask);
  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;
  const prevDrawHandle = gl.bindFramebuffer(36009, handle);
  const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
  gl2.readBuffer(sourceAttachment);
  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
  gl2.readBuffer(readBuffer);
  gl2.bindFramebuffer(36008, prevReadHandle || null);
  gl2.bindFramebuffer(36009, prevDrawHandle || null);
  if (deleteSrcFramebuffer) {
    srcFramebuffer.delete();
  }
  if (deleteDstFramebuffer) {
    dstFramebuffer.delete();
  }
  return dstFramebuffer;
}
function getFramebuffer(source) {
  if (!(source instanceof _framebuffer.default)) {
    return {
      framebuffer: (0, _textureUtils.toFramebuffer)(source),
      deleteFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(type, {
    clamped: false
  });
  const components = (0, _formatUtils.glFormatToComponents)(format);
  return new ArrayType(width * height * components);
}
},{"./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../webgl-utils/format-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js","../webgl-utils/texture-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  [33902]: {
    gl1: new Float32Array([1, 1])
  },
  [33901]: {
    gl1: new Float32Array([1, 1])
  },
  [3379]: {
    gl1: 64,
    gl2: 2048
  },
  [34076]: {
    gl1: 16
  },
  [34930]: {
    gl1: 8
  },
  [35661]: {
    gl1: 8
  },
  [35660]: {
    gl1: 0
  },
  [34024]: {
    gl1: 1
  },
  [36348]: {
    gl1: 8
  },
  [34921]: {
    gl1: 8
  },
  [36347]: {
    gl1: 128
  },
  [36349]: {
    gl1: 16
  },
  [3386]: {
    gl1: new Int32Array([0, 0])
  },
  [32883]: {
    gl1: 0,
    gl2: 256
  },
  [35071]: {
    gl1: 0,
    gl2: 256
  },
  [37447]: {
    gl1: 0,
    gl2: 0
  },
  [36063]: {
    gl1: 0,
    gl2: 4
  },
  [35379]: {
    gl1: 0,
    gl2: 0
  },
  [35374]: {
    gl1: 0,
    gl2: 0
  },
  [35377]: {
    gl1: 0,
    gl2: 0
  },
  [34852]: {
    gl1: 0,
    gl2: 4
  },
  [36203]: {
    gl1: 0,
    gl2: 0
  },
  [33001]: {
    gl1: 0,
    gl2: 0
  },
  [33000]: {
    gl1: 0,
    gl2: 0
  },
  [37157]: {
    gl1: 0,
    gl2: 0
  },
  [35373]: {
    gl1: 0,
    gl2: 0
  },
  [35657]: {
    gl1: 0,
    gl2: 0
  },
  [36183]: {
    gl1: 0,
    gl2: 0
  },
  [37137]: {
    gl1: 0,
    gl2: 0
  },
  [34045]: {
    gl1: 0,
    gl2: 0
  },
  [35978]: {
    gl1: 0,
    gl2: 0
  },
  [35979]: {
    gl1: 0,
    gl2: 0
  },
  [35968]: {
    gl1: 0,
    gl2: 0
  },
  [35376]: {
    gl1: 0,
    gl2: 0
  },
  [35375]: {
    gl1: 0,
    gl2: 0
  },
  [35659]: {
    gl1: 0,
    gl2: 0
  },
  [37154]: {
    gl1: 0,
    gl2: 0
  },
  [35371]: {
    gl1: 0,
    gl2: 0
  },
  [35658]: {
    gl1: 0,
    gl2: 0
  },
  [35076]: {
    gl1: 0,
    gl2: -8,
    negative: true
  },
  [35077]: {
    gl1: 0,
    gl2: 7
  },
  [35380]: {
    gl1: 0,
    gl2: 0
  }
};
exports.default = _default;
},{}],"node_modules/@luma.gl/webgl/dist/esm/features/limits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextInfo = getContextInfo;
exports.getContextLimits = getContextLimits;
exports.getGLContextInfo = getGLContextInfo;
var _webglLimitsTable = _interopRequireDefault(require("./webgl-limits-table"));
var _gltools = require("@luma.gl/gltools");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getContextLimits(gl) {
  gl.luma = gl.luma || {};
  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};
    const isWebgl2 = (0, _gltools.isWebGL2)(gl);
    for (const parameter in _webglLimitsTable.default) {
      const limit = _webglLimitsTable.default[parameter];
      const webgl1MinLimit = limit.gl1;
      const webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      const minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;
      const limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
      const value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }
  return gl.luma.limits;
}
function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};
  const info = (0, _gltools.getContextDebugInfo)(gl);
  if (!gl.luma.info) {
    gl.luma.info = {
      [37445]: info.vendor,
      [37446]: info.renderer,
      [7936]: info.vendorMasked,
      [7937]: info.rendererMasked,
      [7938]: info.version,
      [35724]: info.shadingLanguageVersion
    };
  }
  return gl.luma.info;
}
function getContextInfo(gl) {
  return Object.assign((0, _gltools.getContextDebugInfo)(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}
},{"./webgl-limits-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FEATURES = void 0;
var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));
var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const FEATURES = {
  WEBGL2: 'WEBGL2',
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  FLOAT_BLEND: 'FLOAT_BLEND',
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',
  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};
exports.FEATURES = FEATURES;
function checkFloat32ColorAttachment(gl) {
  const testTexture = new _texture2d.default(gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new _framebuffer.default(gl, {
    id: "test-framebuffer",
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}
var _default = {
  [FEATURES.WEBGL2]: [false, true],
  [FEATURES.VERTEX_ARRAY_OBJECT]: ['OES_vertex_array_object', true],
  [FEATURES.TIMER_QUERY]: ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2'],
  [FEATURES.INSTANCED_RENDERING]: ['ANGLE_instanced_arrays', true],
  [FEATURES.MULTIPLE_RENDER_TARGETS]: ['WEBGL_draw_buffers', true],
  [FEATURES.ELEMENT_INDEX_UINT32]: ['OES_element_index_uint', true],
  [FEATURES.BLEND_EQUATION_MINMAX]: ['EXT_blend_minmax', true],
  [FEATURES.FLOAT_BLEND]: ['EXT_float_blend'],
  [FEATURES.COLOR_ENCODING_SRGB]: ['EXT_sRGB', true],
  [FEATURES.TEXTURE_DEPTH]: ['WEBGL_depth_texture', true],
  [FEATURES.TEXTURE_FLOAT]: ['OES_texture_float', true],
  [FEATURES.TEXTURE_HALF_FLOAT]: ['OES_texture_half_float', true],
  [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ['OES_texture_float_linear'],
  [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ['OES_texture_half_float_linear'],
  [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ['EXT_texture_filter_anisotropic'],
  [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ['EXT_color_buffer_half_float'],
  [FEATURES.GLSL_FRAG_DATA]: ['WEBGL_draw_buffers', true],
  [FEATURES.GLSL_FRAG_DEPTH]: ['EXT_frag_depth', true],
  [FEATURES.GLSL_DERIVATIVES]: ['OES_standard_derivatives', true],
  [FEATURES.GLSL_TEXTURE_LOD]: ['EXT_shader_texture_lod', true]
};
exports.default = _default;
},{"../classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/features.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFeatures = getFeatures;
exports.hasFeature = hasFeature;
exports.hasFeatures = hasFeatures;
var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_UNSUPPORTED_FEATURE = 2;
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => {
    return isFeatureSupported(gl, feature);
  });
}
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  for (const cap in _webglFeaturesTable.default) {
    if (gl.luma.caps[cap] === undefined) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }
  return gl.luma.caps;
}
function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  if (gl.luma.caps[cap] === undefined) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }
  if (!gl.luma.caps[cap]) {
    _gltools.log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
  }
  return gl.luma.caps[cap];
}
function queryFeature(gl, cap) {
  const feature = _webglFeaturesTable.default[cap];
  (0, _assert.assert)(feature, cap);
  let isSupported;
  const featureDefinition = (0, _gltools.isWebGL2)(gl) ? feature[1] || feature[0] : feature[0];
  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    (0, _assert.assert)(false);
  }
  return isSupported;
}
},{"./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;
function isOldIE() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const navigator = typeof window !== 'undefined' && window.navigator || {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = canCompileGLGSExtension;
var _checkOldIe = _interopRequireDefault(require("./check-old-ie"));
var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const feature = _webglFeaturesTable.default[cap];
  (0, _assert.assert)(feature, cap);
  if (!(0, _checkOldIe.default)(options)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const source = "#extension GL_".concat(extensionName, " : enable\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
},{"./check-old-ie":"node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js","./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
var _limits = require("./limits");
var _webglFeaturesTable = require("./webgl-features-table");
var _features = require("./features");
var _checkGlslExtension = _interopRequireDefault(require("./check-glsl-extension"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./limits":"node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features":"node_modules/@luma.gl/webgl/dist/esm/features/features.js","./check-glsl-extension":"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = void 0;
var _gltools = require("@luma.gl/gltools");
var _resource = _interopRequireDefault(require("./resource"));
var _texture2d = _interopRequireDefault(require("./texture-2d"));
var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));
var _clear = require("./clear");
var _copyAndBlit = require("./copy-and-blit.js");
var _features = require("../features");
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';
class Framebuffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Framebuffer';
  }
  static isSupported(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      colorBufferFloat,
      colorBufferHalfFloat
    } = options;
    let supported = true;
    if (colorBufferFloat) {
      supported = Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float') || gl.getExtension('OES_texture_float'));
    }
    if (colorBufferHalfFloat) {
      supported = supported && Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float'));
    }
    return supported;
  }
  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
      id: 'default-framebuffer',
      handle: null,
      attachments: {}
    });
    return gl.luma.defaultFramebuffer;
  }
  get MAX_COLOR_ATTACHMENTS() {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
  }
  get MAX_DRAW_BUFFERS() {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = 36064;
    this.drawBuffers = [36064];
    this.ownResources = [];
    this.initialize(opts);
    Object.seal(this);
  }
  get color() {
    return this.attachments[36064] || null;
  }
  get texture() {
    return this.attachments[36064] || null;
  }
  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }
  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }
  initialize(_ref) {
    let {
      width = 1,
      height = 1,
      attachments = null,
      color = true,
      depth = true,
      stencil = false,
      check = true,
      readBuffer = undefined,
      drawBuffers = undefined
    } = _ref;
    (0, _assert.assert)(width >= 0 && height >= 0, 'Width and height need to be integers');
    this.width = width;
    this.height = height;
    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({
          width,
          height
        });
      }
    } else {
      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
    }
    this.update({
      clearAttachments: true,
      attachments,
      readBuffer,
      drawBuffers
    });
    if (attachments && check) {
      this.checkStatus();
    }
  }
  delete() {
    for (const resource of this.ownResources) {
      resource.delete();
    }
    super.delete();
    return this;
  }
  update(_ref2) {
    let {
      attachments = {},
      readBuffer,
      drawBuffers,
      clearAttachments = false,
      resizeAttachments = true
    } = _ref2;
    this.attach(attachments, {
      clearAttachments,
      resizeAttachments
    });
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }
    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }
    gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }
  resize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let {
      width,
      height
    } = options;
    if (this.handle === null) {
      (0, _assert.assert)(width === undefined && height === undefined);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }
    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }
    if (width !== this.width && height !== this.height) {
      _gltools.log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
    }
    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({
        width,
        height
      });
    }
    this.width = width;
    this.height = height;
    return this;
  }
  attach(attachments) {
    let {
      clearAttachments = false,
      resizeAttachments = true
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const newAttachments = {};
    if (clearAttachments) {
      Object.keys(this.attachments).forEach(key => {
        newAttachments[key] = null;
      });
    }
    Object.assign(newAttachments, attachments);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    for (const key in newAttachments) {
      (0, _assert.assert)(key !== undefined, 'Misspelled framebuffer binding point?');
      const attachment = Number(key);
      const descriptor = newAttachments[attachment];
      let object = descriptor;
      if (!object) {
        this._unattach(attachment);
      } else if (object instanceof _renderbuffer.default) {
        this._attachRenderbuffer({
          attachment,
          renderbuffer: object
        });
      } else if (Array.isArray(descriptor)) {
        const [texture, layer = 0, level = 0] = descriptor;
        object = texture;
        this._attachTexture({
          attachment,
          texture,
          layer,
          level
        });
      } else {
        this._attachTexture({
          attachment,
          texture: object,
          layer: 0,
          level: 0
        });
      }
      if (resizeAttachments && object) {
        object.resize({
          width: this.width,
          height: this.height
        });
      }
    }
    this.gl.bindFramebuffer(36160, prevHandle || null);
    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {
      delete this.attachments[key];
    });
  }
  checkStatus() {
    const {
      gl
    } = this;
    const status = this.getStatus();
    if (status !== 36053) {
      throw new Error(_getFrameBufferStatus(status));
    }
    return this;
  }
  getStatus() {
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);
    return status;
  }
  clear() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      color,
      depth,
      stencil,
      drawBuffers = []
    } = options;
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    if (color || depth || stencil) {
      (0, _clear.clear)(this.gl, {
        color,
        depth,
        stencil
      });
    }
    drawBuffers.forEach((value, drawBuffer) => {
      (0, _clear.clearBuffer)(this.gl, {
        drawBuffer,
        value
      });
    });
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }
  readPixels() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();
    return null;
  }
  readPixelsToBuffer() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();
    return null;
  }
  copyToDataUrl() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();
    return null;
  }
  copyToImage() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();
    return null;
  }
  copyToTexture() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();
    return null;
  }
  blit() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();
    return null;
  }
  invalidate(_ref3) {
    let {
      attachments = [],
      x = 0,
      y = 0,
      width,
      height
    } = _ref3;
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    const prevHandle = gl2.bindFramebuffer(36008, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;
    if (invalidateAll) {
      gl2.invalidateFramebuffer(36008, attachments);
    } else {
      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
    }
    gl2.bindFramebuffer(36008, prevHandle);
    return this;
  }
  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);
    if (value === null) {
      this.gl.bindFramebuffer(36160, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
      this.gl.bindFramebuffer(36160, null);
    }
    if (keys && value > 1000) {
      value = (0, _constantsToKeys.getKey)(this.gl, value);
    }
    return value;
  }
  getAttachmentParameters() {
    let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;
    let keys = arguments.length > 1 ? arguments[1] : undefined;
    let parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
    const values = {};
    for (const pname of parameters) {
      const key = keys ? (0, _constantsToKeys.getKey)(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }
    return values;
  }
  getParameters() {
    let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    const attachments = Object.keys(this.attachments);
    const parameters = {};
    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? (0, _constantsToKeys.getKey)(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }
    return parameters;
  }
  show() {
    if (typeof window !== 'undefined') {
      window.open((0, _copyAndBlit.copyToDataUrl)(this), 'luma-debug-texture');
    }
    return this;
  }
  log() {
    let logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (logLevel > _gltools.log.level || typeof window === 'undefined') {
      return this;
    }
    message = message || "Framebuffer ".concat(this.id);
    const image = (0, _copyAndBlit.copyToDataUrl)(this, {
      targetMaxHeight: 100
    });
    _gltools.log.image({
      logLevel,
      message,
      image
    }, message)();
    return this;
  }
  bind() {
    let {
      target = 36160
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }
  unbind() {
    let {
      target = 36160
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.gl.bindFramebuffer(target, null);
    return this;
  }
  _createDefaultAttachments(color, depth, stencil, width, height) {
    let defaultAttachments = null;
    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36064] = new _texture2d.default(this.gl, {
        id: "".concat(this.id, "-color0"),
        pixels: null,
        format: 6408,
        type: 5121,
        width,
        height,
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.ownResources.push(defaultAttachments[36064]);
    }
    if (depth && stencil) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[33306] = new _renderbuffer.default(this.gl, {
        id: "".concat(this.id, "-depth-stencil"),
        format: 35056,
        width,
        height: 111
      });
      this.ownResources.push(defaultAttachments[33306]);
    } else if (depth) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36096] = new _renderbuffer.default(this.gl, {
        id: "".concat(this.id, "-depth"),
        format: 33189,
        width,
        height
      });
      this.ownResources.push(defaultAttachments[36096]);
    } else if (stencil) {
      (0, _assert.assert)(false);
    }
    return defaultAttachments;
  }
  _unattach(attachment) {
    const oldAttachment = this.attachments[attachment];
    if (!oldAttachment) {
      return;
    }
    if (oldAttachment instanceof _renderbuffer.default) {
      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
    } else {
      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
    }
    delete this.attachments[attachment];
  }
  _attachRenderbuffer(_ref4) {
    let {
      attachment = 36064,
      renderbuffer
    } = _ref4;
    const {
      gl
    } = this;
    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
    this.attachments[attachment] = renderbuffer;
  }
  _attachTexture(_ref5) {
    let {
      attachment = 36064,
      texture,
      layer,
      level
    } = _ref5;
    const {
      gl
    } = this;
    gl.bindTexture(texture.target, texture.handle);
    switch (texture.target) {
      case 35866:
      case 32879:
        const gl2 = (0, _gltools.assertWebGL2Context)(gl);
        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        (0, _assert.assert)(false, 'Illegal texture type');
    }
    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  }
  _setReadBuffer(readBuffer) {
    const gl2 = (0, _gltools.getWebGL2Context)(this.gl);
    if (gl2) {
      gl2.readBuffer(readBuffer);
    } else {
      (0, _assert.assert)(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
    }
    this.readBuffer = readBuffer;
  }
  _setDrawBuffers(drawBuffers) {
    const {
      gl
    } = this;
    const gl2 = (0, _gltools.assertWebGL2Context)(gl);
    if (gl2) {
      gl2.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension('WEBGL_draw_buffers');
      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        (0, _assert.assert)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
      }
    }
    this.drawBuffers = drawBuffers;
  }
  _getAttachmentParameterFallback(pname) {
    const caps = (0, _features.getFeatures)(this.gl);
    switch (pname) {
      case 36052:
        return !caps.WEBGL2 ? 0 : null;
      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return !caps.WEBGL2 ? 8 : null;
      case 33297:
        return !caps.WEBGL2 ? 5125 : null;
      case 33296:
        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
      default:
        return null;
    }
  }
  _createHandle() {
    return this.gl.createFramebuffer();
  }
  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }
  _bindHandle(handle) {
    return this.gl.bindFramebuffer(36160, handle);
  }
}
exports.default = Framebuffer;
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}
const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./clear":"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./copy-and-blit.js":"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","../features":"node_modules/@luma.gl/webgl/dist/esm/features/index.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTextureFrom = cloneTextureFrom;
exports.toFramebuffer = toFramebuffer;
var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));
var _textureCube = _interopRequireDefault(require("../classes/texture-cube"));
var _texture3d = _interopRequireDefault(require("../classes/texture-3d"));
var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function cloneTextureFrom(refTexture, overrides) {
  (0, _assert.assert)(refTexture instanceof _texture2d.default || refTexture instanceof _textureCube.default || refTexture instanceof _texture3d.default);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}
function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new _framebuffer.default(gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}
},{"../classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","../classes/texture-cube":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","../classes/texture-3d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","../classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderName;
function getShaderName(shader) {
  let defaultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unnamed';
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderTypeName;
const GL_FRAGMENT_SHADER = 0x8b30;
const GL_VERTEX_SHADER = 0x8b31;
function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';
    case GL_VERTEX_SHADER:
      return 'vertex';
    default:
      return 'unknown type';
  }
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatGLSLCompilerError;
exports.parseGLSLCompilerError = parseGLSLCompilerError;
var _getShaderName = _interopRequireDefault(require("./get-shader-name"));
var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function formatGLSLCompilerError(errLog, src, shaderType) {
  const {
    shaderName,
    errors,
    warnings
  } = parseGLSLCompilerError(errLog, src, shaderType);
  return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || (0, _getShaderName.default)(src) || '(unnamed)';
  const shaderDescription = "".concat((0, _getShaderTypeName.default)(shaderType), " shader ").concat(name);
  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    const segments = errorString.split(':');
    const type = segments[0];
    const line = parseInt(segments[2], 10);
    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }
    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }
  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}
function formatErrors(errors, lines) {
  let message = '';
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }
    message += "".concat(line, "\n");
    if (errors[i + 1]) {
      const error = errors[i + 1];
      const segments = error.split(':', 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }
  return message;
}
function addLineNumbers(string) {
  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start);
    const digits = lineNumber.length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}
function padLeft(string, digits) {
  let result = '';
  for (let i = 0; i < digits; ++i) {
    result += ' ';
  }
  return "".concat(result).concat(string);
}
},{"./get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-type-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderVersion;
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);
  if (words.length >= 2 && words[0] === '#version') {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version = v;
    }
  }
  return version;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "formatGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.default;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderTypeName", {
  enumerable: true,
  get: function () {
    return _getShaderTypeName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "parseGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.parseGLSLCompilerError;
  }
});
var _formatGlslError = _interopRequireWildcard(require("./format-glsl-error"));
var _getShaderName = _interopRequireDefault(require("./get-shader-name"));
var _getShaderVersion = _interopRequireDefault(require("./get-shader-version"));
var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./format-glsl-error":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js","./get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-version":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","./get-shader-type-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VertexShader = exports.Shader = exports.FragmentShader = void 0;
var _gltools = require("@luma.gl/gltools");
var _glslUtils = require("../glsl-utils");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
var _resource = _interopRequireDefault(require("./resource"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';
class Shader extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Shader';
  }
  static getTypeName(shaderType) {
    switch (shaderType) {
      case 35633:
        return 'vertex-shader';
      case 35632:
        return 'fragment-shader';
      default:
        (0, _assert.assert)(false);
        return 'unknown';
    }
  }
  constructor(gl, props) {
    (0, _gltools.assertWebGLContext)(gl);
    (0, _assert.assert)(typeof props.source === 'string', ERR_SOURCE);
    const id = (0, _glslUtils.getShaderName)(props.source, null) || props.id || (0, _utils.uid)("unnamed ".concat(Shader.getTypeName(props.shaderType)));
    super(gl, {
      id
    });
    this.shaderType = props.shaderType;
    this.source = props.source;
    this.initialize(props);
  }
  initialize(_ref) {
    let {
      source
    } = _ref;
    const shaderName = (0, _glslUtils.getShaderName)(source, null);
    if (shaderName) {
      this.id = (0, _utils.uid)(shaderName);
    }
    this._compile(source);
  }
  getParameter(pname) {
    return this.gl.getShaderParameter(this.handle, pname);
  }
  toString() {
    return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
  }
  getName() {
    return (0, _glslUtils.getShaderName)(this.source) || 'unnamed-shader';
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  getTranslatedSource() {
    const extension = this.gl.getExtension('WEBGL_debug_shaders');
    return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';
  }
  _compile() {
    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;
    if (!source.startsWith('#version ')) {
      source = "#version 100\n".concat(source);
    }
    this.source = source;
    this.gl.shaderSource(this.handle, this.source);
    this.gl.compileShader(this.handle);
    const compileStatus = this.getParameter(35713);
    if (!compileStatus) {
      const infoLog = this.gl.getShaderInfoLog(this.handle);
      const {
        shaderName,
        errors,
        warnings
      } = (0, _glslUtils.parseGLSLCompilerError)(infoLog, this.source, this.shaderType, this.id);
      _gltools.log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
      _gltools.log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
      throw new Error("GLSL compilation errors in ".concat(shaderName));
    }
  }
  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }
}
exports.Shader = Shader;
class VertexShader extends Shader {
  get [Symbol.toStringTag]() {
    return 'VertexShader';
  }
  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }
    super(gl, Object.assign({}, props, {
      shaderType: 35633
    }));
  }
  _createHandle() {
    return this.gl.createShader(35633);
  }
}
exports.VertexShader = VertexShader;
class FragmentShader extends Shader {
  get [Symbol.toStringTag]() {
    return 'FragmentShader';
  }
  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }
    super(gl, Object.assign({}, props, {
      shaderType: 35632
    }));
  }
  _createHandle() {
    return this.gl.createShader(35632);
  }
}
exports.FragmentShader = FragmentShader;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../glsl-utils":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkUniformValues = checkUniformValues;
exports.copyUniform = copyUniform;
exports.getUniformSetter = getUniformSetter;
exports.parseUniformName = parseUniformName;
var _gltools = require("@luma.gl/gltools");
var _framebuffer = _interopRequireDefault(require("./framebuffer"));
var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));
var _texture = _interopRequireDefault(require("./texture"));
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const UNIFORM_SETTERS = {
  [5126]: getArraySetter.bind(null, 'uniform1fv', toFloatArray, 1, setVectorUniform),
  [35664]: getArraySetter.bind(null, 'uniform2fv', toFloatArray, 2, setVectorUniform),
  [35665]: getArraySetter.bind(null, 'uniform3fv', toFloatArray, 3, setVectorUniform),
  [35666]: getArraySetter.bind(null, 'uniform4fv', toFloatArray, 4, setVectorUniform),
  [5124]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35667]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35668]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35669]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35670]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35671]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35672]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35673]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35674]: getArraySetter.bind(null, 'uniformMatrix2fv', toFloatArray, 4, setMatrixUniform),
  [35675]: getArraySetter.bind(null, 'uniformMatrix3fv', toFloatArray, 9, setMatrixUniform),
  [35676]: getArraySetter.bind(null, 'uniformMatrix4fv', toFloatArray, 16, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [5125]: getArraySetter.bind(null, 'uniform1uiv', toUIntArray, 1, setVectorUniform),
  [36294]: getArraySetter.bind(null, 'uniform2uiv', toUIntArray, 2, setVectorUniform),
  [36295]: getArraySetter.bind(null, 'uniform3uiv', toUIntArray, 3, setVectorUniform),
  [36296]: getArraySetter.bind(null, 'uniform4uiv', toUIntArray, 4, setVectorUniform),
  [35685]: getArraySetter.bind(null, 'uniformMatrix2x3fv', toFloatArray, 6, setMatrixUniform),
  [35686]: getArraySetter.bind(null, 'uniformMatrix2x4fv', toFloatArray, 8, setMatrixUniform),
  [35687]: getArraySetter.bind(null, 'uniformMatrix3x2fv', toFloatArray, 6, setMatrixUniform),
  [35688]: getArraySetter.bind(null, 'uniformMatrix3x4fv', toFloatArray, 12, setMatrixUniform),
  [35689]: getArraySetter.bind(null, 'uniformMatrix4x2fv', toFloatArray, 8, setMatrixUniform),
  [35690]: getArraySetter.bind(null, 'uniformMatrix4x3fv', toFloatArray, 12, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [35679]: getSamplerSetter,
  [35682]: getSamplerSetter,
  [36289]: getSamplerSetter,
  [36292]: getSamplerSetter,
  [36293]: getSamplerSetter,
  [36298]: getSamplerSetter,
  [36299]: getSamplerSetter,
  [36300]: getSamplerSetter,
  [36303]: getSamplerSetter,
  [36306]: getSamplerSetter,
  [36307]: getSamplerSetter,
  [36308]: getSamplerSetter,
  [36311]: getSamplerSetter
};
const FLOAT_ARRAY = {};
const INT_ARRAY = {};
const UINT_ARRAY = {};
const array1 = [0];
function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }
  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }
  const length = value.length;
  if (length % uniformLength) {
    _gltools.log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }
  if (value instanceof Type) {
    return value;
  }
  let result = cache[length];
  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }
  for (let i = 0; i < length; i++) {
    result[i] = value[i];
  }
  return result;
}
function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}
function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }
  return setter().bind(null, gl, location);
}
function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = name.match(UNIFORM_NAME_REGEXP);
  if (!matches || matches.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }
  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}
function checkUniformValues(uniforms, source, uniformMap) {
  for (const uniformName in uniforms) {
    const value = uniforms[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : '';
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }
  return true;
}
function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }
  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture.default) {
    return true;
  } else if (value instanceof _renderbuffer.default) {
    return true;
  } else if (value instanceof _framebuffer.default) {
    return Boolean(value.texture);
  }
  return false;
}
function copyUniform(uniforms, key, value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    if (uniforms[key]) {
      const dest = uniforms[key];
      for (let i = 0, len = value.length; i < len; ++i) {
        dest[i] = value[i];
      }
    } else {
      uniforms[key] = value.slice();
    }
  } else {
    uniforms[key] = value;
  }
}
function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }
  const checkLength = Math.min(value.length, 16);
  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }
  return true;
}
function getSamplerSetter() {
  let cache = null;
  return (gl, location, value) => {
    const update = cache !== value;
    if (update) {
      gl.uniform1i(location, value);
      cache = value;
    }
    return update;
  };
}
function getArraySetter(functionName, toArray, size, uniformSetter) {
  let cache = null;
  let cacheLength = null;
  return (gl, location, value) => {
    const arrayValue = toArray(value, size);
    const length = arrayValue.length;
    let update = false;
    if (cache === null) {
      cache = new Float32Array(length);
      cacheLength = length;
      update = true;
    } else {
      (0, _assert.assert)(cacheLength === length, 'Uniform length cannot change.');
      for (let i = 0; i < length; ++i) {
        if (arrayValue[i] !== cache[i]) {
          update = true;
          break;
        }
      }
    }
    if (update) {
      uniformSetter(gl, functionName, location, arrayValue);
      cache.set(arrayValue);
    }
    return update;
  };
}
function setVectorUniform(gl, functionName, location, value) {
  gl[functionName](location, value);
}
function setMatrixUniform(gl, functionName, location, value) {
  gl[functionName](location, false, value);
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decomposeCompositeGLType = decomposeCompositeGLType;
exports.getCompositeGLType = getCompositeGLType;
exports.getPrimitiveCount = getPrimitiveCount;
exports.getPrimitiveDrawMode = getPrimitiveDrawMode;
exports.getVertexCount = getVertexCount;
var _assert = require("../utils/assert");
const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_POINTS = 0x0;
const GL_LINES = 0x1;
const GL_LINE_LOOP = 0x2;
const GL_LINE_STRIP = 0x3;
const GL_TRIANGLES = 0x4;
const GL_TRIANGLE_STRIP = 0x5;
const GL_TRIANGLE_FAN = 0x6;
const GL_FLOAT = 0x1406;
const GL_FLOAT_VEC2 = 0x8b50;
const GL_FLOAT_VEC3 = 0x8b51;
const GL_FLOAT_VEC4 = 0x8b52;
const GL_INT = 0x1404;
const GL_INT_VEC2 = 0x8b53;
const GL_INT_VEC3 = 0x8b54;
const GL_INT_VEC4 = 0x8b55;
const GL_UNSIGNED_INT = 0x1405;
const GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const GL_UNSIGNED_INT_VEC4 = 0x8dc8;
const GL_BOOL = 0x8b56;
const GL_BOOL_VEC2 = 0x8b57;
const GL_BOOL_VEC3 = 0x8b58;
const GL_BOOL_VEC4 = 0x8b59;
const GL_FLOAT_MAT2 = 0x8b5a;
const GL_FLOAT_MAT3 = 0x8b5b;
const GL_FLOAT_MAT4 = 0x8b5c;
const GL_FLOAT_MAT2x3 = 0x8b65;
const GL_FLOAT_MAT2x4 = 0x8b66;
const GL_FLOAT_MAT3x2 = 0x8b67;
const GL_FLOAT_MAT3x4 = 0x8b68;
const GL_FLOAT_MAT4x2 = 0x8b69;
const GL_FLOAT_MAT4x3 = 0x8b6a;
const COMPOSITE_GL_TYPES = {
  [GL_FLOAT]: [GL_FLOAT, 1, 'float'],
  [GL_FLOAT_VEC2]: [GL_FLOAT, 2, 'vec2'],
  [GL_FLOAT_VEC3]: [GL_FLOAT, 3, 'vec3'],
  [GL_FLOAT_VEC4]: [GL_FLOAT, 4, 'vec4'],
  [GL_INT]: [GL_INT, 1, 'int'],
  [GL_INT_VEC2]: [GL_INT, 2, 'ivec2'],
  [GL_INT_VEC3]: [GL_INT, 3, 'ivec3'],
  [GL_INT_VEC4]: [GL_INT, 4, 'ivec4'],
  [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, 'uint'],
  [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, 'uvec2'],
  [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, 'uvec3'],
  [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, 'uvec4'],
  [GL_BOOL]: [GL_FLOAT, 1, 'bool'],
  [GL_BOOL_VEC2]: [GL_FLOAT, 2, 'bvec2'],
  [GL_BOOL_VEC3]: [GL_FLOAT, 3, 'bvec3'],
  [GL_BOOL_VEC4]: [GL_FLOAT, 4, 'bvec4'],
  [GL_FLOAT_MAT2]: [GL_FLOAT, 8, 'mat2'],
  [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, 'mat2x3'],
  [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, 'mat2x4'],
  [GL_FLOAT_MAT3]: [GL_FLOAT, 12, 'mat3'],
  [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, 'mat3x2'],
  [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, 'mat3x4'],
  [GL_FLOAT_MAT4]: [GL_FLOAT, 16, 'mat4'],
  [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, 'mat4x2'],
  [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, 'mat4x3']
};
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;
    case GL_LINES:
      return GL_LINES;
    case GL_LINE_STRIP:
      return GL_LINES;
    case GL_LINE_LOOP:
      return GL_LINES;
    case GL_TRIANGLES:
      return GL_TRIANGLES;
    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;
    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function getPrimitiveCount(_ref) {
  let {
    drawMode,
    vertexCount
  } = _ref;
  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;
    case GL_LINES:
      return vertexCount / 2;
    case GL_LINE_STRIP:
      return vertexCount - 1;
    case GL_TRIANGLES:
      return vertexCount / 3;
    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function getVertexCount(_ref2) {
  let {
    drawMode,
    vertexCount
  } = _ref2;
  const primitiveCount = getPrimitiveCount({
    drawMode,
    vertexCount
  });
  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;
    case GL_LINES:
      return primitiveCount * 2;
    case GL_TRIANGLES:
      return primitiveCount * 3;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
  if (!typeAndSize) {
    return null;
  }
  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}
function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;
    default:
  }
  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }
  return null;
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _accessor = _interopRequireDefault(require("./accessor"));
var _gltools = require("@luma.gl/gltools");
var _attributeUtils = require("../webgl-utils/attribute-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ProgramConfiguration {
  constructor(program) {
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);
    this._readAttributesFromProgram(program);
    this._readVaryingsFromProgram(program);
  }
  getAttributeInfo(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return this.attributeInfosByLocation[location];
    }
    return this.attributeInfosByName[locationOrName] || null;
  }
  getAttributeLocation(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.location : -1;
  }
  getAttributeAccessor(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.accessor : null;
  }
  getVaryingInfo(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return this.varyingInfos[location];
    }
    return this.varyingInfosByName[locationOrName] || null;
  }
  getVaryingIndex(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.location : -1;
  }
  getVaryingAccessor(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.accessor : null;
  }
  _readAttributesFromProgram(program) {
    const {
      gl
    } = program;
    const count = gl.getProgramParameter(program.handle, 35721);
    for (let index = 0; index < count; index++) {
      const {
        name,
        type,
        size
      } = gl.getActiveAttrib(program.handle, index);
      const location = gl.getAttribLocation(program.handle, name);
      if (location >= 0) {
        this._addAttribute(location, name, type, size);
      }
    }
    this.attributeInfos.sort((a, b) => a.location - b.location);
  }
  _readVaryingsFromProgram(program) {
    const {
      gl
    } = program;
    if (!(0, _gltools.isWebGL2)(gl)) {
      return;
    }
    const count = gl.getProgramParameter(program.handle, 35971);
    for (let location = 0; location < count; location++) {
      const {
        name,
        type,
        size
      } = gl.getTransformFeedbackVarying(program.handle, location);
      this._addVarying(location, name, type, size);
    }
    this.varyingInfos.sort((a, b) => a.location - b.location);
  }
  _addAttribute(location, name, compositeType, size) {
    const {
      type,
      components
    } = (0, _attributeUtils.decomposeCompositeGLType)(compositeType);
    const accessor = {
      type,
      size: size * components
    };
    this._inferProperties(location, name, accessor);
    const attributeInfo = {
      location,
      name,
      accessor: new _accessor.default(accessor)
    };
    this.attributeInfos.push(attributeInfo);
    this.attributeInfosByLocation[location] = attributeInfo;
    this.attributeInfosByName[attributeInfo.name] = attributeInfo;
  }
  _inferProperties(location, name, accessor) {
    if (/instance/i.test(name)) {
      accessor.divisor = 1;
    }
  }
  _addVarying(location, name, compositeType, size) {
    const {
      type,
      components
    } = (0, _attributeUtils.decomposeCompositeGLType)(compositeType);
    const accessor = new _accessor.default({
      type,
      size: size * components
    });
    const varying = {
      location,
      name,
      accessor
    };
    this.varyingInfos.push(varying);
    this.varyingInfosByName[varying.name] = varying;
  }
}
exports.default = ProgramConfiguration;
},{"./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/program.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _texture = _interopRequireDefault(require("./texture"));
var _framebuffer = _interopRequireDefault(require("./framebuffer"));
var _uniforms = require("./uniforms");
var _shader = require("./shader");
var _programConfiguration = _interopRequireDefault(require("./program-configuration"));
var _gltools = require("@luma.gl/gltools");
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _attributeUtils = require("../webgl-utils/attribute-utils");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_PROGRAM_PERF_PRIORITY = 4;
const GL_SEPARATE_ATTRIBS = 0x8c8d;
const V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];
class Program extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Program';
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, props);
    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);
    this._isCached = false;
    this.initialize(props);
    Object.seal(this);
    this._setId(props.id);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      hash,
      vs,
      fs,
      varyings,
      bufferMode = GL_SEPARATE_ATTRIBS
    } = props;
    this.hash = hash || '';
    this.vs = typeof vs === 'string' ? new _shader.VertexShader(this.gl, {
      id: "".concat(props.id, "-vs"),
      source: vs
    }) : vs;
    this.fs = typeof fs === 'string' ? new _shader.FragmentShader(this.gl, {
      id: "".concat(props.id, "-fs"),
      source: fs
    }) : fs;
    (0, _assert.assert)(this.vs instanceof _shader.VertexShader);
    (0, _assert.assert)(this.fs instanceof _shader.FragmentShader);
    this.uniforms = {};
    this._textureUniforms = {};
    if (varyings && varyings.length > 0) {
      (0, _gltools.assertWebGL2Context)(this.gl);
      this.varyings = varyings;
      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._compileAndLink();
    this._readUniformLocationsFromLinkedProgram();
    this.configuration = new _programConfiguration.default(this);
    return this.setProps(props);
  }
  delete() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this._isCached) {
      return this;
    }
    return super.delete(options);
  }
  setProps(props) {
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }
    return this;
  }
  draw(_ref) {
    let {
      logPriority,
      drawMode = 4,
      vertexCount,
      offset = 0,
      start,
      end,
      isIndexed = false,
      indexType = 5123,
      instanceCount = 0,
      isInstanced = instanceCount > 0,
      vertexArray = null,
      transformFeedback,
      framebuffer,
      parameters = {},
      uniforms,
      samplers
    } = _ref;
    if (uniforms || samplers) {
      _gltools.log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();
      this.setUniforms(uniforms || {});
    }
    if (_gltools.log.priority >= logPriority) {
      const fb = framebuffer ? framebuffer.id : 'default';
      const message = "mode=".concat((0, _constantsToKeys.getKey)(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat((0, _constantsToKeys.getKey)(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
      _gltools.log.log(logPriority, message)();
    }
    (0, _assert.assert)(vertexArray);
    this.gl.useProgram(this.handle);
    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
      return false;
    }
    vertexArray.bindForDraw(vertexCount, instanceCount, () => {
      if (framebuffer !== undefined) {
        parameters = Object.assign({}, parameters, {
          framebuffer
        });
      }
      if (transformFeedback) {
        const primitiveMode = (0, _attributeUtils.getPrimitiveDrawMode)(drawMode);
        transformFeedback.begin(primitiveMode);
      }
      this._bindTextures();
      (0, _gltools.withParameters)(this.gl, parameters, () => {
        if (isIndexed && isInstanced) {
          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
        } else if (isIndexed && (0, _gltools.isWebGL2)(this.gl) && !isNaN(start) && !isNaN(end)) {
          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
        } else if (isIndexed) {
          this.gl.drawElements(drawMode, vertexCount, indexType, offset);
        } else if (isInstanced) {
          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
        } else {
          this.gl.drawArrays(drawMode, offset, vertexCount);
        }
      });
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    return true;
  }
  setUniforms() {
    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (_gltools.log.priority >= 2) {
      (0, _uniforms.checkUniformValues)(uniforms, this.id, this._uniformSetters);
    }
    this.gl.useProgram(this.handle);
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      const uniformSetter = this._uniformSetters[uniformName];
      if (uniformSetter) {
        let value = uniform;
        let textureUpdate = false;
        if (value instanceof _framebuffer.default) {
          value = value.texture;
        }
        if (value instanceof _texture.default) {
          textureUpdate = this.uniforms[uniformName] !== uniform;
          if (textureUpdate) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }
            const texture = value;
            const {
              textureIndex
            } = uniformSetter;
            texture.bind(textureIndex);
            value = textureIndex;
            this._textureUniforms[uniformName] = texture;
          } else {
            value = uniformSetter.textureIndex;
          }
        } else if (this._textureUniforms[uniformName]) {
          delete this._textureUniforms[uniformName];
        }
        if (uniformSetter(value) || textureUpdate) {
          (0, _uniforms.copyUniform)(this.uniforms, uniformName, uniform);
        }
      }
    }
    return this;
  }
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const uniformName in this._textureUniforms) {
      const texture = this._textureUniforms[uniformName];
      texture.update();
      texturesRenderable = texturesRenderable && texture.loaded;
    }
    return texturesRenderable;
  }
  _bindTextures() {
    for (const uniformName in this._textureUniforms) {
      const textureIndex = this._uniformSetters[uniformName].textureIndex;
      this._textureUniforms[uniformName].bind(textureIndex);
    }
  }
  _createHandle() {
    return this.gl.createProgram();
  }
  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  _getOptionsFromHandle(handle) {
    const shaderHandles = this.gl.getAttachedShaders(handle);
    const opts = {};
    for (const shaderHandle of shaderHandles) {
      const type = this.gl.getShaderParameter(this.handle, 35663);
      switch (type) {
        case 35633:
          opts.vs = new _shader.VertexShader({
            handle: shaderHandle
          });
          break;
        case 35632:
          opts.fs = new _shader.FragmentShader({
            handle: shaderHandle
          });
          break;
        default:
      }
    }
    return opts;
  }
  _getParameter(pname) {
    return this.gl.getProgramParameter(this.handle, pname);
  }
  _setId(id) {
    if (!id) {
      const programName = this._getName();
      this.id = (0, _utils.uid)(programName);
    }
  }
  _getName() {
    let programName = this.vs.getName() || this.fs.getName();
    programName = programName.replace(/shader/i, '');
    programName = programName ? "".concat(programName, "-program") : 'program';
    return programName;
  }
  _compileAndLink() {
    const {
      gl
    } = this;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    _gltools.log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    gl.linkProgram(this.handle);
    _gltools.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    if (gl.debug || _gltools.log.level > 0) {
      const linked = gl.getProgramParameter(this.handle, 35714);
      if (!linked) {
        throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);
      if (!validated) {
        throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
      }
    }
  }
  _readUniformLocationsFromLinkedProgram() {
    const {
      gl
    } = this;
    this._uniformSetters = {};
    this._uniformCount = this._getParameter(35718);
    for (let i = 0; i < this._uniformCount; i++) {
      const info = this.gl.getActiveUniform(this.handle, i);
      const {
        name
      } = (0, _uniforms.parseUniformName)(info.name);
      let location = gl.getUniformLocation(this.handle, name);
      this._uniformSetters[name] = (0, _uniforms.getUniformSetter)(gl, location, info);
      if (info.size > 1) {
        for (let l = 0; l < info.size; l++) {
          location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
          this._uniformSetters["".concat(name, "[").concat(l, "]")] = (0, _uniforms.getUniformSetter)(gl, location, info);
        }
      }
    }
    this._textureIndexCounter = 0;
  }
  getActiveUniforms(uniformIndices, pname) {
    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
  }
  getUniformBlockIndex(blockName) {
    return this.gl2.getUniformBlockIndex(this.handle, blockName);
  }
  getActiveUniformBlockParameter(blockIndex, pname) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
  }
  uniformBlockBinding(blockIndex, blockBinding) {
    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
  }
}
exports.default = Program;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./uniforms":"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./shader":"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./program-configuration":"node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/query.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _features = require("../features");
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const GL_QUERY_RESULT = 0x8866;
const GL_QUERY_RESULT_AVAILABLE = 0x8867;
const GL_TIME_ELAPSED_EXT = 0x88bf;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const GL_ANY_SAMPLES_PASSED = 0x8c2f;
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;
class Query extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Query';
  }
  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const webgl2 = (0, _gltools.isWebGL2)(gl);
    const hasTimerQuery = (0, _features.hasFeatures)(gl, _features.FEATURES.TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;
    for (const key of opts) {
      switch (key) {
        case 'queries':
          supported = supported && webgl2;
          break;
        case 'timers':
          supported = supported && hasTimerQuery;
          break;
        default:
          (0, _assert.assert)(false);
      }
    }
    return supported;
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;
    Object.seal(this);
  }
  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }
  beginOcclusionQuery() {
    let {
      conservative = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }
  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }
  begin(target) {
    if (this._queryPending) {
      return this;
    }
    this.target = target;
    this.gl2.beginQuery(this.target, this.handle);
    return this;
  }
  end() {
    if (this._queryPending) {
      return this;
    }
    if (this.target) {
      this.gl2.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return this;
  }
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }
    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }
  isTimerDisjoint() {
    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);
  }
  getResult() {
    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  createPoll() {
    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise) {
      return this._pollingPromise;
    }
    let counter = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject('Timed out');
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };
      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }
  _createHandle() {
    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }
  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }
}
exports.default = Query;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","../features":"node_modules/@luma.gl/webgl/dist/esm/features/index.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _resource = _interopRequireDefault(require("./resource"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _utils = require("../utils/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TransformFeedback extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'TransformFeedback';
  }
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGL2Context)(gl);
    super(gl, props);
    this.initialize(props);
    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);
    Object.seal(this);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.buffers = {};
    this.unused = {};
    this.configuration = null;
    this.bindOnUse = true;
    if (!(0, _utils.isObjectEmpty)(this.buffers)) {
      this.bind(() => this._unbindBuffers());
    }
    this.setProps(props);
    return this;
  }
  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ('configuration' in props) {
      this.configuration = props.configuration;
    }
    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }
    if ('buffers' in props) {
      this.setBuffers(props.buffers);
    }
  }
  setBuffers() {
    let buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
    return this;
  }
  setBuffer(locationOrName, bufferOrParams) {
    const location = this._getVaryingIndex(locationOrName);
    const {
      buffer,
      byteSize,
      byteOffset
    } = this._getBufferParams(bufferOrParams);
    if (location < 0) {
      this.unused[locationOrName] = buffer;
      _gltools.log.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
      return this;
    }
    this.buffers[location] = bufferOrParams;
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteSize);
    }
    return this;
  }
  begin() {
    let primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    this.gl.bindTransformFeedback(36386, this.handle);
    this._bindBuffers();
    this.gl.beginTransformFeedback(primitiveMode);
    return this;
  }
  end() {
    this.gl.endTransformFeedback();
    this._unbindBuffers();
    this.gl.bindTransformFeedback(36386, null);
    return this;
  }
  _getBufferParams(bufferOrParams) {
    let byteOffset;
    let byteSize;
    let buffer;
    if (bufferOrParams instanceof _buffer.default === false) {
      buffer = bufferOrParams.buffer;
      byteSize = bufferOrParams.byteSize;
      byteOffset = bufferOrParams.byteOffset;
    } else {
      buffer = bufferOrParams;
    }
    if (byteOffset !== undefined || byteSize !== undefined) {
      byteOffset = byteOffset || 0;
      byteSize = byteSize || buffer.byteLength - byteOffset;
    }
    return {
      buffer,
      byteOffset,
      byteSize
    };
  }
  _getVaryingInfo(locationOrName) {
    return this.configuration && this.configuration.getVaryingInfo(locationOrName);
  }
  _getVaryingIndex(locationOrName) {
    if (this.configuration) {
      return this.configuration.getVaryingInfo(locationOrName).location;
    }
    const location = Number(locationOrName);
    return Number.isFinite(location) ? location : -1;
  }
  _bindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(this.buffers[bufferIndex]);
        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
      }
    }
  }
  _unbindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        this._bindBuffer(bufferIndex, null);
      }
    }
  }
  _bindBuffer(index, buffer) {
    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let byteSize = arguments.length > 3 ? arguments[3] : undefined;
    const handle = buffer && buffer.handle;
    if (!handle || byteSize === undefined) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
    }
    return this;
  }
  _createHandle() {
    return this.gl.createTransformFeedback();
  }
  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }
  _bindHandle(handle) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }
}
exports.default = TransformFeedback;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillArray = fillArray;
exports.getScratchArray = getScratchArray;
exports.getScratchArrayBuffer = getScratchArrayBuffer;
let arrayBuffer = null;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}
function fillArray(_ref) {
  let {
    target,
    source,
    start = 0,
    count = 1
  } = _ref;
  const length = source.length;
  const total = count * length;
  let copied = 0;
  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _gltools = require("@luma.gl/gltools");
var _arrayUtilsFlat = require("../utils/array-utils-flat");
var _assert = require("../utils/assert");
var _env = require("@probe.gl/env");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';
class VertexArrayObject extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'VertexArrayObject';
  }
  static isSupported(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (options.constantAttributeZero) {
      return (0, _gltools.isWebGL2)(gl) || (0, _env.getBrowser)() === 'Chrome';
    }
    return true;
  }
  static getDefaultArray(gl) {
    gl.luma = gl.luma || {};
    if (!gl.luma.defaultVertexArray) {
      gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
        handle: null,
        isDefaultArray: true
      });
    }
    return gl.luma.defaultVertexArray;
  }
  static getMaxAttributes(gl) {
    VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
    return VertexArrayObject.MAX_ATTRIBUTES;
  }
  static setConstant(gl, location, array) {
    switch (array.constructor) {
      case Float32Array:
        VertexArrayObject._setConstantFloatArray(gl, location, array);
        break;
      case Int32Array:
        VertexArrayObject._setConstantIntArray(gl, location, array);
        break;
      case Uint32Array:
        VertexArrayObject._setConstantUintArray(gl, location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const id = opts.id || opts.program && opts.program.id;
    super(gl, Object.assign({}, opts, {
      id
    }));
    this.buffer = null;
    this.bufferValue = null;
    this.isDefaultArray = opts.isDefaultArray || false;
    this.gl2 = gl;
    this.initialize(opts);
    Object.seal(this);
  }
  delete() {
    super.delete();
    if (this.buffer) {
      this.buffer.delete();
    }
    return this;
  }
  get MAX_ATTRIBUTES() {
    return VertexArrayObject.getMaxAttributes(this.gl);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.setProps(props);
  }
  setProps(props) {
    return this;
  }
  setElementBuffer() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assert.assert)(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
    this.bind(() => {
      this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
    });
    return this;
  }
  setBuffer(location, buffer, accessor) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, accessor);
    }
    const {
      size,
      type,
      stride,
      offset,
      normalized,
      integer,
      divisor
    } = accessor;
    const {
      gl,
      gl2
    } = this;
    location = Number(location);
    this.bind(() => {
      gl.bindBuffer(34962, buffer.handle);
      if (integer) {
        (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
        gl2.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      gl.enableVertexAttribArray(location);
      gl2.vertexAttribDivisor(location, divisor || 0);
    });
    return this;
  }
  enable(location) {
    let enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const disablingAttributeZero = !enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {
      constantAttributeZero: true
    });
    if (!disablingAttributeZero) {
      location = Number(location);
      this.bind(() => enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
    }
    return this;
  }
  getConstantBuffer(elementCount, value) {
    const constantValue = this._normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || new _buffer.default(this.gl, byteLength);
    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
    updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = (0, _arrayUtilsFlat.getScratchArray)(value.constructor, length);
      (0, _arrayUtilsFlat.fillArray)({
        target: typedArray,
        source: constantValue,
        start: 0,
        count: length
      });
      this.buffer.subData(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
  _normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  _compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }
  static _setConstantFloatArray(gl, location, array) {
    switch (array.length) {
      case 1:
        gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        gl.vertexAttrib4fv(location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  static _setConstantIntArray(gl, location, array) {
    (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1iv(location, array);
        break;
      case 2:
        gl.vertexAttribI2iv(location, array);
        break;
      case 3:
        gl.vertexAttribI3iv(location, array);
        break;
      case 4:
        gl.vertexAttribI4iv(location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  static _setConstantUintArray(gl, location, array) {
    (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1uiv(location, array);
        break;
      case 2:
        gl.vertexAttribI2uiv(location, array);
        break;
      case 3:
        gl.vertexAttribI3uiv(location, array);
        break;
      case 4:
        gl.vertexAttribI4uiv(location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  _createHandle() {
    const gl2 = this.gl;
    return gl2.createVertexArray();
  }
  _deleteHandle(handle) {
    this.gl2.deleteVertexArray(handle);
    return [this.elements];
  }
  _bindHandle(handle) {
    this.gl2.bindVertexArray(handle);
  }
  _getParameter(pname, _ref) {
    let {
      location
    } = _ref;
    (0, _assert.assert)(Number.isFinite(location));
    return this.bind(() => {
      switch (pname) {
        case 34373:
          return this.gl.getVertexAttribOffset(location, pname);
        default:
          return this.gl.getVertexAttrib(location, pname);
      }
    });
  }
}
exports.default = VertexArrayObject;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/array-utils-flat":"node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _accessor = _interopRequireDefault(require("./accessor"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _vertexArrayObject = _interopRequireDefault(require("./vertex-array-object"));
var _assert = require("../utils/assert");
var _stubMethods = require("../utils/stub-methods");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';
const MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
const DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];
class VertexArray {
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.attributes = {};
    this.vertexArrayObject = new _vertexArrayObject.default(gl);
    (0, _stubMethods.stubRemovedMethods)(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }
  delete() {
    if (this.buffer) {
      this.buffer.delete();
    }
    this.vertexArrayObject.delete();
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.reset();
    this.configuration = null;
    this.bindOnUse = false;
    return this.setProps(props);
  }
  reset() {
    this.elements = null;
    this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES
    } = this.vertexArrayObject;
    this.values = new Array(MAX_ATTRIBUTES).fill(null);
    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
    this.unused = {};
    this.drawParams = null;
    return this;
  }
  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ('configuration' in props) {
      this.configuration = props.configuration;
    }
    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }
    if ('elements' in props) {
      this.setElementBuffer(props.elements);
    }
    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }
    return this;
  }
  clearDrawParams() {
    this.drawParams = null;
  }
  getDrawParams() {
    this.drawParams = this.drawParams || this._updateDrawParams();
    return this.drawParams;
  }
  setAttributes(attributes) {
    Object.assign(this.attributes, attributes);
    this.vertexArrayObject.bind(() => {
      for (const locationOrName in attributes) {
        const value = attributes[locationOrName];
        this._setAttribute(locationOrName, value);
      }
      this.gl.bindBuffer(34962, null);
    });
    return this;
  }
  setElementBuffer() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.elements = elementBuffer;
    this.elementsAccessor = accessor;
    this.clearDrawParams();
    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
    return this;
  }
  setBuffer(locationOrName, buffer) {
    let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, appAccessor);
    }
    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
    if (location >= 0) {
      this.values[location] = buffer;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setBuffer(location, buffer, accessor);
    }
    return this;
  }
  setConstant(locationOrName, arrayValue) {
    let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
      size: arrayValue.length
    }, appAccessor));
    if (location >= 0) {
      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
      this.values[location] = arrayValue;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.enable(location, false);
    }
    return this;
  }
  unbindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.vertexArrayObject.setElementBuffer(null);
      }
      this.buffer = this.buffer || new _buffer.default(this.gl, {
        accessor: {
          size: 4
        }
      });
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        if (this.values[location] instanceof _buffer.default) {
          this.gl.disableVertexAttribArray(location);
          this.gl.bindBuffer(34962, this.buffer.handle);
          this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
        }
      }
    });
    return this;
  }
  bindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.setElementBuffer(this.elements);
      }
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        const buffer = this.values[location];
        if (buffer instanceof _buffer.default) {
          this.setBuffer(location, buffer);
        }
      }
    });
    return this;
  }
  bindForDraw(vertexCount, instanceCount, func) {
    let value;
    this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(vertexCount, instanceCount);
      value = func();
    });
    return value;
  }
  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
    const INVALID_RESULT = {
      location: -1,
      accessor: null
    };
    const {
      location,
      name
    } = this._getAttributeIndex(locationOrName);
    if (!Number.isFinite(location) || location < 0) {
      this.unused[locationOrName] = value;
      _gltools.log.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
      return INVALID_RESULT;
    }
    const accessInfo = this._getAttributeInfo(name || location);
    if (!accessInfo) {
      return INVALID_RESULT;
    }
    const currentAccessor = this.accessors[location] || {};
    const accessor = _accessor.default.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
    const {
      size,
      type
    } = accessor;
    (0, _assert.assert)(Number.isFinite(size) && Number.isFinite(type));
    return {
      location,
      accessor
    };
  }
  _getAttributeInfo(attributeName) {
    return this.configuration && this.configuration.getAttributeInfo(attributeName);
  }
  _getAttributeIndex(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return {
        location
      };
    }
    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
    const name = multiLocation ? multiLocation[1] : locationOrName;
    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
    if (this.configuration) {
      return {
        location: this.configuration.getAttributeLocation(name) + locationOffset,
        name
      };
    }
    return {
      location: -1
    };
  }
  _setAttribute(locationOrName, value) {
    if (value instanceof _buffer.default) {
      this.setBuffer(locationOrName, value);
    } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer.default) {
      const buffer = value[0];
      const accessor = value[1];
      this.setBuffer(locationOrName, buffer, accessor);
    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
      const constant = value;
      this.setConstant(locationOrName, constant);
    } else if (value.buffer instanceof _buffer.default) {
      const accessor = value;
      this.setBuffer(locationOrName, accessor.buffer, accessor);
    } else {
      throw new Error(ERR_ATTRIBUTE_TYPE);
    }
  }
  _setConstantAttributes(vertexCount, instanceCount) {
    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
    let constant = this.values[0];
    if (ArrayBuffer.isView(constant)) {
      this._setConstantAttributeZero(constant, elementCount);
    }
    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      constant = this.values[location];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttribute(location, constant);
      }
    }
  }
  _setConstantAttributeZero(constant, elementCount) {
    if (_vertexArrayObject.default.isSupported(this.gl, {
      constantAttributeZero: true
    })) {
      this._setConstantAttribute(0, constant);
      return;
    }
    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
  }
  _setConstantAttribute(location, constant) {
    _vertexArrayObject.default.setConstant(this.gl, location, constant);
  }
  _updateDrawParams() {
    const drawParams = {
      isIndexed: false,
      isInstanced: false,
      indexCount: Infinity,
      vertexCount: Infinity,
      instanceCount: Infinity
    };
    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      this._updateDrawParamsForLocation(drawParams, location);
    }
    if (this.elements) {
      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
      drawParams.isIndexed = true;
      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
      drawParams.indexOffset = this.elementsAccessor.offset || 0;
    }
    if (drawParams.indexCount === Infinity) {
      drawParams.indexCount = 0;
    }
    if (drawParams.vertexCount === Infinity) {
      drawParams.vertexCount = 0;
    }
    if (drawParams.instanceCount === Infinity) {
      drawParams.instanceCount = 0;
    }
    return drawParams;
  }
  _updateDrawParamsForLocation(drawParams, location) {
    const value = this.values[location];
    const accessor = this.accessors[location];
    if (!value) {
      return;
    }
    const {
      divisor
    } = accessor;
    const isInstanced = divisor > 0;
    drawParams.isInstanced = drawParams.isInstanced || isInstanced;
    if (value instanceof _buffer.default) {
      const buffer = value;
      if (isInstanced) {
        const instanceCount = buffer.getVertexCount(accessor);
        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
      } else {
        const vertexCount = buffer.getVertexCount(accessor);
        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
      }
    }
  }
  setElements() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _gltools.log.deprecated('setElements', 'setElementBuffer')();
    return this.setElementBuffer(elementBuffer, accessor);
  }
}
exports.default = VertexArray;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./vertex-array-object":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/stub-methods":"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _attributeUtils = require("../webgl-utils/attribute-utils");
var _assert = require("../utils/assert");
const ERR_ARGUMENT = 'UniformBufferLayout illegal argument';
const GL_FLOAT = 0x1406;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;
class UniformBufferLayout {
  constructor(layout) {
    this.layout = {};
    this.size = 0;
    for (const key in layout) {
      this._addUniform(key, layout[key]);
    }
    this.size += (4 - this.size % 4) % 4;
    const data = new Float32Array(this.size);
    this.typedArray = {
      [GL_FLOAT]: data,
      [GL_INT]: new Int32Array(data.buffer),
      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)
    };
  }
  getBytes() {
    return this.size * 4;
  }
  getData() {
    return this.typedArray[GL_FLOAT];
  }
  getSubData(index) {
    let data;
    let offset;
    if (index === undefined) {
      data = this.data;
      offset = 0;
    } else {
      const begin = this.offsets[index];
      const end = begin + this.sizes[index];
      data = this.data.subarray(begin, end);
      offset = begin * 4;
    }
    return {
      data,
      offset
    };
  }
  setUniforms(values) {
    for (const key in values) {
      this._setValue(key, values[key]);
    }
    return this;
  }
  _setValue(key, value) {
    const layout = this.layout[key];
    (0, _assert.assert)(layout, 'UniformLayoutStd140 illegal argument');
    const typedArray = this.typedArray[layout.type];
    if (layout.size === 1) {
      typedArray[layout.offset] = value;
    } else {
      typedArray.set(value, layout.offset);
    }
  }
  _addUniform(key, uniformType) {
    const typeAndComponents = (0, _attributeUtils.decomposeCompositeGLType)(uniformType);
    (0, _assert.assert)(typeAndComponents, ERR_ARGUMENT);
    const {
      type,
      components: count
    } = typeAndComponents;
    this.size = this._alignTo(this.size, count);
    const offset = this.size;
    this.size += count;
    this.layout[key] = {
      type,
      size: count,
      offset
    };
  }
  _alignTo(size, count) {
    switch (count) {
      case 1:
        return size;
      case 2:
        return size + size % 2;
      default:
        return size + (4 - size % 4) % 4;
    }
  }
}
exports.default = UniformBufferLayout;
},{"../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatValue = formatValue;
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForUniforms = getDebugTableForUniforms;
var _assert = require("../utils/assert");
var _formatValue = require("../utils/format-value");
function getDebugTableForUniforms(_ref) {
  let {
    header = 'Uniforms',
    program,
    uniforms,
    undefinedOnly = false
  } = _ref;
  (0, _assert.assert)(program);
  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count = 0;
  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }
  let unusedCount = 0;
  const unusedTable = {};
  if (!undefinedOnly) {
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: "NOT USED: ".concat(uniform),
          [header]: (0, _formatValue.formatValue)(uniform)
        };
      }
    }
  }
  return {
    table,
    count,
    unusedTable,
    unusedCount
  };
}
function addUniformToTable(_ref2) {
  let {
    table,
    header,
    uniforms,
    uniformName,
    undefinedOnly
  } = _ref2;
  const value = uniforms[uniformName];
  const isDefined = isUniformDefined(value);
  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? (0, _formatValue.formatValue)(value) : 'N/A',
      'Uniform Type': isDefined ? value : 'NOT PROVIDED'
    };
    return true;
  }
  return false;
}
function isUniformDefined(value) {
  return value !== undefined && value !== null;
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/format-value":"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForVertexArray = getDebugTableForVertexArray;
var _buffer = _interopRequireDefault(require("../classes/buffer"));
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _attributeUtils = require("../webgl-utils/attribute-utils");
var _formatValue = require("../utils/format-value");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getDebugTableForVertexArray(_ref) {
  let {
    vertexArray,
    header = 'Attributes'
  } = _ref;
  if (!vertexArray.configuration) {
    return {};
  }
  const table = {};
  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }
  const attributes = vertexArray.values;
  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);
    if (info) {
      let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      const accessor = vertexArray.accessors[info.location];
      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }
      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }
  return table;
}
function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;
  if (!attribute) {
    return {
      [header]: 'null',
      'Format ': 'N/A'
    };
  }
  let type = 'NOT PROVIDED';
  let size = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value;
  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace('Array', '');
    isInteger = type.indexOf('nt') !== -1;
  }
  if (attribute instanceof _buffer.default) {
    const buffer = attribute;
    const {
      data,
      changed
    } = buffer.getDebugData();
    marker = changed ? '*' : '';
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    let format;
    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = "".concat(instanced ? 'I ' : 'P ', " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat((0, _constantsToKeys.getKey)(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }
    return {
      [header]: "".concat(marker).concat((0, _formatValue.formatValue)(value, {
        size,
        isInteger
      })),
      'Format ': format
    };
  }
  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace('Array', '');
  isInteger = type.indexOf('nt') !== -1;
  return {
    [header]: "".concat((0, _formatValue.formatValue)(value, {
      size,
      isInteger
    }), " (constant)"),
    'Format ': "".concat(size, "x").concat(type, " (constant)")
  };
}
function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size
  } = accessor;
  const typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);
  return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}
},{"../classes/buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/format-value":"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForProgramConfiguration = getDebugTableForProgramConfiguration;
var _attributeUtils = require("../webgl-utils/attribute-utils");
function getDebugTableForProgramConfiguration(config) {
  const table = {};
  const header = "Accessors for ".concat(config.id);
  for (const attributeInfo of config.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration(attributeInfo);
      table["in ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }
  for (const varyingInfo of config.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration(varyingInfo);
      table["out ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }
  return table;
}
function getGLSLDeclaration(attributeInfo) {
  const {
    type,
    size
  } = attributeInfo.accessor;
  const typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);
  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }
  return attributeInfo.name;
}
},{"../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Accessor", {
  enumerable: true,
  get: function () {
    return _accessor.default;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _buffer.default;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _shader.FragmentShader;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _framebuffer.default;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _program.default;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function () {
    return _query.default;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _renderbuffer.default;
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function () {
    return _shader.Shader;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _texture2d.default;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _texture3d.default;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _textureCube.default;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _transformFeedback.default;
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function () {
    return _uniformBufferLayout.default;
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function () {
    return _vertexArray.default;
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function () {
    return _vertexArrayObject.default;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _shader.VertexShader;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.blit;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _clear.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function () {
    return _clear.clearBuffer;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _textureUtils.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToTexture;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getDebugTableForProgramConfiguration", {
  enumerable: true,
  get: function () {
    return _debugProgramConfiguration.getDebugTableForProgramConfiguration;
  }
});
Object.defineProperty(exports, "getDebugTableForUniforms", {
  enumerable: true,
  get: function () {
    return _debugUniforms.getDebugTableForUniforms;
  }
});
Object.defineProperty(exports, "getDebugTableForVertexArray", {
  enumerable: true,
  get: function () {
    return _debugVertexArray.getDebugTableForVertexArray;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "getUniformSetter", {
  enumerable: true,
  get: function () {
    return _uniforms.getUniformSetter;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function () {
    return _loadFile.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadFile.loadImage;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _gltools.log;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _init.lumaStats;
  }
});
Object.defineProperty(exports, "parseUniformName", {
  enumerable: true,
  get: function () {
    return _uniforms.parseUniformName;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loadFile.setPathPrefix;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _utils.uid;
  }
});
var _init = require("./init");
var _requestAnimationFrame = require("./webgl-utils/request-animation-frame");
var _textureUtils = require("./webgl-utils/texture-utils");
var _constantsToKeys = require("./webgl-utils/constants-to-keys");
var _limits = require("./features/limits");
var _webglFeaturesTable = require("./features/webgl-features-table");
var _features = require("./features/features");
var _checkGlslExtension = _interopRequireDefault(require("./features/check-glsl-extension"));
var _accessor = _interopRequireDefault(require("./classes/accessor"));
var _buffer = _interopRequireDefault(require("./classes/buffer"));
var _shader = require("./classes/shader");
var _program = _interopRequireDefault(require("./classes/program"));
var _framebuffer = _interopRequireDefault(require("./classes/framebuffer"));
var _renderbuffer = _interopRequireDefault(require("./classes/renderbuffer"));
var _texture2d = _interopRequireDefault(require("./classes/texture-2d"));
var _textureCube = _interopRequireDefault(require("./classes/texture-cube"));
var _clear = require("./classes/clear");
var _copyAndBlit = require("./classes/copy-and-blit");
var _query = _interopRequireDefault(require("./classes/query"));
var _texture3d = _interopRequireDefault(require("./classes/texture-3d"));
var _transformFeedback = _interopRequireDefault(require("./classes/transform-feedback"));
var _vertexArrayObject = _interopRequireDefault(require("./classes/vertex-array-object"));
var _vertexArray = _interopRequireDefault(require("./classes/vertex-array"));
var _uniformBufferLayout = _interopRequireDefault(require("./classes/uniform-buffer-layout"));
var _loadFile = require("./utils/load-file");
var _getShaderName = _interopRequireDefault(require("./glsl-utils/get-shader-name"));
var _getShaderVersion = _interopRequireDefault(require("./glsl-utils/get-shader-version"));
var _gltools = require("@luma.gl/gltools");
var _assert = require("./utils/assert");
var _utils = require("./utils/utils");
var _uniforms = require("./classes/uniforms");
var _debugUniforms = require("./debug/debug-uniforms");
var _debugVertexArray = require("./debug/debug-vertex-array");
var _debugProgramConfiguration = require("./debug/debug-program-configuration");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./init":"node_modules/@luma.gl/webgl/dist/esm/init.js","./webgl-utils/request-animation-frame":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js","./webgl-utils/texture-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","./webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","./features/limits":"node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./features/webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features/features":"node_modules/@luma.gl/webgl/dist/esm/features/features.js","./features/check-glsl-extension":"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js","./classes/accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./classes/buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./classes/shader":"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./classes/program":"node_modules/@luma.gl/webgl/dist/esm/classes/program.js","./classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./classes/renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./classes/texture-cube":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","./classes/clear":"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./classes/copy-and-blit":"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","./classes/query":"node_modules/@luma.gl/webgl/dist/esm/classes/query.js","./classes/texture-3d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","./classes/transform-feedback":"node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js","./classes/vertex-array-object":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","./classes/vertex-array":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js","./classes/uniform-buffer-layout":"node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js","./utils/load-file":"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js","./glsl-utils/get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./glsl-utils/get-shader-version":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","./utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./classes/uniforms":"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./debug/debug-uniforms":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js","./debug/debug-vertex-array":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js","./debug/debug-program-configuration":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
var _env = require("@probe.gl/env");
const isPage = (0, _env.isBrowser)() && typeof document !== 'undefined';
let statIdCounter = 0;
class AnimationLoop {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      onCreateContext = opts => (0, _gltools.createGLContext)(opts),
      onAddHTML = null,
      onInitialize = () => {},
      onRender = () => {},
      onFinalize = () => {},
      onError,
      gl = null,
      glOptions = {},
      debug = false,
      createFramebuffer = false,
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = _webgl.lumaStats.get("animation-loop-".concat(statIdCounter++))
    } = props;
    let {
      useDevicePixels = true
    } = props;
    if ('useDevicePixelRatio' in props) {
      _webgl.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();
      useDevicePixels = props.useDevicePixelRatio;
    }
    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,
      onError,
      gl,
      glOptions,
      debug,
      createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._pageLoadPromise = null;
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  delete() {
    this.stop();
    this._setDisplay(null);
  }
  setNeedsRedraw(reason) {
    (0, _webgl.assert)(typeof reason === 'string');
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }
    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }
    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }
    return this;
  }
  start() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this._running) {
      return this;
    }
    this._running = true;
    const startPromise = this._getPageLoadPromise().then(() => {
      if (!this._running || this._initialized) {
        return null;
      }
      this._createWebGLContext(opts);
      this._createFramebuffer();
      this._startEventHandling();
      this._initializeCallbackData();
      this._updateCallbackData();
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._gpuTimeQuery = _webgl.Query.isSupported(this.gl, ['timers']) ? new _webgl.Query(this.gl) : null;
      this._initialized = true;
      return this.onInitialize(this.animationProps);
    }).then(appContext => {
      if (this._running) {
        this._addCallbackData(appContext || {});
        if (appContext !== false) {
          this._startLoop();
        }
      }
    });
    if (this.props.onError) {
      startPromise.catch(this.props.onError);
    }
    return this;
  }
  redraw() {
    if (this.isContextLost()) {
      return this;
    }
    this._beginTimers();
    this._setupFrame();
    this._updateCallbackData();
    this._renderFrame(this.animationProps);
    this._clearNeedsRedraw();
    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endTimers();
    return this;
  }
  stop() {
    if (this._running) {
      this._finalizeCallbackData();
      this._cancelAnimationFrame(this._animationFrameId);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }
    return this;
  }
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    this.setNeedsRedraw('waitForRender');
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }
    return this._nextFramePromise;
  }
  async toDataURL() {
    this.setNeedsRedraw('toDataURL');
    await this.waitForRender();
    return this.gl.canvas.toDataURL();
  }
  isContextLost() {
    return this.gl.isContextLost();
  }
  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }
  onInitialize() {
    return this.props.onInitialize(...arguments);
  }
  onRender() {
    return this.props.onRender(...arguments);
  }
  onFinalize() {
    return this.props.onFinalize(...arguments);
  }
  getHTMLControlValue(id) {
    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }
  setViewParameters() {
    _webgl.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();
    return this;
  }
  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };
    this._cancelAnimationFrame(this._animationFrameId);
    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }
  _getPageLoadPromise() {
    if (!this._pageLoadPromise) {
      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {
        if (isPage && document.readyState === 'complete') {
          resolve(document);
          return;
        }
        window.addEventListener('load', () => {
          resolve(document);
        });
      }) : Promise.resolve({});
    }
    return this._pageLoadPromise;
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _cancelAnimationFrame(animationFrameId) {
    if (this.display && this.display.cancelAnimationFrame) {
      return this.display.cancelAnimationFrame(animationFrameId);
    }
    return (0, _webgl.cancelAnimationFrame)(animationFrameId);
  }
  _requestAnimationFrame(renderFrameCallback) {
    if (this._running) {
      if (this.display && this.display.requestAnimationFrame) {
        return this.display.requestAnimationFrame(renderFrameCallback);
      }
      return (0, _webgl.requestAnimationFrame)(renderFrameCallback);
    }
    return undefined;
  }
  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);
      return;
    }
    this.onRender(...arguments);
  }
  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
    this._resizeFramebuffer();
  }
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }
  _updateCallbackData() {
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    this.animationProps._offScreen = this.offScreen;
  }
  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }
  _addCallbackData(appContext) {
    if (typeof appContext === 'object' && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }
  _createWebGLContext(opts) {
    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? (0, _gltools.instrumentGLContext)(this.props.gl, opts) : this.onCreateContext(opts);
    if (!(0, _gltools.isWebGL)(this.gl)) {
      throw new Error('AnimationLoop.onCreateContext - illegal context returned');
    }
    (0, _gltools.resetParameters)(this.gl);
    this._createInfoDiv();
  }
  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);
      if (html) {
        div.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;
    let aspect = 1;
    const {
      canvas
    } = this.gl;
    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return {
      width,
      height,
      aspect
    };
  }
  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }
  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      (0, _gltools.resizeGLContext)(this.gl, {
        useDevicePixels: this.useDevicePixels
      });
    }
  }
  _createFramebuffer() {
    if (this.props.createFramebuffer) {
      this.framebuffer = new _webgl.Framebuffer(this.gl);
    }
  }
  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }
  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }
    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }
    this.cpuTime.timeStart();
  }
  _endTimers() {
    this.cpuTime.timeEnd();
    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.end();
    }
  }
  _startEventHandling() {
    const {
      canvas
    } = this.gl;
    if (canvas) {
      canvas.addEventListener('mousemove', this._onMousemove);
      canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }
  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
}
exports.default = AnimationLoop;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERTEX_SHADER = exports.FRAGMENT_SHADER = void 0;
const VERTEX_SHADER = 'vs';
exports.VERTEX_SHADER = VERTEX_SHADER;
const FRAGMENT_SHADER = 'fs';
exports.FRAGMENT_SHADER = FRAGMENT_SHADER;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./assert":"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;
const TYPE_DEFINITIONS = {
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  array: {
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }
  return propTypes;
}
function parsePropType(propDef) {
  let type = getTypeOf(propDef);
  if (type === 'object') {
    if (!propDef) {
      return {
        type: 'object',
        value: null
      };
    }
    if ('type' in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }
    if (!('value' in propDef)) {
      return {
        type: 'object',
        value: propDef
      };
    }
    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }
  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }
  return typeof value;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.normalizeShaderModule = normalizeShaderModule;
var _utils = require("../utils");
var _propTypes = require("./filters/prop-types");
const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';
class ShaderModule {
  constructor(_ref) {
    let {
      name,
      vs,
      fs,
      dependencies = [],
      uniforms,
      getUniforms,
      deprecations = [],
      defines = {},
      inject = {},
      vertexShader,
      fragmentShader
    } = _ref;
    (0, _utils.assert)(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;
    this.injections = normalizeInjections(inject);
    if (uniforms) {
      this.uniforms = (0, _propTypes.parsePropTypes)(uniforms);
    }
  }
  getModuleSource(type) {
    let moduleSource;
    switch (type) {
      case VERTEX_SHADER:
        moduleSource = this.vs || '';
        break;
      case FRAGMENT_SHADER:
        moduleSource = this.fs || '';
        break;
      default:
        (0, _utils.assert)(false);
    }
    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_'), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
  }
  getUniforms(opts, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }
    if (this.uniforms) {
      return this._defaultGetUniforms(opts);
    }
    return {};
  }
  getDefines() {
    return this.defines;
  }
  checkDeprecations(shaderSource, log) {
    this.deprecations.forEach(def => {
      if (def.regex.test(shaderSource)) {
        if (def.deprecated) {
          log.deprecated(def.old, def.new)();
        } else {
          log.removed(def.old, def.new)();
        }
      }
    });
  }
  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach(def => {
      switch (def.type) {
        case 'function':
          def.regex = new RegExp("\\b".concat(def.old, "\\("));
          break;
        default:
          def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
      }
    });
    return deprecations;
  }
  _defaultGetUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const uniforms = {};
    const propTypes = this.uniforms;
    for (const key in propTypes) {
      const propDef = propTypes[key];
      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          (0, _utils.assert)(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
        }
        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }
    return uniforms;
  }
}
exports.default = ShaderModule;
function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;
    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }
  return module;
}
function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);
    if (typeof injection === 'string') {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
},{"../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js","./filters/prop-types":"node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TEST_EXPORTS = void 0;
exports.resolveModules = resolveModules;
var _shaderModule = _interopRequireDefault(require("./shader-module"));
var _utils = require("../utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);
}
function getDependencyGraph(_ref) {
  let {
    modules,
    level,
    moduleMap,
    moduleDepth
  } = _ref;
  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}
function instantiateModules(modules, seen) {
  return modules.map(module => {
    if (module instanceof _shaderModule.default) {
      return module;
    }
    (0, _utils.assert)(typeof module !== 'string', "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
    (0, _utils.assert)(module.name, 'shader module has no name');
    module = new _shaderModule.default(module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}
const TEST_EXPORTS = {
  getShaderDependencies,
  getDependencyGraph
};
exports.TEST_EXPORTS = TEST_EXPORTS;
},{"./shader-module":"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;
function isOldIE() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FEATURES = void 0;
exports.canCompileGLGSExtension = canCompileGLGSExtension;
exports.getContextInfo = getContextInfo;
exports.hasFeatures = hasFeatures;
var _isOldIe = _interopRequireDefault(require("./is-old-ie"));
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const GL_VENDOR = 0x1f00;
const GL_RENDERER = 0x1f01;
const GL_VERSION = 0x1f02;
const GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
const WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};
const FEATURES = {};
exports.FEATURES = FEATURES;
Object.keys(WEBGL_FEATURES).forEach(key => {
  FEATURES[key] = key;
});
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContextInfo(gl) {
  const info = gl.getExtension('WEBGL_debug_renderer_info');
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}
function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }
  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }
  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return 'AMD';
  }
  return 'UNKNOWN GPU';
}
const compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap) {
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);
  if (!(0, _isOldIe.default)(opts)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const behavior = opts.behavior || 'enable';
  const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);
  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  const value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
  (0, _assert.default)(value === false || value === true);
  return value;
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => getFeature(gl, feature));
}
},{"./is-old-ie":"node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js","./assert":"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.getVersionDefines = getVersionDefines;
var _webglInfo = require("../utils/webgl-info");
function getPlatformShaderDefines(gl) {
  const debugInfo = (0, _webglInfo.getContextInfo)(gl);
  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
    case 'intel':
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    case 'amd':
      return "#define AMD_GPU\n";
    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}
function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DEPTH)) {
    versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES)) {
    versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
  }
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA, {
    behavior: 'require'
  })) {
    versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
  }
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
  }
  return versionDefines;
}
},{"../utils/webgl-info":"node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MODULE_INJECTORS_VS = exports.MODULE_INJECTORS_FS = void 0;
const MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
exports.MODULE_INJECTORS_VS = MODULE_INJECTORS_VS;
const MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
exports.MODULE_INJECTORS_FS = MODULE_INJECTORS_FS;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DECLARATION_INJECT_MARKER = void 0;
exports.combineInjects = combineInjects;
exports.default = injectShader;
var _moduleInjectors = require("../modules/module-injectors");
var _constants = require("./constants");
var _utils = require("../utils");
const MODULE_INJECTORS = {
  [_constants.VERTEX_SHADER]: _moduleInjectors.MODULE_INJECTORS_VS,
  [_constants.FRAGMENT_SHADER]: _moduleInjectors.MODULE_INJECTORS_FS
};
const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
exports.DECLARATION_INJECT_MARKER = DECLARATION_INJECT_MARKER;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const fragments = [];
function injectShader(source, type, inject) {
  let injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const isVertex = type === _constants.VERTEX_SHADER;
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = "".concat(fragments.join('\n'), "\n");
    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, match => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, '');
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, match => match + MODULE_INJECTORS[type]);
  }
  return source;
}
function combineInjects(injects) {
  const result = {};
  (0, _utils.assert)(Array.isArray(injects) && injects.length > 1);
  injects.forEach(inject => {
    for (const key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}
},{"../modules/module-injectors":"node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js","./constants":"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transpileShader;
function testVariable(qualifier) {
  return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), 'g');
}
const ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, '#version 300 es\n'], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, 'textureLod('], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, 'texture(']];
const ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']];
const ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('varying'), 'in $1']];
const ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, '#version 100'], [/\btexture(2D|2DProj|Cube)Lod\(/g, 'texture$1LodEXT('], [/\btexture\(/g, 'texture2D('], [/\btextureLod\(/g, 'texture2DLodEXT(']];
const ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']];
const ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'varying $1']];
const ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';
const ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), 'g'), outputName);
  } else {
    const outputName = 'fragmentColor';
    source = source.replace(REGEX_START_OF_MAIN, match => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), 'g'), outputName);
  }
  return source;
}
function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp("\\b".concat(outputName, "\\b"), 'g'), ES100_FRAGMENT_OUTPUT_NAME);
  }
  return source;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assembleShaders = assembleShaders;
var _constants = require("./constants");
var _resolveModules = require("./resolve-modules");
var _platformDefines = require("./platform-defines");
var _injectShader = _interopRequireWildcard(require("./inject-shader"));
var _transpileShader = _interopRequireDefault(require("./transpile-shader"));
var _utils = require("../utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const INJECT_SHADER_DECLARATIONS = "\n\n".concat(_injectShader.DECLARATION_INJECT_MARKER, "\n\n");
const SHADER_TYPE = {
  [_constants.VERTEX_SHADER]: 'vertex',
  [_constants.FRAGMENT_SHADER]: 'fragment'
};
const FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
function assembleShaders(gl, opts) {
  const {
    vs,
    fs
  } = opts;
  const modules = (0, _resolveModules.resolveModules)(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: _constants.VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: _constants.FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShader(gl, _ref) {
  let {
    id,
    source,
    type,
    modules,
    defines = {},
    hookFunctions = [],
    inject = {},
    transpileToGLSL100 = false,
    prologue = true,
    log
  } = _ref;
  (0, _utils.assert)(typeof source === 'string', 'shader source must be a string');
  const isVertex = type === _constants.VERTEX_SHADER;
  const sourceLines = source.split('\n');
  let glslVersion = 100;
  let versionLine = '';
  let coreSource = source;
  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  } else {
    versionLine = "#version ".concat(glslVersion);
  }
  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat((0, _platformDefines.getPlatformShaderDefines)(gl), "\n").concat((0, _platformDefines.getVersionDefines)(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === 'decl') {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log) {
      module.checkDeprecations(coreSource, log);
    }
    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];
    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);
      if (match) {
        const name = match[2];
        const injectionType = name === 'decl' ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = (0, _injectShader.default)(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = (0, _injectShader.default)(assembledSource, type, mainInjections);
  assembledSource = (0, _transpileShader.default)(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}
function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getShaderType(_ref2) {
  let {
    type
  } = _ref2;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}
function getShaderName(_ref3) {
  let {
    id,
    source,
    type
  } = _ref3;
  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
}
function getApplicationDefines() {
  let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let count = 0;
  let sourceText = '';
  for (const define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }
    count++;
    const value = defines[define];
    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
  }
  if (count === 0) {
    sourceText += '\n';
  }
  return sourceText;
}
function getHookFunctions(hookFunctions, hookInjections) {
  let result = '';
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");
    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);
      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }
    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }
    result += '}\n';
  }
  return result;
}
function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach(hook => {
    let opts;
    if (typeof hook !== 'string') {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}
},{"./constants":"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","./resolve-modules":"node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js","./platform-defines":"node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js","./inject-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./transpile-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToVec4 = convertToVec4;
exports.getPassthroughFS = getPassthroughFS;
exports.getQualifierDetails = getQualifierDetails;
exports.typeToChannelCount = typeToChannelCount;
exports.typeToChannelSuffix = typeToChannelSuffix;
var _utils = require("../utils");
const FS100 = "void main() {gl_FragColor = vec4(0);}";
const FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
const FS300 = "#version 300 es\n".concat(FS_GLES);
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, '').split(/\s+/);
  const [qualifier, type, definition] = words;
  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }
  const name = definition.split(';')[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;
  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return "#version ".concat(version, "\n").concat(FS_GLES);
    }
    return FS100;
  }
  const outputValue = convertToVec4(input, inputType);
  if (version >= 300) {
    return "#version ".concat(version, " ").concat(version === 300 ? 'es' : '', "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }
  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';
    case 'vec2':
      return 'xy';
    case 'vec3':
      return 'xyz';
    case 'vec4':
      return 'xyzw';
    default:
      (0, _utils.assert)(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;
    case 'vec2':
      return 2;
    case 'vec3':
      return 3;
    case 'vec4':
      return 4;
    default:
      (0, _utils.assert)(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
    case 'vec2':
      return "vec4(".concat(variable, ", 0.0, 1.0)");
    case 'vec3':
      return "vec4(".concat(variable, ", 1.0)");
    case 'vec4':
      return variable;
    default:
      (0, _utils.assert)(false);
      return null;
  }
}
},{"../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.random = void 0;
const fs = "float random(vec3 scale, float seed) {\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n";
const random = {
  name: 'random',
  fs
};
exports.random = random;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp32 = void 0;
const fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
const fp32 = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};
exports.fp32 = fp32;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64LowPart = fp64LowPart;
exports.fp64ify = fp64ify;
exports.fp64ifyMatrix4 = fp64ifyMatrix4;
function fp64ify(a) {
  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const hiPart = Math.fround(a);
  const loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a) {
  return a - Math.fround(a);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64 = void 0;
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64LowPart;
  }
});
exports.fp64arithmetic = void 0;
Object.defineProperty(exports, "fp64ify", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ify;
  }
});
Object.defineProperty(exports, "fp64ifyMatrix4", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ifyMatrix4;
  }
});
var _fp64Utils = require("./fp64-utils");
var _fp64Arithmetic = _interopRequireDefault(require("./fp64-arithmetic.glsl"));
var _fp64Functions = _interopRequireDefault(require("./fp64-functions.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CONST_UNIFORMS = {
  ONE: 1.0
};
function getUniforms() {
  return CONST_UNIFORMS;
}
const fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: _fp64Arithmetic.default,
  fs: null,
  getUniforms,
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
};
exports.fp64arithmetic = fp64arithmetic;
const fp64 = {
  name: 'fp64',
  vs: _fp64Functions.default,
  fs: null,
  dependencies: [fp64arithmetic],
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
};
exports.fp64 = fp64;
},{"./fp64-utils":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js","./fp64-arithmetic.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js","./fp64-functions.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js"}],"node_modules/@math.gl/core/dist/esm/lib/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
},{}],"node_modules/@math.gl/core/dist/esm/lib/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acos = acos;
exports.asin = asin;
exports.atan = atan;
exports.clamp = clamp;
exports.clone = clone;
exports.config = void 0;
exports.configure = configure;
exports.cos = cos;
exports.degrees = degrees;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.formatValue = formatValue;
exports.isArray = isArray;
exports.lerp = lerp;
exports.radians = radians;
exports.sin = sin;
exports.tan = tan;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.withEpsilon = withEpsilon;
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const RADIANS_TO_DEGREES = 1 / Math.PI * 180;
const DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
const config = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true
};
exports.config = config;
function configure(options) {
  for (const key in options) {
    (0, _assert.default)(key in config);
    config[key] = options[key];
  }
  return config;
}
function formatValue(value, {
  precision = config.precision
} = {}) {
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clone(array) {
  return 'clone' in array ? array.clone() : array.slice();
}
function toRadians(degrees) {
  return radians(degrees);
}
function toDegrees(radians) {
  return degrees(radians);
}
function radians(degrees, result) {
  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);
}
function degrees(radians, result) {
  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);
}
function sin(radians, result) {
  return map(radians, angle => Math.sin(angle), result);
}
function cos(radians, result) {
  return map(radians, angle => Math.cos(angle), result);
}
function tan(radians, result) {
  return map(radians, angle => Math.tan(angle), result);
}
function asin(radians, result) {
  return map(radians, angle => Math.asin(angle), result);
}
function acos(radians, result) {
  return map(radians, angle => Math.acos(angle), result);
}
function atan(radians, result) {
  return map(radians, angle => Math.atan(angle), result);
}
function clamp(value, min, max) {
  return map(value, value => Math.max(min, Math.min(max, value)));
}
function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map((ai, i) => lerp(ai, b[i], t));
  }
  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a === b) {
      return true;
    }
    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a && a.equals) {
      return a.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a);
    }
    if (typeof a === 'number' && typeof b === 'number') {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function exactEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (a && typeof a === 'object' && b && typeof b === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }
    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }
  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function withEpsilon(epsilon, func) {
  const oldPrecision = config.EPSILON;
  config.EPSILON = epsilon;
  let value;
  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }
  return value;
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
  if (isArray(value)) {
    const array = value;
    result = result || duplicateArray(array);
    for (let i = 0; i < result.length && i < array.length; ++i) {
      result[i] = func(value[i], i, result);
    }
    return result;
  }
  return func(value);
}
},{"./assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _common = require("../../lib/common");
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
class MathArray extends _extendableBuiltin(Array) {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      targetArray[offset + i] = this[i];
    }
    return targetArray;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return (0, _common.isArray)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(_common.config);
  }
  formatString(opts) {
    let string = '';
    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i], opts);
    }
    return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!(0, _common.equals)(this[i], array[i])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }
    return true;
  }
  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }
    return this.check();
  }
  lerp(a, b, t) {
    if (t === undefined) {
      return this.lerp(this, a, b);
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a[i];
      this[i] = ai + t * (b[i] - ai);
    }
    return this.check();
  }
  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }
    return this.check();
  }
  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }
    return this.check();
  }
  scale(scale) {
    if (typeof scale === 'number') {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scale;
      }
    } else {
      for (let i = 0; i < this.ELEMENTS && i < scale.length; ++i) {
        this[i] *= scale[i];
      }
    }
    return this.check();
  }
  multiplyByScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  check() {
    if (_common.config.debug && !this.validate()) {
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    }
    return this;
  }
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }
    return valid;
  }
  sub(a) {
    return this.subtract(a);
  }
  setScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a;
    }
    return this.check();
  }
  addScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a;
    }
    return this.check();
  }
  subScalar(a) {
    return this.addScalar(-a);
  }
  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  divideScalar(a) {
    return this.multiplyByScalar(1 / a);
  }
  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }
    return this.check();
  }
  get elements() {
    return this;
  }
}
exports.default = MathArray;
},{"../../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@math.gl/core/dist/esm/lib/validators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkNumber = checkNumber;
exports.checkVector = checkVector;
exports.deprecated = deprecated;
exports.validateVector = validateVector;
var _common = require("./common");
function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }
  return value;
}
function checkVector(v, length, callerName = '') {
  if (_common.config.debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }
  return v;
}
const map = {};
function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}
},{"./common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./math-array"));
var _validators = require("../../lib/validators");
var _assert = _interopRequireDefault(require("../../lib/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Vector extends _mathArray.default {
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }
    return length;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }
    return (0, _validators.checkNumber)(length);
  }
  dot(mathArray) {
    let product = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }
    return (0, _validators.checkNumber)(product);
  }
  normalize() {
    const length = this.magnitude();
    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i) {
    (0, _assert.default)(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    return (0, _validators.checkNumber)(this[i]);
  }
  setComponent(i, value) {
    (0, _assert.default)(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    this[i] = value;
    return this.check();
  }
  addVectors(a, b) {
    return this.copy(a).add(b);
  }
  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }
  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }
  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }
}
exports.default = Vector;
},{"./math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../../lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */
exports.RANDOM = RANDOM;
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
    i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};
},{}],"node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
    y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
    y1 = a[1],
    x2 = b[0],
    y2 = b[1],
    // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
    // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */
exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */
exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */
exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */
exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec2_transformMat4AsVector = vec2_transformMat4AsVector;
exports.vec3_transformMat2 = vec3_transformMat2;
exports.vec3_transformMat4AsVector = vec3_transformMat4AsVector;
exports.vec4_transformMat2 = vec4_transformMat2;
exports.vec4_transformMat3 = vec4_transformMat3;
function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
},{}],"node_modules/@math.gl/core/dist/esm/classes/vector2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vector = _interopRequireDefault(require("./base/vector"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var _glMatrixExtras = require("../lib/gl-matrix-extras");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Vector2 extends _vector.default {
  constructor(x = 0, y = 0) {
    super(2);
    if ((0, _common.isArray)(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
      }
      this[0] = x;
      this[1] = y;
    }
  }
  set(x, y) {
    this[0] = x;
    this[1] = y;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    return this.check();
  }
  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
    }
    this[0] = object.x;
    this[1] = object.y;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    return object;
  }
  get ELEMENTS() {
    return 2;
  }
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    vec2.transformMat4(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    (0, _glMatrixExtras.vec2_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    vec2.transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2x3(matrix2x3) {
    vec2.transformMat2d(this, this, matrix2x3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec2.transformMat2(this, this, matrix2);
    return this.check();
  }
}
exports.default = Vector2;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var x = a[0],
    y = a[1],
    z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
    uvy = qz * x - qx * z,
    uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
    uuvy = qz * uvx - qx * uvz,
    uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
    mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
    mag = mag1 * mag2,
    cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */
exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */
exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */
exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */
exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/vector3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vector = _interopRequireDefault(require("./base/vector"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _glMatrixExtras = require("../lib/gl-matrix-extras");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ORIGIN = [0, 0, 0];
let ZERO;
class Vector3 extends _vector.default {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && (0, _common.isArray)(x)) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
        (0, _validators.checkNumber)(z);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }
  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
      (0, _validators.checkNumber)(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  angle(vector) {
    return vec3.angle(this, vector);
  }
  cross(vector) {
    vec3.cross(this, this, vector);
    return this.check();
  }
  rotateX({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateX(this, this, origin, radians);
    return this.check();
  }
  rotateY({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateY(this, this, origin, radians);
    return this.check();
  }
  rotateZ({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateZ(this, this, origin, radians);
    return this.check();
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    vec3.transformMat4(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    (0, _glMatrixExtras.vec3_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    vec3.transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    (0, _glMatrixExtras.vec3_transformMat2)(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    vec3.transformQuat(this, this, quaternion);
    return this.check();
  }
}
exports.default = Vector3;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/dist/esm/classes/vector4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vector = _interopRequireDefault(require("./base/vector"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
var vec4 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _glMatrixExtras = require("../lib/gl-matrix-extras");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let ZERO;
class Vector4 extends _vector.default {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new Vector4(0, 0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  constructor(x = 0, y = 0, z = 0, w = 0) {
    super(-0, -0, -0, -0);
    if ((0, _common.isArray)(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
        (0, _validators.checkNumber)(z);
        (0, _validators.checkNumber)(w);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
    }
  }
  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }
  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
      (0, _validators.checkNumber)(object.z);
      (0, _validators.checkNumber)(object.w);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this;
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    object.w = this[3];
    return object;
  }
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get w() {
    return this[3];
  }
  set w(value) {
    this[3] = (0, _validators.checkNumber)(value);
  }
  transform(matrix4) {
    vec4.transformMat4(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    (0, _glMatrixExtras.vec4_transformMat3)(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    (0, _glMatrixExtras.vec4_transformMat2)(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    vec4.transformQuat(this, this, quaternion);
    return this.check();
  }
  applyMatrix4(m) {
    m.transform(this, this);
    return this;
  }
}
exports.default = Vector4;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./math-array"));
var _validators = require("../../lib/validators");
var _common = require("../../lib/common");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Matrix extends _mathArray.default {
  toString() {
    let string = '[';
    if (_common.config.printRowMajor) {
      string += 'row-major:';
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += " ".concat(this[col * this.RANK + row]);
        }
      }
    } else {
      string += 'column-major:';
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += " ".concat(this[i]);
      }
    }
    string += ']';
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  setElement(row, col, value) {
    this[col * this.RANK + row] = (0, _validators.checkNumber)(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }
    return this;
  }
}
exports.default = Matrix;
},{"./math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/gl-matrix/esm/mat3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromMat2d = fromMat2d;
exports.fromMat4 = fromMat4;
exports.fromQuat = fromQuat;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    x = v[0],
    y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
    y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7],
    a8 = a[8];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */
exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/matrix3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _matrix = _interopRequireDefault(require("./base/matrix"));
var _validators = require("../lib/validators");
var _glMatrixExtras = require("../lib/gl-matrix-extras");
var mat3 = _interopRequireWildcard(require("gl-matrix/mat3"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INDICES;
(function (INDICES) {
  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES[INDICES["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES[INDICES["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES[INDICES["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES[INDICES["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES[INDICES["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES[INDICES["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
const IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class Matrix3 extends _matrix.default {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array, ...args) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else if (args.length > 0) {
      this.copy([array, ...args]);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  fromObject(object) {
    return this.check();
  }
  fromQuaternion(q) {
    mat3.fromQuat(this, q);
    return this.check();
  }
  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  determinant() {
    return mat3.determinant(this);
  }
  transpose() {
    mat3.transpose(this, this);
    return this.check();
  }
  invert() {
    mat3.invert(this, this);
    return this.check();
  }
  multiplyLeft(a) {
    mat3.multiply(this, a, this);
    return this.check();
  }
  multiplyRight(a) {
    mat3.multiply(this, this, a);
    return this.check();
  }
  rotate(radians) {
    mat3.rotate(this, this, radians);
    return this.check();
  }
  scale(factor) {
    if (Array.isArray(factor)) {
      mat3.scale(this, this, factor);
    } else {
      mat3.scale(this, this, [factor, factor]);
    }
    return this.check();
  }
  translate(vec) {
    mat3.translate(this, this, vec);
    return this.check();
  }
  transform(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = vec2.transformMat3(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3.transformMat3(result || [-0, -0, -0], vector, this);
        break;
      case 4:
        out = (0, _glMatrixExtras.vec4_transformMat3)(result || [-0, -0, -0, -0], vector, this);
        break;
      default:
        throw new Error('Illegal vector');
    }
    (0, _validators.checkVector)(out, vector.length);
    return out;
  }
  transformVector(vector, result) {
    return this.transform(vector, result);
  }
  transformVector2(vector, result) {
    return this.transform(vector, result);
  }
  transformVector3(vector, result) {
    return this.transform(vector, result);
  }
}
exports.default = Matrix3;
let ZERO_MATRIX3;
let IDENTITY_MATRIX3;
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3();
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}
},{"./base/matrix":"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js","gl-matrix/mat3":"node_modules/gl-matrix/esm/mat3.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js"}],"node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = void 0;
exports.orthoNO = orthoNO;
exports.orthoZO = orthoZO;
exports.perspective = void 0;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.perspectiveNO = perspectiveNO;
exports.perspectiveZO = perspectiveZO;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(16);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a03 = a[3];
    var a12 = a[6],
      a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
exports.perspective = perspective;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
exports.ortho = ortho;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2];
  var z0 = eyex - target[0],
    z1 = eyey - target[1],
    z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1,
    x1 = upz * z0 - upx * z2,
    x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var a8 = a[8],
    a9 = a[9],
    a10 = a[10],
    a11 = a[11];
  var a12 = a[12],
    a13 = a[13],
    a14 = a[14],
    a15 = a[15];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  var b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  var b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11];
  var b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */
exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
    B = v[0] * w[2] - v[2] * w[0],
    C = v[0] * w[3] - v[3] * w[0],
    D = v[1] * w[2] - v[2] * w[1],
    E = v[1] * w[3] - v[3] * w[1],
    F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */
exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */
exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */
exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */
exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();
exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/matrix4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _matrix = _interopRequireDefault(require("./base/matrix"));
var _validators = require("../lib/validators");
var _glMatrixExtras = require("../lib/gl-matrix-extras");
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INDICES;
(function (INDICES) {
  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES[INDICES["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES[INDICES["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES[INDICES["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES[INDICES["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES[INDICES["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES[INDICES["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES[INDICES["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES[INDICES["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES[INDICES["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES[INDICES["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES[INDICES["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES[INDICES["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES[INDICES["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));
const DEFAULT_FOVY = 45 * Math.PI / 180;
const DEFAULT_ASPECT = 1;
const DEFAULT_NEAR = 0.1;
const DEFAULT_FAR = 500;
const IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Matrix4 extends _matrix.default {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }
  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  fromObject(object) {
    return this.check();
  }
  fromQuaternion(quaternion) {
    mat4.fromQuat(this, quaternion);
    return this.check();
  }
  frustum(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      mat4.frustum(this, left, right, bottom, top, near, far);
    }
    return this.check();
  }
  lookAt(view) {
    const {
      eye,
      center = [0, 0, 0],
      up = [0, 1, 0]
    } = view;
    mat4.lookAt(this, eye, center, up);
    return this.check();
  }
  ortho(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    mat4.ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }
  orthographic(view) {
    const {
      fovy = DEFAULT_FOVY,
      aspect = DEFAULT_ASPECT,
      focalDistance = 1,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }
  perspective(view) {
    const {
      fovy = 45 * Math.PI / 180,
      aspect = 1,
      near = 0.1,
      far = 500
    } = view;
    checkRadians(fovy);
    mat4.perspective(this, fovy, aspect, near, far);
    return this.check();
  }
  determinant() {
    return mat4.determinant(this);
  }
  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }
  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }
  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }
  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }
  transpose() {
    mat4.transpose(this, this);
    return this.check();
  }
  invert() {
    mat4.invert(this, this);
    return this.check();
  }
  multiplyLeft(a) {
    mat4.multiply(this, a, this);
    return this.check();
  }
  multiplyRight(a) {
    mat4.multiply(this, this, a);
    return this.check();
  }
  rotateX(radians) {
    mat4.rotateX(this, this, radians);
    return this.check();
  }
  rotateY(radians) {
    mat4.rotateY(this, this, radians);
    return this.check();
  }
  rotateZ(radians) {
    mat4.rotateZ(this, this, radians);
    return this.check();
  }
  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }
  rotateAxis(radians, axis) {
    mat4.rotate(this, this, radians, axis);
    return this.check();
  }
  scale(factor) {
    mat4.scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }
  translate(vector) {
    mat4.translate(this, this, vector);
    return this.check();
  }
  transform(vector, result) {
    if (vector.length === 4) {
      result = vec4.transformMat4(result || [-0, -0, -0, -0], vector, this);
      (0, _validators.checkVector)(result, 4);
      return result;
    }
    return this.transformAsPoint(vector, result);
  }
  transformAsPoint(vector, result) {
    const {
      length
    } = vector;
    let out;
    switch (length) {
      case 2:
        out = vec2.transformMat4(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3.transformMat4(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error('Illegal vector');
    }
    (0, _validators.checkVector)(out, vector.length);
    return out;
  }
  transformAsVector(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = (0, _glMatrixExtras.vec2_transformMat4AsVector)(result || [-0, -0], vector, this);
        break;
      case 3:
        out = (0, _glMatrixExtras.vec3_transformMat4AsVector)(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error('Illegal vector');
    }
    (0, _validators.checkVector)(out, vector.length);
    return out;
  }
  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }
  makeRotationX(radians) {
    return this.identity().rotateX(radians);
  }
  makeTranslation(x, y, z) {
    return this.identity().translate([x, y, z]);
  }
}
exports.default = Matrix4;
let ZERO;
let IDENTITY;
function getZeroMatrix() {
  if (!ZERO) {
    ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO);
  }
  return ZERO;
}
function getIdentityMatrix() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error('expected radians');
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}
},{"./base/matrix":"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/gl-matrix/esm/quat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = void 0;
exports.calculateW = calculateW;
exports.clone = void 0;
exports.conjugate = conjugate;
exports.copy = void 0;
exports.create = create;
exports.exactEquals = exports.equals = exports.dot = void 0;
exports.exp = exp;
exports.fromEuler = fromEuler;
exports.fromMat3 = fromMat3;
exports.fromValues = void 0;
exports.getAngle = getAngle;
exports.getAxisAngle = getAxisAngle;
exports.identity = identity;
exports.invert = invert;
exports.lerp = exports.length = exports.len = void 0;
exports.ln = ln;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = void 0;
exports.pow = pow;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
exports.setAxisAngle = setAxisAngle;
exports.slerp = slerp;
exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
exports.str = str;
var glMatrix = _interopRequireWildcard(require("./common.js"));
var mat3 = _interopRequireWildcard(require("./mat3.js"));
var vec3 = _interopRequireWildcard(require("./vec3.js"));
var vec4 = _interopRequireWildcard(require("./vec4.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var by = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bz = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients

  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values

  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */
exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */
exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */
exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */
exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */
exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */
exports.equals = equals;
var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
exports.rotationTo = rotationTo;
var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
exports.sqlerp = sqlerp;
var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();
exports.setAxes = setAxes;
},{"./common.js":"node_modules/gl-matrix/esm/common.js","./mat3.js":"node_modules/gl-matrix/esm/mat3.js","./vec3.js":"node_modules/gl-matrix/esm/vec3.js","./vec4.js":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/dist/esm/classes/quaternion.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./base/math-array"));
var _validators = require("../lib/validators");
var _vector = _interopRequireDefault(require("./vector4"));
var quat = _interopRequireWildcard(require("gl-matrix/quat"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const IDENTITY_QUATERNION = [0, 0, 0, 1];
class Quaternion extends _mathArray.default {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    super(-0, -0, -0, -0);
    if (Array.isArray(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      this.set(x, y, z, w);
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }
  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }
  fromObject(object) {
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this.check();
  }
  fromMatrix3(m) {
    quat.fromMat3(this, m);
    return this.check();
  }
  fromAxisRotation(axis, rad) {
    quat.setAxisAngle(this, axis, rad);
    return this.check();
  }
  identity() {
    quat.identity(this);
    return this.check();
  }
  setAxisAngle(axis, rad) {
    return this.fromAxisRotation(axis, rad);
  }
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get w() {
    return this[3];
  }
  set w(value) {
    this[3] = (0, _validators.checkNumber)(value);
  }
  len() {
    return quat.length(this);
  }
  lengthSquared() {
    return quat.squaredLength(this);
  }
  dot(a) {
    return quat.dot(this, a);
  }
  rotationTo(vectorA, vectorB) {
    quat.rotationTo(this, vectorA, vectorB);
    return this.check();
  }
  add(a) {
    quat.add(this, this, a);
    return this.check();
  }
  calculateW() {
    quat.calculateW(this, this);
    return this.check();
  }
  conjugate() {
    quat.conjugate(this, this);
    return this.check();
  }
  invert() {
    quat.invert(this, this);
    return this.check();
  }
  lerp(a, b, t) {
    if (t === undefined) {
      return this.lerp(this, a, b);
    }
    quat.lerp(this, a, b, t);
    return this.check();
  }
  multiplyRight(a) {
    quat.multiply(this, this, a);
    return this.check();
  }
  multiplyLeft(a) {
    quat.multiply(this, a, this);
    return this.check();
  }
  normalize() {
    const length = this.len();
    const l = length > 0 ? 1 / length : 0;
    this[0] = this[0] * l;
    this[1] = this[1] * l;
    this[2] = this[2] * l;
    this[3] = this[3] * l;
    if (length === 0) {
      this[3] = 1;
    }
    return this.check();
  }
  rotateX(rad) {
    quat.rotateX(this, this, rad);
    return this.check();
  }
  rotateY(rad) {
    quat.rotateY(this, this, rad);
    return this.check();
  }
  rotateZ(rad) {
    quat.rotateZ(this, this, rad);
    return this.check();
  }
  scale(b) {
    quat.scale(this, this, b);
    return this.check();
  }
  slerp(arg0, arg1, arg2) {
    let start;
    let target;
    let ratio;
    switch (arguments.length) {
      case 1:
        ({
          start = IDENTITY_QUATERNION,
          target,
          ratio
        } = arg0);
        break;
      case 2:
        start = this;
        target = arg0;
        ratio = arg1;
        break;
      default:
        start = arg0;
        target = arg1;
        ratio = arg2;
    }
    quat.slerp(this, start, target, ratio);
    return this.check();
  }
  transformVector4(vector, result = new _vector.default()) {
    vec4.transformQuat(result, vector, this);
    return (0, _validators.checkVector)(result, 4);
  }
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(axis, rad) {
    return this.setAxisAngle(axis, rad);
  }
  premultiply(a) {
    return this.multiplyLeft(a);
  }
  multiply(a) {
    return this.multiplyRight(a);
  }
}
exports.default = Quaternion;
},{"./base/math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","./vector4":"node_modules/@math.gl/core/dist/esm/classes/vector4.js","gl-matrix/quat":"node_modules/gl-matrix/esm/quat.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _vector = _interopRequireDefault(require("./vector3"));
var _common = require("../lib/common");
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EPSILON = 0.000001;
const EARTH_RADIUS_METERS = 6371000;
class SphericalCoordinates {
  constructor({
    phi = 0,
    theta = 0,
    radius = 1,
    bearing,
    pitch,
    altitude,
    radiusScale = EARTH_RADIUS_METERS
  } = {}) {
    (0, _defineProperty2.default)(this, "phi", void 0);
    (0, _defineProperty2.default)(this, "theta", void 0);
    (0, _defineProperty2.default)(this, "radius", void 0);
    (0, _defineProperty2.default)(this, "radiusScale", void 0);
    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;
    if (bearing !== undefined) {
      this.bearing = bearing;
    }
    if (pitch !== undefined) {
      this.pitch = pitch;
    }
    this.check();
  }
  toString() {
    return this.formatString(_common.config);
  }
  formatString({
    printTypes = false
  }) {
    const f = _common.formatValue;
    return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
  }
  equals(other) {
    return (0, _common.equals)(this.radius, other.radius) && (0, _common.equals)(this.theta, other.theta) && (0, _common.equals)(this.phi, other.phi);
  }
  exactEquals(other) {
    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
  }
  get bearing() {
    return 180 - (0, _common.degrees)(this.phi);
  }
  set bearing(v) {
    this.phi = Math.PI - (0, _common.radians)(v);
  }
  get pitch() {
    return (0, _common.degrees)(this.theta);
  }
  set pitch(v) {
    this.theta = (0, _common.radians)(v);
  }
  get longitude() {
    return (0, _common.degrees)(this.phi);
  }
  get latitude() {
    return (0, _common.degrees)(this.theta);
  }
  get lng() {
    return (0, _common.degrees)(this.phi);
  }
  get lat() {
    return (0, _common.degrees)(this.theta);
  }
  get z() {
    return (this.radius - 1) * this.radiusScale;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this.check();
  }
  clone() {
    return new SphericalCoordinates().copy(this);
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this.check();
  }
  fromLngLatZ([lng, lat, z]) {
    this.radius = 1 + z / this.radiusScale;
    this.phi = (0, _common.radians)(lat);
    this.theta = (0, _common.radians)(lng);
    return this.check();
  }
  fromVector3(v) {
    this.radius = vec3.length(v);
    if (this.radius > 0) {
      this.theta = Math.atan2(v[0], v[1]);
      this.phi = Math.acos((0, _common.clamp)(v[2] / this.radius, -1, 1));
    }
    return this.check();
  }
  toVector3() {
    return new _vector.default(0, 0, this.radius).rotateX({
      radians: this.theta
    }).rotateZ({
      radians: this.phi
    });
  }
  makeSafe() {
    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    return this;
  }
  check() {
    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
      throw new Error('SphericalCoordinates: some fields set to invalid numbers');
    }
    return this;
  }
}
exports.default = SphericalCoordinates;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/core/dist/esm/classes/euler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./base/math-array"));
var _quaternion = _interopRequireDefault(require("./quaternion"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
const ALMOST_ONE = 0.99999;
var RotationOrder;
(function (RotationOrder) {
  RotationOrder[RotationOrder["ZYX"] = 0] = "ZYX";
  RotationOrder[RotationOrder["YXZ"] = 1] = "YXZ";
  RotationOrder[RotationOrder["XZY"] = 2] = "XZY";
  RotationOrder[RotationOrder["ZXY"] = 3] = "ZXY";
  RotationOrder[RotationOrder["YZX"] = 4] = "YZX";
  RotationOrder[RotationOrder["XYZ"] = 5] = "XYZ";
})(RotationOrder || (RotationOrder = {}));
class Euler extends _mathArray.default {
  static get ZYX() {
    return RotationOrder.ZYX;
  }
  static get YXZ() {
    return RotationOrder.YXZ;
  }
  static get XZY() {
    return RotationOrder.XZY;
  }
  static get ZXY() {
    return RotationOrder.ZXY;
  }
  static get YZX() {
    return RotationOrder.YZX;
  }
  static get XYZ() {
    return RotationOrder.XYZ;
  }
  static get RollPitchYaw() {
    return RotationOrder.ZYX;
  }
  static get DefaultOrder() {
    return RotationOrder.ZYX;
  }
  static get RotationOrders() {
    return RotationOrder;
  }
  static rotationOrder(order) {
    return RotationOrder[order];
  }
  get ELEMENTS() {
    return 4;
  }
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    super(-0, -0, -0, -0);
    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      this.fromVector3(...arguments);
    } else {
      this.set(x, y, z, order);
    }
  }
  fromQuaternion(quaternion) {
    const [x, y, z, w] = quaternion;
    const ysqr = y * y;
    const t0 = -2 * (ysqr + z * z) + 1;
    const t1 = +2 * (x * y + w * z);
    let t2 = -2 * (x * z - w * y);
    const t3 = +2 * (y * z + w * x);
    const t4 = -2 * (x * x + ysqr) + 1;
    t2 = t2 > 1 ? 1 : t2;
    t2 = t2 < -1 ? -1 : t2;
    const roll = Math.atan2(t3, t4);
    const pitch = Math.asin(t2);
    const yaw = Math.atan2(t1, t0);
    return this.set(roll, pitch, yaw, Euler.RollPitchYaw);
  }
  fromObject(object) {
    throw new Error('not implemented');
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = Number.isFinite(array[3]) || this.order;
    return this.check();
  }
  set(x = 0, y = 0, z = 0, order) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = Number.isFinite(order) ? order : this[3];
    return this.check();
  }
  validate() {
    return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
  }
  toArray(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    return array;
  }
  toArray4(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    array[offset + 3] = this[3];
    return array;
  }
  toVector3(result = [-0, -0, -0]) {
    result[0] = this[0];
    result[1] = this[1];
    result[2] = this[2];
    return result;
  }
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get alpha() {
    return this[0];
  }
  set alpha(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get beta() {
    return this[1];
  }
  set beta(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get gamma() {
    return this[2];
  }
  set gamma(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get phi() {
    return this[0];
  }
  set phi(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get theta() {
    return this[1];
  }
  set theta(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get psi() {
    return this[2];
  }
  set psi(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get roll() {
    return this[0];
  }
  set roll(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get pitch() {
    return this[1];
  }
  set pitch(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get yaw() {
    return this[2];
  }
  set yaw(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get order() {
    return this[3];
  }
  set order(value) {
    this[3] = checkOrder(value);
  }
  fromVector3(v, order) {
    return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
  }
  fromArray(array, offset = 0) {
    this[0] = array[0 + offset];
    this[1] = array[1 + offset];
    this[2] = array[2 + offset];
    if (array[3] !== undefined) {
      this[3] = array[3];
    }
    return this.check();
  }
  fromRollPitchYaw(roll, pitch, yaw) {
    return this.set(roll, pitch, yaw, RotationOrder.ZYX);
  }
  fromRotationMatrix(m, order = Euler.DefaultOrder) {
    this._fromRotationMatrix(m, order);
    return this.check();
  }
  getRotationMatrix(m) {
    return this._getRotationMatrix(m);
  }
  getQuaternion() {
    const q = new _quaternion.default();
    switch (this[4]) {
      case RotationOrder.XYZ:
        return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);
      case RotationOrder.YXZ:
        return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);
      case RotationOrder.ZXY:
        return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);
      case RotationOrder.ZYX:
        return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);
      case RotationOrder.YZX:
        return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);
      case RotationOrder.XZY:
        return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);
      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
  }
  _fromRotationMatrix(m, order = Euler.DefaultOrder) {
    const m11 = m[0],
      m12 = m[4],
      m13 = m[8];
    const m21 = m[1],
      m22 = m[5],
      m23 = m[9];
    const m31 = m[2],
      m32 = m[6],
      m33 = m[10];
    order = order || this[3];
    switch (order) {
      case Euler.XYZ:
        this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));
        if (Math.abs(m13) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m33);
          this[2] = Math.atan2(-m12, m11);
        } else {
          this[0] = Math.atan2(m32, m22);
          this[2] = 0;
        }
        break;
      case Euler.YXZ:
        this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));
        if (Math.abs(m23) < ALMOST_ONE) {
          this[1] = Math.atan2(m13, m33);
          this[2] = Math.atan2(m21, m22);
        } else {
          this[1] = Math.atan2(-m31, m11);
          this[2] = 0;
        }
        break;
      case Euler.ZXY:
        this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));
        if (Math.abs(m32) < ALMOST_ONE) {
          this[1] = Math.atan2(-m31, m33);
          this[2] = Math.atan2(-m12, m22);
        } else {
          this[1] = 0;
          this[2] = Math.atan2(m21, m11);
        }
        break;
      case Euler.ZYX:
        this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));
        if (Math.abs(m31) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m33);
          this[2] = Math.atan2(m21, m11);
        } else {
          this[0] = 0;
          this[2] = Math.atan2(-m12, m22);
        }
        break;
      case Euler.YZX:
        this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));
        if (Math.abs(m21) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m22);
          this[1] = Math.atan2(-m31, m11);
        } else {
          this[0] = 0;
          this[1] = Math.atan2(m13, m33);
        }
        break;
      case Euler.XZY:
        this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));
        if (Math.abs(m12) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m22);
          this[1] = Math.atan2(m13, m11);
        } else {
          this[0] = Math.atan2(-m23, m33);
          this[1] = 0;
        }
        break;
      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
    this[3] = order;
    return this;
  }
  _getRotationMatrix(result) {
    const te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    const x = this.x,
      y = this.y,
      z = this.z;
    const a = Math.cos(x);
    const c = Math.cos(y);
    const e = Math.cos(z);
    const b = Math.sin(x);
    const d = Math.sin(y);
    const f = Math.sin(z);
    switch (this[3]) {
      case Euler.XYZ:
        {
          const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
          break;
        }
      case Euler.YXZ:
        {
          const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
          break;
        }
      case Euler.ZXY:
        {
          const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
          break;
        }
      case Euler.ZYX:
        {
          const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
          break;
        }
      case Euler.YZX:
        {
          const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
          break;
        }
      case Euler.XZY:
        {
          const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
          break;
        }
      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return te;
  }
  toQuaternion() {
    const cy = Math.cos(this.yaw * 0.5);
    const sy = Math.sin(this.yaw * 0.5);
    const cr = Math.cos(this.roll * 0.5);
    const sr = Math.sin(this.roll * 0.5);
    const cp = Math.cos(this.pitch * 0.5);
    const sp = Math.sin(this.pitch * 0.5);
    const w = cy * cr * cp + sy * sr * sp;
    const x = cy * sr * cp - sy * cr * sp;
    const y = cy * cr * sp + sy * sr * cp;
    const z = sy * cr * cp - cy * sr * sp;
    return new _quaternion.default(x, y, z, w);
  }
}
exports.default = Euler;
function validateOrder(value) {
  return value >= 0 && value < 6;
}
function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }
  return value;
}
},{"./base/math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","./quaternion":"node_modules/@math.gl/core/dist/esm/classes/quaternion.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js"}],"node_modules/@math.gl/core/dist/esm/classes/pose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _matrix = _interopRequireDefault(require("./matrix4"));
var _vector = _interopRequireDefault(require("./vector3"));
var _euler = _interopRequireDefault(require("./euler"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Pose {
  constructor({
    x = 0,
    y = 0,
    z = 0,
    roll = 0,
    pitch = 0,
    yaw = 0,
    position,
    orientation
  } = {}) {
    (0, _defineProperty2.default)(this, "position", void 0);
    (0, _defineProperty2.default)(this, "orientation", void 0);
    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector.default(position);
    } else {
      this.position = new _vector.default(x, y, z);
    }
    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler.default(orientation, orientation[3]);
    } else {
      this.orientation = new _euler.default(roll, pitch, yaw, _euler.default.RollPitchYaw);
    }
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.position.y = value;
  }
  get z() {
    return this.position.z;
  }
  set z(value) {
    this.position.z = value;
  }
  get roll() {
    return this.orientation.roll;
  }
  set roll(value) {
    this.orientation.roll = value;
  }
  get pitch() {
    return this.orientation.pitch;
  }
  set pitch(value) {
    this.orientation.pitch = value;
  }
  get yaw() {
    return this.orientation.yaw;
  }
  set yaw(value) {
    this.orientation.yaw = value;
  }
  getPosition() {
    return this.position;
  }
  getOrientation() {
    return this.orientation;
  }
  equals(pose) {
    if (!pose) {
      return false;
    }
    return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
  }
  exactEquals(pose) {
    if (!pose) {
      return false;
    }
    return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
  }
  getTransformationMatrix() {
    const sr = Math.sin(this.roll);
    const sp = Math.sin(this.pitch);
    const sw = Math.sin(this.yaw);
    const cr = Math.cos(this.roll);
    const cp = Math.cos(this.pitch);
    const cw = Math.cos(this.yaw);
    return new _matrix.default().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
  }
  getTransformationMatrixFromPose(pose) {
    return new _matrix.default().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
  }
  getTransformationMatrixToPose(pose) {
    return new _matrix.default().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
  }
}
exports.default = Pose;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./matrix4":"node_modules/@math.gl/core/dist/esm/classes/matrix4.js","./vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","./euler":"node_modules/@math.gl/core/dist/esm/classes/euler.js"}],"node_modules/@math.gl/core/dist/esm/lib/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  EPSILON1: 1e-1,
  EPSILON2: 1e-2,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
};
exports.default = _default;
},{}],"node_modules/@math.gl/core/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "Matrix3", {
  enumerable: true,
  get: function () {
    return _matrix.default;
  }
});
Object.defineProperty(exports, "Matrix4", {
  enumerable: true,
  get: function () {
    return _matrix2.default;
  }
});
Object.defineProperty(exports, "Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "Quaternion", {
  enumerable: true,
  get: function () {
    return _quaternion.default;
  }
});
Object.defineProperty(exports, "SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "Vector2", {
  enumerable: true,
  get: function () {
    return _vector.default;
  }
});
Object.defineProperty(exports, "Vector3", {
  enumerable: true,
  get: function () {
    return _vector2.default;
  }
});
Object.defineProperty(exports, "Vector4", {
  enumerable: true,
  get: function () {
    return _vector3.default;
  }
});
Object.defineProperty(exports, "_Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "_MathUtils", {
  enumerable: true,
  get: function () {
    return _mathUtils.default;
  }
});
Object.defineProperty(exports, "_Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "_SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "acos", {
  enumerable: true,
  get: function () {
    return _common.acos;
  }
});
Object.defineProperty(exports, "asin", {
  enumerable: true,
  get: function () {
    return _common.asin;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "atan", {
  enumerable: true,
  get: function () {
    return _common.atan;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function () {
    return _common.clamp;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _common.clone;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () {
    return _common.config;
  }
});
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function () {
    return _common.configure;
  }
});
Object.defineProperty(exports, "cos", {
  enumerable: true,
  get: function () {
    return _common.cos;
  }
});
Object.defineProperty(exports, "degrees", {
  enumerable: true,
  get: function () {
    return _common.degrees;
  }
});
Object.defineProperty(exports, "equals", {
  enumerable: true,
  get: function () {
    return _common.equals;
  }
});
Object.defineProperty(exports, "exactEquals", {
  enumerable: true,
  get: function () {
    return _common.exactEquals;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function () {
    return _common.formatValue;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function () {
    return _common.isArray;
  }
});
Object.defineProperty(exports, "lerp", {
  enumerable: true,
  get: function () {
    return _common.lerp;
  }
});
Object.defineProperty(exports, "radians", {
  enumerable: true,
  get: function () {
    return _common.radians;
  }
});
Object.defineProperty(exports, "sin", {
  enumerable: true,
  get: function () {
    return _common.sin;
  }
});
Object.defineProperty(exports, "tan", {
  enumerable: true,
  get: function () {
    return _common.tan;
  }
});
Object.defineProperty(exports, "toDegrees", {
  enumerable: true,
  get: function () {
    return _common.toDegrees;
  }
});
Object.defineProperty(exports, "toRadians", {
  enumerable: true,
  get: function () {
    return _common.toRadians;
  }
});
Object.defineProperty(exports, "withEpsilon", {
  enumerable: true,
  get: function () {
    return _common.withEpsilon;
  }
});
var _vector = _interopRequireDefault(require("./classes/vector2"));
var _vector2 = _interopRequireDefault(require("./classes/vector3"));
var _vector3 = _interopRequireDefault(require("./classes/vector4"));
var _matrix = _interopRequireDefault(require("./classes/matrix3"));
var _matrix2 = _interopRequireDefault(require("./classes/matrix4"));
var _quaternion = _interopRequireDefault(require("./classes/quaternion"));
var _sphericalCoordinates = _interopRequireDefault(require("./classes/spherical-coordinates"));
var _pose = _interopRequireDefault(require("./classes/pose"));
var _euler = _interopRequireDefault(require("./classes/euler"));
var _mathUtils = _interopRequireDefault(require("./lib/math-utils"));
var _assert = _interopRequireDefault(require("./lib/assert"));
var _common = require("./lib/common");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./classes/vector2":"node_modules/@math.gl/core/dist/esm/classes/vector2.js","./classes/vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","./classes/vector4":"node_modules/@math.gl/core/dist/esm/classes/vector4.js","./classes/matrix3":"node_modules/@math.gl/core/dist/esm/classes/matrix3.js","./classes/matrix4":"node_modules/@math.gl/core/dist/esm/classes/matrix4.js","./classes/quaternion":"node_modules/@math.gl/core/dist/esm/classes/quaternion.js","./classes/spherical-coordinates":"node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js","./classes/pose":"node_modules/@math.gl/core/dist/esm/classes/pose.js","./classes/euler":"node_modules/@math.gl/core/dist/esm/classes/euler.js","./lib/math-utils":"node_modules/@math.gl/core/dist/esm/lib/math-utils.js","./lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js","./lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.project = void 0;
var _core = require("@math.gl/core");
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  let prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const uniforms = {};
  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }
  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }
  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }
  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }
  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new _core.Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }
  return uniforms;
}
const common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
const vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
const fs = "\n".concat(common);
const project = {
  name: 'project',
  getUniforms,
  vs,
  fs
};
exports.project = project;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lights = void 0;
var _lights = _interopRequireDefault(require("./lights.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_MODULE_OPTIONS = {
  lightSources: {}
};
function convertColor() {
  let {
    color = [0, 0, 0],
    intensity = 1.0
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return color.map(component => component * intensity / 255.0);
}
function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};
  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }
  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if ('lightSources' in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }
    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }
  if ('lights' in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };
    for (const light of opts.lights || []) {
      switch (light.type) {
        case 'ambient':
          lightSources.ambientLight = light;
          break;
        case 'directional':
          lightSources.directionalLights.push(light);
          break;
        case 'point':
          lightSources.pointLights.push(light);
          break;
        default:
      }
    }
    return getUniforms({
      lightSources
    });
  }
  return {};
}
const lights = {
  name: 'lights',
  vs: _lights.default,
  fs: _lights.default,
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};
exports.lights = lights;
},{"./lights.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirlight = void 0;
var _project = require("../project/project");
const DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
const DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  const uniforms = {};
  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }
  return uniforms;
}
const vs = null;
const fs = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
const dirlight = {
  name: 'dirlight',
  vs,
  fs,
  getUniforms,
  dependencies: [_project.project]
};
exports.dirlight = dirlight;
},{"../project/project":"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.picking = void 0;
const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
const DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingActive: false,
  pickingAttribute: false
};
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  const uniforms = {};
  if (opts.pickingSelectedColor !== undefined) {
    if (!opts.pickingSelectedColor) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, x => x / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms.picking_uHighlightColor = color;
  }
  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = Boolean(opts.pickingActive);
    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
  }
  return uniforms;
}
const vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
const fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
const picking = {
  name: 'picking',
  vs,
  fs,
  getUniforms
};
exports.picking = picking;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phongLighting = exports.gouraudLighting = void 0;
var _lights = require("../lights/lights");
var _phongLighting = _interopRequireDefault(require("./phong-lighting.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_MODULE_OPTIONS = {};
function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map(x => x / 255)
  };
}
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if (!('material' in opts)) {
    return {};
  }
  const {
    material
  } = opts;
  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }
  return getMaterialUniforms(material);
}
const gouraudLighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights.lights],
  vs: _phongLighting.default,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms
};
exports.gouraudLighting = gouraudLighting;
const phongLighting = {
  name: 'phong-lighting',
  dependencies: [_lights.lights],
  fs: _phongLighting.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms
};
exports.phongLighting = phongLighting;
},{"../lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./phong-lighting.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pbr = void 0;
var _lights = require("../lights/lights");
var _pbrVertex = _interopRequireDefault(require("./pbr-vertex.glsl"));
var _pbrFragment = _interopRequireDefault(require("./pbr-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const pbr = {
  name: 'pbr',
  vs: _pbrVertex.default,
  fs: _pbrFragment.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_lights.lights]
};
exports.pbr = pbr;
},{"../lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./pbr-vertex.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js","./pbr-fragment.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tiltShift = void 0;
var _random = require("../utils/random");
const fs = "uniform float blurRadius;\nuniform float gradientRadius;\nuniform vec2 start;\nuniform vec2 end;\nuniform bool invert;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((end - start) * texSize);\n  return invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((start.y - end.y) * texSize.y, (end.x - start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - start * texSize, normal)) / gradientRadius) * blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  blurRadius: {
    value: 15,
    min: 0,
    max: 50
  },
  gradientRadius: {
    value: 200,
    min: 0,
    max: 400
  },
  start: [0, 0],
  end: [1, 1],
  invert: {
    value: false,
    private: true
  }
};
const tiltShift = {
  name: 'tiltShift',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true,
    uniforms: {
      invert: false
    }
  }, {
    sampler: true,
    uniforms: {
      invert: true
    }
  }]
};
exports.tiltShift = tiltShift;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.triangleBlur = void 0;
var _random = require("../utils/random");
const fs = "uniform float radius;\nuniform vec2 delta;\n\nvec4 triangleBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = delta * radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + adjustedDelta * percent);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  radius: {
    value: 20,
    min: 0,
    softMax: 100
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const triangleBlur = {
  name: 'triangleBlur',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true,
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: true,
    uniforms: {
      delta: [0, 1]
    }
  }]
};
exports.triangleBlur = triangleBlur;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomBlur = void 0;
var _random = require("../utils/random");
const fs = "\nuniform vec2 center;\nuniform float strength;\n\nvec4 zoomBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = center * texSize - texCoord * texSize;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  strength: {
    value: 0.3,
    min: 0,
    softMax: 1
  }
};
const zoomBlur = {
  name: 'zoomBlur',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true
  }]
};
exports.zoomBlur = zoomBlur;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brightnessContrast = void 0;
const fs = "uniform float brightness;\nuniform float contrast;\n\nvec4 brightnessContrast_filterColor(vec4 color) {\n  color.rgb += brightness;\n  if (contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\n  }\n  return color;\n}\n\nvec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {\n  return brightnessContrast_filterColor(color);\n}\n";
const uniforms = {
  brightness: {
    value: 0,
    min: -1,
    max: 1
  },
  contrast: {
    value: 0,
    min: -1,
    max: 1
  }
};
const brightnessContrast = {
  name: 'brightnessContrast',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.brightnessContrast = brightnessContrast;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.denoise = void 0;
const fs = "uniform float strength;\n\nvec4 denoise_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  float adjustedExponent = 3. + 200. * pow(1. - strength, 4.);\n\n  vec4 center = texture2D(texture, texCoord);\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float x = -4.0; x <= 4.0; x += 1.0) {\n    for (float y = -4.0; y <= 4.0; y += 1.0) {\n      vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);\n      float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));\n      weight = pow(weight, adjustedExponent);\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  return color / total;\n}\n";
const uniforms = {
  strength: {
    value: 0.5,
    min: 0,
    max: 0.1,
    adjust: strength => 0.53 + 200 * Math.pow(1 - strength, 4)
  }
};
const denoise = {
  name: 'denoise',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }, {
    sampler: true
  }]
};
exports.denoise = denoise;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hueSaturation = void 0;
const fs = "uniform float hue;\nuniform float saturation;\n\nvec4 hueSaturation_filterColor(vec4 color) {\n  float angle = hue * 3.14159265;\n  float s = sin(angle), c = cos(angle);\n  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n  float len = length(color.rgb);\n  color.rgb = vec3(\n    dot(color.rgb, weights.xyz),\n    dot(color.rgb, weights.zxy),\n    dot(color.rgb, weights.yzx)\n  );\n  float average = (color.r + color.g + color.b) / 3.0;\n  if (saturation > 0.0) {\n    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n  } else {\n    color.rgb += (average - color.rgb) * (-saturation);\n  }\n\n  return color;\n}\n\nvec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return hueSaturation_filterColor(color);\n}\n";
const uniforms = {
  hue: {
    value: 0,
    min: -1,
    max: 1
  },
  saturation: {
    value: 0,
    min: -1,
    max: 1
  }
};
const hueSaturation = {
  name: 'hueSaturation',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.hueSaturation = hueSaturation;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noise = void 0;
const fs = "uniform float amount;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return noise_filterColor(color, texCoord);\n}\n";
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const noise = {
  name: 'noise',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.noise = noise;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sepia = void 0;
const fs = "uniform float amount;\n\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));\n  color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));\n  color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n";
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const sepia = {
  name: 'sepia',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.sepia = sepia;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vibrance = void 0;
const fs = "uniform float amount;\n\nvec4 vibrance_filterColor(vec4 color) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  float mx = max(color.r, max(color.g, color.b));\n  float amt = (mx - average) * (-amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n";
const uniforms = {
  amount: {
    value: 0,
    min: -1,
    max: 1
  }
};
const vibrance = {
  name: 'vibrance',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.vibrance = vibrance;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vignette = void 0;
const fs = "uniform float radius;\nuniform float amount;\n\nvec4 vignette_filterColor(vec4 color, vec2 texCoord) {\n  float dist = distance(texCoord, vec2(0.5, 0.5));\n  float ratio = smoothstep(0.8, radius * 0.799, dist * (amount + radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vignette_filterColor(color, texCoord);\n}\n";
const uniforms = {
  radius: {
    value: 0.5,
    min: 0,
    max: 1
  },
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const vignette = {
  name: 'vignette',
  fs,
  uniforms,
  passes: [{
    filter: true
  }]
};
exports.vignette = vignette;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colorHalftone = void 0;
const fs = "uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat scale = 3.1514 / size;\n\nfloat pattern(float angle, vec2 texSize, vec2 texCoord) {\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n\tc * tex.x - s * tex.y,\n\ts * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\tcmy * 10.0 - 3.0 + vec3(\n    pattern(angle + 0.26179, texSize, texCoord),\n\t  pattern(angle + 1.30899, texSize, texCoord),\n    pattern(angle, texSize, texCoord)\n  ),\n\t0.0,\n\t1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 4,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const colorHalftone = {
  name: 'colorHalftone',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.colorHalftone = colorHalftone;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dotScreen = void 0;
const fs = "uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat pattern(vec2 texSize, vec2 texCoord) {\n  float scale = 3.1415 / size;\n\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 3,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const dotScreen = {
  name: 'dotScreen',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.dotScreen = dotScreen;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.edgeWork = void 0;
var _random = require("../utils/random");
const fs = "uniform float radius;\nuniform vec2 delta;\n\nvec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture2D(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n\nvec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec2 sampleColor = texture2D(source, texCoord + relativeDelta * percent).xy;\n    color.x += sampleColor.x * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += sampleColor.y * weight;\n      total.y += weight;\n    }\n  }\n  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\n  return vec4(c, c, c, 1.0);\n}\n";
const uniforms = {
  radius: {
    value: 2,
    min: 1,
    softMax: 50
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const edgeWork = {
  name: 'edgeWork',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: 'edgeWork_sampleColor1',
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: 'edgeWork_sampleColor2',
    uniforms: {
      delta: [0, 1]
    }
  }]
};
exports.edgeWork = edgeWork;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hexagonalPixelate = void 0;
const fs = "uniform vec2 center;\nuniform float scale;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - center * texSize) / scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= scale / texSize;\n\n  return texture2D(texture, choice + center);\n}\n";
const uniforms = {
  center: {
    value: [0.5, 0.5],
    hint: 'screenspace'
  },
  scale: {
    value: 10,
    min: 1,
    softMin: 5,
    softMax: 50
  }
};
const hexagonalPixelate = {
  name: 'hexagonalPixelate',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.hexagonalPixelate = hexagonalPixelate;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ink = void 0;
const fs = "uniform float strength;\n\nvec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture2D(texture, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\n      bigAverage += sample;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += sample;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = strength * strength * strength * strength * strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n";
const uniforms = {
  strength: {
    value: 0.25,
    min: 0,
    softMax: 1
  }
};
const ink = {
  name: 'ink',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.ink = ink;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.magnify = void 0;
const fs = "uniform vec2 screenXY;\nuniform float radiusPixels;\nuniform float zoom;\nuniform float borderWidthPixels;\nuniform vec4 borderColor;\n\nvec4 magnify_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 pos = vec2(screenXY.x, 1.0 - screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < radiusPixels) {\n    return texture2D(texture, (texCoord - pos) / zoom + pos);\n  }\n\n  if (dist <= radiusPixels + borderWidthPixels) {\n    return borderColor;\n  }\n  return texture2D(texture, texCoord);\n}\n";
const uniforms = {
  screenXY: [0, 0],
  radiusPixels: 200,
  zoom: 2.0,
  borderWidthPixels: 0.0,
  borderColor: [255, 255, 255, 255]
};
const magnify = {
  name: 'magnify',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.magnify = magnify;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warp = void 0;
const fs = "vec4 warp_sampleColor(sampler2D texture, vec2 texSize, vec2 coord) {\n  vec4 color = texture2D(texture, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n\n  return color;\n}\n";
const warp = {
  name: 'warp',
  fs
};
exports.warp = warp;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bulgePinch = void 0;
var _warp = require("./warp");
const fs = "uniform float radius;\nuniform float strength;\nuniform vec2 center;\n\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = distance / radius;\n    if (strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 bulgePinch_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  strength: {
    value: 0.5,
    min: -1,
    max: 1
  }
};
const bulgePinch = {
  name: 'bulgePinch',
  fs,
  uniforms,
  dependencies: [_warp.warp],
  passes: [{
    sampler: true
  }]
};
exports.bulgePinch = bulgePinch;
},{"./warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.swirl = void 0;
var _warp = require("./warp");
const fs = "uniform float radius;\nuniform float angle;\nuniform vec2 center;\n\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = (radius - distance) / radius;\n    float theta = percent * percent * angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 swirl_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  angle: {
    value: 3,
    softMin: -25,
    softMax: 25
  }
};
const swirl = {
  name: 'swirl',
  fs,
  uniforms,
  dependencies: [_warp.warp],
  passes: [{
    sampler: true
  }]
};
exports.swirl = swirl;
},{"./warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fxaa = void 0;
/**
 * ORIGINAL LICENCE
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
const fs = "\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture2D(t, p)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n\n\n    FxaaFloat2 pos,\n\n\n\n\n    FxaaTex tex,\n\n\n\n\n    FxaaFloat2 fxaaQualityRcpFrame,\n\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualitySubpix,\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualityEdgeThreshold,\n\n\n\n\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n    if(earlyExit)\n        return rgbyM;\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    #endif\n                        }\n                        #endif\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        texture,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n";
const fxaa = {
  name: 'fxaa',
  uniforms: {},
  fs,
  passes: [{
    sampler: true
  }]
};
exports.fxaa = fxaa;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = void 0;
const vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const transform = {
  name: 'transform',
  vs,
  fs: null
};
exports.transform = transform;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function () {
    return _transform.transform;
  }
});
Object.defineProperty(exports, "_warp", {
  enumerable: true,
  get: function () {
    return _warp.warp;
  }
});
Object.defineProperty(exports, "brightnessContrast", {
  enumerable: true,
  get: function () {
    return _brightnesscontrast.brightnessContrast;
  }
});
Object.defineProperty(exports, "bulgePinch", {
  enumerable: true,
  get: function () {
    return _bulgepinch.bulgePinch;
  }
});
Object.defineProperty(exports, "colorHalftone", {
  enumerable: true,
  get: function () {
    return _colorhalftone.colorHalftone;
  }
});
Object.defineProperty(exports, "denoise", {
  enumerable: true,
  get: function () {
    return _denoise.denoise;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _dirlight.dirlight;
  }
});
Object.defineProperty(exports, "dotScreen", {
  enumerable: true,
  get: function () {
    return _dotscreen.dotScreen;
  }
});
Object.defineProperty(exports, "edgeWork", {
  enumerable: true,
  get: function () {
    return _edgework.edgeWork;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _fp.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _fp2.fp64;
  }
});
Object.defineProperty(exports, "fp64arithmetic", {
  enumerable: true,
  get: function () {
    return _fp2.fp64arithmetic;
  }
});
Object.defineProperty(exports, "fxaa", {
  enumerable: true,
  get: function () {
    return _fxaa.fxaa;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.gouraudLighting;
  }
});
Object.defineProperty(exports, "hexagonalPixelate", {
  enumerable: true,
  get: function () {
    return _hexagonalpixelate.hexagonalPixelate;
  }
});
Object.defineProperty(exports, "hueSaturation", {
  enumerable: true,
  get: function () {
    return _huesaturation.hueSaturation;
  }
});
Object.defineProperty(exports, "ink", {
  enumerable: true,
  get: function () {
    return _ink.ink;
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function () {
    return _lights.lights;
  }
});
Object.defineProperty(exports, "magnify", {
  enumerable: true,
  get: function () {
    return _magnify.magnify;
  }
});
Object.defineProperty(exports, "noise", {
  enumerable: true,
  get: function () {
    return _noise.noise;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _pbr.pbr;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.project;
  }
});
Object.defineProperty(exports, "random", {
  enumerable: true,
  get: function () {
    return _random.random;
  }
});
Object.defineProperty(exports, "sepia", {
  enumerable: true,
  get: function () {
    return _sepia.sepia;
  }
});
Object.defineProperty(exports, "swirl", {
  enumerable: true,
  get: function () {
    return _swirl.swirl;
  }
});
Object.defineProperty(exports, "tiltShift", {
  enumerable: true,
  get: function () {
    return _tiltshift.tiltShift;
  }
});
Object.defineProperty(exports, "triangleBlur", {
  enumerable: true,
  get: function () {
    return _triangleblur.triangleBlur;
  }
});
Object.defineProperty(exports, "vibrance", {
  enumerable: true,
  get: function () {
    return _vibrance.vibrance;
  }
});
Object.defineProperty(exports, "vignette", {
  enumerable: true,
  get: function () {
    return _vignette.vignette;
  }
});
Object.defineProperty(exports, "zoomBlur", {
  enumerable: true,
  get: function () {
    return _zoomblur.zoomBlur;
  }
});
var _random = require("./utils/random");
var _fp = require("./fp32/fp32");
var _fp2 = require("./fp64/fp64");
var _project = require("./project/project");
var _lights = require("./lights/lights");
var _dirlight = require("./dirlight/dirlight");
var _picking = require("./picking/picking");
var _phongLighting = require("./phong-lighting/phong-lighting");
var _pbr = require("./pbr/pbr");
var _tiltshift = require("./image-blur-filters/tiltshift");
var _triangleblur = require("./image-blur-filters/triangleblur");
var _zoomblur = require("./image-blur-filters/zoomblur");
var _brightnesscontrast = require("./image-adjust-filters/brightnesscontrast");
var _denoise = require("./image-adjust-filters/denoise");
var _huesaturation = require("./image-adjust-filters/huesaturation");
var _noise = require("./image-adjust-filters/noise");
var _sepia = require("./image-adjust-filters/sepia");
var _vibrance = require("./image-adjust-filters/vibrance");
var _vignette = require("./image-adjust-filters/vignette");
var _colorhalftone = require("./image-fun-filters/colorhalftone");
var _dotscreen = require("./image-fun-filters/dotscreen");
var _edgework = require("./image-fun-filters/edgework");
var _hexagonalpixelate = require("./image-fun-filters/hexagonalpixelate");
var _ink = require("./image-fun-filters/ink");
var _magnify = require("./image-fun-filters/magnify");
var _bulgepinch = require("./image-warp-filters/bulgepinch");
var _swirl = require("./image-warp-filters/swirl");
var _warp = require("./image-warp-filters/warp");
var _fxaa = require("./fxaa/fxaa");
var _transform = require("./transform/transform");
},{"./utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js","./fp32/fp32":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js","./fp64/fp64":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js","./project/project":"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js","./lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./dirlight/dirlight":"node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js","./picking/picking":"node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js","./phong-lighting/phong-lighting":"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","./pbr/pbr":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js","./image-blur-filters/tiltshift":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js","./image-blur-filters/triangleblur":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js","./image-blur-filters/zoomblur":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js","./image-adjust-filters/brightnesscontrast":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js","./image-adjust-filters/denoise":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js","./image-adjust-filters/huesaturation":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js","./image-adjust-filters/noise":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js","./image-adjust-filters/sepia":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js","./image-adjust-filters/vibrance":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js","./image-adjust-filters/vignette":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js","./image-fun-filters/colorhalftone":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js","./image-fun-filters/dotscreen":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js","./image-fun-filters/edgework":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js","./image-fun-filters/hexagonalpixelate":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js","./image-fun-filters/ink":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js","./image-fun-filters/magnify":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js","./image-warp-filters/bulgepinch":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js","./image-warp-filters/swirl":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js","./image-warp-filters/warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js","./fxaa/fxaa":"node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js","./transform/transform":"node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js"}],"node_modules/@luma.gl/shadertools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  assembleShaders: true,
  combineInjects: true,
  normalizeShaderModule: true,
  getQualifierDetails: true,
  getPassthroughFS: true,
  typeToChannelSuffix: true,
  typeToChannelCount: true,
  convertToVec4: true
};
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function () {
    return _assembleShaders.assembleShaders;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function () {
    return _injectShader.combineInjects;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function () {
    return _shaderUtils.convertToVec4;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getPassthroughFS;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getQualifierDetails;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shaderModule.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelCount;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelSuffix;
  }
});
var _assembleShaders = require("./lib/assemble-shaders");
var _injectShader = require("./lib/inject-shader");
var _shaderModule = require("./lib/shader-module");
var _shaderUtils = require("./utils/shader-utils");
var _modules = require("./modules");
Object.keys(_modules).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _modules[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modules[key];
    }
  });
});
},{"./lib/assemble-shaders":"node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js","./lib/inject-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./lib/shader-module":"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","./utils/shader-utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js","./modules":"node_modules/@luma.gl/shadertools/dist/esm/modules/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _shadertools = require("@luma.gl/shadertools");
var _webgl = require("@luma.gl/webgl");
class ProgramManager {
  static getDefaultProgramManager(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
    return gl.luma.defaultProgramManager;
  }
  constructor(gl) {
    this.gl = gl;
    this._programCache = {};
    this._getUniforms = {};
    this._registeredModules = {};
    this._hookFunctions = [];
    this._defaultModules = [];
    this._hashes = {};
    this._hashCounter = 0;
    this.stateHash = 0;
    this._useCounts = {};
  }
  addDefaultModule(module) {
    if (!this._defaultModules.find(m => m.name === module.name)) {
      this._defaultModules.push(module);
    }
    this.stateHash++;
  }
  removeDefaultModule(module) {
    const moduleName = typeof module === 'string' ? module : module.name;
    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);
    this.stateHash++;
  }
  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, {
        hook
      });
    }
    this._hookFunctions.push(hook);
    this.stateHash++;
  }
  get() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      vs = '',
      fs = '',
      defines = {},
      inject = {},
      varyings = [],
      bufferMode = 0x8c8d,
      transpileToGLSL100 = false
    } = props;
    const modules = this._getModuleList(props.modules);
    const vsHash = this._getHash(vs);
    const fsHash = this._getHash(fs);
    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();
    const varyingHashes = varyings.map(v => this._getHash(v));
    const defineKeys = Object.keys(defines).sort();
    const injectKeys = Object.keys(inject).sort();
    const defineHashes = [];
    const injectHashes = [];
    for (const key of defineKeys) {
      defineHashes.push(this._getHash(key));
      defineHashes.push(this._getHash(defines[key]));
    }
    for (const key of injectKeys) {
      injectHashes.push(this._getHash(key));
      injectHashes.push(this._getHash(inject[key]));
    }
    const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join('/'), "M").concat(moduleHashes.join('/'), "I").concat(injectHashes.join('/'), "V").concat(varyingHashes.join('/'), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? 'T' : '');
    if (!this._programCache[hash]) {
      const assembled = (0, _shadertools.assembleShaders)(this.gl, {
        vs,
        fs,
        modules,
        inject,
        defines,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100
      });
      this._programCache[hash] = new _webgl.Program(this.gl, {
        hash,
        vs: assembled.vs,
        fs: assembled.fs,
        varyings,
        bufferMode
      });
      this._getUniforms[hash] = assembled.getUniforms || (x => {});
      this._useCounts[hash] = 0;
    }
    this._useCounts[hash]++;
    return this._programCache[hash];
  }
  getUniforms(program) {
    return this._getUniforms[program.hash] || null;
  }
  release(program) {
    const hash = program.hash;
    this._useCounts[hash]--;
    if (this._useCounts[hash] === 0) {
      this._programCache[hash].delete();
      delete this._programCache[hash];
      delete this._getUniforms[hash];
      delete this._useCounts[hash];
    }
  }
  _getHash(key) {
    if (this._hashes[key] === undefined) {
      this._hashes[key] = this._hashCounter++;
    }
    return this._hashes[key];
  }
  _getModuleList() {
    let appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count = 0;
    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name = module.name;
      modules[count++] = module;
      seen[name] = true;
    }
    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name = module.name;
      if (!seen[name]) {
        modules[count++] = module;
        seen[name] = true;
      }
    }
    modules.length = count;
    return modules;
  }
}
exports.default = ProgramManager;
},{"@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuffersFromGeometry = getBuffersFromGeometry;
exports.inferAttributeAccessor = inferAttributeAccessor;
var _webgl = require("@luma.gl/webgl");
const GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};
function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;
  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);
    if (name === 'indices') {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = {
        ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new _webgl.Buffer(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }
  if (indices) {
    const data = indices.value || indices;
    (0, _webgl.assert)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
    };
    buffers.indices = [new _webgl.Buffer(gl, {
      data,
      target: 34963
    }), accessor];
  }
  return buffers;
}
function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}
function inferAttributeAccessor(attributeName, attribute) {
  let category;
  switch (attributeName) {
    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;
    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;
    default:
  }
  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;
    case 'uvs':
      attribute.size = attribute.size || 2;
      break;
    default:
  }
  (0, _webgl.assert)(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/model.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _programManager = _interopRequireDefault(require("./program-manager"));
var _webgl = require("@luma.gl/webgl");
var _modelUtils = require("./model-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
const ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';
const NOOP = () => {};
const DRAW_PARAMS = {};
class Model {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      id = (0, _webgl.uid)('model')
    } = props;
    (0, _webgl.assert)((0, _gltools.isWebGL)(gl));
    this.id = id;
    this.gl = gl;
    this.id = props.id || (0, _webgl.uid)('Model');
    this.lastLogTime = 0;
    this.animated = false;
    this.initialize(props);
  }
  initialize(props) {
    this.props = {};
    this.programManager = props.programManager || _programManager.default.getDefaultProgramManager(this.gl);
    this._programManagerState = -1;
    this._managedProgram = false;
    const {
      program = null,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this.program = null;
    this.vertexArray = null;
    this._programDirty = true;
    this.userData = {};
    this.needsRedraw = true;
    this._attributes = {};
    this.attributes = {};
    this.uniforms = {};
    this.pickable = true;
    this._checkProgram();
    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
    this.vertexCount = props.vertexCount || 0;
    this.geometryBuffers = {};
    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
    this._setModelProps(props);
    this.geometry = {};
    (0, _webgl.assert)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
  }
  setProps(props) {
    this._setModelProps(props);
  }
  delete() {
    for (const key in this._attributes) {
      if (this._attributes[key] !== this.attributes[key]) {
        this._attributes[key].delete();
      }
    }
    if (this._managedProgram) {
      this.programManager.release(this.program);
      this._managedProgram = false;
    }
    this.vertexArray.delete();
    this._deleteGeometryBuffers();
  }
  getDrawMode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getProgram() {
    return this.program;
  }
  setProgram(props) {
    const {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this._programDirty = true;
  }
  getUniforms() {
    return this.uniforms;
  }
  setDrawMode(drawMode) {
    this.drawMode = drawMode;
    return this;
  }
  setVertexCount(vertexCount) {
    (0, _webgl.assert)(Number.isFinite(vertexCount));
    this.vertexCount = vertexCount;
    return this;
  }
  setInstanceCount(instanceCount) {
    (0, _webgl.assert)(Number.isFinite(instanceCount));
    this.instanceCount = instanceCount;
    return this;
  }
  setGeometry(geometry) {
    this.drawMode = geometry.drawMode;
    this.vertexCount = geometry.getVertexCount();
    this._deleteGeometryBuffers();
    this.geometryBuffers = (0, _modelUtils.getBuffersFromGeometry)(this.gl, geometry);
    this.vertexArray.setAttributes(this.geometryBuffers);
    return this;
  }
  setAttributes() {
    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if ((0, _webgl.isObjectEmpty)(attributes)) {
      return this;
    }
    const normalizedAttributes = {};
    for (const name in attributes) {
      const attribute = attributes[name];
      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
    }
    this.vertexArray.setAttributes(normalizedAttributes);
    return this;
  }
  setUniforms() {
    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    Object.assign(this.uniforms, uniforms);
    return this;
  }
  getModuleUniforms(opts) {
    this._checkProgram();
    const getUniforms = this.programManager.getUniforms(this.program);
    if (getUniforms) {
      return getUniforms(opts);
    }
    return {};
  }
  updateModuleSettings(opts) {
    const uniforms = this.getModuleUniforms(opts || {});
    return this.setUniforms(uniforms);
  }
  clear(opts) {
    (0, _webgl.clear)(this.program.gl, opts);
    return this;
  }
  draw() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._checkProgram();
    const {
      moduleSettings = null,
      framebuffer,
      uniforms = {},
      attributes = {},
      transformFeedback = this.transformFeedback,
      parameters = {},
      vertexArray = this.vertexArray
    } = opts;
    this.setAttributes(attributes);
    this.updateModuleSettings(moduleSettings);
    this.setUniforms(uniforms);
    let logPriority;
    if (_webgl.log.priority >= LOG_DRAW_PRIORITY) {
      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
    }
    const drawParams = this.vertexArray.getDrawParams();
    const {
      isIndexed = drawParams.isIndexed,
      indexType = drawParams.indexType,
      indexOffset = drawParams.indexOffset,
      vertexArrayInstanced = drawParams.isInstanced
    } = this.props;
    if (vertexArrayInstanced && !this.isInstanced) {
      _webgl.log.warn('Found instanced attributes on non-instanced model', this.id)();
    }
    const {
      isInstanced,
      instanceCount
    } = this;
    const {
      onBeforeRender = NOOP,
      onAfterRender = NOOP
    } = this.props;
    onBeforeRender();
    this.program.setUniforms(this.uniforms);
    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
      logPriority,
      uniforms: null,
      framebuffer,
      parameters,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray,
      transformFeedback,
      isIndexed,
      indexType,
      isInstanced,
      instanceCount,
      offset: isIndexed ? indexOffset : 0
    }));
    onAfterRender();
    if (_webgl.log.priority >= LOG_DRAW_PRIORITY) {
      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
    }
    return didDraw;
  }
  transform() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      discard = true,
      feedbackBuffers,
      unbindModels = []
    } = opts;
    let {
      parameters
    } = opts;
    if (feedbackBuffers) {
      this._setFeedbackBuffers(feedbackBuffers);
    }
    if (discard) {
      parameters = Object.assign({}, parameters, {
        [35977]: discard
      });
    }
    unbindModels.forEach(model => model.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, opts, {
        parameters
      }));
    } finally {
      unbindModels.forEach(model => model.vertexArray.bindBuffers());
    }
    return this;
  }
  render() {
    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _webgl.log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();
    return this.setUniforms(uniforms).draw();
  }
  _setModelProps(props) {
    Object.assign(this.props, props);
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }
    if ('pickable' in props) {
      this.pickable = props.pickable;
    }
    if ('instanceCount' in props) {
      this.instanceCount = props.instanceCount;
    }
    if ('geometry' in props) {
      this.setGeometry(props.geometry);
    }
    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }
    if ('_feedbackBuffers' in props) {
      this._setFeedbackBuffers(props._feedbackBuffers);
    }
  }
  _checkProgram() {
    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
    if (!needsUpdate) {
      return;
    }
    let {
      program
    } = this.programProps;
    if (program) {
      this._managedProgram = false;
    } else {
      const {
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = this.programProps;
      program = this.programManager.get({
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      });
      if (this.program && this._managedProgram) {
        this.programManager.release(this.program);
      }
      this._programManagerState = this.programManager.stateHash;
      this._managedProgram = true;
    }
    (0, _webgl.assert)(program instanceof _webgl.Program, 'Model needs a program');
    this._programDirty = false;
    if (program === this.program) {
      return;
    }
    this.program = program;
    if (this.vertexArray) {
      this.vertexArray.setProps({
        program: this.program,
        attributes: this.vertexArray.attributes
      });
    } else {
      this.vertexArray = new _webgl.VertexArray(this.gl, {
        program: this.program
      });
    }
    this.setUniforms(Object.assign({}, this.getModuleUniforms()));
  }
  _deleteGeometryBuffers() {
    for (const name in this.geometryBuffers) {
      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
      if (buffer instanceof _webgl.Buffer) {
        buffer.delete();
      }
    }
  }
  _setAnimationProps(animationProps) {
    if (this.animated) {
      (0, _webgl.assert)(animationProps, 'Model.draw(): animated uniforms but no animationProps');
    }
  }
  _setFeedbackBuffers() {
    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if ((0, _webgl.isObjectEmpty)(feedbackBuffers)) {
      return this;
    }
    const {
      gl
    } = this.program;
    this.transformFeedback = this.transformFeedback || new _webgl.TransformFeedback(gl, {
      program: this.program
    });
    this.transformFeedback.setBuffers(feedbackBuffers);
    return this;
  }
  _logDrawCallStart(logLevel) {
    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (Date.now() - this.lastLogTime < logDrawTimeout) {
      return undefined;
    }
    this.lastLogTime = Date.now();
    _webgl.log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
      collapsed: _webgl.log.level <= 2
    })();
    return logLevel;
  }
  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
    if (logLevel === undefined) {
      return;
    }
    const attributeTable = (0, _webgl.getDebugTableForVertexArray)({
      vertexArray,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    });
    const {
      table: uniformTable,
      unusedTable,
      unusedCount
    } = (0, _webgl.getDebugTableForUniforms)({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms)
    });
    const {
      table: missingTable,
      count: missingCount
    } = (0, _webgl.getDebugTableForUniforms)({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms),
      undefinedOnly: true
    });
    if (missingCount > 0) {
      _webgl.log.log('MISSING UNIFORMS', Object.keys(missingTable))();
    }
    if (unusedCount > 0) {
      _webgl.log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();
    }
    const configTable = (0, _webgl.getDebugTableForProgramConfiguration)(this.vertexArray.configuration);
    _webgl.log.table(logLevel, attributeTable)();
    _webgl.log.table(logLevel, uniformTable)();
    _webgl.log.table(logLevel + 1, configTable)();
    if (framebuffer) {
      framebuffer.log({
        logLevel: LOG_DRAW_PRIORITY,
        message: "Rendered to ".concat(framebuffer.id)
      });
    }
    _webgl.log.groupEnd(LOG_DRAW_PRIORITY)();
  }
}
exports.default = Model;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./program-manager":"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","./model-utils":"node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
class BufferTransform {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};
    this._initialize(props);
    Object.seal(this);
  }
  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }
  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      varyings
    } = this;
    if (varyings.length > 0) {
      props = Object.assign({}, props, {
        varyings
      });
    }
    return props;
  }
  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const binding = this.bindings[this.currentIndex];
    const {
      sourceBuffers,
      transformFeedback
    } = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    return {
      attributes,
      transformFeedback
    };
  }
  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._setupBuffers(opts);
  }
  getBuffer(varyingName) {
    const {
      feedbackBuffers
    } = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
    if (!bufferOrParams) {
      return null;
    }
    return bufferOrParams instanceof _webgl.Buffer ? bufferOrParams : bufferOrParams.buffer;
  }
  getData() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      varyingName
    } = options;
    const buffer = this.getBuffer(varyingName);
    if (buffer) {
      return buffer.getData();
    }
    return null;
  }
  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._setupBuffers(props);
    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
    if (this.varyings.length > 0) {
      (0, _webgl.assert)((0, _gltools.isWebGL2)(this.gl));
    }
  }
  _getFeedbackBuffers(props) {
    const {
      sourceBuffers = {}
    } = props;
    const feedbackBuffers = {};
    if (this.bindings[this.currentIndex]) {
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }
    if (this.feedbackMap) {
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];
        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }
    Object.assign(feedbackBuffers, props.feedbackBuffers);
    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];
      if (typeof bufferOrRef === 'string') {
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {
          byteLength,
          usage,
          accessor
        } = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }
    return feedbackBuffers;
  }
  _setupBuffers() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers = null
    } = props;
    Object.assign(this.feedbackMap, props.feedbackMap);
    const feedbackBuffers = this._getFeedbackBuffers(props);
    this._updateBindings({
      sourceBuffers,
      feedbackBuffers
    });
  }
  _setupTransformFeedback(binding, _ref) {
    let {
      model
    } = _ref;
    const {
      program
    } = model;
    binding.transformFeedback = new _webgl.TransformFeedback(this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }
  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this.feedbackMap) {
      const {
        sourceBuffers,
        feedbackBuffers
      } = this._swapBuffers(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }
  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }
    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }
    return binding;
  }
  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }
    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
      (0, _webgl.assert)(feedbackBuffers[dstName] instanceof _webgl.Buffer);
    }
    return {
      sourceBuffers,
      feedbackBuffers
    };
  }
  _createNewBuffer(name, opts) {
    const buffer = new _webgl.Buffer(this.gl, opts);
    if (this.resources[name]) {
      this.resources[name].delete();
    }
    this.resources[name] = buffer;
    return buffer;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
}
exports.default = BufferTransform;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSizeUniforms = getSizeUniforms;
exports.getVaryingType = getVaryingType;
exports.processAttributeDefinition = processAttributeDefinition;
exports.updateForTextures = updateForTextures;
var _webgl = require("@luma.gl/webgl");
var _shadertools = require("@luma.gl/shadertools");
const SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
const SIZE_UNIFORM_PREFIX = 'transform_uSize_';
const VS_POS_VARIABLE = 'transform_position';
function updateForTextures(_ref) {
  let {
    vs,
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref;
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs;
  let finalInject = {};
  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split('\n');
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);
        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }
      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });
    if (targetTextureVarying) {
      (0, _webgl.assert)(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
    }
    updatedVs = updateVsLines.join('\n');
  }
  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms(_ref2) {
  let {
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref2;
  const uniforms = {};
  let width;
  let height;
  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }
  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }
  return uniforms;
}
function getAttributeDefinition(line) {
  return (0, _shadertools.getQualifierDetails)(line, ['attribute', 'in']);
}
function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}
function getVaryingType(line, varying) {
  const qualaiferDetails = (0, _shadertools.getQualifierDetails)(line, ['varying', 'out']);
  if (!qualaiferDetails) {
    return null;
  }
  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);
  if (!attributeData) {
    return null;
  }
  const {
    type,
    name
  } = attributeData;
  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = (0, _shadertools.typeToChannelSuffix)(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }
  return null;
}
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _webgl = require("@luma.gl/webgl");
var _shadertools = require("@luma.gl/shadertools");
var _transformShaderUtils = require("./transform-shader-utils");
const SRC_TEX_PARAMETER_OVERRIDES = {
  [10241]: 9728,
  [10240]: 9728,
  [10242]: 33071,
  [10243]: 33071
};
const FS_OUTPUT_VARIABLE = 'transform_output';
class TextureTransform {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.id = this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};
    this._initialize(props);
    Object.seal(this);
  }
  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const updatedModelProps = this._processVertexShader(props);
    return Object.assign({}, props, updatedModelProps);
  }
  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers,
      sourceTextures,
      framebuffer,
      targetTexture
    } = this.bindings[this.currentIndex];
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;
    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;
      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }
      this._setSourceTextureParameters();
      const sizeUniforms = (0, _transformShaderUtils.getSizeUniforms)({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }
    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }
    return {
      attributes,
      framebuffer,
      uniforms,
      discard,
      parameters
    };
  }
  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._setupTextures(opts);
  }
  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }
  getData() {
    let {
      packed = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const pixels = (0, _webgl.readPixelsToArray)(framebuffer);
    if (!packed) {
      return pixels;
    }
    const ArrayType = pixels.constructor;
    const channelCount = (0, _shadertools.typeToChannelCount)(this.targetTextureType);
    const packedPixels = new ArrayType(pixels.length * channelCount / 4);
    let packCount = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }
    return packedPixels;
  }
  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }
  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      _targetTextureVarying,
      _swapTexture
    } = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;
    this._setupTextures(props);
  }
  _createTargetTexture(props) {
    const {
      sourceTextures,
      textureOrReference
    } = props;
    if (textureOrReference instanceof _webgl.Texture2D) {
      return textureOrReference;
    }
    const refTexture = sourceTextures[textureOrReference];
    if (!refTexture) {
      return null;
    }
    this._targetRefTexName = textureOrReference;
    return this._createNewTexture(refTexture);
  }
  _setupTextures() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers,
      _sourceTextures = {},
      _targetTexture
    } = props;
    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });
    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
    this._updateBindings({
      sourceBuffers,
      sourceTextures: _sourceTextures,
      targetTexture
    });
    if ('elementCount' in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }
  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {
      return;
    }
    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });
    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new _webgl.Buffer(this.gl, {
        data: elementIds,
        accessor: {
          size: 1
        }
      });
    } else {
      this.elementIDBuffer.setData({
        data: elementIds
      });
    }
    this.elementCount = elementCount;
  }
  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this._swapTexture) {
      const {
        sourceTextures,
        targetTexture
      } = this._swapTextures(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }
  _updateBinding(binding, opts) {
    const {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = opts;
    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }
    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);
    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      const {
        framebuffer
      } = binding;
      if (framebuffer) {
        framebuffer.update({
          attachments: {
            [36064]: targetTexture
          },
          resizeAttachments: false
        });
        framebuffer.resize({
          width,
          height
        });
      } else {
        binding.framebuffer = new _webgl.Framebuffer(this.gl, {
          id: "transform-framebuffer",
          width,
          height,
          attachments: {
            [36064]: targetTexture
          }
        });
      }
    }
    return binding;
  }
  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];
    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }
  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }
    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;
    const targetTexture = opts.sourceTextures[this._swapTexture];
    return {
      sourceTextures,
      targetTexture
    };
  }
  _createNewTexture(refTexture) {
    const texture = (0, _webgl.cloneTextureFrom)(refTexture, {
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      },
      pixelStore: {
        [37440]: false
      }
    });
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    this.ownTexture = texture;
    return texture;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
  _processVertexShader() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceTextures,
      targetTexture
    } = this.bindings[this.currentIndex];
    const {
      vs,
      uniforms,
      targetTextureType,
      inject,
      samplerTextureMap
    } = (0, _transformShaderUtils.updateForTextures)({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = (0, _shadertools.combineInjects)([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs = props._fs || (0, _shadertools.getPassthroughFS)({
      version: (0, _webgl.getShaderVersion)(vs),
      input: this.targetTextureVarying,
      inputType: targetTextureType,
      output: FS_OUTPUT_VARIABLE
    });
    const modules = this.hasSourceTextures || this.targetTextureVarying ? [_shadertools._transform].concat(props.modules || []) : props.modules;
    return {
      vs,
      fs,
      modules,
      uniforms,
      inject: combinedInject
    };
  }
}
exports.default = TextureTransform;
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","./transform-shader-utils":"node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _shadertools = require("@luma.gl/shadertools");
var _bufferTransform = _interopRequireDefault(require("./buffer-transform"));
var _textureTransform = _interopRequireDefault(require("./texture-transform"));
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
var _model = _interopRequireDefault(require("../lib/model"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Transform {
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;
    this._initialize(props);
    Object.seal(this);
  }
  delete() {
    const {
      model,
      bufferTransform,
      textureTransform
    } = this;
    if (model) {
      model.delete();
    }
    if (bufferTransform) {
      bufferTransform.delete();
    }
    if (textureTransform) {
      textureTransform.delete();
    }
  }
  run() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      clearRenderTarget = true
    } = opts;
    const updatedOpts = this._updateDrawOptions(opts);
    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({
        color: true
      });
    }
    this.model.transform(updatedOpts);
  }
  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }
    (0, _webgl.assert)(swapped, 'Nothing to swap');
  }
  getBuffer() {
    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }
  getData() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      const data = resourceTransform.getData(opts);
      if (data) {
        return data;
      }
    }
    return null;
  }
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if ('elementCount' in opts) {
      this.model.setVertexCount(opts.elementCount);
    }
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      gl
    } = this;
    this._buildResourceTransforms(gl, props);
    props = this._updateModelProps(props);
    this.model = new _model.default(gl, Object.assign({}, props, {
      fs: props.fs || (0, _shadertools.getPassthroughFS)({
        version: (0, _webgl.getShaderVersion)(props.vs)
      }),
      id: props.id || 'transform-model',
      drawMode: props.drawMode || 0,
      vertexCount: props.elementCount
    }));
    this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }
  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }
    return updatedProps;
  }
  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new _bufferTransform.default(gl, props);
    }
    if (canCreateTextureTransform(props)) {
      this.textureTransform = new _textureTransform.default(gl, props);
    }
    (0, _webgl.assert)(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');
  }
  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }
    return updatedOpts;
  }
}
exports.default = Transform;
function canCreateBufferTransform(props) {
  if (!(0, _webgl.isObjectEmpty)(props.feedbackBuffers) || !(0, _webgl.isObjectEmpty)(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }
  return false;
}
function canCreateTextureTransform(props) {
  if (!(0, _webgl.isObjectEmpty)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }
  return false;
}
},{"@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","./buffer-transform":"node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js","./texture-transform":"node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","../lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js"}],"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DRAW_MODE = void 0;
var _webgl = require("@luma.gl/webgl");
const DRAW_MODE = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006
};
exports.DRAW_MODE = DRAW_MODE;
class Geometry {
  static get DRAW_MODE() {
    return DRAW_MODE;
  }
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('geometry'),
      drawMode = DRAW_MODE.TRIANGLES,
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;
    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};
    this._setAttributes(attributes, indices);
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  get mode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(attributeName) {
    return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
  }
  _setAttributes(attributes, indices) {
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {
        value: indices,
        size: 1
      } : indices;
    }
    for (const attributeName in attributes) {
      let attribute = attributes[attributeName];
      attribute = ArrayBuffer.isView(attribute) ? {
        value: attribute
      } : attribute;
      (0, _webgl.assert)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === 'indices') {
        (0, _webgl.assert)(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices.isIndexed !== undefined) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        value,
        size,
        constant
      } = attribute;
      if (!constant && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }
    (0, _webgl.assert)(Number.isFinite(vertexCount));
    return vertexCount;
  }
}
exports.default = Geometry;
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};
class TruncatedConeGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('truncated-code-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateTruncatedCone(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = TruncatedConeGeometry;
function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = 'y',
    topCap = false,
    bottomCap = false
  } = props;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;
  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  let i3 = 0;
  let i2 = 0;
  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;
    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }
    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin = msin(j * mpi * 2 / nradial);
      const cos = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }
  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ConeGeometry extends _truncatedConeGeometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('cone-geometry'),
      radius = 1,
      cap = true
    } = props;
    super({
      ...props,
      id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    });
  }
}
exports.default = ConeGeometry;
},{"./truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
const CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
const CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
const CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
const ATTRIBUTES = {
  POSITION: {
    size: 3,
    value: new Float32Array(CUBE_POSITIONS)
  },
  NORMAL: {
    size: 3,
    value: new Float32Array(CUBE_NORMALS)
  },
  TEXCOORD_0: {
    size: 2,
    value: new Float32Array(CUBE_TEX_COORDS)
  }
};
class CubeGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('cube-geometry')
    } = props;
    super({
      ...props,
      id,
      indices: {
        size: 1,
        value: new Uint16Array(CUBE_INDICES)
      },
      attributes: {
        ...ATTRIBUTES,
        ...props.attributes
      }
    });
  }
}
exports.default = CubeGeometry;
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class CylinderGeometry extends _truncatedConeGeometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('cylinder-geometry'),
      radius = 1
    } = props;
    super({
      ...props,
      id,
      bottomRadius: radius,
      topRadius: radius
    });
  }
}
exports.default = CylinderGeometry;
},{"./truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@math.gl/core");
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
const ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
class IcoSphereGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('ico-sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateIcosaHedron(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = IcoSphereGeometry;
function tesselateIcosaHedron(props) {
  const {
    iterations = 0
  } = props;
  const PI = Math.PI;
  const PI2 = PI * 2;
  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];
  positions.push();
  indices.push();
  const getMiddlePoint = (() => {
    const pointMemo = {};
    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = "".concat(mini, "|").concat(maxi);
      if (key in pointMemo) {
        return pointMemo[key];
      }
      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len;
      ym /= len;
      zm /= len;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  })();
  for (let i = 0; i < iterations; i++) {
    const indices2 = [];
    for (let j = 0; j < indices.length; j += 3) {
      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }
    indices = indices2;
  }
  const normals = new Array(positions.length);
  const texCoords = new Array(positions.length / 3 * 2);
  const l = indices.length;
  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI;
    const v1 = theta1 / PI;
    const u1 = 1 - phi1 / PI2;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI;
    const v2 = theta2 / PI;
    const u2 = 1 - phi2 / PI2;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI;
    const v3 = theta3 / PI;
    const u3 = 1 - phi3 / PI2;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new _core.Vector3(vec1).cross(vec2).normalize();
    let newIndex;
    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }
    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }
  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackIndexedGeometry = unpackIndexedGeometry;
function unpackIndexedGeometry(geometry) {
  const {
    indices,
    attributes
  } = geometry;
  if (!indices) {
    return geometry;
  }
  const vertexCount = indices.value.length;
  const unpackedAttributes = {};
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {
      constant,
      value,
      size
    } = attribute;
    if (constant || !size) {
      continue;
    }
    const unpackedValue = new value.constructor(vertexCount * size);
    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];
      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }
    unpackedAttributes[attributeName] = {
      size,
      value: unpackedValue
    };
  }
  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}
},{}],"node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _geometryUtils = require("../geometry/geometry-utils");
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PlaneGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('plane-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselatePlane(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = PlaneGeometry;
function tesselatePlane(props) {
  const {
    type = 'x,y',
    offset = 0,
    flipCull = false,
    unpack = false
  } = props;
  const coords = type.split(',');
  let c1len = props["".concat(coords[0], "len")] || 1;
  const c2len = props["".concat(coords[1], "len")] || 1;
  const subdivisions1 = props["n".concat(coords[0])] || 1;
  const subdivisions2 = props["n".concat(coords[1])] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  if (flipCull) {
    c1len = -c1len;
  }
  let i2 = 0;
  let i3 = 0;
  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;
      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;
        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;
        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;
        default:
          throw new Error('PlaneGeometry: unknown type');
      }
      i2 += 2;
      i3 += 3;
    }
  }
  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);
  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }
  const geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? (0, _geometryUtils.unpackIndexedGeometry)(geometry) : geometry;
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","../geometry/geometry-utils":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class SphereGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateSphere(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = SphereGeometry;
function tesselateSphere(props) {
  const {
    nlat = 10,
    nlong = 10
  } = props;
  let {
    radius = 1
  } = props;
  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);
  if (typeof radius === 'number') {
    const value = radius;
    radius = (n1, n2, n3, u, v) => value;
  }
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;
  const indices = new IndexType(nlat * nlong * 6);
  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;
      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;
      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      const r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }
  const numVertsAround = nlong + 1;
  for (let x = 0; x < nlong; x++) {
    for (let y = 0; y < nlat; y++) {
      const index = (x * nlat + y) * 6;
      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;
      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }
  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/animation/timeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timeline = void 0;
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
  constructor() {
    this.time = 0;
    this.channels = new Map();
    this.animations = new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }
  addChannel(props) {
    const {
      delay = 0,
      duration = Number.POSITIVE_INFINITY,
      rate = 1,
      repeat = 1
    } = props;
    const handle = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };
    this._setChannelTime(channel, this.time);
    this.channels.set(handle, channel);
    return handle;
  }
  removeChannel(handle) {
    this.channels.delete(handle);
    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === handle) {
        this.detachAnimation(animationHandle);
      }
    }
  }
  isFinished(handle) {
    const channel = this.channels.get(handle);
    if (channel === undefined) {
      return false;
    }
    return this.time >= channel.delay + channel.duration * channel.repeat;
  }
  getTime(handle) {
    if (handle === undefined) {
      return this.time;
    }
    const channel = this.channels.get(handle);
    if (channel === undefined) {
      return -1;
    }
    return channel.time;
  }
  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();
    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }
    const animations = this.animations.values();
    for (const animationData of animations) {
      const {
        animation,
        channel
      } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }
  play() {
    this.playing = true;
  }
  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }
  detachAnimation(handle) {
    this.animations.delete(handle);
  }
  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }
      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }
  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;
    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }
}
exports.Timeline = Timeline;
},{}],"node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyFrames = void 0;
class KeyFrames {
  constructor(keyFrames) {
    this._lastTime = -1;
    this.startIndex = -1;
    this.endIndex = -1;
    this.factor = 0;
    this.times = [];
    this.values = [];
    this.setKeyFrames(keyFrames);
    this.setTime(0);
  }
  setKeyFrames(keyFrames) {
    const numKeys = keyFrames.length;
    this.times.length = numKeys;
    this.values.length = numKeys;
    for (let i = 0; i < numKeys; ++i) {
      this.times[i] = keyFrames[i][0];
      this.values[i] = keyFrames[i][1];
    }
    this._calculateKeys(this._lastTime);
  }
  setTime(time) {
    time = Math.max(0, time);
    if (time !== this._lastTime) {
      this._calculateKeys(time);
      this._lastTime = time;
    }
  }
  getStartTime() {
    return this.times[this.startIndex];
  }
  getEndTime() {
    return this.times[this.endIndex];
  }
  getStartData() {
    return this.values[this.startIndex];
  }
  getEndData() {
    return this.values[this.endIndex];
  }
  _calculateKeys(time) {
    let index = 0;
    const numKeys = this.times.length;
    for (index = 0; index < numKeys - 2; ++index) {
      if (this.times[index + 1] > time) {
        break;
      }
    }
    this.startIndex = index;
    this.endIndex = index + 1;
    const startTime = this.times[this.startIndex];
    const endTime = this.times[this.endIndex];
    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);
  }
}
exports.KeyFrames = KeyFrames;
},{}],"node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _model = _interopRequireDefault(require("../lib/model"));
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
const POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
class ClipSpace extends _model.default {
  constructor(gl, opts) {
    const TEX_COORDS = POSITIONS.map(coord => coord === -1 ? 0 : coord);
    super(gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry.default({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    }));
    this.setVertexCount(4);
  }
}
exports.default = ClipSpace;
},{"../lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js","../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js"}],"node_modules/@luma.gl/engine/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _animationLoop.default;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _clipSpace.default;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _coneGeometry.default;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _cubeGeometry.default;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _cylinderGeometry.default;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _geometry.default;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _icoSphereGeometry.default;
  }
});
Object.defineProperty(exports, "KeyFrames", {
  enumerable: true,
  get: function () {
    return _keyFrames.KeyFrames;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _model.default;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _planeGeometry.default;
  }
});
Object.defineProperty(exports, "ProgramManager", {
  enumerable: true,
  get: function () {
    return _programManager.default;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _sphereGeometry.default;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _timeline.Timeline;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _truncatedConeGeometry.default;
  }
});
var _animationLoop = _interopRequireDefault(require("./lib/animation-loop"));
var _model = _interopRequireDefault(require("./lib/model"));
var _programManager = _interopRequireDefault(require("./lib/program-manager"));
var _transform = _interopRequireDefault(require("./transform/transform"));
var _geometry = _interopRequireDefault(require("./geometry/geometry"));
var _coneGeometry = _interopRequireDefault(require("./geometries/cone-geometry"));
var _cubeGeometry = _interopRequireDefault(require("./geometries/cube-geometry"));
var _cylinderGeometry = _interopRequireDefault(require("./geometries/cylinder-geometry"));
var _icoSphereGeometry = _interopRequireDefault(require("./geometries/ico-sphere-geometry"));
var _planeGeometry = _interopRequireDefault(require("./geometries/plane-geometry"));
var _sphereGeometry = _interopRequireDefault(require("./geometries/sphere-geometry"));
var _truncatedConeGeometry = _interopRequireDefault(require("./geometries/truncated-cone-geometry"));
var _timeline = require("./animation/timeline");
var _keyFrames = require("./animation/key-frames");
var _clipSpace = _interopRequireDefault(require("./utils/clip-space"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/animation-loop":"node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js","./lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js","./lib/program-manager":"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js","./transform/transform":"node_modules/@luma.gl/engine/dist/esm/transform/transform.js","./geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","./geometries/cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js","./geometries/cube-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","./geometries/cylinder-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js","./geometries/ico-sphere-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js","./geometries/plane-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js","./geometries/sphere-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js","./geometries/truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","./animation/timeline":"node_modules/@luma.gl/engine/dist/esm/animation/timeline.js","./animation/key-frames":"node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js","./utils/clip-space":"node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js"}],"node_modules/@luma.gl/core/dist/esm/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _engine.AnimationLoop;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _webgl.Buffer;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _engine.ClipSpace;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.ConeGeometry;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.CubeGeometry;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _engine.CylinderGeometry;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webgl.FEATURES;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _webgl.FragmentShader;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Framebuffer;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _engine.Geometry;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _engine.IcoSphereGeometry;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _engine.Model;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _engine.PlaneGeometry;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _webgl.Program;
  }
});
Object.defineProperty(exports, "ProgramManager", {
  enumerable: true,
  get: function () {
    return _engine.ProgramManager;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Renderbuffer;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _engine.SphereGeometry;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture2D;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture3D;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _webgl.TextureCube;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _engine.Timeline;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _engine.Transform;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _webgl.TransformFeedback;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.TruncatedConeGeometry;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _webgl.VertexShader;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _webgl.clear;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _webgl.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _webgl.copyToTexture;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _gltools.createGLContext;
  }
});
Object.defineProperty(exports, "cssToDevicePixels", {
  enumerable: true,
  get: function () {
    return _gltools.cssToDevicePixels;
  }
});
Object.defineProperty(exports, "cssToDeviceRatio", {
  enumerable: true,
  get: function () {
    return _gltools.cssToDeviceRatio;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _shadertools.dirlight;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _shadertools.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _shadertools.fp64;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _gltools.getParameters;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _shadertools.gouraudLighting;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeatures;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _gltools.instrumentGLContext;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _gltools.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _gltools.isWebGL2;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _webgl.lumaStats;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shadertools.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _shadertools.pbr;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _shadertools.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shadertools.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shadertools.project;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _gltools.resetParameters;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _gltools.setParameters;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _gltools.withParameters;
  }
});
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
var _engine = require("@luma.gl/engine");
var _shadertools = require("@luma.gl/shadertools");
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/engine":"node_modules/@luma.gl/engine/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmbientLight = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
let idCount = 0;
class AmbientLight {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "color", void 0);
    (0, _defineProperty2.default)(this, "intensity", void 0);
    (0, _defineProperty2.default)(this, "type", 'ambient');
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    this.id = props.id || "ambient-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
  }
}
exports.AmbientLight = AmbientLight;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectionalLight = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];
let idCount = 0;
class DirectionalLight {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "color", void 0);
    (0, _defineProperty2.default)(this, "intensity", void 0);
    (0, _defineProperty2.default)(this, "type", 'directional');
    (0, _defineProperty2.default)(this, "direction", void 0);
    (0, _defineProperty2.default)(this, "shadow", void 0);
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      direction = DEFAULT_LIGHT_DIRECTION
    } = props;
    const {
      _shadow = false
    } = props;
    this.id = props.id || "directional-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'directional';
    this.direction = new _core.Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }
  getProjectedLight(opts) {
    return this;
  }
}
exports.DirectionalLight = DirectionalLight;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Pass {
  constructor(gl, props = {
    id: 'pass'
  }) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    const {
      id
    } = props;
    this.id = id;
    this.gl = gl;
    this.props = {
      ...props
    };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  render(params) {}
  cleanup() {}
}
exports.default = Pass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.layerIndexResolver = layerIndexResolver;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _pass = _interopRequireDefault(require("./pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LayersPass extends _pass.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "_lastRenderIndex", -1);
  }
  render(options) {
    const gl = this.gl;
    (0, _core.setParameters)(gl, {
      framebuffer: options.target
    });
    return this._drawLayers(options);
  }
  _drawLayers(options) {
    const {
      target,
      moduleParameters,
      viewports,
      views,
      onViewportActive,
      clearStack = true,
      clearCanvas = true
    } = options;
    options.pass = options.pass || 'unknown';
    const gl = this.gl;
    if (clearCanvas) {
      clearGLCanvas(gl, target);
    }
    if (clearStack) {
      this._lastRenderIndex = -1;
    }
    const renderStats = [];
    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);
      const drawLayerParams = this._getDrawLayerParams(viewport, options);
      const subViewports = viewport.subViewports || [viewport];
      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(gl, {
          target,
          moduleParameters,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);
        renderStats.push(stats);
      }
    }
    return renderStats;
  }
  _getDrawLayerParams(viewport, {
    layers,
    pass,
    isPicking = false,
    layerFilter,
    cullRect,
    effects,
    moduleParameters
  }, evaluateShouldDrawOnly = false) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
      const layerParam = {
        shouldDrawLayer
      };
      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
      }
      drawLayerParams[layerIndex] = layerParam;
    }
    return drawLayerParams;
  }
  _drawLayersInViewport(gl, {
    layers,
    moduleParameters: globalModuleParameters,
    pass,
    target,
    viewport,
    view
  }, drawLayerParams) {
    const glViewport = getGLViewport(gl, {
      moduleParameters: globalModuleParameters,
      target,
      viewport
    });
    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? {
        color: true,
        depth: true
      } : view.props.clear;
      (0, _core.withParameters)(gl, {
        scissorTest: true,
        scissor: glViewport
      }, () => (0, _core.clear)(gl, clearOpts));
    }
    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    (0, _core.setParameters)(gl, {
      viewport: glViewport
    });
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const {
        shouldDrawLayer,
        layerRenderIndex,
        moduleParameters,
        layerParameters
      } = drawLayerParams[layerIndex];
      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }
      if (layer.isComposite) {
        renderStatus.compositeCount++;
      } else if (shouldDrawLayer) {
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        moduleParameters.viewport = viewport;
        try {
          layer._drawLayer({
            moduleParameters,
            uniforms: {
              layerIndex: layerRenderIndex
            },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
        }
      }
    }
    return renderStatus;
  }
  shouldDrawLayer(layer) {
    return true;
  }
  getModuleParameters(layer, effects) {
    return null;
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }
  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
    if (!shouldDrawLayer) {
      return false;
    }
    drawContext.layer = layer;
    let parent = layer.parent;
    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }
      drawContext.layer = parent;
      parent = parent.parent;
    }
    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;
      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }
      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }
    layer.activateViewport(drawContext.viewport);
    return true;
  }
  _getModuleParameters(layer, effects, pass, overrides) {
    var _layer$internalState;
    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
      autoWrapLongitude: layer.wrapLongitude,
      viewport: layer.context.viewport,
      mousePosition: layer.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: (0, _core.cssToDeviceRatio)(this.gl)
    });
    if (effects) {
      for (const effect of effects) {
        var _effect$getModulePara;
        Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
      }
    }
    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
  }
}
exports.default = LayersPass;
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
  return resolveLayerIndex;
}
function getGLViewport(gl, {
  moduleParameters,
  target,
  viewport
}) {
  const useTarget = target && target.id !== 'default-framebuffer';
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || (0, _core.cssToDeviceRatio)(gl);
  const height = useTarget ? target.height : gl.drawingBufferHeight;
  const dimensions = viewport;
  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}
function clearGLCanvas(gl, targetFramebuffer) {
  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
  (0, _core.setParameters)(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./pass":"node_modules/@deck.gl/core/dist/esm/passes/pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layersPass = _interopRequireDefault(require("./layers-pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ShadowPass extends _layersPass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "shadowMap", void 0);
    (0, _defineProperty2.default)(this, "depthBuffer", void 0);
    (0, _defineProperty2.default)(this, "fbo", void 0);
    this.shadowMap = new _core.Texture2D(gl, {
      width: 1,
      height: 1,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.depthBuffer = new _core.Renderbuffer(gl, {
      format: 33189,
      width: 1,
      height: 1
    });
    this.fbo = new _core.Framebuffer(gl, {
      id: 'shadowmap',
      width: 1,
      height: 1,
      attachments: {
        [36064]: this.shadowMap,
        [36096]: this.depthBuffer
      }
    });
  }
  render(params) {
    const target = this.fbo;
    (0, _core.withParameters)(this.gl, {
      depthRange: [0, 1],
      depthTest: true,
      blend: false,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const viewport = params.viewports[0];
      const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;
      if (width !== target.width || height !== target.height) {
        target.resize({
          width,
          height
        });
      }
      super.render({
        ...params,
        target,
        pass: 'shadow'
      });
    });
  }
  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: true
    };
  }
  delete() {
    if (this.fbo) {
      this.fbo.delete();
      this.fbo = null;
    }
    if (this.shadowMap) {
      this.shadowMap.delete();
      this.shadowMap = null;
    }
    if (this.depthBuffer) {
      this.depthBuffer.delete();
      this.depthBuffer = null;
    }
  }
}
exports.default = ShadowPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const defines = '#define SMOOTH_EDGE_RADIUS 0.5';
const vs = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
const fs = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
var _default = {
  name: 'geometry',
  vs,
  fs
};
exports.default = _default;
},{}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../../lib/constants");
const COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(_constants.COORDINATE_SYSTEM).map(key => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(_constants.COORDINATE_SYSTEM[key], ";")).join('');
const PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(_constants.PROJECTION_MODE).map(key => "const int PROJECTION_MODE_".concat(key, " = ").concat(_constants.PROJECTION_MODE[key], ";")).join('');
const UNIT_GLSL_CONSTANTS = Object.keys(_constants.UNIT).map(key => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(_constants.UNIT[key], ";")).join('');
var _default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");
exports.default = _default;
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/utils/memoize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memoize;
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return args => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsetOrigin = getOffsetOrigin;
exports.getUniformsFromViewport = getUniformsFromViewport;
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
var _constants = require("../../lib/constants");
var _memoize = _interopRequireDefault(require("../../utils/memoize"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const ZERO_VECTOR = [0, 0, 0, 0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
const getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === _constants.COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }
  switch (viewport.projectionMode) {
    case _constants.PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case _constants.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case _constants.PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case _constants.PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const {
    viewMatrixUncentered,
    projectionMatrix
  } = viewport;
  let {
    viewMatrix,
    viewProjectionMatrix
  } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
    originCommon[3] = 1;
    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix = viewMatrixUncentered || viewMatrix;
    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  coordinateSystem = _constants.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.project_uWrapLongitude = autoWrapLongitude;
  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;
  return uniforms;
}
function calculateViewportUniforms({
  viewport,
  devicePixelRatio,
  coordinateSystem,
  coordinateOrigin
}) {
  const {
    projectionCenter,
    viewProjectionMatrix,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  const focalDistance = vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uWrapLongitude: false,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uModelMatrix: IDENTITY_MATRIX,
    project_uCameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case _constants.COORDINATE_SYSTEM.LNGLAT:
      case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case _constants.COORDINATE_SYSTEM.CARTESIAN:
        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms;
}
},{"gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js","../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@luma.gl/core");
var _geometry = _interopRequireDefault(require("../misc/geometry"));
var _project = _interopRequireDefault(require("./project.glsl"));
var _viewportUniforms = require("./viewport-uniforms");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_MODULE_OPTIONS = {};
function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if ('viewport' in opts) {
    return (0, _viewportUniforms.getUniformsFromViewport)(opts);
  }
  return {};
}
var _default = {
  name: 'project',
  dependencies: [_core.fp32, _geometry.default],
  vs: _project.default,
  getUniforms
};
exports.default = _default;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../misc/geometry":"node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js","./project.glsl":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js","./viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clamp = clamp;
exports.createMat4 = createMat4;
exports.lerp = lerp;
exports.log2 = void 0;
exports.mod = mod;
exports.transformVector = transformVector;
var _vec = require("gl-matrix/vec4");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = (0, _vec.transformMat4)([], vector, matrix);
  (0, _vec.scale)(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function lerp(start, end, step) {
  return step * end + (1 - step) * start;
}
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
  return Math.log(x) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2;
exports.log2 = log2;
},{"gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/web-mercator/dist/esm/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '@math.gl/web-mercator: assertion failed.');
  }
}
},{}],"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_LATITUDE = exports.DEFAULT_ALTITUDE = void 0;
exports.addMetersToLngLat = addMetersToLngLat;
exports.altitudeToFovy = altitudeToFovy;
exports.fovyToAltitude = fovyToAltitude;
exports.getDistanceScales = getDistanceScales;
exports.getMeterZoom = getMeterZoom;
exports.getProjectionMatrix = getProjectionMatrix;
exports.getProjectionParameters = getProjectionParameters;
exports.getViewMatrix = getViewMatrix;
exports.lngLatToWorld = lngLatToWorld;
exports.pixelsToWorld = pixelsToWorld;
exports.scaleToZoom = scaleToZoom;
exports.unitsPerMeter = unitsPerMeter;
exports.worldToLngLat = worldToLngLat;
exports.worldToPixels = worldToPixels;
exports.zoomToScale = zoomToScale;
var _mathUtils = require("./math-utils");
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE = 512;
const EARTH_CIRCUMFERENCE = 40.03e6;
const MAX_LATITUDE = 85.051129;
exports.MAX_LATITUDE = MAX_LATITUDE;
const DEFAULT_ALTITUDE = 1.5;
exports.DEFAULT_ALTITUDE = DEFAULT_ALTITUDE;
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}
function scaleToZoom(scale) {
  return (0, _mathUtils.log2)(scale);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  (0, _assert.default)(Number.isFinite(lng));
  (0, _assert.default)(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
  const lambda2 = lng * DEGREES_TO_RADIANS;
  const phi2 = lat * DEGREES_TO_RADIANS;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}
function worldToLngLat(xy) {
  const [x, y] = xy;
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}
function getMeterZoom(options) {
  const {
    latitude
  } = options;
  (0, _assert.default)(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
  const {
    latitude,
    longitude,
    highPrecision = false
  } = options;
  (0, _assert.default)(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x, y, z] = xyz;
  const {
    unitsPerMeter,
    unitsPerMeter2
  } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);
  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    height,
    pitch,
    bearing,
    altitude,
    scale,
    center
  } = options;
  const vm = (0, _mathUtils.createMat4)();
  mat4.translate(vm, vm, [0, 0, -altitude]);
  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);
  const relativeScale = scale / height;
  mat4.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    mat4.translate(vm, vm, vec3.negate([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const {
    width,
    height,
    altitude,
    pitch = 0,
    offset,
    center,
    scale,
    nearZMultiplier = 1,
    farZMultiplier = 1
  } = options;
  let {
    fovy = altitudeToFovy(DEFAULT_ALTITUDE)
  } = options;
  if (altitude !== undefined) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS;
  const pitchRadians = pitch * DEGREES_TO_RADIANS;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin((0, _mathUtils.clamp)(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function getProjectionMatrix(options) {
  const {
    fov,
    aspect,
    near,
    far
  } = getProjectionParameters(options);
  const projectionMatrix = mat4.perspective([], fov, aspect, near, far);
  return projectionMatrix;
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x, y, z = 0] = xyz;
  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x, y, z] = xyz;
  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');
  if (Number.isFinite(z)) {
    const coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }
  const coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  const coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2.lerp([], coord0, coord1, t);
}
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","./assert":"node_modules/@math.gl/web-mercator/dist/esm/assert.js"}],"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fitBounds;
var _assert = _interopRequireDefault(require("./assert"));
var _mathUtils = require("./math-utils");
var _webMercatorUtils = require("./web-mercator-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    maxZoom = 24,
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = (0, _webMercatorUtils.lngLatToWorld)([west, (0, _mathUtils.clamp)(north, -_webMercatorUtils.MAX_LATITUDE, _webMercatorUtils.MAX_LATITUDE)]);
  const se = (0, _webMercatorUtils.lngLatToWorld)([east, (0, _mathUtils.clamp)(south, -_webMercatorUtils.MAX_LATITUDE, _webMercatorUtils.MAX_LATITUDE)]);
  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  (0, _assert.default)(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX = targetSize[0] / size[0];
  const scaleY = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = (0, _webMercatorUtils.worldToLngLat)(center);
  const zoom = Math.min(maxZoom, (0, _mathUtils.log2)(Math.abs(Math.min(scaleX, scaleY))));
  (0, _assert.default)(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === 'number') {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  (0, _assert.default)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}
},{"./assert":"node_modules/@math.gl/web-mercator/dist/esm/assert.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBounds;
var _webMercatorUtils = require("./web-mercator-utils");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var _mathUtils = require("./math-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const DEGREES_TO_RADIANS = Math.PI / 180;
function getBounds(viewport, z = 0) {
  const {
    width,
    height,
    unproject
  } = viewport;
  const unprojectOps = {
    targetZ: z
  };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x, targetZ) {
  const {
    pixelUnprojectionMatrix
  } = viewport;
  const coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, 0, 1, 1]);
  const coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = vec2.lerp([], coord0, coord1, t);
  const result = (0, _webMercatorUtils.worldToLngLat)(coord);
  result.push(targetZ);
  return result;
}
},{"./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _mathUtils = require("./math-utils");
var _webMercatorUtils = require("./web-mercator-utils");
var _fitBounds = _interopRequireDefault(require("./fit-bounds"));
var _getBounds = _interopRequireDefault(require("./get-bounds"));
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WebMercatorViewport {
  constructor(props = {
    width: 1,
    height: 1
  }) {
    (0, _defineProperty2.default)(this, "latitude", void 0);
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "zoom", void 0);
    (0, _defineProperty2.default)(this, "pitch", void 0);
    (0, _defineProperty2.default)(this, "bearing", void 0);
    (0, _defineProperty2.default)(this, "altitude", void 0);
    (0, _defineProperty2.default)(this, "fovy", void 0);
    (0, _defineProperty2.default)(this, "meterOffset", void 0);
    (0, _defineProperty2.default)(this, "center", void 0);
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "scale", void 0);
    (0, _defineProperty2.default)(this, "distanceScales", void 0);
    (0, _defineProperty2.default)(this, "viewMatrix", void 0);
    (0, _defineProperty2.default)(this, "projectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "viewProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelUnprojectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "equals", viewport => {
      if (!(viewport instanceof WebMercatorViewport)) {
        return false;
      }
      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
    });
    (0, _defineProperty2.default)(this, "project", (lngLatZ, options = {}) => {
      const {
        topLeft = true
      } = options;
      const worldPosition = this.projectPosition(lngLatZ);
      const coord = (0, _webMercatorUtils.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
      const [x, y] = coord;
      const y2 = topLeft ? y : this.height - y;
      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];
    });
    (0, _defineProperty2.default)(this, "unproject", (xyz, options = {}) => {
      const {
        topLeft = true,
        targetZ = undefined
      } = options;
      const [x, y, z] = xyz;
      const y2 = topLeft ? y : this.height - y;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    });
    (0, _defineProperty2.default)(this, "projectPosition", xyz => {
      const [X, Y] = (0, _webMercatorUtils.lngLatToWorld)(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    });
    (0, _defineProperty2.default)(this, "unprojectPosition", xyz => {
      const [X, Y] = (0, _webMercatorUtils.worldToLngLat)(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    });
    let {
      width,
      height,
      altitude = null,
      fovy = null
    } = props;
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      position = null,
      nearZMultiplier = 0.02,
      farZMultiplier = 1.01
    } = props;
    width = width || 1;
    height = height || 1;
    if (fovy === null && altitude === null) {
      altitude = _webMercatorUtils.DEFAULT_ALTITUDE;
      fovy = (0, _webMercatorUtils.altitudeToFovy)(altitude);
    } else if (fovy === null) {
      fovy = (0, _webMercatorUtils.altitudeToFovy)(altitude);
    } else if (altitude === null) {
      altitude = (0, _webMercatorUtils.fovyToAltitude)(fovy);
    }
    const scale = (0, _webMercatorUtils.zoomToScale)(zoom);
    altitude = Math.max(0.75, altitude);
    const distanceScales = (0, _webMercatorUtils.getDistanceScales)({
      longitude,
      latitude
    });
    const center = (0, _webMercatorUtils.lngLatToWorld)([longitude, latitude]);
    center.push(0);
    if (position) {
      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));
    }
    this.projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
      width,
      height,
      scale,
      center,
      pitch,
      fovy,
      nearZMultiplier,
      farZMultiplier
    });
    this.viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
      height,
      scale,
      center,
      pitch,
      bearing,
      altitude
    });
    this.width = width;
    this.height = height;
    this.scale = scale;
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.center = center;
    this.meterOffset = position || [0, 0, 0];
    this.distanceScales = distanceScales;
    this._initMatrices();
    Object.freeze(this);
  }
  _initMatrices() {
    const {
      width,
      height,
      projectionMatrix,
      viewMatrix
    } = this;
    const vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, projectionMatrix);
    mat4.multiply(vpm, vpm, viewMatrix);
    this.viewProjectionMatrix = vpm;
    const m = (0, _mathUtils.createMat4)();
    mat4.scale(m, m, [width / 2, -height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);
    mat4.multiply(m, m, vpm);
    const mInverse = mat4.invert((0, _mathUtils.createMat4)(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }
    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
  }
  projectFlat(lngLat) {
    return (0, _webMercatorUtils.lngLatToWorld)(lngLat);
  }
  unprojectFlat(xy) {
    return (0, _webMercatorUtils.worldToLngLat)(xy);
  }
  getMapCenterByLngLatPosition({
    lngLat,
    pos
  }) {
    const fromLocation = (0, _webMercatorUtils.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
    const toLocation = (0, _webMercatorUtils.lngLatToWorld)(lngLat);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    return (0, _webMercatorUtils.worldToLngLat)(newCenter);
  }
  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0, _fitBounds.default)(Object.assign({
      width,
      height,
      bounds
    }, options));
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }
  getBounds(options) {
    const corners = this.getBoundingRegion(options);
    const west = Math.min(...corners.map(p => p[0]));
    const east = Math.max(...corners.map(p => p[0]));
    const south = Math.min(...corners.map(p => p[1]));
    const north = Math.max(...corners.map(p => p[1]));
    return [[west, south], [east, north]];
  }
  getBoundingRegion(options = {}) {
    return (0, _getBounds.default)(this, options.z || 0);
  }
  getLocationAtPoint({
    lngLat,
    pos
  }) {
    return this.getMapCenterByLngLatPosition({
      lngLat,
      pos
    });
  }
}
exports.default = WebMercatorViewport;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","./fit-bounds":"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js","./get-bounds":"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeViewportProps;
var _webMercatorUtils = require("./web-mercator-utils");
var _mathUtils = require("./math-utils");
const TILE_SIZE = 512;
function normalizeViewportProps(props) {
  const {
    width,
    height,
    pitch = 0
  } = props;
  let {
    longitude,
    latitude,
    zoom,
    bearing = 0
  } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
  }
  const minZoom = (0, _mathUtils.log2)(height / TILE_SIZE);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = (0, _webMercatorUtils.worldToLngLat)([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = (0, _webMercatorUtils.worldToLngLat)([0, TILE_SIZE - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return {
    width,
    height,
    longitude,
    latitude,
    zoom,
    pitch,
    bearing
  };
}
},{"./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flyToViewport;
exports.getFlyToDuration = getFlyToDuration;
var _mathUtils = require("./math-utils");
var _webMercatorUtils = require("./web-mercator-utils");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const EPSILON = 0.01;
const VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];
const DEFAULT_OPTS = {
  curve: 1.414,
  speed: 1.2
};
function flyToViewport(startProps, endProps, t, options) {
  const {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0
  } = getFlyToTransitionParams(startProps, endProps, options);
  if (u1 < EPSILON) {
    const viewport = {};
    for (const key of VIEWPORT_TRANSITION_PROPS) {
      const startValue = startProps[key];
      const endValue = endProps[key];
      viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
    }
    return viewport;
  }
  const s = t * S;
  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  const scaleIncrement = 1 / w;
  const newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);
  const newCenterWorld = vec2.scale([], uDelta, u);
  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);
  const newCenter = (0, _webMercatorUtils.worldToLngLat)(newCenterWorld);
  return {
    longitude: newCenter[0],
    latitude: newCenter[1],
    zoom: newZoom
  };
}
function getFlyToDuration(startProps, endProps, options) {
  const opts = {
    ...DEFAULT_OPTS,
    ...options
  };
  const {
    screenSpeed,
    speed,
    maxDuration
  } = opts;
  const {
    S,
    rho
  } = getFlyToTransitionParams(startProps, endProps, opts);
  const length = 1000 * S;
  let duration;
  if (Number.isFinite(screenSpeed)) {
    duration = length / (screenSpeed / rho);
  } else {
    duration = length / speed;
  }
  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function getFlyToTransitionParams(startProps, endProps, opts) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const rho = opts.curve;
  const startZoom = startProps.zoom;
  const startCenter = [startProps.longitude, startProps.latitude];
  const startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
  const endZoom = endProps.zoom;
  const endCenter = [endProps.longitude, endProps.latitude];
  const scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);
  const startCenterXY = (0, _webMercatorUtils.lngLatToWorld)(startCenter);
  const endCenterXY = (0, _webMercatorUtils.lngLatToWorld)(endCenter);
  const uDelta = vec2.sub([], endCenterXY, startCenterXY);
  const w0 = Math.max(startProps.width, startProps.height);
  const w1 = w0 / scale;
  const u1 = vec2.length(uDelta) * startScale;
  const _u1 = Math.max(u1, EPSILON);
  const rho2 = rho * rho;
  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  const S = (r1 - r0) / rho;
  return {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0,
    r1
  };
}
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js"}],"node_modules/@math.gl/web-mercator/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MAX_LATITUDE", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.MAX_LATITUDE;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "addMetersToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.addMetersToLngLat;
  }
});
Object.defineProperty(exports, "altitudeToFovy", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.altitudeToFovy;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "fitBounds", {
  enumerable: true,
  get: function () {
    return _fitBounds.default;
  }
});
Object.defineProperty(exports, "flyToViewport", {
  enumerable: true,
  get: function () {
    return _flyToViewport.default;
  }
});
Object.defineProperty(exports, "fovyToAltitude", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.fovyToAltitude;
  }
});
Object.defineProperty(exports, "getBounds", {
  enumerable: true,
  get: function () {
    return _getBounds.default;
  }
});
Object.defineProperty(exports, "getDistanceScales", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getDistanceScales;
  }
});
Object.defineProperty(exports, "getFlyToDuration", {
  enumerable: true,
  get: function () {
    return _flyToViewport.getFlyToDuration;
  }
});
Object.defineProperty(exports, "getMeterZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getMeterZoom;
  }
});
Object.defineProperty(exports, "getProjectionMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionMatrix;
  }
});
Object.defineProperty(exports, "getProjectionParameters", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionParameters;
  }
});
Object.defineProperty(exports, "getViewMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "lngLatToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "normalizeViewportProps", {
  enumerable: true,
  get: function () {
    return _normalizeViewportProps.default;
  }
});
Object.defineProperty(exports, "pixelsToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.pixelsToWorld;
  }
});
Object.defineProperty(exports, "scaleToZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.scaleToZoom;
  }
});
Object.defineProperty(exports, "unitsPerMeter", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.unitsPerMeter;
  }
});
Object.defineProperty(exports, "worldToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToLngLat;
  }
});
Object.defineProperty(exports, "worldToPixels", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToPixels;
  }
});
Object.defineProperty(exports, "zoomToScale", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.zoomToScale;
  }
});
var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));
var _getBounds = _interopRequireDefault(require("./get-bounds"));
var _fitBounds = _interopRequireDefault(require("./fit-bounds"));
var _normalizeViewportProps = _interopRequireDefault(require("./normalize-viewport-props"));
var _flyToViewport = _interopRequireWildcard(require("./fly-to-viewport"));
var _webMercatorUtils = require("./web-mercator-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./web-mercator-viewport":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js","./get-bounds":"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","./fit-bounds":"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js","./normalize-viewport-props":"node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js","./fly-to-viewport":"node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../../lib/constants");
var _project = _interopRequireDefault(require("../project/project"));
var _core = require("@math.gl/core");
var _memoize = _interopRequireDefault(require("../../utils/memoize"));
var _webMercator = require("@math.gl/web-mercator");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
const fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
const getMemoizedViewportCenterPosition = (0, _memoize.default)(getViewportCenterPosition);
const getMemoizedViewProjectionMatrices = (0, _memoize.default)(getViewProjectionMatrices);
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x, y, z] = xyz;
  const coord = (0, _webMercator.pixelsToWorld)([x, y, z], pixelUnprojectionMatrix);
  if (Number.isFinite(z)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({
  viewport,
  center
}) {
  return new _core.Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({
  viewport,
  shadowMatrices
}) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? undefined : 1;
  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix = shadowMatrix.clone().translate(new _core.Vector3(viewport.center).negate());
    const positions = corners.map(corner => viewMatrix.transform(corner));
    const projectionMatrix = new _core.Matrix4().ortho({
      left: Math.min(...positions.map(position => position[0])),
      right: Math.max(...positions.map(position => position[0])),
      bottom: Math.min(...positions.map(position => position[1])),
      top: Math.max(...positions.map(position => position[1])),
      near: Math.min(...positions.map(position => -position[2])),
      far: Math.max(...positions.map(position => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts, context) {
  const {
    shadowEnabled = true
  } = opts;
  if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      shadow_uDrawShadowMap: false,
      shadow_uUseShadowMap: false
    };
  }
  const uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();
  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new _core.Vector3(opts.viewport.center).negate());
    if (context.project_uCoordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === _constants.PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }
  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
    uniforms["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];
    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
    } else {
      uniforms["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
    }
  }
  return uniforms;
}
var _default = {
  name: 'shadow',
  dependencies: [_project.default],
  vs,
  fs,
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
    'fs:DECKGL_FILTER_COLOR': "\n    color = shadow_filterShadowColor(color);\n    "
  },
  getUniforms: (opts = {}, context = {}) => {
    if ('viewport' in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
      return createShadowUniforms(opts, context);
    }
    return {};
  }
};
exports.default = _default;
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _ambientLight = require("./ambient-light");
var _directionalLight = require("./directional-light");
var _core2 = require("@math.gl/core");
var _shadowPass = _interopRequireDefault(require("../../passes/shadow-pass"));
var _shadow = _interopRequireDefault(require("../../shaderlib/shadow/shadow"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1.0
};
const DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
  color: [255, 255, 255],
  intensity: 1.0,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}];
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];
class LightingEffect {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", 'lighting-effect');
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "shadowColor", DEFAULT_SHADOW_COLOR);
    (0, _defineProperty2.default)(this, "shadow", void 0);
    (0, _defineProperty2.default)(this, "ambientLight", void 0);
    (0, _defineProperty2.default)(this, "directionalLights", void 0);
    (0, _defineProperty2.default)(this, "pointLights", void 0);
    (0, _defineProperty2.default)(this, "shadowPasses", []);
    (0, _defineProperty2.default)(this, "shadowMaps", []);
    (0, _defineProperty2.default)(this, "dummyShadowMap", null);
    (0, _defineProperty2.default)(this, "programManager", void 0);
    (0, _defineProperty2.default)(this, "shadowMatrices", void 0);
    this.setProps(props);
  }
  setProps(props) {
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];
    for (const key in props) {
      const lightSource = props[key];
      switch (lightSource.type) {
        case 'ambient':
          this.ambientLight = lightSource;
          break;
        case 'directional':
          this.directionalLights.push(lightSource);
          break;
        case 'point':
          this.pointLights.push(lightSource);
          break;
        default:
      }
    }
    this._applyDefaultLights();
    this.shadow = this.directionalLights.some(light => light.shadow);
    this.props = props;
  }
  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.shadow) return;
    this.shadowMatrices = this._calculateMatrices();
    if (this.shadowPasses.length === 0) {
      this._createShadowPasses(gl);
    }
    if (!this.programManager) {
      this.programManager = _core.ProgramManager.getDefaultProgramManager(gl);
      if (_shadow.default) {
        this.programManager.addDefaultModule(_shadow.default);
      }
    }
    if (!this.dummyShadowMap) {
      this.dummyShadowMap = new _core.Texture2D(gl, {
        width: 1,
        height: 1
      });
    }
    for (let i = 0; i < this.shadowPasses.length; i++) {
      const shadowPass = this.shadowPasses[i];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        moduleParameters: {
          shadowLightId: i,
          dummyShadowMap: this.dummyShadowMap,
          shadowMatrices: this.shadowMatrices
        }
      });
    }
  }
  getModuleParameters(layer) {
    const parameters = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    parameters.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({
        layer
      })),
      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({
        layer
      }))
    };
    return parameters;
  }
  cleanup() {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }
    this.shadowPasses.length = 0;
    this.shadowMaps.length = 0;
    if (this.dummyShadowMap) {
      this.dummyShadowMap.delete();
      this.dummyShadowMap = null;
    }
    if (this.shadow && this.programManager) {
      this.programManager.removeDefaultModule(_shadow.default);
      this.programManager = null;
    }
  }
  _calculateMatrices() {
    const lightMatrices = [];
    for (const light of this.directionalLights) {
      const viewMatrix = new _core2.Matrix4().lookAt({
        eye: new _core2.Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix);
    }
    return lightMatrices;
  }
  _createShadowPasses(gl) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const shadowPass = new _shadowPass.default(gl);
      this.shadowPasses[i] = shadowPass;
      this.shadowMaps[i] = shadowPass.shadowMap;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = this;
    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new _ambientLight.AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new _directionalLight.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new _directionalLight.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }
}
exports.default = LightingEffect;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./ambient-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js","./directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../passes/shadow-pass":"node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js","../../shaderlib/shadow/shadow":"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js"}],"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TypedArrayManager = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TypedArrayManager {
  constructor(options = {}) {
    (0, _defineProperty2.default)(this, "_pool", []);
    (0, _defineProperty2.default)(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    });
    this.setOptions(options);
  }
  setOptions(options) {
    Object.assign(this.opts, options);
  }
  allocate(typedArray, count, {
    size = 1,
    type,
    padding = 0,
    copy = false,
    initialize = false,
    maxCount
  }) {
    const Type = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count * size + padding;
    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }
      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type(typedArray.buffer, 0, newSize);
      }
    }
    let maxSize = Infinity;
    if (maxCount) {
      maxSize = maxCount * size + padding;
    }
    const newArray = this._allocate(Type, newSize, initialize, maxSize);
    if (typedArray && copy) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }
    this._release(typedArray);
    return newArray;
  }
  release(typedArray) {
    this._release(typedArray);
  }
  _allocate(Type, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }
    const pool = this._pool;
    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
    const i = pool.findIndex(b => b.byteLength >= byteLength);
    if (i >= 0) {
      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
      if (initialize) {
        array.fill(0);
      }
      return array;
    }
    return new Type(sizeToAllocate);
  }
  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }
    const pool = this._pool;
    const {
      buffer
    } = typedArray;
    const {
      byteLength
    } = buffer;
    const i = pool.findIndex(b => b.byteLength >= byteLength);
    if (i < 0) {
      pool.push(buffer);
    } else if (i > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i, 0, buffer);
    }
    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }
}
exports.TypedArrayManager = TypedArrayManager;
var _default = new TypedArrayManager();
exports.default = _default;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMat4 = createMat4;
exports.fp64LowPart = fp64LowPart;
exports.getCameraPosition = getCameraPosition;
exports.getFrustumPlanes = getFrustumPlanes;
exports.mergeBounds = mergeBounds;
exports.mod = mod;
exports.toDoublePrecisionArray = toDoublePrecisionArray;
var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
const scratchVector = new _core.Vector3();
function getFrustumPlane(a, b, c, d) {
  scratchVector.set(a, b, c);
  const L = scratchVector.len();
  return {
    distance: d / L,
    normal: new _core.Vector3(-a / L, -b / L, -c / L)
  };
}
function fp64LowPart(x) {
  return x - Math.fround(x);
}
let scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const {
    size = 1,
    startIndex = 0
  } = options;
  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;
  const count = (endIndex - startIndex) / size;
  scratchArray = _typedArrayManager.default.allocate(scratchArray, count, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j = 0; j < size; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size] = fp64LowPart(value);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds) continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}
},{"./typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _log = _interopRequireDefault(require("../utils/log"));
var _mathUtils = require("../utils/math-utils");
var _core = require("@math.gl/core");
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var _webMercator = require("@math.gl/web-mercator");
var _constants = require("../lib/constants");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEGREES_TO_RADIANS = Math.PI / 180;
const IDENTITY = (0, _mathUtils.createMat4)();
const ZERO_VECTOR = [0, 0, 0];
const DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function createProjectionMatrix({
  width,
  height,
  orthographic,
  fovyRadians,
  focalDistance,
  padding,
  near,
  far
}) {
  const aspect = width / height;
  const matrix = orthographic ? new _core.Matrix4().orthographic({
    fovy: fovyRadians,
    aspect,
    focalDistance,
    near,
    far
  }) : new _core.Matrix4().perspective({
    fovy: fovyRadians,
    aspect,
    near,
    far
  });
  if (padding) {
    const {
      left = 0,
      right = 0,
      top = 0,
      bottom = 0
    } = padding;
    const offsetX = (0, _core.clamp)((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = (0, _core.clamp)((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
class Viewport {
  constructor(opts = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "x", void 0);
    (0, _defineProperty2.default)(this, "y", void 0);
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "padding", void 0);
    (0, _defineProperty2.default)(this, "isGeospatial", void 0);
    (0, _defineProperty2.default)(this, "zoom", void 0);
    (0, _defineProperty2.default)(this, "focalDistance", void 0);
    (0, _defineProperty2.default)(this, "position", void 0);
    (0, _defineProperty2.default)(this, "modelMatrix", void 0);
    (0, _defineProperty2.default)(this, "distanceScales", void 0);
    (0, _defineProperty2.default)(this, "scale", void 0);
    (0, _defineProperty2.default)(this, "center", void 0);
    (0, _defineProperty2.default)(this, "cameraPosition", void 0);
    (0, _defineProperty2.default)(this, "projectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "viewMatrix", void 0);
    (0, _defineProperty2.default)(this, "viewMatrixUncentered", void 0);
    (0, _defineProperty2.default)(this, "viewMatrixInverse", void 0);
    (0, _defineProperty2.default)(this, "viewProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelUnprojectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "resolution", void 0);
    (0, _defineProperty2.default)(this, "_frustumPlanes", {});
    this.id = opts.id || this.constructor.displayName || 'viewport';
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR;
    this.modelMatrix = opts.modelMatrix || null;
    const {
      longitude,
      latitude
    } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this._initProps(opts);
    this._initMatrices(opts);
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? _constants.PROJECTION_MODE.WEB_MERCATOR : _constants.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }
    return _constants.PROJECTION_MODE.IDENTITY;
  }
  equals(viewport) {
    if (!(viewport instanceof Viewport)) {
      return false;
    }
    if (this === viewport) {
      return true;
    }
    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, _core.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _core.equals)(viewport.viewMatrix, this.viewMatrix);
  }
  project(xyz, {
    topLeft = true
  } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = (0, _webMercator.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
    const [x, y] = coord;
    const y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }
  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = (0, _webMercator.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X, Y, Z] = this.unprojectPosition(coord);
    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }
    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }
  projectPosition(xyz) {
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X, Y, Z];
  }
  unprojectPosition(xyz) {
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X, Y, Z];
  }
  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = (0, _webMercator.lngLatToWorld)(xyz);
      result[1] = (0, _core.clamp)(result[1], -318, 830);
      return result;
    }
    return xyz;
  }
  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return (0, _webMercator.worldToLngLat)(xyz);
    }
    return xyz;
  }
  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }
  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin) {
      return (0, _webMercator.getDistanceScales)({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }
    return this.distanceScales;
  }
  containsPixel({
    x,
    y,
    width = 1,
    height = 1
  }) {
    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
  }
  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }
    Object.assign(this._frustumPlanes, (0, _mathUtils.getFrustumPlanes)(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }
  panByPosition(coords, pixel) {
    return null;
  }
  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;
    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = (0, _webMercator.getMeterZoom)({
          latitude
        }) + Math.log2(this.focalDistance);
      }
      this.distanceScales = opts.distanceScales || (0, _webMercator.getDistanceScales)({
        latitude,
        longitude
      });
    }
    const scale = Math.pow(2, this.zoom);
    this.scale = scale;
    const {
      position,
      modelMatrix
    } = opts;
    let meterOffset = ZERO_VECTOR;
    if (position) {
      meterOffset = modelMatrix ? new _core.Matrix4(modelMatrix).transformAsVector(position, []) : position;
    }
    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new _core.Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }
  _initMatrices(opts) {
    const {
      viewMatrix = IDENTITY,
      projectionMatrix = null,
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      far = 1000,
      padding = null,
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix;
    this.viewMatrix = new _core.Matrix4().multiplyRight(viewMatrix).translate(new _core.Vector3(this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = (0, _mathUtils.getCameraPosition)(this.viewMatrixInverse);
    const viewportMatrix = (0, _mathUtils.createMat4)();
    const pixelProjectionMatrix = (0, _mathUtils.createMat4)();
    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = mat4.invert((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);
    if (!this.pixelUnprojectionMatrix) {
      _log.default.warn('Pixel project matrix not invertible')();
    }
  }
}
exports.default = Viewport;
(0, _defineProperty2.default)(Viewport, "displayName", 'Viewport');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("./viewport"));
var _webMercator = require("@math.gl/web-mercator");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var _core = require("@math.gl/core");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WebMercatorViewport extends _viewport.default {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      legacyMeterSizes = false
    } = opts;
    let {
      width,
      height,
      altitude = 1.5
    } = opts;
    const scale = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;
    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = (0, _webMercator.altitudeToFovy)(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = (0, _webMercator.fovyToAltitude)(fovy);
      } else {
        fovy = (0, _webMercator.altitudeToFovy)(altitude);
      }
      let offset;
      if (padding) {
        const {
          top = 0,
          bottom = 0
        } = padding;
        offset = [0, (0, _core.clamp)((top + height - bottom) / 2, 0, height) - height / 2];
      }
      projectionParameters = (0, _webMercator.getProjectionParameters)({
        width,
        height,
        scale,
        center: position && [0, 0, position[2] * (0, _webMercator.unitsPerMeter)(latitude)],
        offset,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
    }
    let viewMatrixUncentered = (0, _webMercator.getViewMatrix)({
      height,
      pitch,
      bearing,
      scale,
      altitude
    });
    if (worldOffset) {
      const viewOffset = new _core.Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }
    super({
      ...opts,
      width,
      height,
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "latitude", void 0);
    (0, _defineProperty2.default)(this, "pitch", void 0);
    (0, _defineProperty2.default)(this, "bearing", void 0);
    (0, _defineProperty2.default)(this, "altitude", void 0);
    (0, _defineProperty2.default)(this, "fovy", void 0);
    (0, _defineProperty2.default)(this, "orthographic", void 0);
    (0, _defineProperty2.default)(this, "_subViewports", void 0);
    (0, _defineProperty2.default)(this, "_pseudoMeters", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);
      for (let x = minOffset; x <= maxOffset; x++) {
        const offsetViewport = x ? new WebMercatorViewport({
          ...this,
          worldOffset: x
        }) : this;
        this._subViewports.push(offsetViewport);
      }
    }
    return this._subViewports;
  }
  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * (0, _webMercator.unitsPerMeter)(xyz[1]);
    return [X, Y, Z];
  }
  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) / (0, _webMercator.unitsPerMeter)(Y);
    return [X, Y, Z];
  }
  addMetersToLngLat(lngLatZ, xyz) {
    return (0, _webMercator.addMetersToLngLat)(lngLatZ, xyz);
  }
  panByPosition(coords, pixel) {
    const fromLocation = (0, _webMercator.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return {
      longitude,
      latitude
    };
  }
  getBounds(options = {}) {
    const corners = (0, _webMercator.getBounds)(this, options.z || 0);
    return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
  }
  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0, _webMercator.fitBounds)({
      width,
      height,
      bounds,
      ...options
    });
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }
}
exports.default = WebMercatorViewport;
(0, _defineProperty2.default)(WebMercatorViewport, "displayName", 'WebMercatorViewport');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorldPosition = getWorldPosition;
exports.projectPosition = projectPosition;
var _constants = require("../../lib/constants");
var _viewportUniforms = require("./viewport-uniforms");
var _webMercatorViewport = _interopRequireDefault(require("../../viewports/web-mercator-viewport"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _webMercator = require("@math.gl/web-mercator");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof _webMercatorViewport.default) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }
  return p;
}
function normalizeParameters(opts) {
  const {
    viewport,
    modelMatrix,
    coordinateOrigin
  } = opts;
  let {
    coordinateSystem,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = opts;
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === undefined) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === undefined) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, {
  viewport,
  modelMatrix,
  coordinateSystem,
  coordinateOrigin,
  offsetMode
}) {
  let [x, y, z = 0] = position;
  if (modelMatrix) {
    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);
  }
  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);
    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition((0, _webMercator.addMetersToLngLat)(coordinateOrigin, [x, y, z]), viewport, offsetMode);
    case _constants.COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}
function projectPosition(position, params) {
  const {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = normalizeParameters(params);
  const {
    autoOffset = true
  } = params;
  const {
    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN,
    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    offsetMode = false
  } = autoOffset ? (0, _viewportUniforms.getOffsetOrigin)(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    vec3.sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js","../../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointLight = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _projectFunctions = require("../../shaderlib/project/project-functions");
var _constants = require("../../lib/constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_ATTENUATION = [0, 0, 1];
const DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];
let idCount = 0;
class PointLight {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "color", void 0);
    (0, _defineProperty2.default)(this, "intensity", void 0);
    (0, _defineProperty2.default)(this, "type", 'point');
    (0, _defineProperty2.default)(this, "position", void 0);
    (0, _defineProperty2.default)(this, "attenuation", void 0);
    (0, _defineProperty2.default)(this, "projectedLight", void 0);
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      position = DEFAULT_LIGHT_POSITION
    } = props;
    this.id = props.id || "point-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'point';
    this.position = position;
    this.attenuation = getAttenuation(props);
    this.projectedLight = {
      ...this
    };
  }
  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin
    } = layer.props;
    const position = (0, _projectFunctions.projectPosition)(this.position, {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      fromCoordinateSystem: viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN,
      fromCoordinateOrigin: [0, 0, 0]
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = position;
    return projectedLight;
  }
}
exports.PointLight = PointLight;
function getAttenuation(props) {
  if (props.attenuation) {
    return props.attenuation;
  }
  if ('intensity' in props) {
    return [0, 0, props.intensity || 0];
  }
  return DEFAULT_ATTENUATION;
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../shaderlib/project/project-functions":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _pointLight = require("./point-light");
var _viewportUniforms = require("../../shaderlib/project/viewport-uniforms");
class CameraLight extends _pointLight.PointLight {
  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin,
      modelMatrix
    } = layer.props;
    const {
      project_uCameraPosition
    } = (0, _viewportUniforms.getUniformsFromViewport)({
      viewport,
      modelMatrix,
      coordinateSystem,
      coordinateOrigin
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = project_uCameraPosition;
    return projectedLight;
  }
}
exports.default = CameraLight;
},{"./point-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","../../shaderlib/project/viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"node_modules/@math.gl/sun/dist/esm/suncalc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSunDirection = getSunDirection;
exports.getSunPosition = getSunPosition;
const DEGREES_TO_RADIANS = Math.PI / 180;
const DAY_IN_MS = 1000 * 60 * 60 * 24;
const JD1970 = 2440588;
const JD2000 = 2451545;
const e = DEGREES_TO_RADIANS * 23.4397;
const M0 = 357.5291;
const M1 = 0.98560028;
const THETA0 = 280.147;
const THETA1 = 360.9856235;
function getSunPosition(timestamp, latitude, longitude) {
  const longitudeWestInRadians = DEGREES_TO_RADIANS * -longitude;
  const phi = DEGREES_TO_RADIANS * latitude;
  const d = toDays(timestamp);
  const c = getSunCoords(d);
  const H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}
function getSunDirection(timestamp, latitude, longitude) {
  const {
    azimuth,
    altitude
  } = getSunPosition(timestamp, latitude, longitude);
  return [Math.sin(azimuth) * Math.cos(altitude), Math.cos(azimuth) * Math.cos(altitude), -Math.sin(altitude)];
}
function toJulianDay(timestamp) {
  const ts = typeof timestamp === 'number' ? timestamp : timestamp.getTime();
  return ts / DAY_IN_MS - 0.5 + JD1970;
}
function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}
function getRightAscension(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}
function getDeclination(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}
function getAzimuth(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}
function getAltitude(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}
function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}
function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS * (M0 + M1 * days);
}
function getEclipticLongitude(meanAnomaly) {
  const M = meanAnomaly;
  const C = DEGREES_TO_RADIANS * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
  const P = DEGREES_TO_RADIANS * 102.9372;
  return M + C + P + Math.PI;
}
function getSunCoords(dates) {
  const M = getSolarMeanAnomaly(dates);
  const L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}
},{}],"node_modules/@math.gl/sun/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getSunDirection", {
  enumerable: true,
  get: function () {
    return _suncalc.getSunDirection;
  }
});
Object.defineProperty(exports, "getSunPosition", {
  enumerable: true,
  get: function () {
    return _suncalc.getSunPosition;
  }
});
var _suncalc = require("./suncalc");
},{"./suncalc":"node_modules/@math.gl/sun/dist/esm/suncalc.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _directionalLight = require("./directional-light");
var _sun = require("@math.gl/sun");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class SunLight extends _directionalLight.DirectionalLight {
  constructor(opts) {
    super(opts);
    (0, _defineProperty2.default)(this, "timestamp", void 0);
    this.timestamp = opts.timestamp;
  }
  getProjectedLight({
    layer
  }) {
    const {
      viewport
    } = layer.context;
    const isGlobe = viewport.resolution && viewport.resolution > 0;
    if (isGlobe) {
      const [x, y, z] = (0, _sun.getSunDirection)(this.timestamp, 0, 0);
      this.direction = [x, -z, y];
    } else {
      const {
        latitude,
        longitude
      } = viewport;
      this.direction = (0, _sun.getSunDirection)(this.timestamp, latitude, longitude);
    }
    return this;
  }
}
exports.default = SunLight;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","@math.gl/sun":"node_modules/@math.gl/sun/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _pass = _interopRequireDefault(require("./pass"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ScreenPass extends _pass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "model", void 0);
    const {
      module,
      fs,
      id
    } = props;
    this.model = new _core.ClipSpace(gl, {
      id,
      fs,
      modules: [module]
    });
  }
  render(params) {
    const gl = this.gl;
    (0, _core.setParameters)(gl, {
      viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
    });
    (0, _core.withParameters)(gl, {
      framebuffer: params.outputBuffer,
      clearColor: [0, 0, 0, 0]
    }, () => this._renderPass(gl, params));
  }
  delete() {
    this.model.delete();
    this.model = null;
  }
  _renderPass(gl, options) {
    const {
      inputBuffer
    } = options;
    (0, _core.clear)(gl, {
      color: true
    });
    this.model.draw({
      moduleSettings: options.moduleSettings,
      uniforms: {
        texture: inputBuffer,
        texSize: [inputBuffer.width, inputBuffer.height]
      },
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }
}
exports.default = ScreenPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./pass":"node_modules/@deck.gl/core/dist/esm/passes/pass.js"}],"node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _screenPass = _interopRequireDefault(require("../passes/screen-pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PostProcessEffect {
  constructor(module, props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "module", void 0);
    (0, _defineProperty2.default)(this, "passes", void 0);
    this.id = "".concat(module.name, "-pass");
    this.props = props;
    (0, _core.normalizeShaderModule)(module);
    this.module = module;
  }
  setProps(props) {
    this.props = props;
  }
  preRender() {}
  postRender(gl, params) {
    const passes = this.passes || createPasses(gl, this.module, this.id);
    this.passes = passes;
    const {
      target
    } = params;
    let inputBuffer = params.inputBuffer;
    let outputBuffer = params.swapBuffer;
    for (let index = 0; index < this.passes.length; index++) {
      if (target && index === this.passes.length - 1) {
        outputBuffer = target;
      }
      this.passes[index].render({
        inputBuffer,
        outputBuffer,
        moduleSettings: this.props
      });
      const switchBuffer = outputBuffer;
      outputBuffer = inputBuffer;
      inputBuffer = switchBuffer;
    }
    return inputBuffer;
  }
  cleanup() {
    if (this.passes) {
      for (const pass of this.passes) {
        pass.delete();
      }
      this.passes = undefined;
    }
  }
}
exports.default = PostProcessEffect;
function createPasses(gl, module, id) {
  if (!module.passes) {
    const fs = getFragmentShaderForRenderPass(module);
    const pass = new _screenPass.default(gl, {
      id,
      module,
      fs
    });
    return [pass];
  }
  return module.passes.map((pass, index) => {
    const fs = getFragmentShaderForRenderPass(module, pass);
    const idn = "".concat(id, "-").concat(index);
    return new _screenPass.default(gl, {
      id: idn,
      module,
      fs
    });
  });
}
const FILTER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
const SAMPLER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
function getFragmentShaderForRenderPass(module, pass = module) {
  if (pass.filter) {
    const func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }
  if (pass.sampler) {
    const func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");
    return SAMPLER_FS_TEMPLATE(func);
  }
  return null;
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../passes/screen-pass":"node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layersPass = _interopRequireDefault(require("./layers-pass"));
var _core = require("@luma.gl/core");
var _log = _interopRequireDefault(require("../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const PICKING_PARAMETERS = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
class PickLayersPass extends _layersPass.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "pickZ", void 0);
    (0, _defineProperty2.default)(this, "_colorEncoderState", null);
  }
  render(props) {
    if ('pickingFBO' in props) {
      return this._drawPickingBuffer(props);
    }
    return super.render(props);
  }
  _drawPickingBuffer({
    layers,
    layerFilter,
    views,
    viewports,
    onViewportActive,
    pickingFBO,
    deviceRect: {
      x,
      y,
      width,
      height
    },
    cullRect,
    effects,
    pass = 'picking',
    pickZ,
    moduleParameters
  }) {
    const gl = this.gl;
    this.pickZ = pickZ;
    const colorEncoderState = this._resetColorEncoder(pickZ);
    const renderStatus = (0, _core.withParameters)(gl, {
      scissorTest: true,
      scissor: [x, y, width, height],
      clearColor: [0, 0, 0, 0],
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      colorMask: [true, true, true, true],
      ...PICKING_PARAMETERS,
      blend: !pickZ
    }, () => super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects === null || effects === void 0 ? void 0 : effects.filter(e => e.useInPicking),
      pass,
      isPicking: true,
      moduleParameters
    }));
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return {
      decodePickingColor,
      stats: renderStatus
    };
  }
  shouldDrawLayer(layer) {
    const {
      pickable,
      operation
    } = layer.props;
    return pickable && operation.includes('draw') || operation.includes('terrain');
  }
  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }
  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = {
      ...layer.props.parameters
    };
    const {
      pickable,
      operation
    } = layer.props;
    if (!this._colorEncoderState) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes('draw')) {
      Object.assign(pickParameters, PICKING_PARAMETERS);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }
    if (operation.includes('terrain')) {
      pickParameters.blend = false;
    }
    return pickParameters;
  }
  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }
}
exports.default = PickLayersPass;
function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;
    if (a <= 255) {
      entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      _log.default.warn('Too many pickable layers, only picking the first 255')();
      a = 0;
    }
  }
  return [0, 0, 0, a / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROP_TYPES_SYMBOL = exports.LIFECYCLE = exports.DEPRECATED_PROPS_SYMBOL = exports.COMPONENT_SYMBOL = exports.ASYNC_RESOLVED_SYMBOL = exports.ASYNC_ORIGINAL_SYMBOL = exports.ASYNC_DEFAULTS_SYMBOL = void 0;
const LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Initialized',
  AWAITING_GC: 'Discarded. Awaiting garbage collection',
  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
exports.LIFECYCLE = LIFECYCLE;
const COMPONENT_SYMBOL = Symbol.for('component');
exports.COMPONENT_SYMBOL = COMPONENT_SYMBOL;
const PROP_TYPES_SYMBOL = Symbol.for('propTypes');
exports.PROP_TYPES_SYMBOL = PROP_TYPES_SYMBOL;
const DEPRECATED_PROPS_SYMBOL = Symbol.for('deprecatedProps');
exports.DEPRECATED_PROPS_SYMBOL = DEPRECATED_PROPS_SYMBOL;
const ASYNC_DEFAULTS_SYMBOL = Symbol.for('asyncPropDefaults');
exports.ASYNC_DEFAULTS_SYMBOL = ASYNC_DEFAULTS_SYMBOL;
const ASYNC_ORIGINAL_SYMBOL = Symbol.for('asyncPropOriginal');
exports.ASYNC_ORIGINAL_SYMBOL = ASYNC_ORIGINAL_SYMBOL;
const ASYNC_RESOLVED_SYMBOL = Symbol.for('asyncPropResolved');
exports.ASYNC_RESOLVED_SYMBOL = ASYNC_RESOLVED_SYMBOL;
},{}],"node_modules/@deck.gl/core/dist/esm/utils/flatten.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillArray = fillArray;
exports.flatten = flatten;
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray({
  target,
  source,
  start = 0,
  count = 1
}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;
  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@loaders.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Resource {
  constructor(id, data, context) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "isLoaded", void 0);
    (0, _defineProperty2.default)(this, "persistent", void 0);
    (0, _defineProperty2.default)(this, "_loadCount", 0);
    (0, _defineProperty2.default)(this, "_subscribers", new Set());
    (0, _defineProperty2.default)(this, "_data", void 0);
    (0, _defineProperty2.default)(this, "_loader", void 0);
    (0, _defineProperty2.default)(this, "_error", void 0);
    (0, _defineProperty2.default)(this, "_content", void 0);
    this.id = id;
    this.context = context;
    this.setData(data);
  }
  subscribe(consumer) {
    this._subscribers.add(consumer);
  }
  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {}
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }
    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;
    if (typeof data === 'string') {
      loader = (0, _core.load)(data);
    }
    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then(result => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = undefined;
          this._content = result;
        }
      }).catch(error => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = undefined;
      this._content = data;
    }
    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }
}
exports.default = Resource;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _resource = _interopRequireDefault(require("./resource"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ResourceManager {
  constructor({
    gl,
    protocol
  }) {
    (0, _defineProperty2.default)(this, "protocol", void 0);
    (0, _defineProperty2.default)(this, "_context", void 0);
    (0, _defineProperty2.default)(this, "_resources", void 0);
    (0, _defineProperty2.default)(this, "_consumers", void 0);
    (0, _defineProperty2.default)(this, "_pruneRequest", void 0);
    this.protocol = protocol || 'resource://';
    this._context = {
      gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }
  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }
    return resourceId in this._resources;
  }
  add({
    resourceId,
    data,
    forceUpdate = false,
    persistent = true
  }) {
    let res = this._resources[resourceId];
    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new _resource.default(resourceId, data, this._context);
      this._resources[resourceId] = res;
    }
    res.persistent = persistent;
  }
  remove(resourceId) {
    const res = this._resources[resourceId];
    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }
  unsubscribe({
    consumerId
  }) {
    const consumer = this._consumers[consumerId];
    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];
        if (resource) {
          resource.unsubscribe(request);
        }
      }
      delete this._consumers[consumerId];
      this.prune();
    }
  }
  subscribe({
    resourceId,
    onChange,
    consumerId,
    requestId = 'default'
  }) {
    const {
      _resources: resources,
      protocol
    } = this;
    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, '');
      if (!resources[resourceId]) {
        this.add({
          resourceId,
          data: null,
          persistent: false
        });
      }
    }
    const res = resources[resourceId];
    this._track(consumerId, requestId, res, onChange);
    if (res) {
      return res.getData();
    }
    return undefined;
  }
  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }
  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }
  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    const request = consumer[requestId] || {};
    const oldResource = request.resourceId && this._resources[request.resourceId];
    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }
    if (resource) {
      consumer[requestId] = request;
      request.onChange = onChange;
      request.resourceId = resource.id;
      resource.subscribe(request);
    }
  }
  _prune() {
    this._pruneRequest = null;
    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];
      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }
}
exports.default = ResourceManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./resource":"node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _project = _interopRequireDefault(require("../project/project"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
var _default = {
  name: 'project32',
  dependencies: [_project.default],
  vs
};
exports.default = _default;
},{"../project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@luma.gl/core");
var _default = {
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
    'vs:DECKGL_FILTER_COLOR': "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
    'fs:#decl': "\nuniform bool picking_uAttribute;\n  ",
    'fs:DECKGL_FILTER_COLOR': {
      order: 99,
      injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
    }
  },
  ..._core.picking
};
exports.default = _default;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProgramManager = createProgramManager;
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _core.gouraudLighting;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _core.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.default;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.default;
  }
});
Object.defineProperty(exports, "project32", {
  enumerable: true,
  get: function () {
    return _project2.default;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function () {
    return _shadow.default;
  }
});
var _core = require("@luma.gl/core");
var _project = _interopRequireDefault(require("./project/project"));
var _project2 = _interopRequireDefault(require("./project32/project32"));
var _shadow = _interopRequireDefault(require("./shadow/shadow"));
var _picking = _interopRequireDefault(require("./picking/picking"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_MODULES = [_project.default];
const SHADER_HOOKS = ['vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)', 'vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)', 'vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)', 'fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)'];
function createProgramManager(gl) {
  const programManager = _core.ProgramManager.getDefaultProgramManager(gl);
  for (const shaderModule of DEFAULT_MODULES) {
    programManager.addDefaultModule(shaderModule);
  }
  for (const shaderHook of SHADER_HOOKS) {
    programManager.addShaderHook(shaderHook);
  }
  return programManager;
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","./project32/project32":"node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js","./shadow/shadow":"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js","./picking/picking":"node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _constants = require("../lifecycle/constants");
var _log = _interopRequireDefault(require("../utils/log"));
var _debug = _interopRequireDefault(require("../debug"));
var _flatten = require("../utils/flatten");
var _stats = require("@probe.gl/stats");
var _resourceManager = _interopRequireDefault(require("./resource/resource-manager"));
var _viewport2 = _interopRequireDefault(require("../viewports/viewport"));
var _shaderlib = require("../shaderlib");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_SET_LAYERS = 'layerManager.setLayers';
const TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';
class LayerManager {
  constructor(gl, {
    deck,
    stats,
    viewport: _viewport,
    timeline
  } = {}) {
    (0, _defineProperty2.default)(this, "layers", void 0);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "resourceManager", void 0);
    (0, _defineProperty2.default)(this, "_lastRenderedLayers", []);
    (0, _defineProperty2.default)(this, "_needsRedraw", false);
    (0, _defineProperty2.default)(this, "_needsUpdate", false);
    (0, _defineProperty2.default)(this, "_nextLayers", null);
    (0, _defineProperty2.default)(this, "_debug", false);
    (0, _defineProperty2.default)(this, "activateViewport", viewport => {
      (0, _debug.default)(TRACE_ACTIVATE_VIEWPORT, this, viewport);
      if (viewport) {
        this.context.viewport = viewport;
      }
    });
    this.layers = [];
    this.resourceManager = new _resourceManager.default({
      gl,
      protocol: 'deck://'
    });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl,
      deck,
      programManager: gl && (0, _shaderlib.createProgramManager)(gl),
      stats: stats || new _stats.Stats({
        id: 'deck.gl'
      }),
      viewport: _viewport || new _viewport2.default({
        id: 'DEFAULT-INITIAL-VIEWPORT'
      }),
      timeline: timeline || new _core.Timeline(),
      resourceManager: this.resourceManager,
      onError: undefined
    };
    Object.seal(this);
  }
  finalize() {
    this.resourceManager.finalize();
    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }
    return redraw;
  }
  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return 'layers changed';
    }
    return this._needsUpdate;
  }
  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }
  getLayers({
    layerIds
  } = {}) {
    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;
  }
  setProps(props) {
    if ('debug' in props) {
      this._debug = props.debug;
    }
    if ('userData' in props) {
      this.context.userData = props.userData;
    }
    if ('layers' in props) {
      this._nextLayers = props.layers;
    }
    if ('onError' in props) {
      this.context.onError = props.onError;
    }
  }
  setLayers(newLayers, reason) {
    (0, _debug.default)(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = (0, _flatten.flatten)(newLayers, Boolean);
    for (const layer of flatLayers) {
      layer.context = this.context;
    }
    this._updateLayers(this.layers, flatLayers);
  }
  updateLayers() {
    const reason = this.needsUpdate();
    if (reason) {
      this.setNeedsRedraw("updating layers: ".concat(reason));
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }
    this._nextLayers = null;
  }
  _handleError(stage, error, layer) {
    layer.raiseError(error, "".concat(stage, " of ").concat(layer));
  }
  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};
    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        _log.default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }
    const generatedLayers = [];
    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
    this._finalizeOldLayers(oldLayerMap);
    let needsUpdate = false;
    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = "Uniform transition in ".concat(layer);
        break;
      }
    }
    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }
  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];
      if (oldLayer === null) {
        _log.default.warn("Multiple new layers with same id ".concat(newLayer.id))();
      }
      oldLayerMap[newLayer.id] = null;
      let sublayers = null;
      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }
        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);
          this._updateLayer(newLayer);
        }
        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err) {
        this._handleError('matching', err, newLayer);
      }
      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }
  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];
      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }
  _initializeLayer(layer) {
    try {
      layer._initialize();
      layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError('initialization', err, layer);
    }
  }
  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);
    newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
    }
  }
  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError('update', err, layer);
    }
  }
  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
    layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
    try {
      layer._finalize();
      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError('finalization', err, layer);
    }
  }
}
exports.default = LayerManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","./resource/resource-manager":"node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../shaderlib":"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepEqual = deepEqual;
function deepEqual(a, b, depth) {
  if (a === b) {
    return true;
  }
  if (!depth || !a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b)) {
    return false;
  }
  if (typeof a === 'object' && typeof b === 'object') {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a[key], b[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/view-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deepEqual = require("../utils/deep-equal");
var _log = _interopRequireDefault(require("../utils/log"));
var _flatten = require("../utils/flatten");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ViewManager {
  constructor(props) {
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "views", void 0);
    (0, _defineProperty2.default)(this, "viewState", void 0);
    (0, _defineProperty2.default)(this, "controllers", void 0);
    (0, _defineProperty2.default)(this, "timeline", void 0);
    (0, _defineProperty2.default)(this, "_viewports", void 0);
    (0, _defineProperty2.default)(this, "_viewportMap", void 0);
    (0, _defineProperty2.default)(this, "_isUpdating", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "_needsUpdate", void 0);
    (0, _defineProperty2.default)(this, "_eventManager", void 0);
    (0, _defineProperty2.default)(this, "_eventCallbacks", void 0);
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'First render';
    this._needsUpdate = 'Initialize';
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }
  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];
      if (controller) {
        controller.finalize();
      }
    }
    this.controllers = {};
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }
  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];
      if (controller) {
        controller.updateTransition();
      }
    }
  }
  getViewports(rect) {
    if (rect) {
      return this._viewports.filter(viewport => viewport.containsPixel(rect));
    }
    return this._viewports;
  }
  getViews() {
    const viewMap = {};
    this.views.forEach(view => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }
  getView(viewId) {
    return this.views.find(view => view.id === viewId);
  }
  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === 'string' ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }
  getViewport(viewId) {
    return this._viewportMap[viewId];
  }
  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = {
      x: xyz[0],
      y: xyz[1]
    };
    for (let i = viewports.length - 1; i >= 0; --i) {
      const viewport = viewports[i];
      if (viewport.containsPixel(pixel)) {
        const p = xyz.slice();
        p[0] -= viewport.x;
        p[1] -= viewport.y;
        return viewport.unproject(p, opts);
      }
    }
    return null;
  }
  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }
    if (props.viewState) {
      this._setViewState(props.viewState);
    }
    if ('width' in props || 'height' in props) {
      this._setSize(props.width, props.height);
    }
    if (!this._isUpdating) {
      this._update();
    }
  }
  _update() {
    this._isUpdating = true;
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    this._isUpdating = false;
  }
  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate('Size changed');
    }
  }
  _setViews(views) {
    views = (0, _flatten.flatten)(views, Boolean);
    const viewsChanged = this._diffViews(views, this.views);
    if (viewsChanged) {
      this.setNeedsUpdate('views changed');
    }
    this.views = views;
  }
  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !(0, _deepEqual.deepEqual)(viewState, this.viewState, 3);
      if (viewStateChanged) {
        this.setNeedsUpdate('viewState changed');
      }
      this.viewState = viewState;
    } else {
      _log.default.warn('missing `viewState` or `initialViewState`')();
    }
  }
  _onViewStateChange(viewId, event) {
    if (this._eventCallbacks.onViewStateChange) {
      this._eventCallbacks.onViewStateChange({
        ...event,
        viewId
      });
    }
  }
  _createController(view, props) {
    const Controller = props.type;
    const controller = new Controller({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, props.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: viewState => {
        var _this$getView;
        return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
      }
    });
    return controller;
  }
  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;
    if (controllerProps) {
      const resolvedProps = {
        ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };
      if (!controller) {
        controller = this._createController(view, resolvedProps);
      }
      if (controller) {
        controller.setProps(resolvedProps);
      }
      return controller;
    }
    return null;
  }
  _rebuildViewports() {
    const {
      views
    } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;
    for (let i = views.length; i--;) {
      const view = views[i];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({
        viewState,
        width: this.width,
        height: this.height
      });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);
      if (hasController && !oldController) {
        invalidateControllers = true;
      }
      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }
      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
      this._viewports.unshift(viewport);
    }
    for (const id in oldControllers) {
      const oldController = oldControllers[id];
      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {};
    this._viewports.forEach(viewport => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }
  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }
    return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
  }
}
exports.default = ViewManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js"}],"node_modules/@deck.gl/core/dist/esm/utils/positions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPosition = getPosition;
exports.parsePosition = parsePosition;
const PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case 'number':
      return {
        position: value,
        relative: false
      };
    case 'string':
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === '%';
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'deck.gl: assertion failed.');
  }
}
},{}],"node_modules/@deck.gl/core/dist/esm/views/view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _positions = require("../utils/positions");
var _deepEqual = require("../utils/deep-equal");
var _assert = _interopRequireDefault(require("../utils/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class View {
  constructor(props) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "viewportInstance", void 0);
    (0, _defineProperty2.default)(this, "_x", void 0);
    (0, _defineProperty2.default)(this, "_y", void 0);
    (0, _defineProperty2.default)(this, "_width", void 0);
    (0, _defineProperty2.default)(this, "_height", void 0);
    (0, _defineProperty2.default)(this, "_padding", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    const {
      id,
      x = 0,
      y = 0,
      width = '100%',
      height = '100%',
      padding = null,
      viewportInstance
    } = props || {};
    (0, _assert.default)(!viewportInstance || viewportInstance instanceof _viewport.default);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || 'view';
    this.props = {
      ...props,
      id: this.id
    };
    this._x = (0, _positions.parsePosition)(x);
    this._y = (0, _positions.parsePosition)(y);
    this._width = (0, _positions.parsePosition)(width);
    this._height = (0, _positions.parsePosition)(height);
    this._padding = padding && {
      left: (0, _positions.parsePosition)(padding.left || 0),
      right: (0, _positions.parsePosition)(padding.right || 0),
      top: (0, _positions.parsePosition)(padding.top || 0),
      bottom: (0, _positions.parsePosition)(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }
  equals(view) {
    if (this === view) {
      return true;
    }
    if (this.viewportInstance) {
      return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
    }
    return this.ViewportType === view.ViewportType && (0, _deepEqual.deepEqual)(this.props, view.props, 2);
  }
  makeViewport({
    width,
    height,
    viewState
  }) {
    if (this.viewportInstance) {
      return this.viewportInstance;
    }
    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({
      width,
      height
    });
    return new this.ViewportType({
      ...viewState,
      ...this.props,
      ...viewportDimensions
    });
  }
  getViewStateId() {
    const {
      viewState
    } = this.props;
    if (typeof viewState === 'string') {
      return viewState;
    }
    return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
  }
  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === 'object') {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }
      const newViewState = {
        ...viewState
      };
      for (const key in this.props.viewState) {
        if (key !== 'id') {
          newViewState[key] = this.props.viewState[key];
        }
      }
      return newViewState;
    }
    return viewState;
  }
  getDimensions({
    width,
    height
  }) {
    const dimensions = {
      x: (0, _positions.getPosition)(this._x, width),
      y: (0, _positions.getPosition)(this._y, height),
      width: (0, _positions.getPosition)(this._width, width),
      height: (0, _positions.getPosition)(this._height, height)
    };
    if (this._padding) {
      dimensions.padding = {
        left: (0, _positions.getPosition)(this._padding.left, width),
        top: (0, _positions.getPosition)(this._padding.top, height),
        right: (0, _positions.getPosition)(this._padding.right, width),
        bottom: (0, _positions.getPosition)(this._padding.bottom, height)
      };
    }
    return dimensions;
  }
  get controller() {
    const opts = this.props.controller;
    if (!opts) {
      return null;
    }
    if (opts === true) {
      return {
        type: this.ControllerType
      };
    }
    if (typeof opts === 'function') {
      return {
        type: opts
      };
    }
    return {
      type: this.ControllerType,
      ...opts
    };
  }
}
exports.default = View;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../utils/positions":"node_modules/@deck.gl/core/dist/esm/utils/positions.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Transition {
  constructor(timeline) {
    (0, _defineProperty2.default)(this, "_inProgress", void 0);
    (0, _defineProperty2.default)(this, "_handle", void 0);
    (0, _defineProperty2.default)(this, "_timeline", void 0);
    (0, _defineProperty2.default)(this, "time", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    this._inProgress = false;
    this._handle = null;
    this._timeline = timeline;
    this.time = 0;
    this.settings = {
      duration: 0
    };
  }
  get inProgress() {
    return this._inProgress;
  }
  start(settings) {
    var _this$settings$onStar, _this$settings;
    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
  }
  end() {
    if (this._inProgress) {
      var _this$settings$onEnd, _this$settings2;
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
    }
  }
  cancel() {
    if (this._inProgress) {
      var _this$settings$onInte, _this$settings3;
      (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }
  update() {
    var _this$settings$onUpda, _this$settings4;
    if (!this._inProgress) {
      return false;
    }
    if (this._handle === null) {
      const {
        _timeline: timeline,
        settings
      } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }
    this.time = this._timeline.getTime(this._handle);
    this._onUpdate();
    (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);
    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }
    return true;
  }
  _onUpdate() {}
}
exports.default = Transition;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_EVENTS = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transition = _interopRequireDefault(require("../transitions/transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const noop = () => {};
const TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
exports.TRANSITION_EVENTS = TRANSITION_EVENTS;
const DEFAULT_EASING = t => t;
const DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
class TransitionManager {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "getControllerState", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "propsInTransition", void 0);
    (0, _defineProperty2.default)(this, "transition", void 0);
    (0, _defineProperty2.default)(this, "onViewStateChange", void 0);
    (0, _defineProperty2.default)(this, "onStateChange", void 0);
    (0, _defineProperty2.default)(this, "_onTransitionUpdate", transition => {
      const {
        time,
        settings: {
          interpolator,
          startProps,
          endProps,
          duration,
          easing
        }
      } = transition;
      const t = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    });
    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new _transition.default(opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop;
    this.onStateChange = opts.onStateChange || noop;
  }
  finalize() {
    this.transition.cancel();
  }
  getViewportInTransition() {
    return this.propsInTransition;
  }
  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;
    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }
    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;
      if (this.transition.inProgress) {
        const {
          interruption,
          endProps
        } = this.transition.settings;
        startProps = {
          ...currentProps,
          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)
        };
      }
      this._triggerTransition(startProps, nextProps);
      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }
    return transitionTriggered;
  }
  updateTransition() {
    this.transition.update();
  }
  _isTransitionEnabled(props) {
    const {
      transitionDuration,
      transitionInterpolator
    } = props;
    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);
  }
  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }
    return false;
  }
  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
    }
    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }
    return true;
  }
  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
    if (duration === 0) {
      return;
    }
    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({
      inTransition: true
    });
    this.updateTransition();
  }
  _onTransitionEnd(callback) {
    return transition => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback === null || callback === void 0 ? void 0 : callback(transition);
    };
  }
}
exports.default = TransitionManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../transitions/transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _assert = _interopRequireDefault(require("../utils/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TransitionInterpolator {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "_propsToCompare", void 0);
    (0, _defineProperty2.default)(this, "_propsToExtract", void 0);
    (0, _defineProperty2.default)(this, "_requiredProps", void 0);
    const {
      compare,
      extract,
      required
    } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }
  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !(0, _core.equals)(currentProps[key], nextProps[key])) {
        return false;
      }
    }
    return true;
  }
  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};
    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }
    this._checkRequiredProps(startViewStateProps);
    this._checkRequiredProps(endViewStateProps);
    return {
      start: startViewStateProps,
      end: endViewStateProps
    };
  }
  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }
  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }
    this._requiredProps.forEach(propName => {
      const value = props[propName];
      (0, _assert.default)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
    });
  }
}
exports.default = TransitionInterpolator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
const DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];
class LinearInterpolator extends _transitionInterpolator.default {
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);
    (0, _defineProperty2.default)(this, "opts", void 0);
    this.opts = normalizedOpts;
  }
  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const {
      makeViewport,
      around
    } = this.opts;
    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }
    return result;
  }
  interpolateProps(startProps, endProps, t) {
    const propsInTransition = {};
    for (const key of this._propsToExtract) {
      propsInTransition[key] = (0, _core.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }
    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({
        ...endProps,
        ...propsInTransition
      });
      Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, (0, _core.lerp)(startProps.around, endProps.around, t)));
    }
    return propsInTransition;
  }
}
exports.default = LinearInterpolator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transitionManager = _interopRequireDefault(require("./transition-manager"));
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
const DEFAULT_INERTIA = 300;
const INERTIA_EASING = t => 1 - (1 - t) * (1 - t);
const EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown']
};
const pinchEventWorkaround = {};
class Controller {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "state", {});
    (0, _defineProperty2.default)(this, "transitionManager", void 0);
    (0, _defineProperty2.default)(this, "eventManager", void 0);
    (0, _defineProperty2.default)(this, "onViewStateChange", void 0);
    (0, _defineProperty2.default)(this, "onStateChange", void 0);
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    (0, _defineProperty2.default)(this, "_controllerState", void 0);
    (0, _defineProperty2.default)(this, "_events", {});
    (0, _defineProperty2.default)(this, "_interactionState", {
      isDragging: false
    });
    (0, _defineProperty2.default)(this, "_customEvents", []);
    (0, _defineProperty2.default)(this, "_eventStartBlocked", null);
    (0, _defineProperty2.default)(this, "_panMove", false);
    (0, _defineProperty2.default)(this, "invertPan", false);
    (0, _defineProperty2.default)(this, "dragMode", 'rotate');
    (0, _defineProperty2.default)(this, "inertia", 0);
    (0, _defineProperty2.default)(this, "scrollZoom", true);
    (0, _defineProperty2.default)(this, "dragPan", true);
    (0, _defineProperty2.default)(this, "dragRotate", true);
    (0, _defineProperty2.default)(this, "doubleClickZoom", true);
    (0, _defineProperty2.default)(this, "touchZoom", true);
    (0, _defineProperty2.default)(this, "touchRotate", false);
    (0, _defineProperty2.default)(this, "keyboard", true);
    this.transitionManager = new _transitionManager.default({
      ...opts,
      getControllerState: props => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;
    this.onViewStateChange = opts.onViewStateChange || (() => {});
    this.onStateChange = opts.onStateChange || (() => {});
    this.makeViewport = opts.makeViewport;
  }
  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    if (this.props) {
      this.setProps(this.props);
    }
  }
  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        var _this$eventManager;
        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
      }
    }
    this.transitionManager.finalize();
  }
  handleEvent(event) {
    this._controllerState = undefined;
    const eventStartBlocked = this._eventStartBlocked;
    switch (event.type) {
      case 'panstart':
        return eventStartBlocked ? false : this._onPanStart(event);
      case 'panmove':
        return this._onPan(event);
      case 'panend':
        return this._onPanEnd(event);
      case 'pinchstart':
        return eventStartBlocked ? false : this._onPinchStart(event);
      case 'pinchmove':
        return this._onPinch(event);
      case 'pinchend':
        return this._onPinchEnd(event);
      case 'tripanstart':
        return eventStartBlocked ? false : this._onTriplePanStart(event);
      case 'tripanmove':
        return this._onTriplePan(event);
      case 'tripanend':
        return this._onTriplePanEnd(event);
      case 'doubletap':
        return this._onDoubleTap(event);
      case 'wheel':
        return this._onWheel(event);
      case 'keydown':
        return this._onKeyDown(event);
      default:
        return false;
    }
  }
  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }
  getCenter(event) {
    const {
      x,
      y
    } = this.props;
    const {
      offsetCenter
    } = event;
    return [offsetCenter.x - x, offsetCenter.y - y];
  }
  isPointInBounds(pos, event) {
    const {
      width,
      height
    } = this.props;
    if (event && event.handled) {
      return false;
    }
    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
    if (inside && event) {
      event.stopPropagation();
    }
    return inside;
  }
  isFunctionKeyPressed(event) {
    const {
      srcEvent
    } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || false;
  }
  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }
  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }
    this.props = props;
    if (!('transitionInterpolator' in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }
    this.transitionManager.processViewStateChange(props);
    const {
      inertia
    } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const {
      scrollZoom = true,
      dragPan = true,
      dragRotate = true,
      doubleClickZoom = true,
      touchZoom = true,
      touchRotate = false,
      keyboard = true
    } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach(eventName => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;
          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }
  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = {
      ...newControllerState.getViewportProps(),
      ...extraProps
    };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();
    this._setInteractionState(interactionState);
    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();
      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState,
          interactionState: this._interactionState,
          oldViewState
        });
      }
    }
  }
  _onTransition(params) {
    this.onViewStateChange({
      ...params,
      interactionState: this._interactionState
    });
  }
  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }
  _onPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
    if (this.invertPan || this.dragMode === 'pan') {
      alternateMode = !alternateMode;
    }
    const newControllerState = this.controllerState[alternateMode ? 'panStart' : 'rotateStart']({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }
  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }
  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }
  _onPanMoveEnd(event) {
    const {
      inertia
    } = this;
    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.pan({
        pos: endPos
      }).panEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }
    return true;
  }
  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onPanRotateEnd(event) {
    const {
      inertia
    } = this;
    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      }).rotateEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }
    event.srcEvent.preventDefault();
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const {
      speed = 0.01,
      smooth = false
    } = this.scrollZoom === true ? {} : this.scrollZoom;
    const {
      delta
    } = event;
    let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
    if (delta < 0 && scale !== 0) {
      scale = 1 / scale;
    }
    const newControllerState = this.controllerState.zoom({
      pos,
      scale
    });
    this.updateViewport(newControllerState, {
      ...this._getTransitionProps({
        around: pos
      }),
      transitionDuration: smooth ? 250 : 1
    }, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }
  _onTriplePanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.rotateStart({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onTriplePan(event) {
    if (!this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onTriplePanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const {
      inertia
    } = this;
    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  _onPinchStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.zoomStart({
      pos
    }).rotateStart({
      pos
    });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    let newControllerState = this.controllerState;
    if (this.touchZoom) {
      const {
        scale
      } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({
        pos,
        scale
      });
    }
    if (this.touchRotate) {
      const {
        rotation
      } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }
  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const {
      inertia
    } = this;
    const {
      _lastPinchEvent
    } = pinchEventWorkaround;
    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z = Math.log2(event.scale);
      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
      const endScale = Math.pow(2, z + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({
        pos,
        scale: endScale
      }).zoomEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }
    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }
  _onDoubleTap(event) {
    if (!this.doubleClickZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({
      pos,
      scale: isZoomOut ? 0.5 : 2
    });
    this.updateViewport(newControllerState, this._getTransitionProps({
      around: pos
    }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }
  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }
    const funcKey = this.isFunctionKeyPressed(event);
    const {
      zoomSpeed,
      moveSpeed,
      rotateSpeedX,
      rotateSpeedY
    } = this.keyboard === true ? {} : this.keyboard;
    const {
      controllerState
    } = this;
    let newControllerState;
    const interactionState = {};
    switch (event.srcEvent.code) {
      case 'Minus':
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case 'Equal':
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case 'ArrowLeft':
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case 'ArrowRight':
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case 'ArrowUp':
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case 'ArrowDown':
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      default:
        return false;
    }
    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }
  _getTransitionProps(opts) {
    const {
      transition
    } = this;
    if (!transition || !transition.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }
    return opts ? {
      ...transition,
      transitionInterpolator: new _linearInterpolator.default({
        ...opts,
        ...transition.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition;
  }
}
exports.default = Controller;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-manager":"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ViewState {
  constructor(props, state) {
    (0, _defineProperty2.default)(this, "_viewportProps", void 0);
    (0, _defineProperty2.default)(this, "_state", void 0);
    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
exports.default = ViewState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MapState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _viewState = _interopRequireDefault(require("./view-state"));
var _webMercator = require("@math.gl/web-mercator");
var _assert = _interopRequireDefault(require("../utils/assert"));
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const PITCH_MOUSE_THRESHOLD = 5;
const PITCH_ACCEL = 1.2;
class MapState extends _viewState.default {
  constructor(options) {
    const {
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing = 0,
      pitch = 0,
      altitude = 1.5,
      position = [0, 0, 0],
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom,
      normalize = true
    } = options;
    (0, _assert.default)(Number.isFinite(longitude));
    (0, _assert.default)(Number.isFinite(latitude));
    (0, _assert.default)(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    this.makeViewport = options.makeViewport;
  }
  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }
  pan({
    pos,
    startPos
  }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();
    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {
      return this;
    }
    let newRotation;
    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomLngLat
    } = this.getState();
    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomLngLat) {
      return this;
    }
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale);
    zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({
      ...this.getViewportProps(),
      zoom
    });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }
  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }
  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }
  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }
  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }
  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const {
      maxPitch,
      minPitch,
      pitch
    } = props;
    props.pitch = (0, _core.clamp)(pitch, minPitch, maxPitch);
    const {
      normalize = true
    } = props;
    if (normalize) {
      Object.assign(props, (0, _webMercator.normalizeViewportProps)(props));
    }
    return props;
  }
  _zoomFromCenter(scale) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale
    });
  }
  _panFromCenter(offset) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const {
      width,
      height
    } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;
    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }
    deltaScaleY = (0, _core.clamp)(deltaScaleY, -1, 1);
    const {
      minPitch,
      maxPitch
    } = this.getViewportProps();
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;
    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }
    return {
      pitch,
      bearing
    };
  }
}
exports.MapState = MapState;
class MapController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", MapState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default({
        transitionProps: {
          compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch', 'position'],
          required: ['longitude', 'latitude', 'zoom']
        }
      })
    });
    (0, _defineProperty2.default)(this, "dragMode", 'pan');
  }
  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;
    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }
}
exports.default = MapController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/map-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _webMercatorViewport = _interopRequireDefault(require("../viewports/web-mercator-viewport"));
var _mapController = _interopRequireDefault(require("../controllers/map-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class MapView extends _view.default {
  get ViewportType() {
    return _webMercatorViewport.default;
  }
  get ControllerType() {
    return _mapController.default;
  }
}
exports.default = MapView;
(0, _defineProperty2.default)(MapView, "displayName", 'MapView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","../controllers/map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js"}],"node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deepEqual = require("../utils/deep-equal");
var _lightingEffect = _interopRequireDefault(require("../effects/lighting/lighting-effect"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHTING_EFFECT = new _lightingEffect.default();
function compareEffects(e1, e2) {
  var _e1$order, _e2$order;
  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
  return o1 - o2;
}
class EffectManager {
  constructor() {
    (0, _defineProperty2.default)(this, "effects", void 0);
    (0, _defineProperty2.default)(this, "_resolvedEffects", []);
    (0, _defineProperty2.default)(this, "_defaultEffects", []);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    this.effects = [];
    this._needsRedraw = 'Initial render';
    this._setEffects([]);
  }
  addDefaultEffect(effect) {
    const defaultEffects = this._defaultEffects;
    if (!defaultEffects.find(e => e.id === effect.id)) {
      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);
      if (index < 0) {
        defaultEffects.push(effect);
      } else {
        defaultEffects.splice(index, 0, effect);
      }
      this._setEffects(this.effects);
    }
  }
  setProps(props) {
    if ('effects' in props) {
      if (!(0, _deepEqual.deepEqual)(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(effects) {
    const oldEffectsMap = {};
    for (const effect of this.effects) {
      oldEffectsMap[effect.id] = effect;
    }
    const nextEffects = [];
    for (const effect of effects) {
      const oldEffect = oldEffectsMap[effect.id];
      if (oldEffect && oldEffect !== effect) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect.props);
          nextEffects.push(oldEffect);
        } else {
          oldEffect.cleanup();
          nextEffects.push(effect);
        }
      } else {
        nextEffects.push(effect);
      }
      delete oldEffectsMap[effect.id];
    }
    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup();
    }
    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);
    if (!effects.some(effect => effect instanceof _lightingEffect.default)) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
    this._needsRedraw = 'effects changed';
  }
  finalize() {
    for (const effect of this._resolvedEffects) {
      effect.cleanup();
    }
    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }
}
exports.default = EffectManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../effects/lighting/lighting-effect":"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js"}],"node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _layersPass = _interopRequireDefault(require("./layers-pass"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class DrawLayersPass extends _layersPass.default {
  shouldDrawLayer(layer) {
    const {
      operation
    } = layer.props;
    return operation.includes('draw') || operation.includes('terrain');
  }
}
exports.default = DrawLayersPass;
},{"./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"}],"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _debug = _interopRequireDefault(require("../debug"));
var _drawLayersPass = _interopRequireDefault(require("../passes/draw-layers-pass"));
var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';
class DeckRenderer {
  constructor(gl) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "layerFilter", void 0);
    (0, _defineProperty2.default)(this, "drawPickingColors", void 0);
    (0, _defineProperty2.default)(this, "drawLayersPass", void 0);
    (0, _defineProperty2.default)(this, "pickLayersPass", void 0);
    (0, _defineProperty2.default)(this, "renderCount", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "renderBuffers", void 0);
    (0, _defineProperty2.default)(this, "lastPostProcessEffect", void 0);
    this.gl = gl;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new _drawLayersPass.default(gl);
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.renderCount = 0;
    this._needsRedraw = 'Initial render';
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }
  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = 'layerFilter changed';
    }
    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = 'drawPickingColors changed';
    }
  }
  renderLayers(opts) {
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts,
      target: opts.target || _core.Framebuffer.getDefaultFramebuffer(this.gl)
    };
    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }
    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    const renderStats = layerPass.render({
      ...renderOpts,
      target: outputBuffer
    });
    if (renderOpts.effects) {
      this._postRender(renderOpts.effects, renderOpts);
    }
    this.renderCount++;
    (0, _debug.default)(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  finalize() {
    const {
      renderBuffers
    } = this;
    for (const buffer of renderBuffers) {
      buffer.delete();
    }
    renderBuffers.length = 0;
  }
  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};
    for (const effect of effects) {
      opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
      if (effect.postRender) {
        this.lastPostProcessEffect = effect.id;
      }
    }
    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers
    } = this;
    if (renderBuffers.length === 0) {
      renderBuffers.push(new _core.Framebuffer(this.gl), new _core.Framebuffer(this.gl));
    }
    for (const buffer of renderBuffers) {
      buffer.resize();
    }
  }
  _postRender(effects, opts) {
    const {
      renderBuffers
    } = this;
    const params = {
      ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1],
      target: null
    };
    for (const effect of effects) {
      if (effect.postRender) {
        if (effect.id === this.lastPostProcessEffect) {
          params.target = opts.target;
          effect.postRender(this.gl, params);
          break;
        }
        const buffer = effect.postRender(this.gl, params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }
}
exports.default = DeckRenderer;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../passes/draw-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js","../passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClosestObject = getClosestObject;
exports.getUniqueObjects = getUniqueObjects;
var _log = _interopRequireDefault(require("../../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({
  pickedColors,
  decodePickingColor,
  deviceX,
  deviceY,
  deviceRadius,
  deviceRect
}) {
  const {
    x,
    y,
    width,
    height
  } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x + dx,
        pickedY: y + dy
      };
    }
    _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({
  pickedColors,
  decodePickingColor
}) {
  const uniqueColors = new Map();
  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(',');
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}
},{"../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmptyPickingInfo = getEmptyPickingInfo;
exports.getLayerPickingInfo = getLayerPickingInfo;
exports.processPickInfo = processPickInfo;
function getEmptyPickingInfo({
  pickInfo,
  viewports,
  pixelRatio,
  x,
  y,
  z
}) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
      x,
      y
    });
  }
  let coordinate;
  if (pickedViewport) {
    const point = [x - pickedViewport.x, y - pickedViewport.y];
    if (z !== undefined) {
      point[2] = z;
    }
    coordinate = pickedViewport.unproject(point);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    devicePixel: pickInfo && 'pickedX' in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : undefined,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const {
    pickInfo,
    lastPickedInfo,
    mode,
    layers
  } = opts;
  const {
    pickedColor,
    pickedLayer,
    pickedObjectIndex
  } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === 'hover') {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(layer => {
    let info = {
      ...baseInfo
    };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === 'hover') {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === 'hover') {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({
  layer,
  info,
  mode
}) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));
var _queryObject = require("./picking/query-object");
var _pickInfo = require("./picking/pick-info");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class DeckPicker {
  constructor(gl) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "pickingFBO", void 0);
    (0, _defineProperty2.default)(this, "depthFBO", void 0);
    (0, _defineProperty2.default)(this, "pickLayersPass", void 0);
    (0, _defineProperty2.default)(this, "layerFilter", void 0);
    (0, _defineProperty2.default)(this, "lastPickedInfo", void 0);
    (0, _defineProperty2.default)(this, "_pickable", true);
    this.gl = gl;
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(props) {
    if ('layerFilter' in props) {
      this.layerFilter = props.layerFilter;
    }
    if ('_pickable' in props) {
      this._pickable = props._pickable;
    }
  }
  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.delete();
    }
    if (this.depthFBO) {
      this.depthFBO.color.delete();
      this.depthFBO.delete();
    }
  }
  pickObject(opts) {
    return this._pickClosestObject(opts);
  }
  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }
  getLastPickedObject({
    x,
    y,
    layers,
    viewports
  }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
    const info = {
      x,
      y,
      viewport,
      coordinate,
      layer
    };
    return {
      ...lastPickedInfo,
      ...info
    };
  }
  _resizeBuffer() {
    var _this$pickingFBO, _this$depthFBO;
    const {
      gl
    } = this;
    if (!this.pickingFBO) {
      this.pickingFBO = new _core.Framebuffer(gl);
      if (_core.Framebuffer.isSupported(gl, {
        colorBufferFloat: true
      })) {
        const depthFBO = new _core.Framebuffer(gl);
        depthFBO.attach({
          [36064]: new _core.Texture2D(gl, {
            format: (0, _core.isWebGL2)(gl) ? 34836 : 6408,
            type: 5126
          })
        });
        this.depthFBO = depthFBO;
      }
    }
    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
  }
  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }
    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }
  _pickClosestObject({
    layers,
    views,
    viewports,
    x,
    y,
    radius = 0,
    depth = 1,
    mode = 'query',
    unproject3D,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);
    const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
    if (!pickableLayers) {
      return {
        result: [],
        emptyInfo: (0, _pickInfo.getEmptyPickingInfo)({
          viewports,
          x,
          y,
          pixelRatio
        })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = (0, _core.cssToDevicePixels)(this.gl, [x, y], true);
    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
    const deviceRadius = Math.round(radius * pixelRatio);
    const {
      width,
      height
    } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x - radius,
      y: y - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = new Set();
    for (let i = 0; i < depth; i++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: "picking:".concat(mode)
        });
        pickInfo = (0, _queryObject.getClosestObject)({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const {
          pickedColors: pickedColors2
        } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: "picking:".concat(mode, ":z")
        }, true);
        if (pickedColors2[3]) {
          z = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = (0, _pickInfo.processPickInfo)({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x,
        y,
        z,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return {
      result,
      emptyInfo: infos.get(null)
    };
  }
  _pickVisibleObjects({
    layers,
    views,
    viewports,
    x,
    y,
    width = 1,
    height = 1,
    mode = 'query',
    maxObjects = null,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
    const leftTop = (0, _core.cssToDevicePixels)(this.gl, [x, y], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = (0, _core.cssToDevicePixels)(this.gl, [x + width, y + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: {
        x,
        y,
        width,
        height
      },
      effects,
      pass: "picking:".concat(mode)
    });
    const pickInfos = (0, _queryObject.getUniqueObjects)(pickedResult);
    const uniqueInfos = new Map();
    const isMaxObjects = Number.isFinite(maxObjects);
    for (let i = 0; i < pickInfos.length; i++) {
      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x,
        y,
        pixelRatio
      };
      info = (0, _pickInfo.getLayerPickingInfo)({
        layer: pickInfo.pickedLayer,
        info,
        mode
      });
      if (!uniqueInfos.has(info.object)) {
        uniqueInfos.set(info.object, info);
      }
    }
    return Array.from(uniqueInfos.values());
  }
  _drawAndSample({
    layers,
    views,
    viewports,
    onViewportActive,
    deviceRect,
    cullRect,
    effects,
    pass
  }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {}
    };
    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
      }
    }
    const {
      decodePickingColor
    } = this.pickLayersPass.render(opts);
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    (0, _core.readPixelsToArray)(pickingFBO, {
      sourceX: x,
      sourceY: y,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return {
      pickedColors,
      decodePickingColor
    };
  }
  _getPickingRect({
    deviceX,
    deviceY,
    deviceRadius,
    deviceWidth,
    deviceHeight
  }) {
    const x = Math.max(0, deviceX - deviceRadius);
    const y = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
    if (width <= 0 || height <= 0) {
      return null;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
}
exports.default = DeckPicker;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","./picking/query-object":"node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js","./picking/pick-info":"node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js"}],"node_modules/@deck.gl/core/dist/esm/lib/tooltip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultStyle = {
  zIndex: '1',
  position: 'absolute',
  pointerEvents: 'none',
  color: '#a0a7b4',
  backgroundColor: '#29323c',
  padding: '10px',
  top: '0',
  left: '0',
  display: 'none'
};
class Tooltip {
  constructor(canvas) {
    (0, _defineProperty2.default)(this, "el", null);
    (0, _defineProperty2.default)(this, "isVisible", false);
    const canvasParent = canvas.parentElement;
    if (canvasParent) {
      this.el = document.createElement('div');
      this.el.className = 'deck-tooltip';
      Object.assign(this.el.style, defaultStyle);
      canvasParent.appendChild(this.el);
    }
  }
  setTooltip(displayInfo, x, y) {
    const el = this.el;
    if (!el) {
      return;
    }
    if (typeof displayInfo === 'string') {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = 'none';
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }
      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }
      if (displayInfo.className) {
        el.className = displayInfo.className;
      }
      Object.assign(el.style, displayInfo.style);
    }
    this.isVisible = true;
    el.style.display = 'block';
    el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
  }
  remove() {
    if (this.el) {
      this.el.remove();
      this.el = null;
    }
  }
}
exports.default = Tooltip;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/hammerjs/hammer.js":[function(require,module,exports) {
var define;
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
  'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }
    return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
    var i;
    if (!obj) {
      return;
    }
    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;
      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);
      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }
      return method.apply(this, arguments);
    };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  } else {
    assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }
      i++;
    }
    return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
    var baseP = base.prototype,
      childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;
    if (properties) {
      assign(childP, properties);
    }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
    return val1 === undefined ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;
      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          return i;
        }
        i++;
      }
      return -1;
    }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;
    while (i < src.length) {
      var val = key ? src[i][key] : src[i];
      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }
      values[i] = val;
      i++;
    }
    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }
    return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;
      if (prop in obj) {
        return prop;
      }
      i++;
    }
    return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
    return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }
  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };
    this.init();
  }
  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function () {},
    /**
     * bind the events
     */
    init: function () {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },
    /**
     * unbind the events
     */
    destroy: function () {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;
    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }
    return new Type(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;
    if (isFirst) {
      manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }
    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }
    input.target = target;
  }
  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};
    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }
    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
      deltaTime = input.timeStamp - last.timeStamp,
      velocity,
      velocityX,
      velocityY,
      direction;
    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }
    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }
    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }
    var x = 0,
      y = 0,
      i = 0;
    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }
    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }
    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
      y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
      y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
  }
  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type];

      // on start we want to have the left mouse button down
      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      }

      // mouse must be down
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = this.manager.session.pointerEvents = [];
  }
  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType == INPUT_TYPE_TOUCH;

      // get index of the event in the store
      var storeIndex = inArray(store, ev.pointerId, 'pointerId');

      // start and mouse must be down
      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      }

      // it not found, so the pointer hasn't been down (so it's probably a hover)
      if (storeIndex < 0) {
        return;
      }

      // update the event in the store
      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });
      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }
  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

      // should we handle the touch events?
      if (type === INPUT_START) {
        this.started = true;
      }
      if (!this.started) {
        return;
      }
      var touches = normalizeSingleTouches.call(this, ev, type);

      // when done, reset the started state
      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }
      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);
    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }
    return [all, changed];
  }
  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }
  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);
      if (!touches) {
        return;
      }
      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }
    var i,
      targetTouches,
      changedTouches = toArray(ev.changedTouches),
      changedTargetTouches = [],
      target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
      i = 0;
      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      }

      // cleanup removed touches
      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }
      i++;
    }
    if (!changedTargetTouches.length) {
      return;
    }
    return [
    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */

  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;
  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
    this.primaryTouch = null;
    this.lastTouches = [];
  }
  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
        return;
      }

      // when we're in a touch event, record touches to  de-dupe synthetic mouse event
      if (isTouch) {
        recordTouches.call(this, inputEvent, inputData);
      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
        return;
      }
      this.callback(manager, inputEvent, inputData);
    },
    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });
  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }
  function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];
    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      this.lastTouches.push(lastTouch);
      var lts = this.lastTouches;
      var removeLastTouch = function () {
        var i = lts.indexOf(lastTouch);
        if (i > -1) {
          lts.splice(i, 1);
        }
      };
      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }
  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX,
      y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x),
        dy = Math.abs(y - t.y);
      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }
    return false;
  }
  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function (value) {
      // find out the touch-action by the event handlers
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }
      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }
      this.actions = value.toLowerCase().trim();
    },
    /**
     * just re-set the touchAction value
     */
    update: function () {
      this.set(this.manager.options.touchAction);
    },
    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function () {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },
    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function (input) {
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection;

      // if the touch action did prevented once this session
      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }
      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
      if (hasNone) {
        //do not prevent defaults if this is a tap gesture

        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;
        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }
      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }
      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    },
    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function (srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }
    return TOUCH_ACTION_AUTO;
  }
  function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
      return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
      // If css.supports is not supported but there is native touch-action assume it supports
      // all values. This is the case for IE 10 and 11.
      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},
    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function (options) {
      assign(this.options, options);

      // also update the touchAction, in case something changed about the directions/enabled state
      this.manager && this.manager.touchAction.update();
      return this;
    },
    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }
      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }
      return this;
    },
    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },
    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }
      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }
      return this;
    },
    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);
      if (index > -1) {
        this.requireFail.splice(index, 1);
      }
      return this;
    },
    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function () {
      return this.requireFail.length > 0;
    },
    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function (otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },
    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function (input) {
      var self = this;
      var state = this.state;
      function emit(event) {
        self.manager.emit(event, input);
      }

      // 'panstart' and 'panmove'
      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      }

      // panend and pancancel
      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    },
    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function (input) {
      if (this.canEmit()) {
        return this.emit(input);
      }
      // it's failing anyway
      this.state = STATE_FAILED;
    },
    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function () {
      var i = 0;
      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }
        i++;
      }
      return true;
    },
    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign({}, inputData);

      // is is enabled and allow recognizing?
      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      }

      // reset when we've reached the end
      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }
      this.state = this.process(inputDataClone);

      // the recognizer has recognized a gesture
      // so trigger an event
      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },
    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function (inputData) {},
    // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function () {},
    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function () {}
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }
    return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }
    return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
      return manager.get(otherRecognizer);
    }
    return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }
  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },
    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function (input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },
    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function (input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input);

      // on cancel input and we've recognized before, return STATE_CANCELLED
      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }
        return state | STATE_CHANGED;
      }
      return STATE_FAILED;
    }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }
  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function () {
      var direction = this.options.direction;
      var actions = [];
      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }
      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }
      return actions;
    },
    directionTest: function (input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY;

      // lock to axis?
      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }
      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function (input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    },
    emit: function (input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);
      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }
      this._super.emit.call(this, input);
    }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function (input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }
      this._super.emit.call(this, input);
    }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }
  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function () {
      return [TOUCH_ACTION_AUTO];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input;

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }
      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function (input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }
      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function () {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function (input) {
      var direction = this.options.direction;
      var velocity;
      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }
      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function (input) {
      var direction = directionStr(input.offsetDirection);
      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }
      this.manager.emit(this.options.event, input);
    }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }
  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function () {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();
      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      }

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }
        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;
        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }
        this._input = input;

        // if tap count matches we have recognized it,
        // else it has began recognizing...
        var tapCount = this.count % options.taps;
        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }
      return STATE_FAILED;
    },
    failTimeout: function () {
      this._timer = setTimeoutContext(function () {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function () {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.7';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,
    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,
    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,
    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,
    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,
    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
    [RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ['rotate']], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],
    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',
      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',
      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',
      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',
      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',
      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function (options) {
      assign(this.options, options);

      // Options that need a little more setup
      if (options.touchAction) {
        this.touchAction.update();
      }
      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }
      return this;
    },
    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function (force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },
    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      var session = this.session;
      if (session.stopped) {
        return;
      }

      // run the touch-action polyfill
      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers;

      // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`
      var curRecognizer = session.curRecognizer;

      // reset when the last recognizer is recognized
      // or when we're in a new session
      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }
      var i = 0;
      while (i < recognizers.length) {
        recognizer = recognizers[i];

        // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.
        if (session.stopped !== FORCED_STOP && (
        // 1
        !curRecognizer || recognizer == curRecognizer ||
        // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        }

        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer
        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }
        i++;
      }
    },
    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function (recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }
      var recognizers = this.recognizers;
      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }
      return null;
    },
    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function (recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      }

      // remove existing
      var existing = this.get(recognizer.options.event);
      if (existing) {
        this.remove(existing);
      }
      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },
    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function (recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }
      recognizer = this.get(recognizer);

      // let's make sure this recognizer exists
      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);
        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }
      return this;
    },
    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function (events, handler) {
      if (events === undefined) {
        return;
      }
      if (handler === undefined) {
        return;
      }
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },
    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function (events, handler) {
      if (events === undefined) {
        return;
      }
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },
    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function (event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      }

      // no handlers, so skip it all
      var handlers = this.handlers[event] && this.handlers[event].slice();
      if (!handlers || !handlers.length) {
        return;
      }
      data.type = event;
      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };
      var i = 0;
      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },
    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function () {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
      return;
    }
    var prop;
    each(manager.options.cssProps, function (value, name) {
      prop = prefixed(element.style, name);
      if (add) {
        manager.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = manager.oldCssProps[prop] || '';
      }
    });
    if (!add) {
      manager.oldCssProps = {};
    }
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }
  assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
  freeGlobal.Hammer = Hammer;
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return Hammer;
    });
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }
})(window, document, 'Hammer');
},{}],"node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enhanceMouseInput = enhanceMouseInput;
exports.enhancePointerEventInput = enhancePointerEventInput;
/**
 * This file contains overrides the default
 * hammer.js functions to add our own utility
 */
/* eslint-disable */
/* Hammer.js constants */
const INPUT_START = 1;
const INPUT_MOVE = 2;
const INPUT_END = 4;
const MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
/**
 * Helper function that returns true if any element in an array meets given criteria.
 * Because older browsers do not support `Array.prototype.some`
 * @params array {Array}
 * @params predict {Function}
 */
function some(array, predict) {
  for (let i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }
  return false;
}
/* eslint-disable no-invalid-this */
function enhancePointerEventInput(PointerEventInput) {
  const oldHandler = PointerEventInput.prototype.handler;
  // overrides PointerEventInput.handler to accept right mouse button
  PointerEventInput.prototype.handler = function handler(ev) {
    const store = this.store;
    // Allow non-left mouse buttons through
    if (ev.button > 0 && ev.type === 'pointerdown') {
      if (!some(store, e => e.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
// overrides MouseInput.handler to accept right mouse button
function enhanceMouseInput(MouseInput) {
  MouseInput.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    // on start we want to have the mouse button down
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }
    // mouse must be down
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: 'mouse',
      srcEvent: ev
    });
  };
}
},{}],"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Manager = void 0;
var hammerjs = _interopRequireWildcard(require("hammerjs"));
var _hammerOverrides = require("./hammer-overrides");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
(0, _hammerOverrides.enhancePointerEventInput)(hammerjs.PointerEventInput);
(0, _hammerOverrides.enhanceMouseInput)(hammerjs.MouseInput);
const Manager = hammerjs.Manager;
exports.Manager = Manager;
var _default = hammerjs;
exports.default = _default;
},{"hammerjs":"node_modules/hammerjs/hammer.js","./hammer-overrides":"node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js"}],"node_modules/mjolnir.js/dist/esm/inputs/input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
class Input {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = {
      enable: true,
      ...options
    };
  }
}
exports.default = Input;
},{}],"node_modules/mjolnir.js/dist/esm/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZERS = exports.INPUT_EVENT_TYPES = exports.GESTURE_EVENT_ALIASES = exports.EVENT_RECOGNIZER_MAP = exports.BASIC_EVENT_ALIASES = void 0;
var _hammer = _interopRequireDefault(require("./utils/hammer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// This module contains constants that must be conditionally required
// due to `window`/`document` references downstream.
const RECOGNIZERS = _hammer.default ? [[_hammer.default.Pan, {
  event: 'tripan',
  pointers: 3,
  threshold: 0,
  enable: false
}], [_hammer.default.Rotate, {
  enable: false
}], [_hammer.default.Pinch, {
  enable: false
}], [_hammer.default.Swipe, {
  enable: false
}], [_hammer.default.Pan, {
  threshold: 0,
  enable: false
}], [_hammer.default.Press, {
  enable: false
}], [_hammer.default.Tap, {
  event: 'doubletap',
  taps: 2,
  enable: false
}],
// TODO - rename to 'tap' and 'singletap' in the next major release
[_hammer.default.Tap, {
  event: 'anytap',
  enable: false
}], [_hammer.default.Tap, {
  enable: false
}]] : null;
// Recognize the following gestures even if a given recognizer succeeds
exports.RECOGNIZERS = RECOGNIZERS;
const RECOGNIZER_COMPATIBLE_MAP = {
  tripan: ['rotate', 'pinch', 'pan'],
  rotate: ['pinch'],
  pinch: ['pan'],
  pan: ['press', 'doubletap', 'anytap', 'tap'],
  doubletap: ['anytap'],
  anytap: ['tap']
};
// Recognize the folling gestures only if a given recognizer fails
exports.RECOGNIZER_COMPATIBLE_MAP = RECOGNIZER_COMPATIBLE_MAP;
const RECOGNIZER_FALLBACK_MAP = {
  doubletap: ['tap']
};
/**
 * Only one set of basic input events will be fired by Hammer.js:
 * either pointer, touch, or mouse, depending on system support.
 * In order to enable an application to be agnostic of system support,
 * alias basic input events into "classes" of events: down, move, and up.
 * See `_onBasicInput()` for usage of these aliases.
 */
exports.RECOGNIZER_FALLBACK_MAP = RECOGNIZER_FALLBACK_MAP;
const BASIC_EVENT_ALIASES = {
  pointerdown: 'pointerdown',
  pointermove: 'pointermove',
  pointerup: 'pointerup',
  touchstart: 'pointerdown',
  touchmove: 'pointermove',
  touchend: 'pointerup',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup'
};
exports.BASIC_EVENT_ALIASES = BASIC_EVENT_ALIASES;
const INPUT_EVENT_TYPES = {
  KEY_EVENTS: ['keydown', 'keyup'],
  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
  WHEEL_EVENTS: [
  // Chrome, Safari
  'wheel',
  // IE
  'mousewheel']
};
/**
 * "Gestural" events are those that have semantic meaning beyond the basic input event,
 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
 * Hammer.js handles these with its Recognizer system;
 * this block maps event names to the Recognizers required to detect the events.
 */
exports.INPUT_EVENT_TYPES = INPUT_EVENT_TYPES;
const EVENT_RECOGNIZER_MAP = {
  tap: 'tap',
  anytap: 'anytap',
  doubletap: 'doubletap',
  press: 'press',
  pinch: 'pinch',
  pinchin: 'pinch',
  pinchout: 'pinch',
  pinchstart: 'pinch',
  pinchmove: 'pinch',
  pinchend: 'pinch',
  pinchcancel: 'pinch',
  rotate: 'rotate',
  rotatestart: 'rotate',
  rotatemove: 'rotate',
  rotateend: 'rotate',
  rotatecancel: 'rotate',
  tripan: 'tripan',
  tripanstart: 'tripan',
  tripanmove: 'tripan',
  tripanup: 'tripan',
  tripandown: 'tripan',
  tripanleft: 'tripan',
  tripanright: 'tripan',
  tripanend: 'tripan',
  tripancancel: 'tripan',
  pan: 'pan',
  panstart: 'pan',
  panmove: 'pan',
  panup: 'pan',
  pandown: 'pan',
  panleft: 'pan',
  panright: 'pan',
  panend: 'pan',
  pancancel: 'pan',
  swipe: 'swipe',
  swipeleft: 'swipe',
  swiperight: 'swipe',
  swipeup: 'swipe',
  swipedown: 'swipe'
};
/**
 * Map gestural events typically provided by browsers
 * that are not reported in 'hammer.input' events
 * to corresponding Hammer.js gestures.
 */
exports.EVENT_RECOGNIZER_MAP = EVENT_RECOGNIZER_MAP;
const GESTURE_EVENT_ALIASES = {
  click: 'tap',
  anyclick: 'anytap',
  dblclick: 'doubletap',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup',
  mouseover: 'pointerover',
  mouseout: 'pointerout',
  mouseleave: 'pointerleave'
};
exports.GESTURE_EVENT_ALIASES = GESTURE_EVENT_ALIASES;
},{"./utils/hammer":"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js"}],"node_modules/mjolnir.js/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.userAgent = exports.passiveSupported = exports.global = exports.document = void 0;
// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global'
/* global window, global, document, navigator */
const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
exports.userAgent = userAgent;
const window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
const global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
const document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;
/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */
let passiveSupported = false;
/* eslint-disable accessor-pairs, no-empty */
exports.passiveSupported = passiveSupported;
try {
  const options = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      exports.passiveSupported = passiveSupported = true;
      return true;
    }
  };
  window_.addEventListener('test', null, options);
  window_.removeEventListener('test', null);
} catch (err) {
  exports.passiveSupported = passiveSupported = false;
}
},{}],"node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
var _constants = require("../constants");
var _globals = require("../utils/globals");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const firefox = _globals.userAgent.indexOf('firefox') !== -1;
const {
  WHEEL_EVENTS: WHEEL_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const EVENT_TYPE = 'wheel';
// Constants for normalizing input delta
const WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const WHEEL_DELTA_PER_LINE = 40;
// Slow down zoom if shift key is held for more precise zooming
const SHIFT_MULTIPLIER = 0.25;
class WheelInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    /* eslint-disable complexity, max-statements */
    this.handleEvent = event => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (_globals.window.WheelEvent) {
        // Firefox doubles the values on retina screens...
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }
        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: 'mouse',
        target: event.target
      });
    };
    this.events = (this.options.events || []).concat(WHEEL_EVENTS);
    this.events.forEach(event => element.addEventListener(event, this.handleEvent, _globals.passiveSupported ? {
      passive: false
    } : false));
  }
  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
}
exports.default = WheelInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js","../constants":"node_modules/mjolnir.js/dist/esm/constants.js","../utils/globals":"node_modules/mjolnir.js/dist/esm/utils/globals.js"}],"node_modules/mjolnir.js/dist/esm/inputs/move-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
var _constants = require("../constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  MOUSE_EVENTS: MOUSE_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const MOVE_EVENT_TYPE = 'pointermove';
const OVER_EVENT_TYPE = 'pointerover';
const OUT_EVENT_TYPE = 'pointerout';
const ENTER_EVENT_TYPE = 'pointerenter';
const LEAVE_EVENT_TYPE = 'pointerleave';
/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */
class MoveInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = event => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const {
      enable: enable
    } = this.options;
    this.enableMoveEvent = enable;
    this.enableLeaveEvent = enable;
    this.enableEnterEvent = enable;
    this.enableOutEvent = enable;
    this.enableOverEvent = enable;
    this.events = (this.options.events || []).concat(MOUSE_EVENTS);
    this.events.forEach(event => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === MOVE_EVENT_TYPE) {
      this.enableMoveEvent = enabled;
    }
    if (eventType === OVER_EVENT_TYPE) {
      this.enableOverEvent = enabled;
    }
    if (eventType === OUT_EVENT_TYPE) {
      this.enableOutEvent = enabled;
    }
    if (eventType === ENTER_EVENT_TYPE) {
      this.enableEnterEvent = enabled;
    }
    if (eventType === LEAVE_EVENT_TYPE) {
      this.enableLeaveEvent = enabled;
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent) {
      if (event.type === 'mouseover') {
        this._emit(OVER_EVENT_TYPE, event);
      }
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent) {
      if (event.type === 'mouseout') {
        this._emit(OUT_EVENT_TYPE, event);
      }
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent) {
      if (event.type === 'mouseenter') {
        this._emit(ENTER_EVENT_TYPE, event);
      }
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent) {
      if (event.type === 'mouseleave') {
        this._emit(LEAVE_EVENT_TYPE, event);
      }
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case 'mousedown':
          if (event.button >= 0) {
            // Button is down
            this.pressed = true;
          }
          break;
        case 'mousemove':
          // Move events use `which` to track the button being pressed
          if (event.which === 0) {
            // Button is not down
            this.pressed = false;
          }
          if (!this.pressed) {
            // Drag events are emitted by hammer already
            // we just need to emit the move event on hover
            this._emit(MOVE_EVENT_TYPE, event);
          }
          break;
        case 'mouseup':
          this.pressed = false;
          break;
        default:
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type: type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: 'mouse',
      target: event.target
    });
  }
}
exports.default = MoveInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js","../constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/inputs/key-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
var _constants = require("../constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  KEY_EVENTS: KEY_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const DOWN_EVENT_TYPE = 'keydown';
const UP_EVENT_TYPE = 'keyup';
class KeyInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = event => {
      // Ignore if focused on text input
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {
        return;
      }
      if (this.enableDownEvent && event.type === 'keydown') {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === 'keyup') {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = (this.options.events || []).concat(KEY_EVENTS);
    element.tabIndex = this.options.tabIndex || 0;
    element.style.outline = 'none';
    this.events.forEach(event => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === DOWN_EVENT_TYPE) {
      this.enableDownEvent = enabled;
    }
    if (eventType === UP_EVENT_TYPE) {
      this.enableUpEvent = enabled;
    }
  }
}
exports.default = KeyInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js","../constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EVENT_TYPE = 'contextmenu';
class ContextmenuInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = event => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: 'mouse',
        target: event.target
      });
    };
    element.addEventListener('contextmenu', this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener('contextmenu', this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
}
exports.default = ContextmenuInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js"}],"node_modules/mjolnir.js/dist/esm/utils/event-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsetPosition = getOffsetPosition;
exports.whichButtons = whichButtons;
/* Constants */
const DOWN_EVENT = 1;
const MOVE_EVENT = 2;
const UP_EVENT = 4;
const MOUSE_EVENTS = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
const MOUSE_EVENT_WHICH_LEFT = 1;
const MOUSE_EVENT_WHICH_MIDDLE = 2;
const MOUSE_EVENT_WHICH_RIGHT = 3;
// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
const MOUSE_EVENT_BUTTON_LEFT = 0;
const MOUSE_EVENT_BUTTON_MIDDLE = 1;
const MOUSE_EVENT_BUTTON_RIGHT = 2;
// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
const MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
 * Extract the involved mouse button
 */
function whichButtons(event) {
  const eventType = MOUSE_EVENTS[event.srcEvent.type];
  if (!eventType) {
    // Not a mouse evet
    return null;
  }
  const {
    buttons: buttons,
    button: button,
    which: which
  } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (
  // button is up, need to find out which one was pressed before
  eventType === UP_EVENT ||
  // moving but does not support `buttons` API
  eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return {
    leftButton: leftButton,
    middleButton: middleButton,
    rightButton: rightButton
  };
}
/**
 * Calculate event position relative to the root element
 */
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  // `center` is a hammer.js event property
  if (!center) {
    // Not a gestural event
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  // Fix scale for map affected by a CSS transform.
  // See https://stackoverflow.com/a/26893663/3528533
  const scaleX = rect.width / rootElement.offsetWidth || 1;
  const scaleY = rect.height / rootElement.offsetHeight || 1;
  // Calculate center relative to the root element
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return {
    center: center,
    offsetCenter: offsetCenter
  };
}
},{}],"node_modules/mjolnir.js/dist/esm/utils/event-registrar.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _eventUtils = require("./event-utils");
const DEFAULT_OPTIONS = {
  srcElement: 'root',
  priority: 0
};
class EventRegistrar {
  constructor(eventManager) {
    /**
     * Handles hammerjs event
     */
    this.handleEvent = event => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target = event.srcEvent.target;
      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);
        if (mjolnirEvent.handled) {
          return;
        }
        target = target.parentNode;
      }
      this._emit(mjolnirEvent, 'root');
    };
    this.eventManager = eventManager;
    this.handlers = [];
    // Element -> handler map
    this.handlersByElement = new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler, options, once = false, passive = false) {
    const {
      handlers: handlers,
      handlersByElement: handlersByElement
    } = this;
    let opts = DEFAULT_OPTIONS;
    if (typeof options === 'string' || options && options.addEventListener) {
      // is DOM element, backward compatibility
      // @ts-ignore
      opts = {
        ...DEFAULT_OPTIONS,
        srcElement: options
      };
    } else if (options) {
      opts = {
        ...DEFAULT_OPTIONS,
        ...options
      };
    }
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type: type,
      handler: handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    // Sort handlers by descending priority
    // Handlers with the same priority are excuted in the order of registration
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler) {
    const {
      handlers: handlers,
      handlersByElement: handlersByElement
    } = this;
    for (let i = handlers.length - 1; i >= 0; i--) {
      const entry = handlers[i];
      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some(entry => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      // Prevents the current event from bubbling up
      const stopPropagation = () => {
        event.handled = true;
      };
      // Prevent any remaining listeners from being called
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i = 0; i < entries.length; i++) {
        const {
          type: type,
          handler: handler,
          once: once
        } = entries[i];
        handler({
          ...event,
          // @ts-ignore
          type: type,
          stopPropagation: stopPropagation,
          stopImmediatePropagation: stopImmediatePropagation
        });
        if (once) {
          entriesToRemove.push(entries[i]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i = 0; i < entriesToRemove.length; i++) {
        const {
          type: type,
          handler: handler
        } = entriesToRemove[i];
        this.remove(type, handler);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...(0, _eventUtils.whichButtons)(event),
      ...(0, _eventUtils.getOffsetPosition)(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement: rootElement
    };
  }
}
exports.default = EventRegistrar;
},{"./event-utils":"node_modules/mjolnir.js/dist/esm/utils/event-utils.js"}],"node_modules/mjolnir.js/dist/esm/event-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _hammer = require("./utils/hammer");
var _wheelInput = _interopRequireDefault(require("./inputs/wheel-input"));
var _moveInput = _interopRequireDefault(require("./inputs/move-input"));
var _keyInput = _interopRequireDefault(require("./inputs/key-input"));
var _contextmenuInput = _interopRequireDefault(require("./inputs/contextmenu-input"));
var _eventRegistrar = _interopRequireDefault(require("./utils/event-registrar"));
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_OPTIONS = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: _hammer.Manager,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: 'none',
  tabIndex: 0
};
// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.
class EventManager {
  constructor(element = null, options) {
    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */
    this._onBasicInput = event => {
      const {
        srcEvent: srcEvent
      } = event;
      const alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    };
    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */
    this._onOtherEvent = event => {
      // console.log('onotherevent', event.type, event)
      this.manager.emit(event.type, event);
    };
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    this.events = new Map();
    this.setElement(element);
    // Register all passed events.
    const {
      events: events
    } = this.options;
    if (events) {
      this.on(events);
    }
  }
  getElement() {
    return this.element;
  }
  setElement(element) {
    if (this.element) {
      // unregister all events
      this.destroy();
    }
    this.element = element;
    if (!element) {
      return;
    }
    const {
      options: options
    } = this;
    const ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || _constants.RECOGNIZERS
    }).on('hammer.input', this._onBasicInput);
    if (!options.recognizers) {
      // Set default recognize withs
      // http://hammerjs.github.io/recognize-with/
      Object.keys(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(name => {
        const recognizer = this.manager.get(name);
        if (recognizer) {
          _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }
    // Set recognizer options
    for (const recognizerName in options.recognizerOptions) {
      const recognizer = this.manager.get(recognizerName);
      if (recognizer) {
        const recognizerOption = options.recognizerOptions[recognizerName];
        // `enable` is managed by the event registrations
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }
    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this.wheelInput = new _wheelInput.default(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new _moveInput.default(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new _keyInput.default(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new _contextmenuInput.default(element, this._onOtherEvent, {
      enable: false
    });
    // Register all existing events
    for (const [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        // Enable recognizer for this event.
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }
  // Tear down internal event management implementations.
  destroy() {
    if (this.element) {
      // wheelInput etc. are created in setElement() and therefore
      // cannot exist if there is no element
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }
  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }
  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }
  off(event, handler) {
    this._removeEventHandler(event, handler);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name, enabled) {
    const {
      manager: manager
    } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name);
    // @ts-ignore
    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({
        enable: enabled
      });
      const fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];
      if (fallbackRecognizers && !this.options.recognizers) {
        // Set default require failures
        // http://hammerjs.github.io/require-failure/
        fallbackRecognizers.forEach(otherName => {
          const otherRecognizer = manager.get(otherName);
          if (enabled) {
            // Wait for this recognizer to fail
            otherRecognizer.requireFailure(name);
            /**
             * This seems to be a bug in hammerjs:
             * requireFailure() adds both ways
             * dropRequireFailure() only drops one way
             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
               recognizer-constructor.js#L136
             */
            recognizer.dropRequireFailure(otherName);
          } else {
            // Do not wait for this recognizer to fail
            otherRecognizer.dropRequireFailure(name);
          }
        });
      }
    }
    this.wheelInput.enableEventType(name, enabled);
    this.moveInput.enableEventType(name, enabled);
    this.keyInput.enableEventType(name, enabled);
    this.contextmenuInput.enableEventType(name, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== 'string') {
      // @ts-ignore
      opts = handler;
      // If `event` is a map, call `on()` for each entry.
      for (const eventName in event) {
        this._addEventHandler(eventName, event[eventName], opts, once, passive);
      }
      return;
    }
    const {
      manager: manager,
      events: events
    } = this;
    // Alias to a recognized gesture as necessary.
    const eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
    let eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      eventRegistrar = new _eventRegistrar.default(this);
      events.set(eventAlias, eventRegistrar);
      // Enable recognizer for this event.
      eventRegistrar.recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Listen to the event
      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler, opts, once, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler) {
    if (typeof event !== 'string') {
      // If `event` is a map, call `off()` for each entry.
      for (const eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }
      return;
    }
    const {
      events: events
    } = this;
    // Alias to a recognized gesture as necessary.
    const eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
    const eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler);
    if (eventRegistrar.isEmpty()) {
      const {
        recognizerName: recognizerName
      } = eventRegistrar;
      // Disable recognizer if no more handlers are attached to its events
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
}
exports.default = EventManager;
},{"./utils/hammer":"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js","./inputs/wheel-input":"node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js","./inputs/move-input":"node_modules/mjolnir.js/dist/esm/inputs/move-input.js","./inputs/key-input":"node_modules/mjolnir.js/dist/esm/inputs/key-input.js","./inputs/contextmenu-input":"node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js","./utils/event-registrar":"node_modules/mjolnir.js/dist/esm/utils/event-registrar.js","./constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EventManager", {
  enumerable: true,
  get: function () {
    return _eventManager.default;
  }
});
var _eventManager = _interopRequireDefault(require("./event-manager"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./event-manager":"node_modules/mjolnir.js/dist/esm/event-manager.js"}],"node_modules/@deck.gl/core/dist/esm/lib/deck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layerManager = _interopRequireDefault(require("./layer-manager"));
var _viewManager = _interopRequireDefault(require("./view-manager"));
var _mapView = _interopRequireDefault(require("../views/map-view"));
var _effectManager = _interopRequireDefault(require("./effect-manager"));
var _deckRenderer = _interopRequireDefault(require("./deck-renderer"));
var _deckPicker = _interopRequireDefault(require("./deck-picker"));
var _tooltip = _interopRequireDefault(require("./tooltip"));
var _log = _interopRequireDefault(require("../utils/log"));
var _deepEqual = require("../utils/deep-equal");
var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));
var _init = require("./init");
var _env = require("@probe.gl/env");
var _core = require("@luma.gl/core");
var _stats = require("@probe.gl/stats");
var _mjolnir = require("mjolnir.js");
var _assert = _interopRequireDefault(require("../utils/assert"));
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function noop() {}
const getCursor = ({
  isDragging
}) => isDragging ? 'grabbing' : 'grab';
const defaultProps = {
  id: '',
  width: '100%',
  height: '100%',
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: 'none',
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onInteractionStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLoad: noop,
  onError: error => _log.default.error(error.message)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
class Deck {
  constructor(props) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "width", 0);
    (0, _defineProperty2.default)(this, "height", 0);
    (0, _defineProperty2.default)(this, "userData", {});
    (0, _defineProperty2.default)(this, "canvas", null);
    (0, _defineProperty2.default)(this, "viewManager", null);
    (0, _defineProperty2.default)(this, "layerManager", null);
    (0, _defineProperty2.default)(this, "effectManager", null);
    (0, _defineProperty2.default)(this, "deckRenderer", null);
    (0, _defineProperty2.default)(this, "deckPicker", null);
    (0, _defineProperty2.default)(this, "eventManager", null);
    (0, _defineProperty2.default)(this, "tooltip", null);
    (0, _defineProperty2.default)(this, "metrics", void 0);
    (0, _defineProperty2.default)(this, "animationLoop", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "viewState", void 0);
    (0, _defineProperty2.default)(this, "cursorState", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "_pickRequest", void 0);
    (0, _defineProperty2.default)(this, "_lastPointerDownInfo", null);
    (0, _defineProperty2.default)(this, "_metricsCounter", void 0);
    (0, _defineProperty2.default)(this, "_onPointerMove", event => {
      const {
        _pickRequest
      } = this;
      if (event.type === 'pointerleave') {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = {
          x: _pickRequest.x,
          y: _pickRequest.y
        };
      }
      _pickRequest.event = event;
    });
    (0, _defineProperty2.default)(this, "_onEvent", event => {
      const eventOptions = _constants.EVENTS[event.type];
      const pos = event.offsetCenter;
      if (!eventOptions || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const {
        layer
      } = info;
      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      const rootHandler = this.props[eventOptions.handler];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    });
    (0, _defineProperty2.default)(this, "_onPointerDown", event => {
      const pos = event.offsetCenter;
      const pickedInfo = this._pick('pickObject', 'pickObject Time', {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    });
    this.props = {
      ...defaultProps,
      ...props
    };
    props = this.props;
    this._needsRedraw = 'Initial render';
    this._pickRequest = {
      mode: 'hover',
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };
    if (props.viewState && props.initialViewState) {
      _log.default.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();
    }
    if ((0, _env.getBrowser)() === 'IE') {
      _log.default.warn('IE 11 is not supported')();
    }
    this.viewState = props.initialViewState;
    if (!props.gl) {
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }
    }
    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new _stats.Stats({
      id: 'deck.gl'
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);
    if (props._typedArrayManagerProps) {
      _typedArrayManager.default.setOptions(props._typedArrayManagerProps);
    }
    this.animationLoop.start();
  }
  finalize() {
    var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
    this.animationLoop.stop();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
    this.layerManager = null;
    (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
    this.viewManager = null;
    (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
    this.effectManager = null;
    (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
    this.deckRenderer = null;
    (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
    this.deckPicker = null;
    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
    this.eventManager = null;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
    this.tooltip = null;
    if (!this.props.canvas && !this.props.gl && this.canvas) {
      var _this$canvas$parentEl;
      (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
      this.canvas = null;
    }
  }
  setProps(props) {
    this.stats.get('setProps Time').timeStart();
    if ('onLayerHover' in props) {
      _log.default.removed('onLayerHover', 'onHover')();
    }
    if ('onLayerClick' in props) {
      _log.default.removed('onLayerClick', 'onClick')();
    }
    if (props.initialViewState && !(0, _deepEqual.deepEqual)(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }
    Object.assign(this.props, props);
    this._setCanvasSize(this.props);
    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop.setProps(resolvedProps);
    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
    }
    this.stats.get('setProps Time').timeEnd();
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    if (!this.layerManager) {
      return false;
    }
    if (this.props._animate) {
      return 'Deck._animate';
    }
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }
  redraw(reason) {
    if (!this.layerManager) {
      return;
    }
    let redrawReason = this.needsRedraw({
      clearRedrawFlags: true
    });
    redrawReason = reason || redrawReason;
    if (!redrawReason) {
      return;
    }
    this.stats.get('Redraw Count').incrementCount();
    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }
  get isInitialized() {
    return this.viewManager !== null;
  }
  getViews() {
    (0, _assert.default)(this.viewManager);
    return this.viewManager.views;
  }
  getViewports(rect) {
    (0, _assert.default)(this.viewManager);
    return this.viewManager.getViewports(rect);
  }
  pickObject(opts) {
    const infos = this._pick('pickObject', 'pickObject Time', opts).result;
    return infos.length ? infos[0] : null;
  }
  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;
  }
  pickObjects(opts) {
    return this._pick('pickObjects', 'pickObjects Time', opts);
  }
  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({
        resourceId: id,
        data: resources[id],
        forceUpdate
      });
    }
  }
  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }
  _addDefaultEffect(effect) {
    this.effectManager.addDefaultEffect(effect);
  }
  _pick(method, statKey, opts) {
    (0, _assert.default)(this.deckPicker);
    const {
      stats
    } = this;
    stats.get('Pick Count').incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }
  _createCanvas(props) {
    let canvas = props.canvas;
    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
      (0, _assert.default)(canvas);
    }
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = props.id || 'deckgl-overlay';
      const parent = props.parent || document.body;
      parent.appendChild(canvas);
    }
    Object.assign(canvas.style, props.style);
    return canvas;
  }
  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }
    const {
      width,
      height
    } = props;
    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
      this.canvas.style.width = cssWidth;
    }
    if (height || height === 0) {
      var _props$style;
      const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
      this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || 'absolute';
      this.canvas.style.height = cssHeight;
    }
  }
  _updateCanvasSize() {
    const {
      canvas
    } = this;
    if (!canvas) {
      return;
    }
    const newWidth = canvas.clientWidth || canvas.width;
    const newHeight = canvas.clientHeight || canvas.height;
    if (newWidth !== this.width || newHeight !== this.height) {
      var _this$viewManager2;
      this.width = newWidth;
      this.height = newHeight;
      (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
        width: newWidth,
        height: newHeight
      });
      this.props.onResize({
        width: newWidth,
        height: newHeight
      });
    }
  }
  _createAnimationLoop(props) {
    const {
      width,
      height,
      gl,
      glOptions,
      debug,
      onError,
      onBeforeRender,
      onAfterRender,
      useDevicePixels
    } = props;
    return new _core.AnimationLoop({
      width,
      height,
      useDevicePixels,
      autoResizeViewport: false,
      gl,
      onCreateContext: opts => (0, _core.createGLContext)({
        ...glOptions,
        ...opts,
        canvas: this.canvas,
        debug,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: context => this._setGLContext(context.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender,
      onAfterRender,
      onError
    });
  }
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  _getViews() {
    let views = this.props.views || [new _mapView.default({
      id: 'default-view'
    })];
    views = Array.isArray(views) ? views : [views];
    if (views.length && this.props.controller) {
      views[0].props.controller = this.props.controller;
    }
    return views;
  }
  _onContextLost() {
    const {
      onError
    } = this.props;
    if (this.animationLoop && onError) {
      onError(new Error('WebGL context is lost'));
    }
  }
  _pickAndCallback() {
    const {
      _pickRequest
    } = this;
    if (_pickRequest.event) {
      const {
        result,
        emptyInfo
      } = this._pick('pickObject', 'pickObject Time', _pickRequest);
      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;
      for (const info of result) {
        var _info$layer;
        pickedInfo = info;
        handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
      }
      if (!handled && this.props.onHover) {
        this.props.onHover(pickedInfo, _pickRequest.event);
      }
      if (this.props.getTooltip && this.tooltip) {
        const displayInfo = this.props.getTooltip(pickedInfo);
        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
      }
      _pickRequest.event = null;
    }
  }
  _updateCursor() {
    const container = this.props.parent || this.canvas;
    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }
  _setGLContext(gl) {
    if (this.layerManager) {
      return;
    }
    if (!this.canvas) {
      this.canvas = gl.canvas;
      (0, _core.instrumentGLContext)(gl, {
        enable: true,
        copyState: true
      });
    }
    this.tooltip = new _tooltip.default(this.canvas);
    (0, _core.setParameters)(gl, {
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthTest: true,
      depthFunc: 515
    });
    this.props.onWebGLInitialized(gl);
    const timeline = new _core.Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new _mjolnir.EventManager(this.props.parent || gl.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const eventType in _constants.EVENTS) {
      this.eventManager.on(eventType, this._onEvent);
    }
    this.viewManager = new _viewManager.default({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new _layerManager.default(gl, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new _effectManager.default();
    this.deckRenderer = new _deckRenderer.default(gl);
    this.deckPicker = new _deckPicker.default(gl);
    this.setProps(this.props);
    this._updateCanvasSize();
    this.props.onLoad();
  }
  _drawLayers(redrawReason, renderOptions) {
    const {
      gl
    } = this.layerManager.context;
    (0, _core.setParameters)(gl, this.props.parameters);
    this.props.onBeforeRender({
      gl
    });
    this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: 'screen',
      effects: this.effectManager.getEffects(),
      ...renderOptions
    });
    this.props.onAfterRender({
      gl
    });
  }
  _onRenderFrame(animationProps) {
    this._getFrameStats();
    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();
      this.stats.reset();
      _log.default.table(4, this.metrics)();
      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }
    this._updateCanvasSize();
    this._updateCursor();
    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
      this.tooltip.setTooltip(null);
    }
    this.layerManager.updateLayers();
    this._pickAndCallback();
    this.redraw();
    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }
  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;
    if (this.viewState) {
      this.viewState = {
        ...this.viewState,
        [params.viewId]: viewState
      };
      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({
            viewState: this.viewState
          });
        }
      }
    }
  }
  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }
  _getFrameStats() {
    const {
      stats
    } = this;
    stats.get('frameRate').timeEnd();
    stats.get('frameRate').timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);
    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);
  }
  _getMetrics() {
    const {
      metrics,
      stats
    } = this;
    metrics.fps = stats.get('frameRate').getHz();
    metrics.setPropsTime = stats.get('setProps Time').time;
    metrics.updateAttributesTime = stats.get('Update Attributes').time;
    metrics.framesRedrawn = stats.get('Redraw Count').count;
    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;
    metrics.pickCount = stats.get('Pick Count').count;
    metrics.gpuTime = stats.get('GPU Time').time;
    metrics.cpuTime = stats.get('CPU Time').time;
    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();
    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();
    const memoryStats = _core.lumaStats.get('Memory Usage');
    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;
    metrics.textureMemory = memoryStats.get('Texture Memory').count;
    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;
    metrics.gpuMemory = memoryStats.get('GPU Memory').count;
  }
}
exports.default = Deck;
(0, _defineProperty2.default)(Deck, "defaultProps", defaultProps);
(0, _defineProperty2.default)(Deck, "VERSION", _init.VERSION);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./view-manager":"node_modules/@deck.gl/core/dist/esm/lib/view-manager.js","../views/map-view":"node_modules/@deck.gl/core/dist/esm/views/map-view.js","./effect-manager":"node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js","./deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./deck-picker":"node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js","./tooltip":"node_modules/@deck.gl/core/dist/esm/lib/tooltip.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","./init":"node_modules/@deck.gl/core/dist/esm/lib/init.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","mjolnir.js":"node_modules/mjolnir.js/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ShaderAttribute {
  constructor(dataColumn, opts) {
    (0, _defineProperty2.default)(this, "opts", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    this.opts = opts;
    this.source = dataColumn;
  }
  get value() {
    return this.source.value;
  }
  getValue() {
    const buffer = this.source.getBuffer();
    const accessor = this.getAccessor();
    if (buffer) {
      return [buffer, accessor];
    }
    const {
      value
    } = this.source;
    const {
      size
    } = accessor;
    let constantValue = value;
    if (value && value.length !== size) {
      constantValue = new Float32Array(size);
      const index = accessor.elementOffset || 0;
      for (let i = 0; i < size; ++i) {
        constantValue[i] = value[index + i];
      }
    }
    return constantValue;
  }
  getAccessor() {
    return {
      ...this.source.getAccessor(),
      ...this.opts
    };
  }
}
exports.default = ShaderAttribute;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;
function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error('Unknown GL type');
  }
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _shaderAttribute = _interopRequireDefault(require("./shader-attribute"));
var _glUtils = require("./gl-utils");
var _typedArrayManager = _interopRequireDefault(require("../../utils/typed-array-manager"));
var _mathUtils = require("../../utils/math-utils");
var _log = _interopRequireDefault(require("../../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    _log.default.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return {
    ...shaderAttributeOptions,
    offset,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
class DataColumn {
  constructor(gl, opts, state) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "size", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    (0, _defineProperty2.default)(this, "value", void 0);
    (0, _defineProperty2.default)(this, "doublePrecision", void 0);
    (0, _defineProperty2.default)(this, "_buffer", void 0);
    (0, _defineProperty2.default)(this, "state", void 0);
    this.gl = gl;
    this.id = opts.id || '';
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === 5130;
    let {
      defaultValue
    } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;
    if (doublePrecision) {
      bufferType = 5126;
    } else if (!logicalType && opts.isIndexed) {
      bufferType = gl && (0, _core.hasFeature)(gl, _core.FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    } else {
      bufferType = logicalType || 5126;
    }
    let defaultType = (0, _glUtils.glArrayFromType)(logicalType || bufferType || 5126);
    this.doublePrecision = doublePrecision;
    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }
    this.value = null;
    this.settings = {
      ...opts,
      defaultType,
      defaultValue: defaultValue,
      logicalType,
      type: bufferType,
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = {
      ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
    this._buffer = null;
  }
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed,
        type
      } = this.settings;
      this._buffer = new _core.Buffer(this.gl, {
        id: this.id,
        target: isIndexed ? 34963 : 34962,
        accessor: {
          type
        }
      });
    }
    return this._buffer;
  }
  get byteOffset() {
    const accessor = this.getAccessor();
    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }
    return 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(n) {
    this.state.numInstances = n;
  }
  delete() {
    if (this._buffer) {
      this._buffer.delete();
      this._buffer = null;
    }
    _typedArrayManager.default.release(this.state.allocatedValue);
  }
  getShaderAttributes(id, options) {
    if (this.doublePrecision) {
      const shaderAttributes = {};
      const isBuffer64Bit = this.value instanceof Float64Array;
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
      shaderAttributes[id] = new _shaderAttribute.default(this, doubleShaderAttributeDefs.high);
      shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new _shaderAttribute.default(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
      return shaderAttributes;
    }
    if (options) {
      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
      return {
        [id]: new _shaderAttribute.default(this, shaderAttributeDef)
      };
    }
    return {
      [id]: this
    };
  }
  getBuffer() {
    if (this.state.constant) {
      return null;
    }
    return this.state.externalBuffer || this._buffer;
  }
  getValue() {
    if (this.state.constant) {
      return this.value;
    }
    return [this.getBuffer(), this.getAccessor()];
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }
    let result = null;
    if (this.state.constant && this.value) {
      const min = Array.from(this.value);
      result = [min, min];
    } else {
      const {
        value,
        numInstances,
        size
      } = this;
      const len = numInstances * size;
      if (value && len && value.length >= len) {
        const min = new Array(size).fill(Infinity);
        const max = new Array(size).fill(-Infinity);
        for (let i = 0; i < len;) {
          for (let j = 0; j < size; j++) {
            const v = value[i++];
            if (v < min[j]) min[j] = v;
            if (v > max[j]) max[j] = v;
          }
        }
        result = [min, max];
      }
    }
    this.state.bounds = result;
    return result;
  }
  setData(data) {
    const {
      state
    } = this;
    let opts;
    if (ArrayBuffer.isView(data)) {
      opts = {
        value: data
      };
    } else if (data instanceof _core.Buffer) {
      opts = {
        buffer: data
      };
    } else {
      opts = data;
    }
    const accessor = {
      ...this.settings,
      ...opts
    };
    state.bufferAccessor = accessor;
    state.bounds = null;
    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);
      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }
      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
      if (!hasChanged) {
        return false;
      }
      state.externalBuffer = null;
      state.constant = true;
      this.value = value;
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value || null;
      const isBuffer64Bit = opts.value instanceof Float64Array;
      accessor.type = opts.type || buffer.accessor.type;
      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
      accessor.stride = getStride(accessor);
    } else if (opts.value) {
      this._checkExternalBuffer(opts);
      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
      const {
        buffer,
        byteOffset
      } = this;
      if (this.doublePrecision && value instanceof Float64Array) {
        value = (0, _mathUtils.toDoublePrecisionArray)(value, accessor);
      }
      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
      if (buffer.byteLength < requiredBufferSize) {
        buffer.reallocate(requiredBufferSize);
      }
      buffer.setAccessor(null);
      buffer.subData({
        data: value,
        offset: byteOffset
      });
      accessor.type = opts.type || buffer.accessor.type;
    }
    return true;
  }
  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const {
      startOffset = 0,
      endOffset
    } = opts;
    this.buffer.subData({
      data: this.doublePrecision && value instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(value, {
        size: this.size,
        startIndex: startOffset,
        endIndex: endOffset
      }) : value.subarray(startOffset, endOffset),
      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
    });
  }
  allocate(numInstances, copy = false) {
    const {
      state
    } = this;
    const oldValue = state.allocatedValue;
    const value = _typedArrayManager.default.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy
    });
    this.value = value;
    const {
      buffer,
      byteOffset
    } = this;
    if (buffer.byteLength < value.byteLength + byteOffset) {
      buffer.reallocate(value.byteLength + byteOffset);
      if (copy && oldValue) {
        buffer.subData({
          data: oldValue instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(oldValue, this) : oldValue,
          offset: byteOffset
        });
      }
    }
    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    state.bufferAccessor = this.settings;
    return true;
  }
  _checkExternalBuffer(opts) {
    const {
      value
    } = opts;
    if (!ArrayBuffer.isView(value)) {
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    }
    const ArrayType = this.settings.defaultType;
    let illegalArrayType = false;
    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }
    if (illegalArrayType) {
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
    }
    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {
      _log.default.warn("Attribute ".concat(this.id, " is normalized"))();
    }
  }
  normalizeConstant(value) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);
      case 5122:
        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);
      case 5121:
        return new Float32Array(value).map(x => x / 255);
      case 5123:
        return new Float32Array(value).map(x => x / 65535);
      default:
        return value;
    }
  }
  _normalizeValue(value, out, start) {
    const {
      defaultValue,
      size
    } = this.settings;
    if (Number.isFinite(value)) {
      out[start] = value;
      return out;
    }
    if (!value) {
      let i = size;
      while (--i >= 0) {
        out[start + i] = defaultValue[i];
      }
      return out;
    }
    switch (size) {
      case 4:
        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
      case 3:
        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
      case 2:
        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
      case 1:
        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;
      default:
        let i = size;
        while (--i >= 0) {
          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }
    }
    return out;
  }
  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }
    const {
      size
    } = this;
    for (let i = 0; i < size; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }
    return true;
  }
}
exports.default = DataColumn;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./shader-attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js","./gl-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js","../../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","../../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIterable = createIterable;
exports.getAccessorFromBuffer = getAccessorFromBuffer;
exports.isAsyncIterable = isAsyncIterable;
const EMPTY_ARRAY = [];
const placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === 'function') {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return {
    iterable,
    objectInfo
  };
}
function isAsyncIterable(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const {
    size,
    stride,
    offset,
    startIndices,
    nested
  } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, {
    index,
    target
  }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;
      for (let j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }
      return target;
    }
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);
        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        for (let j = 0; j < size; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }
    return result;
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/range.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FULL = exports.EMPTY = void 0;
exports.add = add;
const EMPTY = [];
exports.EMPTY = EMPTY;
const FULL = [[0, Infinity]];
exports.FULL = FULL;
function add(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range[0] < 0) {
    range[0] = 0;
  }
  if (range[0] >= range[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len = rangeList.length;
  let insertPosition = 0;
  for (let i = 0; i < len; i++) {
    const range0 = rangeList[i];
    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padArray = padArray;
function padArrayChunk(options) {
  const {
    source,
    target,
    start = 0,
    size,
    getData
  } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start;
  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }
  target.set(source, start);
  if (!getData) {
    return;
  }
  let i = sourceLength;
  while (i < targetLength) {
    const datum = getData(i, source);
    for (let j = 0; j < size; j++) {
      target[start + i] = datum[j] || 0;
      i++;
    }
  }
}
function padArray({
  source,
  target,
  size,
  getData,
  sourceStartIndices,
  targetStartIndices
}) {
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      size,
      getData
    });
    return target;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));
  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size;
    const nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }
  return target;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cycleBuffers = cycleBuffers;
exports.getAttributeBufferLength = getAttributeBufferLength;
exports.getAttributeTypeFromSize = getAttributeTypeFromSize;
exports.getSourceBufferAttribute = getSourceBufferAttribute;
exports.normalizeTransitionSettings = normalizeTransitionSettings;
exports.padBuffer = padBuffer;
var _arrayUtils = require("../../utils/array-utils");
const DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: t => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = {
      type: 'interpolation',
      duration: userSettings
    };
  }
  const type = userSettings.type || 'interpolation';
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}
function getSourceBufferAttribute(gl, attribute) {
  const buffer = attribute.getBuffer();
  if (buffer) {
    return [buffer, {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }
  return attribute.value;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return 'float';
    case 2:
      return 'vec2';
    case 3:
      return 'vec3';
    case 4:
      return 'vec4';
    default:
      throw new Error("No defined attribute type for size \"".concat(size, "\""));
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const {
    doublePrecision,
    settings,
    value,
    size
  } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}
function padBuffer({
  buffer,
  numInstances,
  attribute,
  fromLength,
  fromStartIndices,
  getData = x => x
}) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const toLength = getAttributeBufferLength(attribute, numInstances);
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }
  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);
  const source = buffer.getData({
    length: fromLength
  });
  const data = new Float32Array(toLength);
  (0, _arrayUtils.padArray)({
    source,
    target: data,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (buffer.byteLength < data.byteLength + byteOffset) {
    buffer.reallocate(data.byteLength + byteOffset);
  }
  buffer.subData({
    data,
    offset: byteOffset
  });
}
},{"../../utils/array-utils":"node_modules/@deck.gl/core/dist/esm/utils/array-utils.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _dataColumn = _interopRequireDefault(require("./data-column"));
var _assert = _interopRequireDefault(require("../../utils/assert"));
var _iterableUtils = require("../../utils/iterable-utils");
var _flatten = require("../../utils/flatten");
var range = _interopRequireWildcard(require("../../utils/range"));
var _attributeTransitionUtils = require("./attribute-transition-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Attribute extends _dataColumn.default {
  constructor(gl, opts) {
    super(gl, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      updateRanges: range.FULL
    });
    (0, _defineProperty2.default)(this, "constant", false);
    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);
    Object.seal(this.settings);
    Object.seal(this.state);
    this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(layout) {
    this.state.startIndices = layout;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({
    clearChangedFlags = false
  } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }
  getUpdateTriggers() {
    const {
      accessor
    } = this.settings;
    return [this.id].concat(typeof accessor !== 'function' && accessor || []);
  }
  supportsTransition() {
    return Boolean(this.settings.transition);
  }
  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }
    const {
      accessor
    } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];
    return (0, _attributeTransitionUtils.normalizeTransitionSettings)(userSettings, layerSettings);
  }
  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);
    if (dataRange) {
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange;
      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = range.FULL;
    }
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = range.EMPTY;
  }
  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }
  allocate(numInstances) {
    const {
      state,
      settings
    } = this;
    if (settings.noAlloc) {
      return false;
    }
    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== range.FULL);
      return true;
    }
    return false;
  }
  updateBuffer({
    numInstances,
    data,
    props,
    context
  }) {
    if (!this.needsUpdate()) {
      return false;
    }
    const {
      state: {
        updateRanges
      },
      settings: {
        update,
        noAlloc
      }
    } = this;
    let updated = true;
    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, {
          data,
          startRow,
          endRow,
          props,
          numInstances
        });
      }
      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({
            startOffset,
            endOffset
          });
        }
      }
      this._checkAttributeArray();
    } else {
      updated = false;
    }
    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }
  setConstantValue(value) {
    if (value === undefined || typeof value === 'function') {
      return false;
    }
    const hasChanged = this.setData({
      constant: true,
      value
    });
    if (hasChanged) {
      this.setNeedsRedraw();
    }
    this.clearNeedsUpdate();
    return true;
  }
  setExternalBuffer(buffer) {
    const {
      state
    } = this;
    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }
    this.clearNeedsUpdate();
    if (state.lastExternalBuffer === buffer) {
      return true;
    }
    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }
  setBinaryValue(buffer, startIndices = null) {
    const {
      state,
      settings
    } = this;
    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }
    if (settings.noAlloc) {
      return false;
    }
    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }
    state.binaryValue = buffer;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;
    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer)) {
        buffer = {
          value: buffer
        };
      }
      const binaryValue = buffer;
      (0, _assert.default)(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = (0, _iterableUtils.getAccessorFromBuffer)(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices: startIndices,
        nested: needsNormalize
      });
      return false;
    }
    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }
  getVertexOffset(row) {
    const {
      startIndices
    } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }
  getShaderAttributes() {
    const shaderAttributeDefs = this.settings.shaderAttributes || {
      [this.id]: null
    };
    const shaderAttributes = {};
    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }
    return shaderAttributes;
  }
  _autoUpdater(attribute, {
    data,
    startRow,
    endRow,
    props,
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }
    const {
      settings,
      state,
      value,
      size,
      startIndices
    } = attribute;
    const {
      accessor,
      transform
    } = settings;
    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);
    (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
    let i = attribute.getVertexOffset(startRow);
    const {
      iterable,
      objectInfo
    } = (0, _iterableUtils.createIterable)(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);
      if (transform) {
        objectValue = transform.call(this, objectValue);
      }
      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i;
          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);
            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);
          (0, _flatten.fillArray)({
            target: value,
            source: objectInfo.target,
            start: i,
            count: numVertices
          });
        }
        i += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i);
        i += size;
      }
    }
  }
  _validateAttributeUpdaters() {
    const {
      settings
    } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';
    if (!hasUpdater) {
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
  }
  _checkAttributeArray() {
    const {
      value
    } = this;
    const limit = Math.min(4, this.size);
    if (value && value.length >= limit) {
      let valid = true;
      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);
        case 3:
          valid = valid && Number.isFinite(value[2]);
        case 2:
          valid = valid && Number.isFinite(value[1]);
        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;
        default:
          valid = false;
      }
      if (!valid) {
        throw new Error("Illegal attribute generated for ".concat(this.id));
      }
    }
  }
}
exports.default = Attribute;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./data-column":"node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js","../../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","../../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","../../utils/range":"node_modules/@deck.gl/core/dist/esm/utils/range.js","./attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _attribute = _interopRequireDefault(require("../lib/attribute/attribute"));
var _attributeTransitionUtils = require("../lib/attribute/attribute-transition-utils");
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GPUInterpolationTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "type", 'interpolation');
    (0, _defineProperty2.default)(this, "attributeInTransition", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    (0, _defineProperty2.default)(this, "attribute", void 0);
    (0, _defineProperty2.default)(this, "transition", void 0);
    (0, _defineProperty2.default)(this, "currentStartIndices", void 0);
    (0, _defineProperty2.default)(this, "currentLength", void 0);
    (0, _defineProperty2.default)(this, "transform", void 0);
    (0, _defineProperty2.default)(this, "buffers", void 0);
    this.gl = gl;
    this.transition = new _transition.default(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _attribute.default(gl, attribute.settings);
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.transform = getTransform(gl, attribute);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances) {
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }
    this.settings = transitionSettings;
    const {
      gl,
      buffers,
      attribute
    } = this;
    (0, _attributeTransitionUtils.cycleBuffers)(buffers);
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };
    for (const buffer of buffers) {
      (0, _attributeTransitionUtils.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0, _attributeTransitionUtils.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start(transitionSettings);
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aFrom: buffers[0],
        aTo: (0, _attributeTransitionUtils.getSourceBufferAttribute)(gl, attribute)
      },
      feedbackBuffers: {
        vCurrent: buffers[1]
      }
    });
  }
  update() {
    const updated = this.transition.update();
    if (updated) {
      const {
        duration,
        easing
      } = this.settings;
      const {
        time
      } = this.transition;
      let t = time / duration;
      if (easing) {
        t = easing(t);
      }
      this.transform.run({
        uniforms: {
          time: t
        }
      });
    }
    return updated;
  }
  cancel() {
    this.transition.cancel();
    this.transform.delete();
    for (const buffer of this.buffers) {
      buffer.delete();
    }
    this.buffers.length = 0;
  }
}
exports.default = GPUInterpolationTransition;
const vs = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
function getTransform(gl, attribute) {
  const attributeType = (0, _attributeTransitionUtils.getAttributeTypeFromSize)(attribute.size);
  return new _core.Transform(gl, {
    vs,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vCurrent']
  });
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/attribute/attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","../lib/attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _attributeTransitionUtils = require("../lib/attribute/attribute-transition-utils");
var _attribute = _interopRequireDefault(require("../lib/attribute/attribute"));
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GPUSpringTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "type", 'spring');
    (0, _defineProperty2.default)(this, "attributeInTransition", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    (0, _defineProperty2.default)(this, "attribute", void 0);
    (0, _defineProperty2.default)(this, "transition", void 0);
    (0, _defineProperty2.default)(this, "currentStartIndices", void 0);
    (0, _defineProperty2.default)(this, "currentLength", void 0);
    (0, _defineProperty2.default)(this, "texture", void 0);
    (0, _defineProperty2.default)(this, "framebuffer", void 0);
    (0, _defineProperty2.default)(this, "transform", void 0);
    (0, _defineProperty2.default)(this, "buffers", void 0);
    this.gl = gl;
    this.type = 'spring';
    this.transition = new _transition.default(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _attribute.default(gl, {
      ...attribute.settings,
      normalized: false
    });
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.texture = getTexture(gl);
    this.framebuffer = getFramebuffer(gl, this.texture);
    this.transform = getTransform(gl, attribute, this.framebuffer);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances) {
    const {
      gl,
      buffers,
      attribute
    } = this;
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };
    for (const buffer of buffers) {
      (0, _attributeTransitionUtils.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }
    this.settings = transitionSettings;
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0, _attributeTransitionUtils.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start({
      ...transitionSettings,
      duration: Infinity
    });
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aTo: (0, _attributeTransitionUtils.getSourceBufferAttribute)(gl, attribute)
      }
    });
  }
  update() {
    const {
      buffers,
      transform,
      framebuffer,
      transition
    } = this;
    const updated = transition.update();
    if (!updated) {
      return false;
    }
    const settings = this.settings;
    transform.update({
      sourceBuffers: {
        aPrev: buffers[0],
        aCur: buffers[1]
      },
      feedbackBuffers: {
        vNext: buffers[2]
      }
    });
    transform.run({
      framebuffer,
      discard: false,
      clearRenderTarget: true,
      uniforms: {
        stiffness: settings.stiffness,
        damping: settings.damping
      },
      parameters: {
        depthTest: false,
        blend: true,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    });
    (0, _attributeTransitionUtils.cycleBuffers)(buffers);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: this.attribute.value
    });
    const isTransitioning = (0, _core.readPixelsToArray)(framebuffer)[0] > 0;
    if (!isTransitioning) {
      transition.end();
    }
    return true;
  }
  cancel() {
    this.transition.cancel();
    this.transform.delete();
    for (const buffer of this.buffers) {
      buffer.delete();
    }
    this.buffers.length = 0;
    this.texture.delete();
    this.framebuffer.delete();
  }
}
exports.default = GPUSpringTransition;
function getTransform(gl, attribute, framebuffer) {
  const attributeType = (0, _attributeTransitionUtils.getAttributeTypeFromSize)(attribute.size);
  return new _core.Transform(gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vNext']
  });
}
function getTexture(gl) {
  return new _core.Texture2D(gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function getFramebuffer(gl, texture) {
  return new _core.Framebuffer(gl, {
    id: 'spring-transition-is-transitioning-framebuffer',
    width: 1,
    height: 1,
    attachments: {
      [36064]: texture
    }
  });
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","../lib/attribute/attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _gpuInterpolationTransition = _interopRequireDefault(require("../../transitions/gpu-interpolation-transition"));
var _gpuSpringTransition = _interopRequireDefault(require("../../transitions/gpu-spring-transition"));
var _log = _interopRequireDefault(require("../../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRANSITION_TYPES = {
  interpolation: _gpuInterpolationTransition.default,
  spring: _gpuSpringTransition.default
};
class AttributeTransitionManager {
  constructor(gl, {
    id,
    timeline
  }) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "isSupported", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "timeline", void 0);
    (0, _defineProperty2.default)(this, "transitions", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "numInstances", void 0);
    this.id = id;
    this.gl = gl;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
    this.isSupported = _core.Transform.isSupported(gl);
  }
  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }
  update({
    attributes,
    transitions,
    numInstances
  }) {
    this.numInstances = numInstances || 1;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings) continue;
      this._updateAttribute(attributeName, attribute, settings);
    }
    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];
      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }
  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }
  getAttributes() {
    const animatedAttributes = {};
    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];
      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }
    return animatedAttributes;
  }
  run() {
    if (!this.isSupported || this.numInstances === 0) {
      return false;
    }
    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();
      if (updated) {
        this.needsRedraw = true;
      }
    }
    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }
  _removeTransition(attributeName) {
    this.transitions[attributeName].cancel();
    delete this.transitions[attributeName];
  }
  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;
    if (isNew) {
      if (!this.isSupported) {
        _log.default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
        return;
      }
      if (transition) {
        this._removeTransition(attributeName);
      }
      const TransitionType = TRANSITION_TYPES[settings.type];
      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          gl: this.gl
        });
      } else {
        _log.default.error("unsupported transition type '".concat(settings.type, "'"))();
        isNew = false;
      }
    }
    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }
}
exports.default = AttributeTransitionManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../../transitions/gpu-interpolation-transition":"node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js","../../transitions/gpu-spring-transition":"node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _attribute = _interopRequireDefault(require("./attribute"));
var _log = _interopRequireDefault(require("../../utils/log"));
var _memoize = _interopRequireDefault(require("../../utils/memoize"));
var _mathUtils = require("../../utils/math-utils");
var _debug = _interopRequireDefault(require("../../debug"));
var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_INVALIDATE = 'attributeManager.invalidate';
const TRACE_UPDATE_START = 'attributeManager.updateStart';
const TRACE_UPDATE_END = 'attributeManager.updateEnd';
const TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';
const TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';
const TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';
class AttributeManager {
  constructor(gl, {
    id = 'attribute-manager',
    stats,
    timeline
  } = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "attributes", void 0);
    (0, _defineProperty2.default)(this, "updateTriggers", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "userData", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "attributeTransitionManager", void 0);
    (0, _defineProperty2.default)(this, "mergeBoundsMemoized", (0, _memoize.default)(_mathUtils.mergeBounds));
    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions"),
      timeline
    });
    Object.seal(this);
  }
  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }
  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }
  setNeedsRedraw() {
    this.needsRedraw = true;
  }
  add(attributes) {
    this._add(attributes);
  }
  addInstanced(attributes) {
    this._add(attributes, {
      instanced: 1
    });
  }
  remove(attributeNameArray) {
    for (const name of attributeNameArray) {
      if (this.attributes[name] !== undefined) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }
  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
    (0, _debug.default)(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }
  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }
    (0, _debug.default)(TRACE_INVALIDATE, this, 'all');
  }
  update({
    data,
    numInstances,
    startIndices = null,
    transitions,
    props = {},
    buffers = {},
    context = {}
  }) {
    let updated = false;
    (0, _debug.default)(TRACE_UPDATE_START, this);
    if (this.stats) {
      this.stats.get('Update Attributes').timeStart();
    }
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;
      if (props[attributeName]) {
        _log.default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
      }
      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {
        updated = true;
        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }
      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }
    if (updated) {
      (0, _debug.default)(TRACE_UPDATE_END, this, numInstances);
    }
    if (this.stats) {
      this.stats.get('Update Attributes').timeEnd();
    }
    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }
  updateTransition() {
    const {
      attributeTransitionManager
    } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }
  getAttributes() {
    return this.attributes;
  }
  getBounds(attributeNames) {
    const bounds = attributeNames.map(attributeName => {
      var _this$attributes$attr;
      return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
    });
    return this.mergeBoundsMemoized(bounds);
  }
  getChangedAttributes(opts = {
    clearChangedFlags: false
  }) {
    const {
      attributes,
      attributeTransitionManager
    } = this;
    const changedAttributes = {
      ...attributeTransitionManager.getAttributes()
    };
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }
    return changedAttributes;
  }
  getShaderAttributes(attributes, excludeAttributes = {}) {
    if (!attributes) {
      attributes = this.getAttributes();
    }
    const shaderAttributes = {};
    for (const attributeName in attributes) {
      if (!excludeAttributes[attributeName]) {
        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
      }
    }
    return shaderAttributes;
  }
  _add(attributes, extraProps = {}) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
    }
    this._mapUpdateTriggersToAttributes();
  }
  _createAttribute(name, attribute, extraProps) {
    const props = {
      ...attribute,
      id: name,
      size: attribute.isIndexed && 1 || attribute.size || 1,
      divisor: extraProps.instanced ? 1 : attribute.divisor || 0
    };
    return new _attribute.default(this.gl, props);
  }
  _mapUpdateTriggersToAttributes() {
    const triggers = {};
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach(triggerName => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }
    this.updateTriggers = triggers;
  }
  _invalidateTrigger(triggerName, dataRange) {
    const {
      attributes,
      updateTriggers
    } = this;
    const invalidatedAttributes = updateTriggers[triggerName];
    if (invalidatedAttributes) {
      invalidatedAttributes.forEach(name => {
        const attribute = attributes[name];
        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }
    return invalidatedAttributes;
  }
  _updateAttribute(opts) {
    const {
      attribute,
      numInstances
    } = opts;
    (0, _debug.default)(TRACE_ATTRIBUTE_UPDATE_START, attribute);
    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }
    if (attribute.allocate(numInstances)) {
      (0, _debug.default)(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }
    const updated = attribute.updateBuffer(opts);
    if (updated) {
      this.needsRedraw = true;
      (0, _debug.default)(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }
}
exports.default = AttributeManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","../../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","./attribute-transition-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@math.gl/core");
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class CPUInterpolationTransition extends _transition.default {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time,
      settings: {
        fromValue,
        toValue,
        duration,
        easing
      }
    } = this;
    const t = easing(time / duration);
    this._value = (0, _core.lerp)(fromValue, toValue, t);
  }
}
exports.default = CPUInterpolationTransition;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EPSILON = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
class CPUSpringTransition extends _transition.default {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue,
      toValue,
      damping,
      stiffness
    } = this.settings;
    const {
      _prevValue = fromValue,
      _currValue = fromValue
    } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance(nextValue, toValue);
    const velocity = distance(nextValue, _currValue);
    if (delta < EPSILON && velocity < EPSILON) {
      nextValue = toValue;
      this.end();
    }
    this._prevValue = _currValue;
    this._currValue = nextValue;
  }
}
exports.default = CPUSpringTransition;
},{"./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _attributeTransitionUtils = require("./attribute/attribute-transition-utils");
var _cpuInterpolationTransition = _interopRequireDefault(require("../transitions/cpu-interpolation-transition"));
var _cpuSpringTransition = _interopRequireDefault(require("../transitions/cpu-spring-transition"));
var _log = _interopRequireDefault(require("../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRANSITION_TYPES = {
  interpolation: _cpuInterpolationTransition.default,
  spring: _cpuSpringTransition.default
};
class UniformTransitionManager {
  constructor(timeline) {
    this.transitions = new Map();
    this.timeline = timeline;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(key, fromValue, toValue, settings) {
    const {
      transitions
    } = this;
    if (transitions.has(key)) {
      const transition = transitions.get(key);
      const {
        value = transition.settings.fromValue
      } = transition;
      fromValue = value;
      this.remove(key);
    }
    settings = (0, _attributeTransitionUtils.normalizeTransitionSettings)(settings);
    if (!settings) {
      return;
    }
    const TransitionType = TRANSITION_TYPES[settings.type];
    if (!TransitionType) {
      _log.default.error("unsupported transition type '".concat(settings.type, "'"))();
      return;
    }
    const transition = new TransitionType(this.timeline);
    transition.start({
      ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }
  remove(key) {
    const {
      transitions
    } = this;
    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }
  update() {
    const propsInTransition = {};
    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;
      if (!transition.inProgress) {
        this.remove(key);
      }
    }
    return propsInTransition;
  }
  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }
}
exports.default = UniformTransitionManager;
},{"./attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","../transitions/cpu-interpolation-transition":"node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js","../transitions/cpu-spring-transition":"node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareProps = compareProps;
exports.diffProps = diffProps;
exports.validateProps = validateProps;
var _constants = require("./constants");
function validateProps(props) {
  const propTypes = props[_constants.PROP_TYPES_SYMBOL];
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      validate
    } = propType;
    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[_constants.PROP_TYPES_SYMBOL],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes = props[_constants.PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === 'number' || type === 'color' || type === 'array';
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({
  newProps,
  oldProps,
  ignoreProps = {},
  propTypes = {},
  triggerName = 'props'
}) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== 'object' || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  if (typeof oldProps !== 'object' || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return 'changed deeply';
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return 'changed deeply';
    }
  }
  if (!equal && oldProp !== newProp) {
    return 'changed shallowly';
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }
  let dataChanged = false;
  const {
    dataComparator,
    _dataDiff
  } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = 'Data comparator detected a change';
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = 'A new data container was supplied';
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return {
      all: true
    };
  }
  if ('all' in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, 'all');
    if (diffReason) {
      return {
        all: true
      };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const {
    extensions
  } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}
},{"./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/utils/count.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.count = count;
const ERR_NOT_OBJECT = 'count(): argument not an object';
const ERR_NOT_CONTAINER = 'count(): argument not a container';
function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === 'function') {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === 'object' && value.constructor === Object;
}
function isObject(value) {
  return value !== null && typeof value === 'object';
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeShaders = mergeShaders;
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }
  const result = {
    ...target,
    ...source
  };
  if ('defines' in source) {
    result.defines = {
      ...target.defines,
      ...source.defines
    };
  }
  if ('modules' in source) {
    result.modules = (target.modules || []).concat(source.modules);
    if (source.modules.some(module => module.name === 'project64')) {
      const index = result.modules.findIndex(module => module.name === 'project32');
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ('inject' in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = {
        ...target.inject
      };
      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || '') + source.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/texture.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTexture = createTexture;
exports.destroyTexture = destroyTexture;
var _core = require("@luma.gl/core");
const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
const internalTextures = {};
function createTexture(gl, image, parameters) {
  if (image instanceof _core.Texture2D) {
    return image;
  } else if (image.constructor && image.constructor.name !== 'Object') {
    image = {
      data: image
    };
  }
  let specialTextureParameters = null;
  if (image.compressed) {
    specialTextureParameters = {
      [10241]: image.data.length > 1 ? 9985 : 9729
    };
  }
  const texture = new _core.Texture2D(gl, {
    ...image,
    parameters: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...specialTextureParameters,
      ...parameters
    }
  });
  internalTextures[texture.id] = true;
  return texture;
}
function destroyTexture(texture) {
  if (!texture || !(texture instanceof _core.Texture2D)) {
    return;
  }
  if (internalTextures[texture.id]) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;
var _texture = require("../utils/texture");
var _deepEqual = require("../utils/deep-equal");
const TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },
    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
    },
    equal(value1, value2, propType) {
      return (0, _deepEqual.deepEqual)(value1, value2, 1);
    }
  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf(value);
      return valueType === 'function' || valueType === getTypeOf(propType.value);
    },
    equal(value1, value2, propType) {
      if (typeof value2 === 'function') {
        return true;
      }
      return (0, _deepEqual.deepEqual)(value1, value2, 1);
    }
  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },
    equal(value1, value2, propType) {
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? (0, _deepEqual.deepEqual)(value1, value2, depth) : value1 === value2;
    }
  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? (0, _deepEqual.deepEqual)(value1, value2, depth) : value1 === value2;
    }
  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === 'function';
    },
    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }
  },
  data: {
    transform: (value, propType, component) => {
      const {
        dataTransform
      } = component.props;
      return dataTransform && value ? dataTransform(value) : value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;
      if (!context || !context.gl) {
        return null;
      }
      return (0, _texture.createTexture)(context.gl, value, {
        ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: value => {
      (0, _texture.destroyTexture)(value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  const defaultProps = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps[propName] = propType.value;
    }
  }
  return {
    propTypes,
    defaultProps,
    deprecatedProps
  };
}
function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      return normalizePropDefinition(name, propDef);
    case 'array':
      return normalizePropDefinition(name, {
        type: 'array',
        value: propDef,
        compare: false
      });
    case 'boolean':
      return normalizePropDefinition(name, {
        type: 'boolean',
        value: propDef
      });
    case 'number':
      return normalizePropDefinition(name, {
        type: 'number',
        value: propDef
      });
    case 'function':
      return normalizePropDefinition(name, {
        type: 'function',
        value: propDef,
        compare: true
      });
    default:
      return {
        name,
        type: 'unknown',
        value: propDef
      };
  }
}
function normalizePropDefinition(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name,
        type: 'object',
        value: propDef
      };
    }
    return {
      name,
      type: getTypeOf(propDef.value),
      ...propDef
    };
  }
  return {
    name,
    ...TYPE_DEFINITIONS[propDef.type],
    ...propDef
  };
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf(value) {
  if (isArray(value)) {
    return 'array';
  }
  if (value === null) {
    return 'null';
  }
  return typeof value;
}
},{"../utils/texture":"node_modules/@deck.gl/core/dist/esm/utils/texture.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProps = createProps;
var _log = _interopRequireDefault(require("../utils/log"));
var _iterableUtils = require("../utils/iterable-utils");
var _propTypes = require("./prop-types");
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createProps(component, propObjects) {
  let extensions;
  for (let i = propObjects.length - 1; i >= 0; i--) {
    const props = propObjects[i];
    if ('extensions' in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[_constants.COMPONENT_SYMBOL] = component;
  propsInstance[_constants.ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[_constants.ASYNC_RESOLVED_SYMBOL] = {};
  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
const MergedDefaultPropsCacheKey = '_mergedDefaultProps';
function getPropsPrototype(componentClass, extensions) {
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
      }
    }
  }
  const defaultProps = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
  const componentPropDefs = (0, _propTypes.parsePropTypes)(componentDefaultProps);
  const defaultProps = Object.assign(Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[_constants.PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[_constants.DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[_constants.PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[_constants.DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps, componentClass);
  addAsyncPropsToPropPrototype(defaultProps, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);
  defaultProps[_constants.PROP_TYPES_SYMBOL] = propTypes;
  defaultProps[_constants.DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty(componentClass, '_propTypes')) {
    componentClass._propTypes = propTypes;
  }
  return defaultProps;
}
function createPropsPrototype(defaultProps, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps, {
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = "".concat(this.id, ": ").concat(propName);
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        _log.default.deprecated(nameStr, deprecatedProps[propName].join('/'))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      name,
      value
    } = propType;
    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }
  defaultProps[_constants.ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps[_constants.ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps, descriptors);
}
function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,
    set(newValue) {
      if (typeof newValue === 'string' || newValue instanceof Promise || (0, _iterableUtils.isAsyncIterable)(newValue)) {
        this[_constants.ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[_constants.ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },
    get() {
      if (this[_constants.ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[_constants.ASYNC_RESOLVED_SYMBOL]) {
          const value = this[_constants.ASYNC_RESOLVED_SYMBOL][name];
          return value || this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
        }
        if (name in this[_constants.ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[_constants.COMPONENT_SYMBOL] && this[_constants.COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }
      return this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
    }
  };
}
function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  const componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');
  if (!componentName) {
    _log.default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
  }
  return componentName || componentClass.name;
}
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./prop-types":"node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/component.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _constants = require("./constants");
var _createProps = require("./create-props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let counter = 0;
class Component {
  constructor(...propObjects) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "count", void 0);
    this.props = (0, _createProps.createProps)(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }
  clone(newProps) {
    const {
      props
    } = this;
    const asyncProps = {};
    for (const key in props[_constants.ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[_constants.ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[_constants.ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[_constants.ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[_constants.ASYNC_ORIGINAL_SYMBOL][key];
      }
    }
    return new this.constructor({
      ...props,
      ...asyncProps,
      ...newProps
    });
  }
}
exports.default = Component;
(0, _defineProperty2.default)(Component, "componentName", 'Component');
(0, _defineProperty2.default)(Component, "defaultProps", {});
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","./create-props":"node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _iterableUtils = require("../utils/iterable-utils");
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EMPTY_PROPS = Object.freeze({});
class ComponentState {
  constructor(component) {
    (0, _defineProperty2.default)(this, "component", void 0);
    (0, _defineProperty2.default)(this, "onAsyncPropUpdated", void 0);
    (0, _defineProperty2.default)(this, "asyncProps", void 0);
    (0, _defineProperty2.default)(this, "oldProps", void 0);
    (0, _defineProperty2.default)(this, "oldAsyncProps", void 0);
    this.component = component;
    this.asyncProps = {};
    this.onAsyncPropUpdated = () => {};
    this.oldProps = null;
    this.oldAsyncProps = null;
  }
  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }
  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }
  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }
  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }
  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }
    return false;
  }
  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }
  setAsyncProps(props) {
    this.component = props[_constants.COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[_constants.ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[_constants.ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[_constants.ASYNC_DEFAULTS_SYMBOL] || {};
    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
      resolvedValues[propName] = this.getAsyncProp(propName);
    }
    for (const propName in originalValues) {
      const value = originalValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
    }
  }
  _fetch(propName, url) {
    return null;
  }
  _onResolve(propName, value) {}
  _onError(propName, error) {}
  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }
    if (typeof value === 'string') {
      value = this._fetch(propName, value);
    }
    if (value instanceof Promise) {
      this._watchPromise(propName, value);
      return;
    }
    if ((0, _iterableUtils.isAsyncIterable)(value)) {
      this._resolveAsyncIterable(propName, value);
      return;
    }
    this._setPropValue(propName, value);
  }
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }
  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];
    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }
    asyncProp.lastValue = value;
    return true;
  }
  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }
  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {
      this._freezeAsyncOldProps();
      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }
  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then(data => {
        if (!this.component) {
          return;
        }
        data = this._postProcessValue(asyncProp, data);
        this._setAsyncPropValue(propName, data, loadCount);
        this._onResolve(propName, data);
      }).catch(error => {
        this._onError(propName, error);
      });
    }
  }
  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== 'data') {
      this._setPropValue(propName, iterable);
      return;
    }
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      return;
    }
    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count = 0;
    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }
      const {
        dataTransform
      } = this.component.props;
      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }
      Object.defineProperty(data, '__diff', {
        enumerable: false,
        value: [{
          startRow: count,
          endRow: data.length
        }]
      });
      count = data.length;
      this._setAsyncPropValue(propName, data, loadCount);
    }
    this._onResolve(propName, data);
  }
  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;
    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }
      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }
    return value;
  }
  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      const propTypes = this.component && this.component.props[_constants.PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
exports.default = ComponentState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _componentState = _interopRequireDefault(require("../lifecycle/component-state"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LayerState extends _componentState.default {
  constructor({
    attributeManager,
    layer
  }) {
    super(layer);
    (0, _defineProperty2.default)(this, "attributeManager", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "needsUpdate", void 0);
    (0, _defineProperty2.default)(this, "subLayers", void 0);
    (0, _defineProperty2.default)(this, "usesPickingColorCache", void 0);
    (0, _defineProperty2.default)(this, "hasPickingBuffer", void 0);
    (0, _defineProperty2.default)(this, "changeFlags", void 0);
    (0, _defineProperty2.default)(this, "viewport", void 0);
    (0, _defineProperty2.default)(this, "uniformTransitions", void 0);
    (0, _defineProperty2.default)(this, "propsInTransition", void 0);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }
  get layer() {
    return this.component;
  }
  _fetch(propName, url) {
    const layer = this.layer;
    const fetch = layer === null || layer === void 0 ? void 0 : layer.props.fetch;
    if (fetch) {
      return fetch(url, {
        propName,
        layer
      });
    }
    return super._fetch(propName, url);
  }
  _onResolve(propName, value) {
    const layer = this.layer;
    if (layer) {
      const onDataLoad = layer.props.onDataLoad;
      if (propName === 'data' && onDataLoad) {
        onDataLoad(value, {
          propName,
          layer
        });
      }
    }
  }
  _onError(propName, error) {
    const layer = this.layer;
    if (layer) {
      layer.raiseError(error, "loading ".concat(propName, " of ").concat(this.layer));
    }
  }
}
exports.default = LayerState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../lifecycle/component-state":"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _constants = require("./constants");
var _attributeManager = _interopRequireDefault(require("./attribute/attribute-manager"));
var _uniformTransitionManager = _interopRequireDefault(require("./uniform-transition-manager"));
var _props = require("../lifecycle/props");
var _constants2 = require("../lifecycle/constants");
var _count = require("../utils/count");
var _log = _interopRequireDefault(require("../utils/log"));
var _debug = _interopRequireDefault(require("../debug"));
var _core = require("@luma.gl/core");
var _assert = _interopRequireDefault(require("../utils/assert"));
var _memoize = _interopRequireDefault(require("../utils/memoize"));
var _shader = require("../utils/shader");
var _projectFunctions = require("../shaderlib/project/project-functions");
var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));
var _component = _interopRequireDefault(require("../lifecycle/component"));
var _layerState = _interopRequireDefault(require("./layer-state"));
var _webMercator = require("@math.gl/web-mercator");
var _core2 = require("@loaders.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_CHANGE_FLAG = 'layer.changeFlag';
const TRACE_INITIALIZE = 'layer.initialize';
const TRACE_UPDATE = 'layer.update';
const TRACE_FINALIZE = 'layer.finalize';
const TRACE_MATCHED = 'layer.matched';
const MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const EMPTY_ARRAY = Object.freeze([]);
const areViewportsEqual = (0, _memoize.default)(({
  oldViewport,
  viewport
}) => {
  return oldViewport.equals(viewport);
});
let pickingColorCache = new Uint8ClampedArray(0);
const defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: {
    type: 'function',
    value: null,
    optional: true
  },
  _dataDiff: {
    type: 'function',
    value: data => data && data.__diff,
    optional: true
  },
  dataTransform: {
    type: 'function',
    value: null,
    optional: true
  },
  onDataLoad: {
    type: 'function',
    value: null,
    optional: true
  },
  onError: {
    type: 'function',
    value: null,
    optional: true
  },
  fetch: {
    type: 'function',
    value: (url, {
      propName,
      layer,
      loaders,
      loadOptions,
      signal
    }) => {
      const {
        resourceManager
      } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;
      if (signal) {
        var _loadOptions;
        loadOptions = {
          ...loadOptions,
          fetch: {
            ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),
            signal
          }
        };
      }
      let inResourceManager = resourceManager.contains(url);
      if (!inResourceManager && !loadOptions) {
        resourceManager.add({
          resourceId: url,
          data: (0, _core2.load)(url, loaders),
          persistent: false
        });
        inResourceManager = true;
      }
      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: data => {
            var _layer$internalState;
            return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
          },
          consumerId: layer.id,
          requestId: propName
        });
      }
      return (0, _core2.load)(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  operation: 'draw',
  onHover: {
    type: 'function',
    value: null,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    optional: true
  },
  coordinateSystem: _constants.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: 'XYZ',
  colorFormat: 'RGBA',
  parameters: {
    type: 'object',
    value: {},
    optional: true,
    compare: 2
  },
  loadOptions: {
    type: 'object',
    value: null,
    optional: true,
    ignore: true
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: 'array',
    value: [],
    optional: true,
    ignore: true
  },
  getPolygonOffset: {
    type: 'function',
    value: ({
      layerIndex
    }) => [0, -layerIndex * 100]
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'accessor',
    value: [0, 0, 128, 128]
  }
};
class Layer extends _component.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "internalState", null);
    (0, _defineProperty2.default)(this, "lifecycle", _constants2.LIFECYCLE.NO_STATE);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "parent", null);
  }
  get root() {
    let layer = this;
    while (layer.parent) {
      layer = layer.parent;
    }
    return layer;
  }
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return "".concat(className, "({id: '").concat(this.props.id, "'})");
  }
  project(xyz) {
    (0, _assert.default)(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = (0, _projectFunctions.getWorldPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x, y, z] = (0, _webMercator.worldToPixels)(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x, y] : [x, y, z];
  }
  unproject(xy) {
    (0, _assert.default)(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }
  projectPosition(xyz, params) {
    (0, _assert.default)(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return (0, _projectFunctions.projectPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }
  get isComposite() {
    return false;
  }
  setState(partialState) {
    this.setChangeFlags({
      stateChanged: true
    });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }
  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }
  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }
  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem
    } = this.props;
    return coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT || coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN;
  }
  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }
    return false;
  }
  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }
    return false;
  }
  nullPickingColor() {
    return [0, 0, 0];
  }
  encodePickingColor(i, target = []) {
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }
  decodePickingColor(color) {
    (0, _assert.default)(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }
  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }
    if (this.state && this.state.numInstances !== undefined) {
      return this.state.numInstances;
    }
    return (0, _count.count)(this.props.data);
  }
  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }
    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }
    return null;
  }
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['positions', 'instancePositions']);
  }
  getShaders(shaders) {
    for (const extension of this.props.extensions) {
      shaders = (0, _shader.mergeShaders)(shaders, extension.getShaders.call(this, extension));
    }
    return shaders;
  }
  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }
  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const {
      dataChanged
    } = params.changeFlags;
    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
    if (attributeManager) {
      const {
        props
      } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some(extension => extension.getNeedsPickingBuffer.call(this, extension));
      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const {
          pickingColors,
          instancePickingColors
        } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;
        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }
          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }
  finalizeState(context) {
    for (const model of this.getModels()) {
      model.delete();
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.finalize();
    }
    if (this.context) {
      this.context.resourceManager.unsubscribe({
        consumerId: this.id
      });
    }
    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }
  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }
  getPickingInfo({
    info,
    mode,
    sourceLayer
  }) {
    const {
      index
    } = info;
    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }
    return info;
  }
  raiseError(error, message) {
    var _this$props$onError, _this$props;
    if (message) {
      error.message = "".concat(message, ": ").concat(error.message);
    }
    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {
      var _this$context, _this$context$onError;
      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);
    }
  }
  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    return this._getNeedsRedraw(opts);
  }
  needsUpdate() {
    if (!this.internalState) {
      return false;
    }
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }
  hasUniformTransition() {
    var _this$internalState;
    return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
  }
  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;
    if (!oldViewport || !areViewportsEqual({
      oldViewport,
      viewport
    })) {
      this.setChangeFlags({
        viewportChanged: true
      });
      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }
  invalidateAttribute(name = 'all') {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    if (name === 'all') {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name);
    }
  }
  updateAttributes(changedAttributes) {
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes);
    }
  }
  _updateAttributes() {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({
      clearChangedFlags: true
    });
    this.updateAttributes(changedAttributes);
  }
  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }
  _updateUniformTransition() {
    const {
      uniformTransitions
    } = this.internalState;
    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);
      for (const key in propsInTransition) {
        Object.defineProperty(props, key, {
          value: propsInTransition[key]
        });
      }
      return props;
    }
    return this.props;
  }
  calculateInstancePickingColors(attribute, {
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }
    const cacheSize = Math.floor(pickingColorCache.length / 3);
    this.internalState.usesPickingColorCache = true;
    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        _log.default.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();
      }
      pickingColorCache = _typedArrayManager.default.allocate(pickingColorCache, numInstances, {
        size: 3,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 3);
      const pickingColor = [];
      for (let i = cacheSize; i < newCacheSize; i++) {
        this.encodePickingColor(i, pickingColor);
        pickingColorCache[i * 3 + 0] = pickingColor[0];
        pickingColorCache[i * 3 + 1] = pickingColor[1];
        pickingColorCache[i * 3 + 2] = pickingColor[2];
      }
    }
    attribute.value = pickingColorCache.subarray(0, numInstances * 3);
  }
  _setModelAttributes(model, changedAttributes) {
    const attributeManager = this.getAttributeManager();
    const excludeAttributes = model.userData.excludeAttributes || {};
    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
    model.setAttributes(shaderAttributes);
  }
  disablePickingIndex(objectIndex) {
    this._disablePickingIndex(objectIndex);
  }
  _disablePickingIndex(objectIndex) {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    const start = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.subData({
      data: new Uint8Array(end - start),
      offset: start
    });
  }
  restorePickingColors() {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }
    colors.updateSubBuffer({
      startOffset: 0
    });
  }
  _initialize() {
    (0, _assert.default)(!this.internalState);
    (0, _assert.default)(Number.isFinite(this.props.coordinateSystem));
    (0, _debug.default)(TRACE_INITIALIZE, this);
    const attributeManager = this._getAttributeManager();
    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateInstancePickingColors
        }
      });
    }
    this.internalState = new _layerState.default({
      attributeManager,
      layer: this
    });
    this._clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, 'attributeManager', {
      get: () => {
        _log.default.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new _uniformTransitionManager.default(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);
    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }
    this.setChangeFlags({
      dataChanged: 'init',
      propsChanged: 'init',
      viewportChanged: true,
      extensionsChanged: true
    });
    this._update();
  }
  _transferState(oldLayer) {
    (0, _debug.default)(TRACE_MATCHED, this, this === oldLayer);
    const {
      state,
      internalState
    } = oldLayer;
    if (this === oldLayer) {
      return;
    }
    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this._diffProps(this.props, this.internalState.getOldProps());
  }
  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    (0, _debug.default)(TRACE_UPDATE, this, stateNeedsUpdate);
    if (!stateNeedsUpdate) {
      return;
    }
    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;
    const propsInTransition = this._updateUniformTransition();
    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;
    try {
      const updateParams = this._getUpdateParams();
      const oldModels = this.getModels();
      if (context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {}
      }
      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }
      const modelChanged = this.getModels()[0] !== oldModels[0];
      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;
      this._clearChangeFlags();
      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }
  _finalize() {
    (0, _debug.default)(TRACE_FINALIZE, this);
    this.finalizeState(this.context);
    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }
  _drawLayer({
    moduleParameters = null,
    uniforms = {},
    parameters = {}
  }) {
    this._updateAttributeTransition();
    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    const opacity = this.props.opacity;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);
    try {
      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }
      const {
        getPolygonOffset
      } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      (0, _core.setParameters)(context.gl, {
        polygonOffset: offsets
      });
      (0, _core.withParameters)(context.gl, parameters, () => {
        const opts = {
          moduleParameters,
          uniforms,
          parameters,
          context
        };
        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }
        this.draw(opts);
      });
    } finally {
      this.props = currentProps;
    }
  }
  getChangeFlags() {
    var _this$internalState2;
    return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
  }
  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }
    const {
      changeFlags
    } = this.internalState;
    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;
        switch (key) {
          case 'dataChanged':
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];
            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }
          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }
        }
        if (flagChanged) {
          (0, _debug.default)(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }
    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }
  _diffProps(newProps, oldProps) {
    const changeFlags = (0, _props.diffProps)(newProps, oldProps);
    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }
    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        var _newProps$transitions;
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
      }
    }
    return this.setChangeFlags(changeFlags);
  }
  validateProps() {
    (0, _props.validateProps)(this.props);
  }
  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }
  _updateAutoHighlight(info) {
    const pickingModuleParameters = {
      pickingSelectedColor: info.picked ? info.color : null
    };
    const {
      highlightColor
    } = this.props;
    if (info.picked && typeof highlightColor === 'function') {
      pickingModuleParameters.pickingHighlightColor = highlightColor(info);
    }
    this.setModuleParameters(pickingModuleParameters);
    this.setNeedsRedraw();
  }
  _getAttributeManager() {
    const context = this.context;
    return new _attributeManager.default(context.gl, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }
  _postUpdate(updateParams, forceUpdate) {
    const {
      props,
      oldProps
    } = updateParams;
    this.setNeedsRedraw();
    this._updateAttributes();
    const {
      model
    } = this.state;
    model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight,
      highlightedObjectIndex,
      highlightColor
    } = props;
    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const parameters = {};
      if (!autoHighlight) {
        parameters.pickingSelectedColor = null;
      }
      if (Array.isArray(highlightColor)) {
        parameters.pickingHighlightColor = highlightColor;
      }
      if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }
      this.setModuleParameters(parameters);
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }
  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }
    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;
    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }
}
exports.default = Layer;
(0, _defineProperty2.default)(Layer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(Layer, "layerName", 'Layer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./uniform-transition-manager":"node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js","../lifecycle/props":"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../utils/count":"node_modules/@deck.gl/core/dist/esm/utils/count.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","../utils/shader":"node_modules/@deck.gl/core/dist/esm/utils/shader.js","../shaderlib/project/project-functions":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","../lifecycle/component":"node_modules/@deck.gl/core/dist/esm/lifecycle/component.js","./layer-state":"node_modules/@deck.gl/core/dist/esm/lib/layer-state.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layer = _interopRequireDefault(require("./layer"));
var _debug = _interopRequireDefault(require("../debug"));
var _flatten = require("../utils/flatten");
var _constants = require("../lifecycle/constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';
class CompositeLayer extends _layer.default {
  get isComposite() {
    return true;
  }
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);
  }
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  initializeState(context) {}
  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }
  getPickingInfo({
    info
  }) {
    const {
      object
    } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
    if (!isDataWrapped) {
      return info;
    }
    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }
  filterSubLayer(context) {
    return true;
  }
  shouldRenderSubLayer(subLayerId, data) {
    return data && data.length;
  }
  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const {
      _subLayerProps: overridingProps
    } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }
  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }
  getSubLayerAccessor(accessor) {
    if (typeof accessor === 'function') {
      const objectInfo = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (x, i) => {
        if (x && x.__source) {
          objectInfo.index = x.__source.index;
          return accessor(x.__source.object, objectInfo);
        }
        return accessor(x, i);
      };
    }
    return accessor;
  }
  getSubLayerProps(sublayerProps = {}) {
    var _this$props$updateTri;
    const {
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation,
      _subLayerProps: overridingProps
    } = this.props;
    const newProps = {
      id: '',
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || 'sublayer';
    if (overridingSublayerProps) {
      const propTypes = this.props[_constants.PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];
        if (propType && propType.type === 'accessor') {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }
    Object.assign(newProps, sublayerProps, overridingSublayerProps);
    newProps.id = "".concat(this.props.id, "-").concat(sublayerId);
    newProps.updateTriggers = {
      all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };
    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);
      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }
    return newProps;
  }
  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }
  _getAttributeManager() {
    return null;
  }
  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();
    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = (0, _flatten.flatten)(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }
    (0, _debug.default)(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);
    for (const layer of subLayers) {
      layer.parent = this;
    }
  }
}
exports.default = CompositeLayer;
(0, _defineProperty2.default)(CompositeLayer, "layerName", 'CompositeLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _viewport = _interopRequireDefault(require("./viewport"));
var _constants = require("../lib/constants");
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEGREES_TO_RADIANS = Math.PI / 180;
const RADIANS_TO_DEGREES = 180 / Math.PI;
const EARTH_RADIUS = 6370972;
const GLOBE_RADIUS = 256;
function getDistanceScales() {
  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]
  };
}
class GlobeViewport extends _viewport.default {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 2,
      resolution = 10
    } = opts;
    let {
      height,
      altitude = 1.5
    } = opts;
    height = height || 1;
    altitude = Math.max(0.75, altitude);
    const viewMatrix = new _core.Matrix4().lookAt({
      eye: [0, -altitude, 0],
      up: [0, 0, 1]
    });
    const scale = Math.pow(2, zoom);
    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);
    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);
    viewMatrix.scale(scale / height);
    const halfFov = Math.atan(0.5 / altitude);
    const relativeScale = GLOBE_RADIUS * 2 * scale / height;
    super({
      ...opts,
      height,
      viewMatrix,
      longitude,
      latitude,
      zoom,
      distanceScales: getDistanceScales(),
      fovyRadians: halfFov * 2,
      focalDistance: altitude,
      near: nearZMultiplier,
      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
    });
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "latitude", void 0);
    (0, _defineProperty2.default)(this, "resolution", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
    this.resolution = resolution;
  }
  get projectionMode() {
    return _constants.PROJECTION_MODE.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const left = this.unproject([0, this.height / 2], unprojectOption);
    const top = this.unproject([this.width / 2, 0], unprojectOption);
    const right = this.unproject([this.width, this.height / 2], unprojectOption);
    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
    if (right[0] < this.longitude) right[0] += 360;
    if (left[0] > this.longitude) left[0] -= 360;
    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
  }
  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const {
      pixelUnprojectionMatrix
    } = this;
    let coord;
    if (Number.isFinite(z)) {
      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);
    } else {
      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);
      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);
      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));
      const l0Sqr = vec3.sqrLen(coord0);
      const l1Sqr = vec3.sqrLen(coord1);
      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
      const dSqr = 4 * sSqr / lSqr;
      const r0 = Math.sqrt(l0Sqr - dSqr);
      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
      const t = (r0 - dr) / Math.sqrt(lSqr);
      coord = vec3.lerp([], coord0, coord1, t);
    }
    const [X, Y, Z] = this.unprojectPosition(coord);
    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }
    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }
  projectPosition(xyz) {
    const [lng, lat, Z = 0] = xyz;
    const lambda = lng * DEGREES_TO_RADIANS;
    const phi = lat * DEGREES_TO_RADIANS;
    const cosPhi = Math.cos(phi);
    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
  }
  unprojectPosition(xyz) {
    const [x, y, z] = xyz;
    const D = vec3.len(xyz);
    const phi = Math.asin(z / D);
    const lambda = Math.atan2(x, -y);
    const lng = lambda * RADIANS_TO_DEGREES;
    const lat = phi * RADIANS_TO_DEGREES;
    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
    return [lng, lat, Z];
  }
  projectFlat(xyz) {
    return xyz;
  }
  unprojectFlat(xyz) {
    return xyz;
  }
  panByPosition(coords, pixel) {
    const fromPosition = this.unproject(pixel);
    return {
      longitude: coords[0] - fromPosition[0] + this.longitude,
      latitude: coords[1] - fromPosition[1] + this.latitude
    };
  }
}
exports.default = GlobeViewport;
function transformVector(matrix, vector) {
  const result = vec4.transformMat4([], vector, matrix);
  vec4.scale(result, result, 1 / result[3]);
  return result;
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _core = require("@math.gl/core");
var _webMercator = require("@math.gl/web-mercator");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEGREES_TO_RADIANS = Math.PI / 180;
function getViewMatrix({
  height,
  focalDistance,
  orbitAxis,
  rotationX,
  rotationOrbit,
  zoom
}) {
  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];
  const eye = orbitAxis === 'Z' ? [0, -focalDistance, 0] : [0, 0, focalDistance];
  const viewMatrix = new _core.Matrix4().lookAt({
    eye,
    up
  });
  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);
  if (orbitAxis === 'Z') {
    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
  } else {
    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
  }
  const projectionScale = Math.pow(2, zoom) / height;
  viewMatrix.scale(projectionScale);
  return viewMatrix;
}
class OrbitViewport extends _viewport.default {
  constructor(props) {
    const {
      height,
      projectionMatrix,
      fovy = 50,
      orbitAxis = 'Z',
      target = [0, 0, 0],
      rotationX = 0,
      rotationOrbit = 0,
      zoom = 0
    } = props;
    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : (0, _webMercator.fovyToAltitude)(fovy);
    super({
      ...props,
      longitude: undefined,
      viewMatrix: getViewMatrix({
        height: height || 1,
        focalDistance,
        orbitAxis,
        rotationX,
        rotationOrbit,
        zoom
      }),
      fovy,
      focalDistance,
      position: target,
      zoom
    });
    (0, _defineProperty2.default)(this, "projectedCenter", void 0);
    this.projectedCenter = this.project(this.center);
  }
  unproject(xyz, {
    topLeft = true
  } = {}) {
    const [x, y, z = this.projectedCenter[2]] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const [X, Y, Z] = (0, _webMercator.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix);
    return [X, Y, Z];
  }
  panByPosition(coords, pixel) {
    const p0 = this.project(coords);
    const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
    return {
      target: this.unproject(nextCenter)
    };
  }
}
exports.default = OrbitViewport;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _core = require("@math.gl/core");
var _webMercator = require("@math.gl/web-mercator");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const viewMatrix = new _core.Matrix4().lookAt({
  eye: [0, 0, 1]
});
function getProjectionMatrix({
  width,
  height,
  near,
  far,
  padding
}) {
  let left = -width / 2;
  let right = width / 2;
  let bottom = -height / 2;
  let top = height / 2;
  if (padding) {
    const {
      left: l = 0,
      right: r = 0,
      top: t = 0,
      bottom: b = 0
    } = padding;
    const offsetX = (0, _core.clamp)((l + width - r) / 2, 0, width) - width / 2;
    const offsetY = (0, _core.clamp)((t + height - b) / 2, 0, height) - height / 2;
    left -= offsetX;
    right -= offsetX;
    bottom += offsetY;
    top += offsetY;
  }
  return new _core.Matrix4().ortho({
    left,
    right,
    bottom,
    top,
    near,
    far
  });
}
class OrthographicViewport extends _viewport.default {
  constructor(props) {
    const {
      width,
      height,
      near = 0.1,
      far = 1000,
      zoom = 0,
      target = [0, 0, 0],
      padding = null,
      flipY = true
    } = props;
    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
    const zoom_ = Math.min(zoomX, zoomY);
    const scale = Math.pow(2, zoom_);
    let distanceScales;
    if (zoomX !== zoomY) {
      const scaleX = Math.pow(2, zoomX);
      const scaleY = Math.pow(2, zoomY);
      distanceScales = {
        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],
        metersPerUnit: [scale / scaleX, scale / scaleY, 1]
      };
    }
    super({
      ...props,
      longitude: undefined,
      position: target,
      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),
      projectionMatrix: getProjectionMatrix({
        width: width || 1,
        height: height || 1,
        padding,
        near,
        far
      }),
      zoom: zoom_,
      distanceScales
    });
  }
  projectFlat([X, Y]) {
    const {
      unitsPerMeter
    } = this.distanceScales;
    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];
  }
  unprojectFlat([x, y]) {
    const {
      metersPerUnit
    } = this.distanceScales;
    return [x * metersPerUnit[0], y * metersPerUnit[1]];
  }
  panByPosition(coords, pixel) {
    const fromLocation = (0, _webMercator.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    return {
      target: this.unprojectFlat(newCenter)
    };
  }
}
exports.default = OrthographicViewport;
},{"../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _webMercator = require("@math.gl/web-mercator");
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class FirstPersonViewport extends _viewport.default {
  constructor(props) {
    const {
      longitude,
      latitude,
      modelMatrix,
      bearing = 0,
      pitch = 0,
      up = [0, 0, 1]
    } = props;
    const spherical = new _core._SphericalCoordinates({
      bearing,
      pitch: pitch === -90 ? 0.0001 : 90 + pitch
    });
    const dir = spherical.toVector3().normalize();
    const center = modelMatrix ? new _core.Matrix4(modelMatrix).transformAsVector(dir) : dir;
    const zoom = Number.isFinite(latitude) ? (0, _webMercator.getMeterZoom)({
      latitude: latitude
    }) : 0;
    const scale = Math.pow(2, zoom);
    const viewMatrix = new _core.Matrix4().lookAt({
      eye: [0, 0, 0],
      center,
      up
    }).scale(scale);
    super({
      ...props,
      zoom,
      viewMatrix
    });
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "latitude", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
  }
}
exports.default = FirstPersonViewport;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _controller = _interopRequireDefault(require("./controller"));
var _viewState = _interopRequireDefault(require("./view-state"));
var _mathUtils = require("../utils/math-utils");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const MOVEMENT_SPEED = 20;
class FirstPersonState extends _viewState.default {
  constructor(options) {
    const {
      width,
      height,
      position = [0, 0, 0],
      bearing = 0,
      pitch = 0,
      longitude = null,
      latitude = null,
      maxPitch = 90,
      minPitch = -90,
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition
    } = options;
    super({
      width,
      height,
      position,
      bearing,
      pitch,
      longitude,
      latitude,
      maxPitch,
      minPitch
    }, {
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition
    });
  }
  panStart() {
    return this;
  }
  pan() {
    return this;
  }
  panEnd() {
    return this;
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();
    const {
      width,
      height
    } = this.getViewportProps();
    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {
      return this;
    }
    let newRotation;
    if (pos) {
      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      newRotation = {
        bearing: startBearing - deltaScaleX * 180,
        pitch: startPitch - deltaScaleY * 90
      };
    } else {
      newRotation = {
        bearing: startBearing - deltaAngleX,
        pitch: startPitch - deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startRotatePos: null,
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart() {
    return this._getUpdatedState({
      startZoomPosition: this.getViewportProps().position
    });
  }
  zoom({
    scale
  }) {
    let {
      startZoomPosition
    } = this.getState();
    if (!startZoomPosition) {
      startZoomPosition = this.getViewportProps().position;
    }
    const direction = this.getDirection();
    return this._move(direction, Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null
    });
  }
  moveLeft(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: Math.PI / 2
    }), speed);
  }
  moveRight(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: -Math.PI / 2
    }), speed);
  }
  moveUp(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction, speed);
  }
  moveDown(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.negate(), speed);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  zoomIn(speed = 2) {
    return this.zoom({
      scale: speed
    });
  }
  zoomOut(speed = 2) {
    return this.zoom({
      scale: 1 / speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  _move(direction, speed, fromPosition = this.getViewportProps().position) {
    const delta = direction.scale(speed);
    return this._getUpdatedState({
      position: new _core.Vector3(fromPosition).add(delta)
    });
  }
  getDirection(use2D = false) {
    const spherical = new _core._SphericalCoordinates({
      bearing: this.getViewportProps().bearing,
      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
    });
    const direction = spherical.toVector3().normalize();
    return direction;
  }
  _getUpdatedState(newProps) {
    return new FirstPersonState({
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  applyConstraints(props) {
    const {
      pitch,
      maxPitch,
      minPitch,
      longitude,
      bearing
    } = props;
    props.pitch = (0, _core.clamp)(pitch, minPitch, maxPitch);
    if (longitude !== null && (longitude < -180 || longitude > 180)) {
      props.longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      props.bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
    }
    return props;
  }
}
class FirstPersonController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", FirstPersonState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default(['position', 'pitch', 'bearing'])
    });
  }
}
exports.default = FirstPersonController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/views/first-person-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _firstPersonViewport = _interopRequireDefault(require("../viewports/first-person-viewport"));
var _firstPersonController = _interopRequireDefault(require("../controllers/first-person-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class FirstPersonView extends _view.default {
  get ViewportType() {
    return _firstPersonViewport.default;
  }
  get ControllerType() {
    return _firstPersonController.default;
  }
}
exports.default = FirstPersonView;
(0, _defineProperty2.default)(FirstPersonView, "displayName", 'FirstPersonView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/first-person-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js","../controllers/first-person-controller":"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OrbitState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _viewState = _interopRequireDefault(require("./view-state"));
var _mathUtils = require("../utils/math-utils");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrbitState extends _viewState.default {
  constructor(options) {
    const {
      width,
      height,
      rotationX = 0,
      rotationOrbit = 0,
      target = [0, 0, 0],
      zoom = 0,
      minRotationX = -90,
      maxRotationX = 90,
      minZoom = -Infinity,
      maxZoom = Infinity,
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    } = options;
    super({
      width,
      height,
      rotationX,
      rotationOrbit,
      target,
      zoom,
      minRotationX,
      maxRotationX,
      minZoom,
      maxZoom
    }, {
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    });
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    this.makeViewport = options.makeViewport;
  }
  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(pos)
    });
  }
  pan({
    pos,
    startPosition
  }) {
    const startPanPosition = this.getState().startPanPosition || startPosition;
    if (!startPanPosition) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanPosition, pos);
    return this._getUpdatedState(newProps);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startRotationX: this.getViewportProps().rotationX,
      startRotationOrbit: this.getViewportProps().rotationOrbit
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startRotationX,
      startRotationOrbit
    } = this.getState();
    const {
      width,
      height
    } = this.getViewportProps();
    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {
      return this;
    }
    let newRotation;
    if (pos) {
      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      if (startRotationX < -90 || startRotationX > 90) {
        deltaScaleX *= -1;
      }
      newRotation = {
        rotationX: startRotationX + deltaScaleY * 180,
        rotationOrbit: startRotationOrbit + deltaScaleX * 180
      };
    } else {
      newRotation = {
        rotationX: startRotationX + deltaAngleY,
        rotationOrbit: startRotationOrbit + deltaAngleX
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      rotationOrbit
    } = props;
    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
    }
    return props;
  }
  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomPosition
    } = this.getState();
    if (!startZoomPosition) {
      startZoom = this.getViewportProps().zoom;
      startZoomPosition = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomPosition) {
      return this;
    }
    const newZoom = this._calculateNewZoom({
      scale,
      startZoom
    });
    const zoomedViewport = this.makeViewport({
      ...this.getViewportProps(),
      zoom: newZoom
    });
    return this._getUpdatedState({
      zoom: newZoom,
      ...zoomedViewport.panByPosition(startZoomPosition, pos)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: speed
      })
    });
  }
  zoomOut(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: 1 / speed
      })
    });
  }
  moveLeft(speed = 50) {
    return this._panFromCenter([-speed, 0]);
  }
  moveRight(speed = 50) {
    return this._panFromCenter([speed, 0]);
  }
  moveUp(speed = 50) {
    return this._panFromCenter([0, -speed]);
  }
  moveDown(speed = 50) {
    return this._panFromCenter([0, speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX - speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX + speed
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }
    const zoom = startZoom + Math.log2(scale);
    return (0, _core.clamp)(zoom, minZoom, maxZoom);
  }
  _panFromCenter(offset) {
    const {
      width,
      height,
      target
    } = this.getViewportProps();
    return this.pan({
      startPosition: target,
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom,
      maxRotationX,
      minRotationX,
      rotationOrbit
    } = props;
    props.zoom = Array.isArray(zoom) ? [(0, _core.clamp)(zoom[0], minZoom, maxZoom), (0, _core.clamp)(zoom[1], minZoom, maxZoom)] : (0, _core.clamp)(zoom, minZoom, maxZoom);
    props.rotationX = (0, _core.clamp)(props.rotationX, minRotationX, maxRotationX);
    if (rotationOrbit < -180 || rotationOrbit > 180) {
      props.rotationOrbit = (0, _mathUtils.mod)(rotationOrbit + 180, 360) - 180;
    }
    return props;
  }
}
exports.OrbitState = OrbitState;
class OrbitController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", OrbitState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default({
        transitionProps: {
          compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],
          required: ['target', 'zoom']
        }
      })
    });
  }
}
exports.default = OrbitController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/orbit-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _orbitViewport = _interopRequireDefault(require("../viewports/orbit-viewport"));
var _orbitController = _interopRequireDefault(require("../controllers/orbit-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrbitView extends _view.default {
  constructor(props = {}) {
    super(props);
    this.props.orbitAxis = props.orbitAxis || 'Z';
  }
  get ViewportType() {
    return _orbitViewport.default;
  }
  get ControllerType() {
    return _orbitController.default;
  }
}
exports.default = OrbitView;
(0, _defineProperty2.default)(OrbitView, "displayName", 'OrbitView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/orbit-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js","../controllers/orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _orbitController = require("./orbit-controller");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrthographicState extends _orbitController.OrbitState {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "zoomAxis", void 0);
    this.zoomAxis = props.zoomAxis || 'all';
  }
  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }
    let deltaZoom = Math.log2(scale);
    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;
      switch (this.zoomAxis) {
        case 'X':
          newZoomX = (0, _core.clamp)(newZoomX + deltaZoom, minZoom, maxZoom);
          break;
        case 'Y':
          newZoomY = (0, _core.clamp)(newZoomY + deltaZoom, minZoom, maxZoom);
          break;
        default:
          let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z < minZoom) {
            deltaZoom += minZoom - z;
          }
          z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z > maxZoom) {
            deltaZoom += maxZoom - z;
          }
          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }
      return [newZoomX, newZoomY];
    }
    return (0, _core.clamp)(startZoom + deltaZoom, minZoom, maxZoom);
  }
}
class OrthographicController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", OrthographicState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default(['target', 'zoom'])
    });
    (0, _defineProperty2.default)(this, "dragMode", 'pan');
  }
  _onPanRotate() {
    return false;
  }
}
exports.default = OrthographicController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _orthographicViewport = _interopRequireDefault(require("../viewports/orthographic-viewport"));
var _orthographicController = _interopRequireDefault(require("../controllers/orthographic-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrthographicView extends _view.default {
  get ViewportType() {
    return _orthographicViewport.default;
  }
  get ControllerType() {
    return _orthographicController.default;
  }
}
exports.default = OrthographicView;
(0, _defineProperty2.default)(OrthographicView, "displayName", 'OrthographicView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/orthographic-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js","../controllers/orthographic-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _mapController = require("./map-controller");
var _mathUtils = require("../utils/math-utils");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GlobeState extends _mapController.MapState {
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const {
      longitude,
      latitude
    } = props;
    if (longitude < -180 || longitude > 180) {
      props.longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
    }
    props.latitude = (0, _core.clamp)(latitude, -89, 89);
    return props;
  }
}
class GlobeController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", GlobeState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default(['longitude', 'latitude', 'zoom'])
    });
    (0, _defineProperty2.default)(this, "dragMode", 'pan');
  }
  setProps(props) {
    super.setProps(props);
    this.dragRotate = false;
    this.touchRotate = false;
  }
}
exports.default = GlobeController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/globe-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _globeViewport = _interopRequireDefault(require("../viewports/globe-viewport"));
var _globeController = _interopRequireDefault(require("../controllers/globe-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GlobeView extends _view.default {
  get ViewportType() {
    return _globeViewport.default;
  }
  get ControllerType() {
    return _globeController.default;
  }
}
exports.default = GlobeView;
(0, _defineProperty2.default)(GlobeView, "displayName", 'GlobeView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/globe-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js","../controllers/globe-controller":"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deepEqual = require("../utils/deep-equal");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LayerExtension {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "opts", void 0);
    if (opts) {
      this.opts = opts;
    }
  }
  equals(extension) {
    if (this === extension) {
      return true;
    }
    return this.constructor === extension.constructor && (0, _deepEqual.deepEqual)(this.opts, extension.opts, 1);
  }
  getShaders(extension) {
    return null;
  }
  getSubLayerProps(extension) {
    const {
      defaultProps
    } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };
    for (const key in defaultProps) {
      if (key in this.props) {
        const propDef = defaultProps[key];
        const propValue = this.props[key];
        newProps[key] = propValue;
        if (propDef && propDef.type === 'accessor') {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];
          if (typeof propValue === 'function') {
            newProps[key] = this.getSubLayerAccessor(propValue);
          }
        }
      }
    }
    return newProps;
  }
  initializeState(context, extension) {}
  updateState(params, extension) {}
  onNeedsRedraw(extension) {}
  getNeedsPickingBuffer(extension) {
    return false;
  }
  draw(params, extension) {}
  finalizeState(context, extension) {}
}
exports.default = LayerExtension;
(0, _defineProperty2.default)(LayerExtension, "defaultProps", {});
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));
var _core = require("@math.gl/core");
var _webMercator = require("@math.gl/web-mercator");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];
const DEFAULT_OPTS = {
  speed: 1.2,
  curve: 1.414
};
class FlyToInterpolator extends _transitionInterpolator.default {
  constructor(opts = {}) {
    super({
      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
    });
    (0, _defineProperty2.default)(this, "opts", void 0);
    this.opts = {
      ...DEFAULT_OPTS,
      ...opts
    };
  }
  interpolateProps(startProps, endProps, t) {
    const viewport = (0, _webMercator.flyToViewport)(startProps, endProps, t, this.opts);
    for (const key of LINEARLY_INTERPOLATED_PROPS) {
      viewport[key] = (0, _core.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }
    return viewport;
  }
  getDuration(startProps, endProps) {
    let {
      transitionDuration
    } = endProps;
    if (transitionDuration === 'auto') {
      transitionDuration = (0, _webMercator.getFlyToDuration)(startProps, endProps, this.opts);
    }
    return transitionDuration;
  }
}
exports.default = FlyToInterpolator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/tesselator.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _iterableUtils = require("./iterable-utils");
var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));
var _assert = _interopRequireDefault(require("./assert"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Tesselator {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "opts", void 0);
    (0, _defineProperty2.default)(this, "typedArrayManager", void 0);
    (0, _defineProperty2.default)(this, "indexStarts", [0]);
    (0, _defineProperty2.default)(this, "vertexStarts", [0]);
    (0, _defineProperty2.default)(this, "vertexCount", 0);
    (0, _defineProperty2.default)(this, "instanceCount", 0);
    (0, _defineProperty2.default)(this, "attributes", void 0);
    (0, _defineProperty2.default)(this, "_attributeDefs", void 0);
    (0, _defineProperty2.default)(this, "data", void 0);
    (0, _defineProperty2.default)(this, "getGeometry", void 0);
    (0, _defineProperty2.default)(this, "geometryBuffer", void 0);
    (0, _defineProperty2.default)(this, "buffers", void 0);
    (0, _defineProperty2.default)(this, "positionSize", void 0);
    (0, _defineProperty2.default)(this, "normalize", void 0);
    const {
      attributes = {}
    } = opts;
    this.typedArrayManager = _typedArrayManager.default;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }
  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const {
      data,
      buffers = {},
      getGeometry,
      geometryBuffer,
      positionFormat,
      dataChanged,
      normalize = true
    } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize;
    if (geometryBuffer) {
      (0, _assert.default)(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
      if (!normalize) {
        buffers.positions = geometryBuffer;
      }
    }
    this.geometryBuffer = buffers.positions;
    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }
  updatePartialGeometry({
    startRow,
    endRow
  }) {
    this._rebuildGeometry({
      startRow,
      endRow
    });
  }
  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    if (!ArrayBuffer.isView(value)) {
      return null;
    }
    return (0, _iterableUtils.getAccessorFromBuffer)(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }
  _allocate(instanceCount, copy) {
    const {
      attributes,
      buffers,
      _attributeDefs,
      typedArrayManager
    } = this;
    for (const name in _attributeDefs) {
      if (name in buffers) {
        typedArrayManager.release(attributes[name]);
        attributes[name] = null;
      } else {
        const def = _attributeDefs[name];
        def.copy = copy;
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }
  }
  _forEachGeometry(visitor, startRow, endRow) {
    const {
      data,
      getGeometry
    } = this;
    const {
      iterable,
      objectInfo
    } = (0, _iterableUtils.createIterable)(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
      visitor(geometry, objectInfo.index);
    }
  }
  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }
    let {
      indexStarts,
      vertexStarts,
      instanceCount
    } = this;
    const {
      data,
      geometryBuffer
    } = this;
    const {
      startRow = 0,
      endRow = Infinity
    } = dataRange || {};
    const normalizedData = {};
    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }
    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);
      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || 0;
      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof _webgl.Buffer) {
        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }
    this._allocate(instanceCount, Boolean(dataRange));
    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};
    this._forEachGeometry((geometry, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);
    this.vertexCount = indexStarts[indexStarts.length - 1];
  }
}
exports.default = Tesselator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","./assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function () {
    return _ambientLight.AmbientLight;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function () {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function () {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function () {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "Controller", {
  enumerable: true,
  get: function () {
    return _controller.default;
  }
});
Object.defineProperty(exports, "Deck", {
  enumerable: true,
  get: function () {
    return _deck.default;
  }
});
Object.defineProperty(exports, "DeckRenderer", {
  enumerable: true,
  get: function () {
    return _deckRenderer.default;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function () {
    return _directionalLight.DirectionalLight;
  }
});
Object.defineProperty(exports, "FirstPersonController", {
  enumerable: true,
  get: function () {
    return _firstPersonController.default;
  }
});
Object.defineProperty(exports, "FirstPersonView", {
  enumerable: true,
  get: function () {
    return _firstPersonView.default;
  }
});
Object.defineProperty(exports, "FirstPersonViewport", {
  enumerable: true,
  get: function () {
    return _firstPersonViewport.default;
  }
});
Object.defineProperty(exports, "FlyToInterpolator", {
  enumerable: true,
  get: function () {
    return _flyToInterpolator.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _layer.default;
  }
});
Object.defineProperty(exports, "LayerExtension", {
  enumerable: true,
  get: function () {
    return _layerExtension.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function () {
    return _layerManager.default;
  }
});
Object.defineProperty(exports, "LightingEffect", {
  enumerable: true,
  get: function () {
    return _lightingEffect.default;
  }
});
Object.defineProperty(exports, "LinearInterpolator", {
  enumerable: true,
  get: function () {
    return _linearInterpolator.default;
  }
});
Object.defineProperty(exports, "MapController", {
  enumerable: true,
  get: function () {
    return _mapController.default;
  }
});
Object.defineProperty(exports, "MapView", {
  enumerable: true,
  get: function () {
    return _mapView.default;
  }
});
Object.defineProperty(exports, "OPERATION", {
  enumerable: true,
  get: function () {
    return _constants.OPERATION;
  }
});
Object.defineProperty(exports, "OrbitController", {
  enumerable: true,
  get: function () {
    return _orbitController.default;
  }
});
Object.defineProperty(exports, "OrbitView", {
  enumerable: true,
  get: function () {
    return _orbitView.default;
  }
});
Object.defineProperty(exports, "OrbitViewport", {
  enumerable: true,
  get: function () {
    return _orbitViewport.default;
  }
});
Object.defineProperty(exports, "OrthographicController", {
  enumerable: true,
  get: function () {
    return _orthographicController.default;
  }
});
Object.defineProperty(exports, "OrthographicView", {
  enumerable: true,
  get: function () {
    return _orthographicView.default;
  }
});
Object.defineProperty(exports, "OrthographicViewport", {
  enumerable: true,
  get: function () {
    return _orthographicViewport.default;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function () {
    return _pointLight.PointLight;
  }
});
Object.defineProperty(exports, "PostProcessEffect", {
  enumerable: true,
  get: function () {
    return _postProcessEffect.default;
  }
});
Object.defineProperty(exports, "TRANSITION_EVENTS", {
  enumerable: true,
  get: function () {
    return _transitionManager.TRANSITION_EVENTS;
  }
});
Object.defineProperty(exports, "Tesselator", {
  enumerable: true,
  get: function () {
    return _tesselator.default;
  }
});
Object.defineProperty(exports, "TransitionInterpolator", {
  enumerable: true,
  get: function () {
    return _transitionInterpolator.default;
  }
});
Object.defineProperty(exports, "UNIT", {
  enumerable: true,
  get: function () {
    return _constants.UNIT;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _init.VERSION;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function () {
    return _view.default;
  }
});
Object.defineProperty(exports, "Viewport", {
  enumerable: true,
  get: function () {
    return _viewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "_CameraLight", {
  enumerable: true,
  get: function () {
    return _cameraLight.default;
  }
});
Object.defineProperty(exports, "_GlobeController", {
  enumerable: true,
  get: function () {
    return _globeController.default;
  }
});
Object.defineProperty(exports, "_GlobeView", {
  enumerable: true,
  get: function () {
    return _globeView.default;
  }
});
Object.defineProperty(exports, "_GlobeViewport", {
  enumerable: true,
  get: function () {
    return _globeViewport.default;
  }
});
Object.defineProperty(exports, "_LayersPass", {
  enumerable: true,
  get: function () {
    return _layersPass.default;
  }
});
Object.defineProperty(exports, "_PickLayersPass", {
  enumerable: true,
  get: function () {
    return _pickLayersPass.default;
  }
});
Object.defineProperty(exports, "_SunLight", {
  enumerable: true,
  get: function () {
    return _sunLight.default;
  }
});
Object.defineProperty(exports, "_compareProps", {
  enumerable: true,
  get: function () {
    return _props.compareProps;
  }
});
Object.defineProperty(exports, "_count", {
  enumerable: true,
  get: function () {
    return _count.count;
  }
});
Object.defineProperty(exports, "_deepEqual", {
  enumerable: true,
  get: function () {
    return _deepEqual.deepEqual;
  }
});
Object.defineProperty(exports, "_fillArray", {
  enumerable: true,
  get: function () {
    return _flatten.fillArray;
  }
});
Object.defineProperty(exports, "_flatten", {
  enumerable: true,
  get: function () {
    return _flatten.flatten;
  }
});
Object.defineProperty(exports, "_memoize", {
  enumerable: true,
  get: function () {
    return _memoize.default;
  }
});
Object.defineProperty(exports, "_mergeShaders", {
  enumerable: true,
  get: function () {
    return _shader.mergeShaders;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "createIterable", {
  enumerable: true,
  get: function () {
    return _iterableUtils.createIterable;
  }
});
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _mathUtils.fp64LowPart;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _shaderlib.gouraudLighting;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _shaderlib.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shaderlib.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shaderlib.project;
  }
});
Object.defineProperty(exports, "project32", {
  enumerable: true,
  get: function () {
    return _shaderlib.project32;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function () {
    return _shaderlib.shadow;
  }
});
var _init = require("./lib/init");
var _constants = require("./lib/constants");
var _lightingEffect = _interopRequireDefault(require("./effects/lighting/lighting-effect"));
var _ambientLight = require("./effects/lighting/ambient-light");
var _directionalLight = require("./effects/lighting/directional-light");
var _pointLight = require("./effects/lighting/point-light");
var _cameraLight = _interopRequireDefault(require("./effects/lighting/camera-light"));
var _sunLight = _interopRequireDefault(require("./effects/lighting/sun-light"));
var _postProcessEffect = _interopRequireDefault(require("./effects/post-process-effect"));
var _layersPass = _interopRequireDefault(require("./passes/layers-pass"));
var _pickLayersPass = _interopRequireDefault(require("./passes/pick-layers-pass"));
var _deck = _interopRequireDefault(require("./lib/deck"));
var _layerManager = _interopRequireDefault(require("./lib/layer-manager"));
var _attributeManager = _interopRequireDefault(require("./lib/attribute/attribute-manager"));
var _layer = _interopRequireDefault(require("./lib/layer"));
var _compositeLayer = _interopRequireDefault(require("./lib/composite-layer"));
var _deckRenderer = _interopRequireDefault(require("./lib/deck-renderer"));
var _viewport = _interopRequireDefault(require("./viewports/viewport"));
var _webMercatorViewport = _interopRequireDefault(require("./viewports/web-mercator-viewport"));
var _globeViewport = _interopRequireDefault(require("./viewports/globe-viewport"));
var _orbitViewport = _interopRequireDefault(require("./viewports/orbit-viewport"));
var _orthographicViewport = _interopRequireDefault(require("./viewports/orthographic-viewport"));
var _firstPersonViewport = _interopRequireDefault(require("./viewports/first-person-viewport"));
var _shaderlib = require("./shaderlib");
var _view = _interopRequireDefault(require("./views/view"));
var _mapView = _interopRequireDefault(require("./views/map-view"));
var _firstPersonView = _interopRequireDefault(require("./views/first-person-view"));
var _orbitView = _interopRequireDefault(require("./views/orbit-view"));
var _orthographicView = _interopRequireDefault(require("./views/orthographic-view"));
var _globeView = _interopRequireDefault(require("./views/globe-view"));
var _controller = _interopRequireDefault(require("./controllers/controller"));
var _mapController = _interopRequireDefault(require("./controllers/map-controller"));
var _globeController = _interopRequireDefault(require("./controllers/globe-controller"));
var _firstPersonController = _interopRequireDefault(require("./controllers/first-person-controller"));
var _orbitController = _interopRequireDefault(require("./controllers/orbit-controller"));
var _orthographicController = _interopRequireDefault(require("./controllers/orthographic-controller"));
var _layerExtension = _interopRequireDefault(require("./lib/layer-extension"));
var _transitionManager = require("./controllers/transition-manager");
var _transitionInterpolator = _interopRequireDefault(require("./transitions/transition-interpolator"));
var _linearInterpolator = _interopRequireDefault(require("./transitions/linear-interpolator"));
var _flyToInterpolator = _interopRequireDefault(require("./transitions/fly-to-interpolator"));
var _log = _interopRequireDefault(require("./utils/log"));
var _assert = _interopRequireDefault(require("./utils/assert"));
var _iterableUtils = require("./utils/iterable-utils");
var _mathUtils = require("./utils/math-utils");
var _tesselator = _interopRequireDefault(require("./utils/tesselator"));
var _flatten = require("./utils/flatten");
var _count = require("./utils/count");
var _deepEqual = require("./utils/deep-equal");
var _memoize = _interopRequireDefault(require("./utils/memoize"));
var _shader = require("./utils/shader");
var _props = require("./lifecycle/props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/init":"node_modules/@deck.gl/core/dist/esm/lib/init.js","./lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./effects/lighting/lighting-effect":"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js","./effects/lighting/ambient-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js","./effects/lighting/directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","./effects/lighting/point-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","./effects/lighting/camera-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js","./effects/lighting/sun-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js","./effects/post-process-effect":"node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js","./passes/layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","./passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","./lib/deck":"node_modules/@deck.gl/core/dist/esm/lib/deck.js","./lib/layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./lib/attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./lib/layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","./lib/composite-layer":"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","./lib/deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","./viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","./viewports/globe-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js","./viewports/orbit-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js","./viewports/orthographic-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js","./viewports/first-person-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js","./shaderlib":"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js","./views/view":"node_modules/@deck.gl/core/dist/esm/views/view.js","./views/map-view":"node_modules/@deck.gl/core/dist/esm/views/map-view.js","./views/first-person-view":"node_modules/@deck.gl/core/dist/esm/views/first-person-view.js","./views/orbit-view":"node_modules/@deck.gl/core/dist/esm/views/orbit-view.js","./views/orthographic-view":"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js","./views/globe-view":"node_modules/@deck.gl/core/dist/esm/views/globe-view.js","./controllers/controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./controllers/map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","./controllers/globe-controller":"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js","./controllers/first-person-controller":"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js","./controllers/orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","./controllers/orthographic-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js","./lib/layer-extension":"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js","./controllers/transition-manager":"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","./transitions/transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","./transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transitions/fly-to-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js","./utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","./utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","./utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","./utils/tesselator":"node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","./utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","./utils/count":"node_modules/@deck.gl/core/dist/esm/utils/count.js","./utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","./utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","./utils/shader":"node_modules/@deck.gl/core/dist/esm/utils/shader.js","./lifecycle/props":"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js"}],"node_modules/deck.gl-leaflet/dist/deck.gl-leaflet.min.js":[function(require,module,exports) {
var define;
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("leaflet"),require("@deck.gl/core")):"function"==typeof define&&define.amd?define(["exports","leaflet","@deck.gl/core"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).DeckGlLeaflet={},t.L,t.deck)}(this,(function(t,e,n){"use strict";function o(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,o.get?o:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=o(e);function r(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}function a(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function c(t,e){return(c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function s(t){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function u(t,e){return!e||"object"!==s(e)&&"function"!=typeof e?a(t):e}function f(t){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function p(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function h(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?p(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function _(t){return{longitude:t.getCenter().lng,latitude:t.getCenter().lat,zoom:t.getZoom()-1,pitch:0,bearing:0}}function m(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,o=f(t);if(e){var i=f(this).constructor;n=Reflect.construct(o,arguments,i)}else n=o.apply(this,arguments);return u(this,n)}}var d=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&c(t,e)}(f,t);var e,o,s,u=m(f);function f(t){var e;return function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,f),l(a(e=u.call(this)),"_container",void 0),l(a(e),"_deck",void 0),l(a(e),"_animate",void 0),e.props=t,e}return e=f,(o=[{key:"onAdd",value:function(){return this._container=i.DomUtil.create("div"),this._container.className="leaflet-layer",this._zoomAnimated&&i.DomUtil.addClass(this._container,"leaflet-zoom-animated"),this.getPane().appendChild(this._container),this._deck=function(t,e,o,i){if(!o){var r=_(t);o=new n.Deck(h(h({},i),{},{parent:e,controller:!1,style:{zIndex:"auto"},viewState:r}))}return o}(this._map,this._container,this._deck,this.props),this._update(),this}},{key:"onRemove",value:function(t){return i.DomUtil.remove(this._container),this._container=void 0,this._deck.finalize(),this._deck=void 0,this}},{key:"getEvents",value:function(){var t={viewreset:this._reset,movestart:this._onMoveStart,moveend:this._onMoveEnd,zoomstart:this._onZoomStart,zoom:this._onZoom,zoomend:this._onZoomEnd};return this._zoomAnimated&&(t.zoomanim=this._onAnimZoom),t}},{key:"setProps",value:function(t){Object.assign(this.props,t),this._deck&&this._deck.setProps(t)}},{key:"pickObject",value:function(t){return this._deck&&this._deck.pickObject(t)}},{key:"pickMultipleObjects",value:function(t){return this._deck&&this._deck.pickMultipleObjects(t)}},{key:"pickObjects",value:function(t){return this._deck&&this._deck.pickObjects(t)}},{key:"_update",value:function(){if(!this._map._animatingZoom){var t=this._map.getSize();this._container.style.width="".concat(t.x,"px"),this._container.style.height="".concat(t.y,"px");var e,n,o,r=this._map._getMapPanePos().multiplyBy(-1);i.DomUtil.setPosition(this._container,r),e=this._deck,n=this._map,o=_(n),e.setProps({viewState:o}),e.redraw(!1)}}},{key:"_pauseAnimation",value:function(){this._deck.props._animate&&(this._animate=this._deck.props._animate,this._deck.setProps({_animate:!1}))}},{key:"_unpauseAnimation",value:function(){this._animate&&(this._deck.setProps({_animate:this._animate}),this._animate=void 0)}},{key:"_reset",value:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom()),this._update()}},{key:"_onMoveStart",value:function(){this._pauseAnimation()}},{key:"_onMoveEnd",value:function(){this._update(),this._unpauseAnimation()}},{key:"_onZoomStart",value:function(){this._pauseAnimation()}},{key:"_onAnimZoom",value:function(t){this._updateTransform(t.center,t.zoom)}},{key:"_onZoom",value:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())}},{key:"_onZoomEnd",value:function(){this._unpauseAnimation()}},{key:"_updateTransform",value:function(t,e){var n=this._map.getZoomScale(e,this._map.getZoom()),o=i.DomUtil.getPosition(this._container),r=this._map.getSize().multiplyBy(.5),a=this._map.project(this._map.getCenter(),e),c=this._map.project(t,e).subtract(a),s=r.multiplyBy(-n).add(o).add(r).subtract(c);i.Browser.any3d?i.DomUtil.setTransform(this._container,s,n):i.DomUtil.setPosition(this._container,s)}}])&&r(e.prototype,o),s&&r(e,s),f}(i.Layer);t.LeafletLayer=d,Object.defineProperty(t,"__esModule",{value:!0})}));


},{"leaflet":"node_modules/leaflet/dist/leaflet-src.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _arcLayerVertex = _interopRequireDefault(require("./arc-layer-vertex.glsl"));
var _arcLayerFragment = _interopRequireDefault(require("./arc-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  getSourcePosition: {
    type: 'accessor',
    value: x => x.sourcePosition
  },
  getTargetPosition: {
    type: 'accessor',
    value: x => x.targetPosition
  },
  getSourceColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getTargetColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  getHeight: {
    type: 'accessor',
    value: 1
  },
  getTilt: {
    type: 'accessor',
    value: 0
  },
  greatCircle: false,
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  }
};
class ArcLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['instanceSourcePositions', 'instanceTargetPositions']);
  }
  getShaders() {
    return super.getShaders({
      vs: _arcLayerVertex.default,
      fs: _arcLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getSourceColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getTargetColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: 'getHeight',
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: 'getTilt',
        defaultValue: 0
      }
    });
  }
  updateState(opts) {
    super.updateState(opts);
    if (opts.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      greatCircle,
      wrapLongitude
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      greatCircle,
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude
    }).draw();
  }
  _getModel(gl) {
    let positions = [];
    const NUM_SEGMENTS = 50;
    for (let i = 0; i < NUM_SEGMENTS; i++) {
      positions = positions.concat([i, 1, 0, i, -1, 0]);
    }
    const model = new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 5,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
    model.setUniforms({
      numSegments: NUM_SEGMENTS
    });
    return model;
  }
}
exports.default = ArcLayer;
(0, _defineProperty2.default)(ArcLayer, "layerName", 'ArcLayer');
(0, _defineProperty2.default)(ArcLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./arc-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js","./arc-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMesh;
var _core = require("@math.gl/core");
const DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
const DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;
  for (let u = 0; u < uCount; u++) {
    const ut = u / (uCount - 1);
    for (let v = 0; v < vCount; v++) {
      const vt = v / (vCount - 1);
      const p = interpolateQuad(bounds, ut, vt);
      positions[vertex * 3 + 0] = p[0];
      positions[vertex * 3 + 1] = p[1];
      positions[vertex * 3 + 2] = p[2] || 0;
      texCoords[vertex * 2 + 0] = ut;
      texCoords[vertex * 2 + 1] = 1 - vt;
      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i = 0; i < bounds.length; i++) {
    positions[i * 3 + 0] = bounds[i][0];
    positions[i * 3 + 1] = bounds[i][1];
    positions[i * 3 + 2] = bounds[i][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut, vt) {
  return (0, _core.lerp)((0, _core.lerp)(quad[0], quad[1], vt), (0, _core.lerp)(quad[3], quad[2], vt), ut);
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const packUVsIntoRGB = "\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n";
var _default = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat(packUVsIntoRGB, "\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive && !picking_uAttribute) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n");
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _webMercator = require("@math.gl/web-mercator");
var _createMesh = _interopRequireDefault(require("./create-mesh"));
var _bitmapLayerVertex = _interopRequireDefault(require("./bitmap-layer-vertex"));
var _bitmapLayerFragment = _interopRequireDefault(require("./bitmap-layer-fragment"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultProps = {
  image: {
    type: 'image',
    value: null,
    async: true
  },
  bounds: {
    type: 'array',
    value: [1, 0, 0, 1],
    compare: true
  },
  _imageCoordinateSystem: _core.COORDINATE_SYSTEM.DEFAULT,
  desaturate: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0
  },
  transparentColor: {
    type: 'color',
    value: [0, 0, 0, 0]
  },
  tintColor: {
    type: 'color',
    value: [255, 255, 255]
  },
  textureParameters: {
    type: 'object',
    ignore: true
  }
};
class BitmapLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _bitmapLayerVertex.default,
      fs: _bitmapLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(['instancePickingColors']);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: attribute => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        update: attribute => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: attribute => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({
        mesh,
        ...this._getCoordinateUniforms()
      });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const {
      image
    } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const {
      width,
      height
    } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];
    info.bitmap = {
      size: {
        width,
        height
      },
      uv,
      pixel
    };
    return info;
  }
  disablePickingIndex() {
    this.setState({
      disablePicking: true
    });
  }
  restorePickingColors() {
    this.setState({
      disablePicking: false
    });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const {
      bounds
    } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
    }
    return (0, _createMesh.default)(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel(gl) {
    if (!gl) {
      return null;
    }
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        vertexCount: 6
      }),
      isInstanced: false
    });
  }
  draw(opts) {
    const {
      uniforms,
      moduleParameters
    } = opts;
    const {
      model,
      coordinateConversion,
      bounds,
      disablePicking
    } = this.state;
    const {
      image,
      desaturate,
      transparentColor,
      tintColor
    } = this.props;
    if (moduleParameters.pickingActive && disablePicking) {
      return;
    }
    if (image && model) {
      model.setUniforms(uniforms).setUniforms({
        bitmapTexture: image,
        desaturate,
        transparentColor: transparentColor.map(x => x / 255),
        tintColor: tintColor.slice(0, 3).map(x => x / 255),
        coordinateConversion,
        bounds
      }).draw();
    }
  }
  _getCoordinateUniforms() {
    const {
      LNGLAT,
      CARTESIAN,
      DEFAULT
    } = _core.COORDINATE_SYSTEM;
    let {
      _imageCoordinateSystem: imageCoordinateSystem
    } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const {
        bounds
      } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error('_imageCoordinateSystem only supports rectangular bounds');
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return {
          coordinateConversion: -1,
          bounds
        };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = (0, _webMercator.lngLatToWorld)([bounds[0], bounds[1]]);
        const topRight = (0, _webMercator.lngLatToWorld)([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
}
exports.default = BitmapLayer;
(0, _defineProperty2.default)(BitmapLayer, "layerName", 'BitmapLayer');
(0, _defineProperty2.default)(BitmapLayer, "defaultProps", defaultProps);
function unpackUVsFromRGB(color) {
  const [u, v, fracUV] = color;
  const vFrac = (fracUV & 0xf0) / 256;
  const uFrac = (fracUV & 0x0f) / 16;
  return [(u + uFrac) / 256, (v + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","./create-mesh":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js","./bitmap-layer-vertex":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js","./bitmap-layer-fragment":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js"}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildMapping = buildMapping;
exports.default = void 0;
exports.getDiffIcons = getDiffIcons;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _core2 = require("@loaders.gl/core");
var _core3 = require("@deck.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_CANVAS_WIDTH = 1024;
const DEFAULT_BUFFER = 4;
const noop = () => {};
const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return {
      data: imageData,
      width,
      height
    };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return {
    data: ctx.canvas,
    width,
    height
  };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, parameters) {
  const oldWidth = texture.width;
  const oldHeight = texture.height;
  const newTexture = new _core.Texture2D(texture.gl, {
    width,
    height,
    parameters
  });
  (0, _core.copyToTexture)(texture, newTexture, {
    targetY: 0,
    width: oldWidth,
    height: oldHeight
  });
  texture.delete();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const {
      icon,
      xOffset
    } = columns[i];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({
  icons,
  buffer,
  mapping = {},
  xOffset = 0,
  yOffset = 0,
  rowHeight = 0,
  canvasWidth
}) {
  let columns = [];
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const {
        height,
        width
      } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const {
    iterable,
    objectInfo
  } = (0, _core3.createIterable)(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error('Icon is missing.');
    }
    if (!icon.url) {
      throw new Error('Icon url is missing.');
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = {
        ...icon,
        source: object,
        sourceIndex: objectInfo.index
      };
    }
  }
  return icons;
}
class IconManager {
  constructor(gl, {
    onUpdate = noop,
    onError = noop
  }) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "onUpdate", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadOptions", null);
    (0, _defineProperty2.default)(this, "_texture", null);
    (0, _defineProperty2.default)(this, "_externalTexture", null);
    (0, _defineProperty2.default)(this, "_mapping", {});
    (0, _defineProperty2.default)(this, "_textureParameters", null);
    (0, _defineProperty2.default)(this, "_pendingCount", 0);
    (0, _defineProperty2.default)(this, "_autoPacking", false);
    (0, _defineProperty2.default)(this, "_xOffset", 0);
    (0, _defineProperty2.default)(this, "_yOffset", 0);
    (0, _defineProperty2.default)(this, "_rowHeight", 0);
    (0, _defineProperty2.default)(this, "_buffer", DEFAULT_BUFFER);
    (0, _defineProperty2.default)(this, "_canvasWidth", DEFAULT_CANVAS_WIDTH);
    (0, _defineProperty2.default)(this, "_canvasHeight", 0);
    (0, _defineProperty2.default)(this, "_canvas", null);
    this.gl = gl;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    var _this$_texture;
    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || {};
  }
  setProps({
    loadOptions,
    autoPacking,
    iconAtlas,
    iconMapping,
    textureParameters
  }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== undefined) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      var _this$_texture2;
      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._textureParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === 'undefined') {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const {
        mapping,
        xOffset,
        yOffset,
        rowHeight,
        canvasHeight
      } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = new _core.Texture2D(this.gl, {
          width: this._canvasWidth,
          height: this._canvasHeight,
          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement('canvas');
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext('2d', {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      (0, _core2.load)(icon.url, this._loadOptions).then(imageData => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const {
          x,
          y,
          width: maxWidth,
          height: maxHeight
        } = iconDef;
        const {
          data,
          width,
          height
        } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        this._texture.setSubImageData({
          data,
          x: x + (maxWidth - width) / 2,
          y: y + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch(error => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
}
exports.default = IconManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _iconLayerVertex = _interopRequireDefault(require("./icon-layer-vertex.glsl"));
var _iconLayerFragment = _interopRequireDefault(require("./icon-layer-fragment.glsl"));
var _iconManager = _interopRequireDefault(require("./icon-manager"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  iconAtlas: {
    type: 'image',
    value: null,
    async: true
  },
  iconMapping: {
    type: 'object',
    value: {},
    async: true
  },
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  billboard: true,
  sizeUnits: 'pixels',
  sizeMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  alphaCutoff: {
    type: 'number',
    value: 0.05,
    min: 0,
    max: 1
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getIcon: {
    type: 'accessor',
    value: x => x.icon
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  onIconError: {
    type: 'function',
    value: null,
    optional: true
  },
  textureParameters: {
    type: 'object',
    ignore: true
  }
};
class IconLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _iconLayerVertex.default,
      fs: _iconLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    this.state = {
      iconManager: new _iconManager.default(this.context.gl, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: 'getIcon',
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: 'getIcon',
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: 5121,
        accessor: 'getIcon',
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle'
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const attributeManager = this.getAttributeManager();
    const {
      iconAtlas,
      iconMapping,
      data,
      getIcon,
      textureParameters
    } = props;
    const {
      iconManager
    } = this.state;
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate('getIcon');
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({
    uniforms
  }) {
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      sizeUnits,
      billboard,
      alphaCutoff
    } = this.props;
    const {
      iconManager
    } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      this.state.model.setUniforms(uniforms).setUniforms({
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: _core.UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      }).draw();
    }
  }
  _getModel(gl) {
    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    var _this$getCurrentLayer;
    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      _core.log.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const {
      width,
      height,
      anchorX = width / 2,
      anchorY = height / 2
    } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const {
      x,
      y,
      width,
      height
    } = this.state.iconManager.getIconMapping(icon);
    return [x, y, width, height];
  }
}
exports.default = IconLayer;
(0, _defineProperty2.default)(IconLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(IconLayer, "layerName", 'IconLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./icon-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js","./icon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js","./icon-manager":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js"}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _lineLayerVertex = _interopRequireDefault(require("./line-layer-vertex.glsl"));
var _lineLayerFragment = _interopRequireDefault(require("./line-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  getSourcePosition: {
    type: 'accessor',
    value: x => x.sourcePosition
  },
  getTargetPosition: {
    type: 'accessor',
    value: x => x.targetPosition
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  }
};
class LineLayer extends _core.Layer {
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['instanceSourcePositions', 'instanceTargetPositions']);
  }
  getShaders() {
    return super.getShaders({
      vs: _lineLayerVertex.default,
      fs: _lineLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      wrapLongitude
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    }).draw();
    if (wrapLongitude) {
      this.state.model.setUniforms({
        useShortestPath: -1
      }).draw();
    }
  }
  _getModel(gl) {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 5,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = LineLayer;
(0, _defineProperty2.default)(LineLayer, "layerName", 'LineLayer');
(0, _defineProperty2.default)(LineLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./line-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js","./line-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _pointCloudLayerVertex = _interopRequireDefault(require("./point-cloud-layer-vertex.glsl"));
var _pointCloudLayerFragment = _interopRequireDefault(require("./point-cloud-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_NORMAL = [0, 0, 1];
const defaultProps = {
  sizeUnits: 'pixels',
  pointSize: {
    type: 'number',
    min: 0,
    value: 10
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getNormal: {
    type: 'accessor',
    value: DEFAULT_NORMAL
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: true,
  radiusPixels: {
    deprecatedFor: 'pointSize'
  }
};
function normalizeData(data) {
  const {
    header,
    attributes
  } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    attributes.instanceColors = attributes.COLOR_0;
  }
}
class PointCloudLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _pointCloudLayerVertex.default,
      fs: _pointCloudLayerFragment.default,
      modules: [_core.project32, _core.gouraudLighting, _core.picking]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: 'getNormal',
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      }
    });
  }
  updateState(params) {
    const {
      changeFlags,
      props
    } = params;
    super.updateState(params);
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }
  draw({
    uniforms
  }) {
    const {
      pointSize,
      sizeUnits
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      sizeUnits: _core.UNIT[sizeUnits],
      radiusPixels: pointSize
    }).draw();
  }
  _getModel(gl) {
    const positions = [];
    for (let i = 0; i < 3; i++) {
      const angle = i / 3 * Math.PI * 2;
      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
    }
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = PointCloudLayer;
(0, _defineProperty2.default)(PointCloudLayer, "layerName", 'PointCloudLayer');
(0, _defineProperty2.default)(PointCloudLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./point-cloud-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js","./point-cloud-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _scatterplotLayerVertex = _interopRequireDefault(require("./scatterplot-layer-vertex.glsl"));
var _scatterplotLayerFragment = _interopRequireDefault(require("./scatterplot-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  radiusUnits: 'meters',
  radiusScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  radiusMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  lineWidthUnits: 'meters',
  lineWidthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  lineWidthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  lineWidthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getRadius: {
    type: 'accessor',
    value: 1
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  strokeWidth: {
    deprecatedFor: 'getLineWidth'
  },
  outline: {
    deprecatedFor: 'stroked'
  },
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};
class ScatterplotLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _scatterplotLayerVertex.default,
      fs: _scatterplotLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: 'getRadius',
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      radiusUnits,
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      stroked,
      filled,
      billboard,
      antialiasing,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      stroked: stroked ? 1 : 0,
      filled,
      billboard,
      antialiasing,
      radiusUnits: _core.UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: _core.UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 3,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = ScatterplotLayer;
(0, _defineProperty2.default)(ScatterplotLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(ScatterplotLayer, "layerName", 'ScatterplotLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./scatterplot-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js","./scatterplot-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js"}],"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WINDING = void 0;
exports.forEachSegmentInPolygon = forEachSegmentInPolygon;
exports.forEachSegmentInPolygonPoints = forEachSegmentInPolygonPoints;
exports.getPolygonSignedArea = getPolygonSignedArea;
exports.getPolygonSignedAreaPoints = getPolygonSignedAreaPoints;
exports.getPolygonWindingDirection = getPolygonWindingDirection;
exports.getPolygonWindingDirectionPoints = getPolygonWindingDirectionPoints;
exports.modifyPolygonWindingDirection = modifyPolygonWindingDirection;
exports.modifyPolygonWindingDirectionPoints = modifyPolygonWindingDirectionPoints;
var _core = require("@math.gl/core");
const WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
exports.WINDING = WINDING;
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
function getPolygonSignedArea(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  const dim = options.size || 2;
  let area = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);
    j = i;
  }
  return area / 2;
}
function forEachSegmentInPolygon(points, visitor, options = {}) {
  const {
    start = 0,
    end = points.length,
    size = 2,
    isClosed
  } = options;
  const numPoints = (end - start) / size;
  for (let i = 0; i < numPoints - 1; ++i) {
    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);
  }
  const endPointIndex = start + (numPoints - 1) * size;
  const isClosedEx = isClosed || (0, _core.equals)(points[start], points[endPointIndex]) && (0, _core.equals)(points[start + 1], points[endPointIndex + 1]);
  if (!isClosedEx) {
    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);
  }
}
function reversePolygon(points, options) {
  const {
    start = 0,
    end = points.length,
    size = 2
  } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start + i * size;
    const b2 = start + (numPoints - 1 - i) * size;
    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}
function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {
  const currentDirection = getPolygonWindingDirectionPoints(points, options);
  if (currentDirection !== direction) {
    points.reverse();
    return true;
  }
  return false;
}
function getPolygonWindingDirectionPoints(points, options = {}) {
  return Math.sign(getPolygonSignedAreaPoints(points, options));
}
function getPolygonSignedAreaPoints(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  let area = 0;
  for (let i = start, j = end - 1; i < end; ++i) {
    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);
    j = i;
  }
  return area / 2;
}
function forEachSegmentInPolygonPoints(points, visitor, options = {}) {
  const {
    start = 0,
    end = points.length,
    isClosed
  } = options;
  for (let i = start; i < end - 1; ++i) {
    visitor(points[i], points[i + 1], i, i + 1);
  }
  const isClosedEx = isClosed || (0, _core.equals)(points[end - 1], points[0]);
  if (!isClosedEx) {
    visitor(points[end - 1], points[0], end - 1, 0);
  }
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@math.gl/polygon/dist/esm/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _polygonUtils = require("./polygon-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Polygon {
  constructor(points, options = {}) {
    (0, _defineProperty2.default)(this, "points", void 0);
    (0, _defineProperty2.default)(this, "isFlatArray", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    this.points = points;
    this.isFlatArray = !(0, _core.isArray)(points[0]);
    this.options = {
      start: options.start || 0,
      end: options.end || points.length,
      size: options.size || 2,
      isClosed: options.isClosed
    };
    Object.freeze(this);
  }
  getSignedArea() {
    if (this.isFlatArray) return (0, _polygonUtils.getPolygonSignedArea)(this.points, this.options);
    return (0, _polygonUtils.getPolygonSignedAreaPoints)(this.points, this.options);
  }
  getArea() {
    return Math.abs(this.getSignedArea());
  }
  getWindingDirection() {
    return Math.sign(this.getSignedArea());
  }
  forEachSegment(visitor) {
    if (this.isFlatArray) {
      (0, _polygonUtils.forEachSegmentInPolygon)(this.points, (x1, y1, x2, y2, i1, i2) => {
        visitor([x1, y1], [x2, y2], i1, i2);
      }, this.options);
    } else {
      (0, _polygonUtils.forEachSegmentInPolygonPoints)(this.points, visitor, this.options);
    }
  }
  modifyWindingDirection(direction) {
    if (this.isFlatArray) {
      return (0, _polygonUtils.modifyPolygonWindingDirection)(this.points, direction, this.options);
    }
    return (0, _polygonUtils.modifyPolygonWindingDirectionPoints)(this.points, direction, this.options);
  }
}
exports.default = Polygon;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"}],"node_modules/@math.gl/polygon/dist/esm/earcut.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.earcut = earcut;
var _polygonUtils = require("./polygon-utils");
function earcut(positions, holeIndices, dim = 2, areas) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  let invSize;
  let maxX;
  let maxY;
  let minX;
  let minY;
  let x;
  let y;
  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);
  if (positions.length > 80 * dim) {
    minX = maxX = positions[0];
    minY = maxY = positions[1];
    for (let i = dim; i < outerLen; i += dim) {
      x = positions[i];
      y = positions[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise, area) {
  let i;
  let last;
  if (area === undefined) {
    area = (0, _polygonUtils.getPolygonSignedArea)(data, {
      start,
      end,
      size: dim
    });
  }
  if (clockwise === area < 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start;
  let again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  let prev;
  let next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev;
  const b = ear;
  const c = ear.next;
  if (area(a, b, c) >= 0) return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev;
  const b = ear;
  const c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
  const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
  const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
  const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize);
  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ;
  let n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev;
    const b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
  const queue = [];
  let i;
  let len;
  let start;
  let end;
  let list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  if (hx === qx) return m;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  let tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let e;
  let i;
  let inSize = 1;
  let numMerges;
  let p;
  let pSize;
  let q;
  let qSize;
  let tail;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00ff00ff;
  x = (x | x << 4) & 0x0f0f0f0f;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00ff00ff;
  y = (y | y << 4) & 0x0f0f0f0f;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start;
  let leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a;
  let inside = false;
  const px = (a.x + b.x) / 2;
  const py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y);
  const b2 = new Node(b.i, b.x, b.y);
  const an = a.next;
  const bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
},{"./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"}],"node_modules/@math.gl/polygon/dist/esm/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.getPointAtIndex = getPointAtIndex;
exports.push = push;
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}
},{}],"node_modules/@math.gl/polygon/dist/esm/lineclip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bitCode = bitCode;
exports.clipPolygon = clipPolygon;
exports.clipPolyline = clipPolyline;
exports.intersect = intersect;
var _utils = require("./utils");
function clipPolyline(positions, bbox, options) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  const result = [];
  let part = [];
  let a;
  let b;
  let codeA = -1;
  let codeB;
  let lastCode;
  for (let i = 1; i < numPoints; i++) {
    a = (0, _utils.getPointAtIndex)(positions, i - 1, size, startIndex, a);
    b = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, b);
    if (codeA < 0) {
      codeA = bitCode(a, bbox);
    }
    codeB = lastCode = bitCode(b, bbox);
    while (true) {
      if (!(codeA | codeB)) {
        (0, _utils.push)(part, a);
        if (codeB !== lastCode) {
          (0, _utils.push)(part, b);
          if (i < numPoints - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === numPoints - 1) {
          (0, _utils.push)(part, b);
        }
        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        intersect(a, b, codeA, bbox, a);
        codeA = bitCode(a, bbox);
      } else {
        intersect(a, b, codeB, bbox, b);
        codeB = bitCode(b, bbox);
      }
    }
    codeA = lastCode;
  }
  if (part.length) result.push(part);
  return result;
}
function clipPolygon(positions, bbox, options) {
  const {
    size = 2,
    endIndex = positions.length
  } = options || {};
  let {
    startIndex = 0
  } = options || {};
  let numPoints = (endIndex - startIndex) / size;
  let result;
  let p;
  let prev;
  let inside;
  let prevInside;
  for (let edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = (0, _utils.getPointAtIndex)(positions, numPoints - 1, size, startIndex, prev);
    prevInside = !(bitCode(prev, bbox) & edge);
    for (let i = 0; i < numPoints; i++) {
      p = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, p);
      inside = !(bitCode(p, bbox) & edge);
      if (inside !== prevInside) (0, _utils.push)(result, intersect(prev, p, edge, bbox));
      if (inside) (0, _utils.push)(result, p);
      (0, _utils.copy)(prev, p);
      prevInside = inside;
    }
    positions = result;
    startIndex = 0;
    numPoints = result.length / size;
    if (!numPoints) break;
  }
  return result;
}
function intersect(a, b, edge, bbox, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
  }
  return out;
}
function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;
  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;
  return code;
}
},{"./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutPolygonByGrid = cutPolygonByGrid;
exports.cutPolylineByGrid = cutPolylineByGrid;
var _lineclip = require("./lineclip");
var _utils = require("./utils");
function cutPolylineByGrid(positions, options) {
  const {
    size = 2,
    broken = false,
    gridResolution = 10,
    gridOffset = [0, 0],
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a, gridResolution, gridOffset, []);
  const scratchPoint = [];
  (0, _utils.push)(part, a);
  for (let i = 1; i < numPoints; i++) {
    b = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, b);
    codeB = (0, _lineclip.bitCode)(b, cell);
    while (codeB) {
      (0, _lineclip.intersect)(a, b, codeB, cell, scratchPoint);
      const codeAlt = (0, _lineclip.bitCode)(scratchPoint, cell);
      if (codeAlt) {
        (0, _lineclip.intersect)(a, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      (0, _utils.push)(part, scratchPoint);
      (0, _utils.copy)(a, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        (0, _utils.push)(part, a);
      }
      codeB = (0, _lineclip.bitCode)(b, cell);
    }
    (0, _utils.push)(part, b);
    (0, _utils.copy)(a, b);
  }
  return broken ? result : result[0];
}
const TYPE_INSIDE = 0;
const TYPE_BORDER = 1;
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const {
    size = 2,
    gridResolution = 10,
    gridOffset = [0, 0],
    edgeTypes = false
  } = options || {};
  const result = [];
  const queue = [{
    pos: positions,
    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
    holes: holeIndices || []
  }];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const {
      pos,
      types,
      holes
    } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = (0, _lineclip.bitCode)(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = {
        pos: parts[0].pos,
        types: parts[0].types,
        holes: []
      };
      const polygonHigh = {
        pos: parts[1].pos,
        types: parts[1].types,
        holes: []
      };
      queue.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = {
        positions: pos
      };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = (0, _utils.getPointAtIndex)(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];
    if (side && prevSide && prevSide !== side) {
      (0, _lineclip.intersect)(prev, p, edge, bbox, scratchPoint);
      (0, _utils.push)(resultLow, scratchPoint) && typesLow.push(prevType);
      (0, _utils.push)(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      (0, _utils.push)(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      (0, _utils.push)(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    (0, _utils.copy)(prev, p);
    prevSide = side;
    prevType = type;
  }
  return [lowPointCount ? {
    pos: resultLow,
    types: edgeTypes && typesLow
  } : null, highPointCount ? {
    pos: resultHigh,
    types: edgeTypes && typesHigh
  } : null];
}
function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    minX = x < minX ? x : minX;
    maxX = x > maxX ? x : maxX;
    minY = y < minY ? y : minY;
    maxY = y > maxY ? y : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
},{"./lineclip":"node_modules/@math.gl/polygon/dist/esm/lineclip.js","./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutPolygonByMercatorBounds = cutPolygonByMercatorBounds;
exports.cutPolylineByMercatorBounds = cutPolylineByMercatorBounds;
var _cutByGrid = require("./cut-by-grid");
var _utils = require("./utils");
const DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length,
    normalize = true
  } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = (0, _cutByGrid.cutPolylineByGrid)(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const {
    size = 2,
    normalize = true,
    edgeTypes = false
  } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = (0, _cutByGrid.cutPolygonByGrid)(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    (0, _utils.push)(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    (0, _utils.push)(positions, p);
    p[0] = firstLng;
    (0, _utils.push)(positions, p);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}
},{"./cut-by-grid":"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "WINDING", {
  enumerable: true,
  get: function () {
    return _polygonUtils.WINDING;
  }
});
Object.defineProperty(exports, "_Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "clipPolygon", {
  enumerable: true,
  get: function () {
    return _lineclip.clipPolygon;
  }
});
Object.defineProperty(exports, "clipPolyline", {
  enumerable: true,
  get: function () {
    return _lineclip.clipPolyline;
  }
});
Object.defineProperty(exports, "cutPolygonByGrid", {
  enumerable: true,
  get: function () {
    return _cutByGrid.cutPolygonByGrid;
  }
});
Object.defineProperty(exports, "cutPolygonByMercatorBounds", {
  enumerable: true,
  get: function () {
    return _cutByMercatorBounds.cutPolygonByMercatorBounds;
  }
});
Object.defineProperty(exports, "cutPolylineByGrid", {
  enumerable: true,
  get: function () {
    return _cutByGrid.cutPolylineByGrid;
  }
});
Object.defineProperty(exports, "cutPolylineByMercatorBounds", {
  enumerable: true,
  get: function () {
    return _cutByMercatorBounds.cutPolylineByMercatorBounds;
  }
});
Object.defineProperty(exports, "earcut", {
  enumerable: true,
  get: function () {
    return _earcut.earcut;
  }
});
Object.defineProperty(exports, "forEachSegmentInPolygon", {
  enumerable: true,
  get: function () {
    return _polygonUtils.forEachSegmentInPolygon;
  }
});
Object.defineProperty(exports, "getPolygonSignedArea", {
  enumerable: true,
  get: function () {
    return _polygonUtils.getPolygonSignedArea;
  }
});
Object.defineProperty(exports, "getPolygonWindingDirection", {
  enumerable: true,
  get: function () {
    return _polygonUtils.getPolygonWindingDirection;
  }
});
Object.defineProperty(exports, "modifyPolygonWindingDirection", {
  enumerable: true,
  get: function () {
    return _polygonUtils.modifyPolygonWindingDirection;
  }
});
var _polygon = _interopRequireDefault(require("./polygon"));
var _polygonUtils = require("./polygon-utils");
var _earcut = require("./earcut");
var _lineclip = require("./lineclip");
var _cutByGrid = require("./cut-by-grid");
var _cutByMercatorBounds = require("./cut-by-mercator-bounds");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./polygon":"node_modules/@math.gl/polygon/dist/esm/polygon.js","./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","./earcut":"node_modules/@math.gl/polygon/dist/esm/earcut.js","./lineclip":"node_modules/@math.gl/polygon/dist/esm/lineclip.js","./cut-by-grid":"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","./cut-by-mercator-bounds":"node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _polygon = require("@math.gl/polygon");
class ColumnGeometry extends _core2.Geometry {
  constructor(props) {
    const {
      id = (0, _core2.uid)('column-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateColumn(props);
    super({
      ...props,
      id,
      indices,
      attributes
    });
  }
}
exports.default = ColumnGeometry;
function tesselateColumn(props) {
  const {
    radius,
    height = 1,
    nradial = 10
  } = props;
  let {
    vertices
  } = props;
  if (vertices) {
    _core.log.assert(vertices.length >= nradial);
    vertices = vertices.flatMap(v => [v[0], v[1]]);
    (0, _polygon.modifyPolygonWindingDirection)(vertices, _polygon.WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i = 0;
  if (isExtruded) {
    for (let j = 0; j < vertsAroundEdge; j++) {
      const a = j * stepAngle;
      const vertexIndex = j % nradial;
      const sin = Math.sin(a);
      const cos = Math.cos(a);
      for (let k = 0; k < 2; k++) {
        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
        positions[i + 2] = (1 / 2 - k) * height;
        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;
        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
        i += 3;
      }
    }
    positions[i + 0] = positions[i - 3];
    positions[i + 1] = positions[i - 2];
    positions[i + 2] = positions[i - 1];
    i += 3;
  }
  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
    const a = v * stepAngle;
    const vertexIndex = (v + nradial) % nradial;
    const sin = Math.sin(a);
    const cos = Math.cos(a);
    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j = 0; j < nradial; j++) {
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 2;
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      }
    }
  };
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool stroked;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (stroked) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n    if (isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _columnGeometry = _interopRequireDefault(require("./column-geometry"));
var _columnLayerVertex = _interopRequireDefault(require("./column-layer-vertex.glsl"));
var _columnLayerFragment = _interopRequireDefault(require("./column-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  diskResolution: {
    type: 'number',
    min: 4,
    value: 20
  },
  vertices: null,
  radius: {
    type: 'number',
    min: 0,
    value: 1000
  },
  angle: {
    type: 'number',
    value: 0
  },
  offset: {
    type: 'array',
    value: [0, 0]
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusUnits: 'meters',
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: true,
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};
class ColumnLayer extends _core.Layer {
  getShaders() {
    const {
      gl
    } = this.context;
    const transpileToGLSL100 = !(0, _core2.isWebGL2)(gl);
    const defines = {};
    const useDerivatives = this.props.flatShading && (0, _core2.hasFeature)(gl, _core2.FEATURES.GLSL_DERIVATIVES);
    if (useDerivatives) {
      defines.FLAT_SHADING = 1;
    }
    return super.getShaders({
      vs: _columnLayerVertex.default,
      fs: _columnLayerFragment.default,
      defines,
      transpileToGLSL100,
      modules: [_core.project32, useDerivatives ? _core.phongLighting : _core.gouraudLighting, _core.picking]
    });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: 'getElevation'
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getLineWidth',
        transition: true
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
    if (regenerateModels) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }
  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry = new _columnGeometry.default({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;
    if (vertices) {
      for (let i = 0; i < diskResolution; i++) {
        const p = vertices[i];
        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
        meanVertexDistance += d / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry;
  }
  _getModel(gl) {
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      isInstanced: true
    });
  }
  _updateGeometry({
    diskResolution,
    vertices,
    extruded,
    stroked
  }) {
    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3,
      wireframeVertexCount: geometry.indices.value.length
    });
    this.state.model.setProps({
      geometry
    });
  }
  draw({
    uniforms
  }) {
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      radiusUnits,
      elevationScale,
      extruded,
      filled,
      stroked,
      wireframe,
      offset,
      coverage,
      radius,
      angle
    } = this.props;
    const {
      model,
      fillVertexCount,
      wireframeVertexCount,
      edgeDistance
    } = this.state;
    model.setUniforms(uniforms).setUniforms({
      radius,
      angle: angle / 180 * Math.PI,
      offset,
      extruded,
      stroked,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: _core.UNIT[radiusUnits],
      widthUnits: _core.UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    });
    if (extruded && wireframe) {
      model.setProps({
        isIndexed: true
      });
      model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({
        isStroke: true
      }).draw();
    }
    if (filled) {
      model.setProps({
        isIndexed: false
      });
      model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({
        isStroke: false
      }).draw();
    }
    if (!extruded && stroked) {
      model.setProps({
        isIndexed: false
      });
      model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({
        isStroke: true
      }).draw();
    }
  }
}
exports.default = ColumnLayer;
(0, _defineProperty2.default)(ColumnLayer, "layerName", 'ColumnLayer');
(0, _defineProperty2.default)(ColumnLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./column-geometry":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js","./column-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js","./column-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _core2 = require("@deck.gl/core");
var _columnLayer = _interopRequireDefault(require("./column-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    value: 1000
  },
  offset: {
    type: 'array',
    value: [1, 1]
  }
};
class GridCellLayer extends _columnLayer.default {
  getGeometry(diskResolution) {
    return new _core.CubeGeometry();
  }
  draw({
    uniforms
  }) {
    const {
      elevationScale,
      extruded,
      offset,
      coverage,
      cellSize,
      angle,
      radiusUnits
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      radius: cellSize / 2,
      radiusUnits: _core2.UNIT[radiusUnits],
      angle,
      offset,
      extruded,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isWireframe: false
    }).draw();
  }
}
exports.default = GridCellLayer;
(0, _defineProperty2.default)(GridCellLayer, "layerName", 'GridCellLayer');
(0, _defineProperty2.default)(GridCellLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./column-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizePath = normalizePath;
var _polygon = require("@math.gl/polygon");
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length = path.length * size;
    flatPath = new Array(length);
    for (let i = 0; i < path.length; i++) {
      for (let j = 0; j < size; j++) {
        flatPath[i * size + j] = path[i][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return (0, _polygon.cutPolylineByGrid)(flatPath, {
      size,
      gridResolution
    });
  }
  if (wrapLongitude) {
    return (0, _polygon.cutPolylineByMercatorBounds)(flatPath, {
      size
    });
  }
  return flatPath;
}
},{"@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@deck.gl/core");
var _path = require("./path");
const START_CAP = 1;
const END_CAP = 2;
const INVALID = 4;
class PathTesselator extends _core.Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: {
          size: 1,
          type: Uint8ClampedArray
        }
      }
    });
  }
  get(attributeName) {
    return this.attributes[attributeName];
  }
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  normalizeGeometry(path) {
    if (this.normalize) {
      return (0, _path.normalizePath)(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const {
      vertexStart,
      geometrySize
    } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const {
      positions
    } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const {
      vertexStart,
      geometrySize
    } = context;
    const p = new Array(3);
    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p);
      positions[i * 3] = p[0];
      positions[i * 3 + 1] = p[1];
      positions[i * 3 + 2] = p[2];
    }
  }
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  getPointOnPath(path, index, target = []) {
    const {
      positionSize
    } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i = index * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const {
      positionSize
    } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
}
exports.default = PathTesselator;
function isCut(path) {
  return Array.isArray(path[0]);
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./path":"node_modules/@deck.gl/layers/dist/esm/path-layer/path.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _pathTesselator = _interopRequireDefault(require("./path-tesselator"));
var _pathLayerVertex = _interopRequireDefault(require("./path-layer-vertex.glsl"));
var _pathLayerFragment = _interopRequireDefault(require("./path-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  widthUnits: 'meters',
  widthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  widthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  widthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  jointRounded: false,
  capRounded: false,
  miterLimit: {
    type: 'number',
    min: 0,
    value: 4
  },
  billboard: false,
  _pathType: null,
  getPath: {
    type: 'accessor',
    value: object => object.path
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  rounded: {
    deprecatedFor: ['jointRounded', 'capRounded']
  }
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
class PathLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _pathLayerVertex.default,
      fs: _pathLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      positions: {
        size: 3,
        vertexOffset: 1,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPath',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: 5121,
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getWidth',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        accessor: 'getColor',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR
      },
      instancePickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new _pathTesselator.default({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      changeFlags
    } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const {
        pathTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === 'loop',
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      info.object = data.find(d => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  draw({
    uniforms
  }) {
    const {
      jointRounded,
      capRounded,
      billboard,
      miterLimit,
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: {
            value: new Float32Array(SEGMENT_POSITIONS),
            size: 2
          }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get('positions');
  }
  calculateSegmentTypes(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get('segmentTypes');
  }
}
exports.default = PathLayer;
(0, _defineProperty2.default)(PathLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(PathLayer, "layerName", 'PathLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./path-tesselator":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","./path-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","./path-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"}],"node_modules/earcut/src/earcut.js":[function(require,module,exports) {
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHoleIndices = getHoleIndices;
exports.getPositions = getPositions;
exports.getSurfaceIndices = getSurfaceIndices;
exports.normalize = normalize;
var _earcut = _interopRequireDefault(require("earcut"));
var _polygon = require("@math.gl/polygon");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const OUTER_POLYGON_WINDING = _polygon.WINDING.CLOCKWISE;
const HOLE_POLYGON_WINDING = _polygon.WINDING.COUNTER_CLOCKWISE;
const windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error('invalid polygon');
  }
}
function getPositions(polygon) {
  return 'positions' in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return 'holeIndices' in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  (0, _polygon.modifyPolygonWindingDirection)(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  (0, _polygon.modifyPolygonWindingDirection)(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ('positions' in polygon) {
    const {
      positions: srcPositions,
      holeIndices: srcHoleIndices
    } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i = 0; i < numVerts; i++) {
    const j = (i + 1) % numVerts;
    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];
    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i = 0; i < numVerts; i++) {
    const o = i * 3;
    const x = positions[o + 0];
    const y = positions[o + 1];
    const z = positions[o + 2];
    positions[o + xIndex] = x;
    positions[o + yIndex] = y;
    positions[o + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p = [];
    for (let i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      if (is3d) {
        p[2] = positions[i + 2];
      }
      const xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {} else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 1, 2, 0);
    }
  }
  return (0, _earcut.default)(positions, holeIndices, positionSize);
}
},{"earcut":"node_modules/earcut/src/earcut.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var Polygon = _interopRequireWildcard(require("./polygon"));
var _core = require("@deck.gl/core");
var _polygon2 = require("@math.gl/polygon");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class PolygonTesselator extends _core.Tesselator {
  constructor(opts) {
    const {
      fp64,
      IndexType = Uint32Array
    } = opts;
    super({
      ...opts,
      attributes: {
        positions: {
          size: 3,
          type: fp64 ? Float64Array : Float32Array
        },
        vertexValid: {
          type: Uint8ClampedArray,
          size: 1
        },
        indices: {
          type: IndexType,
          size: 1
        }
      }
    });
  }
  get(attributeName) {
    const {
      attributes
    } = this;
    if (attributeName === 'indices') {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error('missing indices buffer');
    }
  }
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return (0, _polygon2.cutPolygonByGrid)(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return (0, _polygon2.cutPolygonByMercatorBounds)(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  getGeometrySize(polygon) {
    if (isCut(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return Polygon.getPositions(polygon).length / this.positionSize;
  }
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      this._updateIndices(polygon, context);
      this._updatePositions(polygon, context);
      this._updateVertexValid(polygon, context);
    }
  }
  _updateIndices(polygon, {
    geometryIndex,
    vertexStart: offset,
    indexStart
  }) {
    const {
      attributes,
      indexStarts,
      typedArrayManager
    } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i = indexStart;
    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  _updatePositions(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      attributes: {
        positions
      },
      positionSize
    } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = Polygon.getPositions(polygon);
    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {
      const x = polygonPositions[j * positionSize];
      const y = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
  }
  _updateVertexValid(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      positionSize
    } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && Polygon.getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
}
exports.default = PolygonTesselator;
function isCut(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}
},{"./polygon":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");
exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");
exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _polygonTesselator = _interopRequireDefault(require("./polygon-tesselator"));
var _solidPolygonLayerVertexTop = _interopRequireDefault(require("./solid-polygon-layer-vertex-top.glsl"));
var _solidPolygonLayerVertexSide = _interopRequireDefault(require("./solid-polygon-layer-vertex-side.glsl"));
var _solidPolygonLayerFragment = _interopRequireDefault(require("./solid-polygon-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: 'CW',
  _full3d: false,
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  getPolygon: {
    type: 'accessor',
    value: f => f.polygon
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: true
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
class SolidPolygonLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders(type) {
    return super.getShaders({
      vs: type === 'top' ? _solidPolygonLayerVertexTop.default : _solidPolygonLayerVertexSide.default,
      fs: _solidPolygonLayerFragment.default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1
      },
      modules: [_core.project32, _core.gouraudLighting, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const {
      gl,
      viewport
    } = this.context;
    let {
      coordinateSystem
    } = this.props;
    const {
      _full3d
    } = this.props;
    if (viewport.isGeospatial && coordinateSystem === _core.COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = _core.COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new _polygonTesselator.default({
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: !gl || (0, _core2.hasFeatures)(gl, _core2.FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(['instancePickingColors']);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: this.calculateIndices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPolygon',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          positions: {
            vertexOffset: 0,
            divisor: 0
          },
          instancePositions: {
            vertexOffset: 0,
            divisor: 1
          },
          nextPositions: {
            vertexOffset: 1,
            divisor: 1
          }
        }
      },
      vertexValid: {
        size: 1,
        divisor: 1,
        type: 5121,
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getElevation',
        shaderAttributes: {
          elevations: {
            divisor: 0
          },
          instanceElevations: {
            divisor: 1
          }
        }
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          fillColors: {
            divisor: 0
          },
          instanceFillColors: {
            divisor: 1
          }
        }
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          lineColors: {
            divisor: 0
          },
          instanceLineColors: {
            divisor: 1
          }
        }
      },
      pickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
        shaderAttributes: {
          pickingColors: {
            divisor: 0
          },
          instancePickingColors: {
            divisor: 1
          }
        }
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      info.object = data.find(d => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  draw({
    uniforms
  }) {
    const {
      extruded,
      filled,
      wireframe,
      elevationScale
    } = this.props;
    const {
      topModel,
      sideModel,
      polygonTesselator
    } = this.state;
    const renderUniforms = {
      ...uniforms,
      extruded: Boolean(extruded),
      elevationScale
    };
    if (sideModel) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);
      if (wireframe) {
        sideModel.setDrawMode(3);
        sideModel.setUniforms({
          isWireframe: true
        }).draw();
      }
      if (filled) {
        sideModel.setDrawMode(6);
        sideModel.setUniforms({
          isWireframe: false
        }).draw();
      }
    }
    if (topModel) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.setUniforms(renderUniforms).draw();
    }
  }
  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const {
      props,
      oldProps,
      changeFlags
    } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      var _this$state$models;
      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach(model => model.delete());
      this.setState(this._getModels(this.context.gl));
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({
    props,
    oldProps,
    changeFlags
  }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const {
        polygonTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels(gl) {
    const {
      id,
      filled,
      extruded
    } = this.props;
    let topModel;
    let sideModel;
    if (filled) {
      const shaders = this.getShaders('top');
      shaders.defines.NON_INSTANCED_MODEL = 1;
      topModel = new _core2.Model(gl, {
        ...shaders,
        id: "".concat(id, "-top"),
        drawMode: 4,
        attributes: {
          vertexPositions: new Float32Array([0, 1])
        },
        uniforms: {
          isWireframe: false,
          isSideVertex: false
        },
        vertexCount: 0,
        isIndexed: true
      });
    }
    if (extruded) {
      sideModel = new _core2.Model(gl, {
        ...this.getShaders('side'),
        id: "".concat(id, "-side"),
        geometry: new _core2.Geometry({
          drawMode: 1,
          vertexCount: 4,
          attributes: {
            vertexPositions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        instanceCount: 0,
        isInstanced: 1
      });
      sideModel.userData.excludeAttributes = {
        indices: true
      };
    }
    return {
      models: [sideModel, topModel].filter(Boolean),
      topModel,
      sideModel
    };
  }
  calculateIndices(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get('indices');
  }
  calculatePositions(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get('positions');
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get('vertexValid');
  }
}
exports.default = SolidPolygonLayer;
(0, _defineProperty2.default)(SolidPolygonLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(SolidPolygonLayer, "layerName", 'SolidPolygonLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./polygon-tesselator":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","./solid-polygon-layer-vertex-top.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","./solid-polygon-layer-vertex-side.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","./solid-polygon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceInRange = replaceInRange;
function replaceInRange({
  data,
  getIndex,
  dataRange,
  replace
}) {
  const {
    startRow = 0,
    endRow = Infinity
  } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i = 0; i < count; i++) {
    const row = getIndex(data[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;
  for (let i = 0; i < replace.length; i++) {
    data[index++] = replace[i];
  }
  if (endChunk) {
    for (let i = 0; i < endChunk.length; i++) {
      data[index++] = endChunk[i];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}
},{}],"node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));
var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));
var Polygon = _interopRequireWildcard(require("../solid-polygon-layer/polygon"));
var _utils = require("../utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultLineColor = [0, 0, 0, 255];
const defaultFillColor = [0, 0, 0, 255];
const defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: 'CW',
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: {
    type: 'accessor',
    value: f => f.polygon
  },
  getFillColor: {
    type: 'accessor',
    value: defaultFillColor
  },
  getLineColor: {
    type: 'accessor',
    value: defaultLineColor
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: true
};
class PolygonLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      paths: []
    };
    if (this.props.getLineDashArray) {
      _core.log.removed('getLineDashArray', 'PathStyleExtension')();
    }
  }
  updateState({
    changeFlags
  }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map(dataRange => (0, _utils.replaceInRange)({
        data: paths,
        getIndex: p => p.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({
        paths,
        pathsDiff
      });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const {
      data,
      getPolygon,
      positionFormat,
      _normalize
    } = this.props;
    const paths = [];
    const positionSize = positionFormat === 'XY' ? 2 : 3;
    const {
      startRow,
      endRow
    } = dataRange;
    const {
      iterable,
      objectInfo
    } = (0, _core.createIterable)(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = Polygon.normalize(polygon, positionSize);
      }
      const {
        holeIndices
      } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
          paths.push(this.getSubLayerRow({
            path
          }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({
          path: positions
        }, object, objectInfo.index));
      }
    }
    return paths;
  }
  renderLayers() {
    const {
      data,
      _dataDiff,
      stroked,
      filled,
      extruded,
      wireframe,
      _normalize,
      _windingOrder,
      elevationScale,
      transitions,
      positionFormat
    } = this.props;
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified
    } = this.props;
    const {
      getFillColor,
      getLineColor,
      getLineWidth,
      getLineDashArray,
      getElevation,
      getPolygon,
      updateTriggers,
      material
    } = this.props;
    const {
      paths,
      pathsDiff
    } = this.state;
    const FillLayer = this.getSubLayerClass('fill', _solidPolygonLayer.default);
    const StrokeLayer = this.getSubLayerClass('stroke', _pathLayer.default);
    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: 'fill',
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      _pathType: 'loop',
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: 'stroke',
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: x => x.path
    });
    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];
  }
}
exports.default = PolygonLayer;
(0, _defineProperty2.default)(PolygonLayer, "layerName", 'PolygonLayer');
(0, _defineProperty2.default)(PolygonLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","../path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/polygon":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","../utils":"node_modules/@deck.gl/layers/dist/esm/utils.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binaryToFeatureForAccesor = binaryToFeatureForAccesor;
exports.calculatePickingColors = calculatePickingColors;
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: {
      ...data.properties[propertiesIndex]
    }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
    const pickingColor = [];
    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 3 + 0] = pickingColor[0];
      pickingColors[key][i * 3 + 1] = pickingColor[1];
      pickingColors[key][i * 3 + 2] = pickingColor[2];
    }
  }
  return pickingColors;
}
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _iconLayer = _interopRequireDefault(require("../../icon-layer/icon-layer"));
var _multiIconLayerFragment = _interopRequireDefault(require("./multi-icon-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_BUFFER = 192.0 / 256;
const EMPTY_ARRAY = [];
const defaultProps = {
  getIconOffsets: {
    type: 'accessor',
    value: x => x.offsets
  },
  alphaCutoff: 0.001,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: {
    type: 'color',
    value: [0, 0, 0, 255]
  }
};
class MultiIconLayer extends _iconLayer.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return {
      ...super.getShaders(),
      fs: _multiIconLayerFragment.default
    };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: 'getIconOffsets'
      },
      instancePickingColors: {
        type: 5121,
        size: 3,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    let {
      outlineColor
    } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map(x => x / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      _core.log.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))();
    }
  }
  draw(params) {
    const {
      sdf,
      smoothing,
      outlineWidth
    } = this.props;
    const {
      outlineColor
    } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;
    params.uniforms = {
      ...params.uniforms,
      sdfBuffer: DEFAULT_BUFFER,
      outlineBuffer,
      gamma: smoothing,
      sdf: Boolean(sdf),
      outlineColor
    };
    super.draw(params);
    if (sdf && outlineWidth) {
      const {
        iconManager
      } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        this.state.model.draw({
          uniforms: {
            outlineBuffer: DEFAULT_BUFFER
          }
        });
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
}
exports.default = MultiIconLayer;
(0, _defineProperty2.default)(MultiIconLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(MultiIconLayer, "layerName", 'MultiIconLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../../icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./multi-icon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js"}],"node_modules/@mapbox/tiny-sdf/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const INF = 1e20;
class TinySDF {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = 'sans-serif',
    fontWeight = 'normal',
    fontStyle = 'normal'
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;

    // make the canvas size big enough to both have the specified buffer around the glyph
    // for "halo", and account for some glyphs possibly being larger than their font size
    const size = this.size = fontSize + buffer * 4;
    const canvas = this._createCanvas(size);
    const ctx = this.ctx = canvas.getContext('2d', {
      willReadFrequently: true
    });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = 'alphabetic';
    ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
    ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);

    // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
    // The remainder is implicitly encoded in the rasterization
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;

    // If the glyph overflows the canvas size, it will be clipped at the bottom/right
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len);
    const glyph = {
      data,
      width,
      height,
      glyphWidth,
      glyphHeight,
      glyphTop,
      glyphLeft,
      glyphAdvance
    };
    if (glyphWidth === 0 || glyphHeight === 0) return glyph;
    const {
      ctx,
      buffer,
      gridInner,
      gridOuter
    } = this;
    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);

    // Initialize grids outside the glyph range to alpha 0
    gridOuter.fill(INF, 0, len);
    gridInner.fill(0, 0, len);
    for (let y = 0; y < glyphHeight; y++) {
      for (let x = 0; x < glyphWidth; x++) {
        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
        if (a === 0) continue; // empty pixels

        const j = (y + buffer) * width + x + buffer;
        if (a === 1) {
          // fully drawn pixels
          gridOuter[j] = 0;
          gridInner[j] = INF;
        } else {
          // aliased pixels
          const d = 0.5 - a;
          gridOuter[j] = d > 0 ? d * d : 0;
          gridInner[j] = d < 0 ? d * d : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i = 0; i < len; i++) {
      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
      data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
    }
    return glyph;
  }
}

// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
exports.default = TinySDF;
function edt(data, x0, y0, width, height, gridSize, f, v, z) {
  for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
  for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);
}

// 1D squared distance transform
function edt1d(grid, offset, stride, length, f, v, z) {
  v[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f[0] = grid[offset];
  for (let q = 1, k = 0, s = 0; q < length; q++) {
    f[q] = grid[offset + q * stride];
    const q2 = q * q;
    do {
      const r = v[k];
      s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
    } while (s <= z[k] && --k > -1);
    k++;
    v[k] = q;
    z[k] = s;
    z[k + 1] = INF;
  }
  for (let q = 0, k = 0; q < length; q++) {
    while (z[k + 1] < q) k++;
    const r = v[k];
    const qr = q - r;
    grid[offset + q * stride] = f[r] + qr * qr;
  }
}
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoWrapping = autoWrapping;
exports.buildMapping = buildMapping;
exports.getTextFromBuffer = getTextFromBuffer;
exports.nextPowOfTwo = nextPowOfTwo;
exports.transformParagraph = transformParagraph;
var _core = require("@deck.gl/core");
const MISSING_CHAR_WIDTH = 32;
const SINGLE_LINE = [];
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  let x = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }
      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i = startIndex; i < endIndex; i++) {
    var _mapping$character;
    const character = text[i];
    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === ' ') {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === undefined) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === 'break-all') {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x = 0;
  let rowHeight = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i] = x + frame.layoutWidth / 2;
      x += frame.layoutWidth;
    } else {
      _core.log.warn("Missing character: ".concat(character, " (").concat(character.codePointAt(0), ")"))();
      leftOffsets[i] = x;
      x += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x = new Array(numCharacters);
  const y = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i = 0; i <= numCharacters; i++) {
    const char = characters[i];
    if (char === '\n' || i === numCharacters) {
      lineEndIndex = i;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          var _iconMapping$char;
          const char = characters[j];
          const layoutOffsetY = ((_iconMapping$char = iconMapping[char]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;
          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === '\n') {
      x[lineStartIndex] = 0;
      y[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return {
    x,
    y,
    rowWidth,
    size
  };
}
function getTextFromBuffer({
  value,
  length,
  stride,
  offset,
  startIndices,
  characterSet
}) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && new Set();
  const texts = new Array(length);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return {
    texts,
    characterCount
  };
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LRUCache {
  constructor(limit = 5) {
    (0, _defineProperty2.default)(this, "limit", void 0);
    (0, _defineProperty2.default)(this, "_cache", {});
    (0, _defineProperty2.default)(this, "_order", []);
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
}
exports.default = LRUCache;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_FONT_SETTINGS = void 0;
exports.setFontAtlasCacheLimit = setFontAtlasCacheLimit;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _tinySdf = _interopRequireDefault(require("@mapbox/tiny-sdf"));
var _core = require("@deck.gl/core");
var _utils = require("./utils");
var _lruCache = _interopRequireDefault(require("./lru-cache"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
const DEFAULT_FONT_SETTINGS = {
  fontFamily: 'Monaco, monospace',
  fontWeight: 'normal',
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
exports.DEFAULT_FONT_SETTINGS = DEFAULT_FONT_SETTINGS;
const MAX_CANVAS_WIDTH = 1024;
const BASELINE_SCALE = 0.9;
const HEIGHT_SCALE = 1.2;
const CACHE_LIMIT = 3;
let cache = new _lruCache.default(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === 'string') {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign = 'left';
}
function setFontAtlasCacheLimit(limit) {
  _core.log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');
  cache = new _lruCache.default(limit);
}
class FontAtlasManager {
  constructor() {
    (0, _defineProperty2.default)(this, "props", {
      ...DEFAULT_FONT_SETTINGS
    });
    (0, _defineProperty2.default)(this, "_key", void 0);
    (0, _defineProperty2.default)(this, "_atlas", void 0);
  }
  get texture() {
    return this._atlas;
  }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const {
      fontSize,
      buffer
    } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext('2d', {
      willReadFrequently: true
    });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const {
      mapping,
      canvasHeight,
      xOffset,
      yOffset
    } = (0, _utils.buildMapping)({
      getFontWidth: char => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...(cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      })
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new _tinySdf.default({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: "".concat(fontWeight)
      });
      for (const char of characterSet) {
        const {
          data,
          width,
          height,
          glyphTop
        } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    if (sdf) {
      return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
    }
    return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
  }
}
exports.default = FontAtlasManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@mapbox/tiny-sdf":"node_modules/@mapbox/tiny-sdf/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./utils":"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","./lru-cache":"node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _textBackgroundLayerVertex = _interopRequireDefault(require("./text-background-layer-vertex.glsl"));
var _textBackgroundLayerFragment = _interopRequireDefault(require("./text-background-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultProps = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  padding: {
    type: 'array',
    value: [0, 0, 0, 0]
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  getBoundingRect: {
    type: 'accessor',
    value: [0, 0, 0, 0]
  },
  getFillColor: {
    type: 'accessor',
    value: [0, 0, 0, 255]
  },
  getLineColor: {
    type: 'accessor',
    value: [0, 0, 0, 255]
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  }
};
class TextBackgroundLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _textBackgroundLayerVertex.default,
      fs: _textBackgroundLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle'
      },
      instanceRects: {
        size: 4,
        accessor: 'getBoundingRect'
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      changeFlags
    } = params;
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      getLineWidth
    } = this.props;
    let {
      padding
    } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    this.state.model.setUniforms(uniforms).setUniforms({
      billboard,
      stroked: Boolean(getLineWidth),
      padding,
      sizeUnits: _core.UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const positions = [0, 0, 1, 0, 1, 1, 0, 1];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = TextBackgroundLayer;
(0, _defineProperty2.default)(TextBackgroundLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(TextBackgroundLayer, "layerName", 'TextBackgroundLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./text-background-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js","./text-background-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _multiIconLayer = _interopRequireDefault(require("./multi-icon-layer/multi-icon-layer"));
var _fontAtlasManager = _interopRequireWildcard(require("./font-atlas-manager"));
var _utils = require("./utils");
var _textBackgroundLayer = _interopRequireDefault(require("./text-background-layer/text-background-layer"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
const ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_LINE_HEIGHT = 1.0;
const defaultProps = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: {
    type: 'accessor',
    value: [255, 255, 255, 255]
  },
  getBorderColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getBorderWidth: {
    type: 'accessor',
    value: 0
  },
  backgroundPadding: {
    type: 'array',
    value: [0, 0, 0, 0]
  },
  characterSet: {
    type: 'object',
    value: _fontAtlasManager.DEFAULT_FONT_SETTINGS.characterSet
  },
  fontFamily: _fontAtlasManager.DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: _fontAtlasManager.DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: {
    type: 'number',
    value: 0,
    min: 0
  },
  outlineColor: {
    type: 'color',
    value: DEFAULT_COLOR
  },
  fontSettings: {
    type: 'object',
    value: {},
    compare: 1
  },
  wordBreak: 'break-word',
  maxWidth: {
    type: 'number',
    value: -1
  },
  getText: {
    type: 'accessor',
    value: x => x.text
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 32
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getTextAnchor: {
    type: 'accessor',
    value: 'middle'
  },
  getAlignmentBaseline: {
    type: 'accessor',
    value: 'center'
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  backgroundColor: {
    deprecatedFor: ['background', 'getBackgroundColor']
  }
};
class TextLayer extends _core.CompositeLayer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "getBoundingRect", (object, objectInfo) => {
      let {
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const {
        fontSize
      } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    });
    (0, _defineProperty2.default)(this, "getIconOffsets", (object, objectInfo) => {
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const {
        x,
        y,
        rowWidth,
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i = 0; i < numCharacters; i++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];
        offsets[index++] = (anchorY - 1) * height / 2 + y[i];
      }
      return offsets;
    });
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new _fontAtlasManager.default()
    };
    if (this.props.maxWidth > 0) {
      _core.log.warn('v8.9 breaking change: TextLayer maxWidth is now relative to text size')();
    }
  }
  updateState(params) {
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({
    info
  }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  _updateFontAtlas() {
    const {
      fontSettings,
      fontFamily,
      fontWeight
    } = this.props;
    const {
      fontAtlasManager,
      characterSet
    } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  _updateText() {
    var _attributes;
    const {
      data,
      characterSet
    } = this.props;
    const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;
    let {
      getText
    } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === 'auto' && new Set();
    if (textBuffer && startIndices) {
      const {
        texts,
        characterCount
      } = (0, _utils.getTextFromBuffer)({
        ...(ArrayBuffer.isView(textBuffer) ? {
          value: textBuffer
        } : textBuffer),
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_, {
        index
      }) => texts[index];
    } else {
      const {
        iterable,
        objectInfo
      } = (0, _core.createIterable)(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || '');
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  transformParagraph(object, objectInfo) {
    const {
      fontAtlasManager
    } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const {
      wordBreak,
      lineHeight,
      maxWidth
    } = this.props;
    const paragraph = getText(object, objectInfo) || '';
    return (0, _utils.transformParagraph)(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const {
      startIndices,
      numInstances,
      getText,
      fontAtlasManager: {
        scale,
        texture,
        mapping
      },
      styleVersion
    } = this.state;
    const {
      data,
      _dataDiff,
      getPosition,
      getColor,
      getSize,
      getAngle,
      getPixelOffset,
      getBackgroundColor,
      getBorderColor,
      getBorderWidth,
      backgroundPadding,
      background,
      billboard,
      fontSettings,
      outlineWidth,
      outlineColor,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions,
      updateTriggers
    } = this.props;
    const CharactersLayerClass = this.getSubLayerClass('characters', _multiIconLayer.default);
    const BackgroundLayerClass = this.getSubLayerClass('background', _textBackgroundLayer.default);
    return [background && new BackgroundLayerClass({
      getFillColor: getBackgroundColor,
      getLineColor: getBorderColor,
      getLineWidth: getBorderWidth,
      padding: backgroundPadding,
      getPosition,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getSize: transitions.getSize,
        getFillColor: transitions.getBackgroundColor,
        getLineColor: transitions.getBorderColor,
        getLineWidth: transitions.getBorderWidth,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: 'background',
      updateTriggers: {
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getSize: updateTriggers.getSize,
        getFillColor: updateTriggers.getBackgroundColor,
        getLineColor: updateTriggers.getBorderColor,
        getLineWidth: updateTriggers.getBorderWidth,
        getPixelOffset: updateTriggers.getPixelOffset,
        getBoundingRect: {
          getText: updateTriggers.getText,
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data: data.attributes && data.attributes.background ? {
        length: data.length,
        attributes: data.attributes.background
      } : data,
      _dataDiff,
      autoHighlight: false,
      getBoundingRect: this.getBoundingRect
    }), new CharactersLayerClass({
      sdf: fontSettings.sdf,
      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : _fontAtlasManager.DEFAULT_FONT_SETTINGS.smoothing,
      outlineWidth: outlineWidth / (fontSettings.radius || _fontAtlasManager.DEFAULT_FONT_SETTINGS.radius),
      outlineColor,
      iconAtlas: texture,
      iconMapping: mapping,
      getPosition,
      getColor,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale: sizeScale * scale,
      sizeUnits,
      sizeMinPixels: sizeMinPixels * scale,
      sizeMaxPixels: sizeMaxPixels * scale,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getColor: transitions.getColor,
        getSize: transitions.getSize,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: 'characters',
      updateTriggers: {
        all: updateTriggers.getText,
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getColor: updateTriggers.getColor,
        getSize: updateTriggers.getSize,
        getPixelOffset: updateTriggers.getPixelOffset,
        getIconOffsets: {
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data,
      _dataDiff,
      startIndices,
      numInstances,
      getIconOffsets: this.getIconOffsets,
      getIcon: getText
    })];
  }
  static set fontAtlasCacheLimit(limit) {
    (0, _fontAtlasManager.setFontAtlasCacheLimit)(limit);
  }
}
exports.default = TextLayer;
(0, _defineProperty2.default)(TextLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(TextLayer, "layerName", 'TextLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./multi-icon-layer/multi-icon-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./font-atlas-manager":"node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js","./utils":"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","./text-background-layer/text-background-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.POLYGON_LAYER = exports.POINT_LAYER = exports.LINE_LAYER = void 0;
exports.forwardProps = forwardProps;
exports.getDefaultProps = getDefaultProps;
var _iconLayer = _interopRequireDefault(require("../icon-layer/icon-layer"));
var _scatterplotLayer = _interopRequireDefault(require("../scatterplot-layer/scatterplot-layer"));
var _textLayer = _interopRequireDefault(require("../text-layer/text-layer"));
var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));
var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const POINT_LAYER = {
  circle: {
    type: _scatterplotLayer.default,
    props: {
      filled: 'filled',
      stroked: 'stroked',
      lineWidthMaxPixels: 'lineWidthMaxPixels',
      lineWidthMinPixels: 'lineWidthMinPixels',
      lineWidthScale: 'lineWidthScale',
      lineWidthUnits: 'lineWidthUnits',
      pointRadiusMaxPixels: 'radiusMaxPixels',
      pointRadiusMinPixels: 'radiusMinPixels',
      pointRadiusScale: 'radiusScale',
      pointRadiusUnits: 'radiusUnits',
      pointAntialiasing: 'antialiasing',
      pointBillboard: 'billboard',
      getFillColor: 'getFillColor',
      getLineColor: 'getLineColor',
      getLineWidth: 'getLineWidth',
      getPointRadius: 'getRadius'
    }
  },
  icon: {
    type: _iconLayer.default,
    props: {
      iconAtlas: 'iconAtlas',
      iconMapping: 'iconMapping',
      iconSizeMaxPixels: 'sizeMaxPixels',
      iconSizeMinPixels: 'sizeMinPixels',
      iconSizeScale: 'sizeScale',
      iconSizeUnits: 'sizeUnits',
      iconAlphaCutoff: 'alphaCutoff',
      iconBillboard: 'billboard',
      getIcon: 'getIcon',
      getIconAngle: 'getAngle',
      getIconColor: 'getColor',
      getIconPixelOffset: 'getPixelOffset',
      getIconSize: 'getSize'
    }
  },
  text: {
    type: _textLayer.default,
    props: {
      textSizeMaxPixels: 'sizeMaxPixels',
      textSizeMinPixels: 'sizeMinPixels',
      textSizeScale: 'sizeScale',
      textSizeUnits: 'sizeUnits',
      textBackground: 'background',
      textBackgroundPadding: 'backgroundPadding',
      textFontFamily: 'fontFamily',
      textFontWeight: 'fontWeight',
      textLineHeight: 'lineHeight',
      textMaxWidth: 'maxWidth',
      textOutlineColor: 'outlineColor',
      textOutlineWidth: 'outlineWidth',
      textWordBreak: 'wordBreak',
      textCharacterSet: 'characterSet',
      textBillboard: 'billboard',
      textFontSettings: 'fontSettings',
      getText: 'getText',
      getTextAngle: 'getAngle',
      getTextColor: 'getColor',
      getTextPixelOffset: 'getPixelOffset',
      getTextSize: 'getSize',
      getTextAnchor: 'getTextAnchor',
      getTextAlignmentBaseline: 'getAlignmentBaseline',
      getTextBackgroundColor: 'getBackgroundColor',
      getTextBorderColor: 'getBorderColor',
      getTextBorderWidth: 'getBorderWidth'
    }
  }
};
exports.POINT_LAYER = POINT_LAYER;
const LINE_LAYER = {
  type: _pathLayer.default,
  props: {
    lineWidthUnits: 'widthUnits',
    lineWidthScale: 'widthScale',
    lineWidthMinPixels: 'widthMinPixels',
    lineWidthMaxPixels: 'widthMaxPixels',
    lineJointRounded: 'jointRounded',
    lineCapRounded: 'capRounded',
    lineMiterLimit: 'miterLimit',
    lineBillboard: 'billboard',
    getLineColor: 'getColor',
    getLineWidth: 'getWidth'
  }
};
exports.LINE_LAYER = LINE_LAYER;
const POLYGON_LAYER = {
  type: _solidPolygonLayer.default,
  props: {
    extruded: 'extruded',
    filled: 'filled',
    wireframe: 'wireframe',
    elevationScale: 'elevationScale',
    material: 'material',
    _full3d: '_full3d',
    getElevation: 'getElevation',
    getFillColor: 'getFillColor',
    getLineColor: 'getLineColor'
  }
};
exports.POLYGON_LAYER = POLYGON_LAYER;
function getDefaultProps({
  type,
  props
}) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const {
    transitions,
    updateTriggers
  } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith('get')) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}
},{"../icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","../scatterplot-layer/scatterplot-layer":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","../text-layer/text-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","../path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeojsonFeatures = getGeojsonFeatures;
exports.separateGeojsonFeatures = separateGeojsonFeatures;
exports.validateGeometry = validateGeometry;
var _core = require("@deck.gl/core");
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  _core.log.assert(geojson.type, 'GeoJSON does not have type');
  switch (geojson.type) {
    case 'Feature':
      return [geojson];
    case 'FeatureCollection':
      _core.log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');
      return geojson.features;
    default:
      return [{
        geometry: geojson
      }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const {
    startRow = 0,
    endRow = features.length
  } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const {
      geometry
    } = feature;
    if (!geometry) {
      continue;
    }
    if (geometry.type === 'GeometryCollection') {
      _core.log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');
      const {
        geometries
      } = geometry;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const {
    type,
    coordinates
  } = geometry;
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = separated;
  if (!validateGeometry(type, coordinates)) {
    _core.log.warn("".concat(type, " coordinates are malformed"))();
    return;
  }
  switch (type) {
    case 'Point':
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case 'MultiPoint':
      coordinates.forEach(point => {
        pointFeatures.push(wrapFeature({
          geometry: {
            type: 'Point',
            coordinates: point
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case 'LineString':
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case 'MultiLineString':
      coordinates.forEach(path => {
        lineFeatures.push(wrapFeature({
          geometry: {
            type: 'LineString',
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case 'Polygon':
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach(path => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: {
            type: 'LineString',
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case 'MultiPolygon':
      coordinates.forEach(polygon => {
        polygonFeatures.push(wrapFeature({
          geometry: {
            type: 'Polygon',
            coordinates: polygon
          }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach(path => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: 'LineString',
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
const COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  _core.log.assert(nestLevel, "Unknown GeoJSON type ".concat(type));
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLayerPropsFromBinary = createLayerPropsFromBinary;
exports.createLayerPropsFromFeatures = createLayerPropsFromFeatures;
var _geojsonBinary = require("./geojson-binary");
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f) {
  return f.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const {
    points,
    lines,
    polygons
  } = geojsonBinary;
  const customPickingColors = (0, _geojsonBinary.calculatePickingColors)(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = 'open';
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = 'open';
  return layerProps;
}
},{"./geojson-binary":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _utils = require("../utils");
var _geojsonBinary = require("./geojson-binary");
var _subLayerMap = require("./sub-layer-map");
var _geojson = require("./geojson");
var _geojsonLayerProps = require("./geojson-layer-props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const FEATURE_TYPES = ['points', 'linestrings', 'polygons'];
const defaultProps = {
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.circle),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.icon),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.text),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.LINE_LAYER),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POLYGON_LAYER),
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: {
    type: 'object',
    value: null
  },
  iconMapping: {
    type: 'object',
    value: {}
  },
  getIcon: {
    type: 'accessor',
    value: f => f.properties.icon
  },
  getText: {
    type: 'accessor',
    value: f => f.properties.text
  },
  pointType: 'circle',
  getRadius: {
    deprecatedFor: 'getPointRadius'
  }
};
class GeoJsonLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {}
    };
  }
  updateState({
    props,
    changeFlags
  }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const {
      data
    } = this.props;
    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;
    this.setState({
      binary
    });
    if (binary) {
      this._updateStateBinary({
        props,
        changeFlags
      });
    } else {
      this._updateStateJSON({
        props,
        changeFlags
      });
    }
  }
  _updateStateBinary({
    props,
    changeFlags
  }) {
    const layerProps = (0, _geojsonLayerProps.createLayerPropsFromBinary)(props.data, this.encodePickingColor);
    this.setState({
      layerProps
    });
  }
  _updateStateJSON({
    props,
    changeFlags
  }) {
    const features = (0, _geojson.getGeojsonFeatures)(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = (0, _geojson.separateGeojsonFeatures)(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push((0, _utils.replaceInRange)({
            data: newFeatures[key],
            getIndex: f => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = (0, _geojson.separateGeojsonFeatures)(features, wrapFeature);
    }
    const layerProps = (0, _geojsonLayerProps.createLayerPropsFromFeatures)(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index,
      sourceLayer
    } = info;
    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith("".concat(this.id, "-").concat(ft, "-")));
    if (index >= 0 && sourceLayer.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = "".concat(this.id, "-points-");
    const sourceIsPoints = info.featureType === 'points';
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    const {
      extruded,
      wireframe
    } = this.props;
    const {
      layerProps
    } = this.state;
    const id = 'polygons-fill';
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, _subLayerMap.POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = (0, _subLayerMap.forwardProps)(this, _subLayerMap.POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const {
      extruded,
      stroked
    } = this.props;
    const {
      layerProps
    } = this.state;
    const polygonStrokeLayerId = 'polygons-stroke';
    const lineStringsLayerId = 'linestrings';
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, _subLayerMap.LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, _subLayerMap.LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = (0, _subLayerMap.forwardProps)(this, _subLayerMap.LINE_LAYER.props);
      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
        id: polygonStrokeLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
        id: lineStringsLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.lines)];
    }
    return null;
  }
  _renderPointLayers() {
    const {
      pointType
    } = this.props;
    const {
      layerProps,
      binary
    } = this.state;
    let {
      highlightedObjectIndex
    } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split('+'));
    const pointLayers = [];
    for (const type of types) {
      const id = "points-".concat(type);
      const PointLayerMapping = _subLayerMap.POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = (0, _subLayerMap.forwardProps)(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === 'text' && binary) {
          const {
            instancePickingColors,
            ...rest
          } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            data: {
              ...pointsLayerProps.data,
              attributes: rest
            }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const {
      extruded
    } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];
  }
  getSubLayerAccessor(accessor) {
    const {
      binary
    } = this.state;
    if (!binary || typeof accessor !== 'function') {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const {
        data,
        index
      } = info;
      const feature = (0, _geojsonBinary.binaryToFeatureForAccesor)(data, index);
      return accessor(feature, info);
    };
  }
}
exports.default = GeoJsonLayer;
(0, _defineProperty2.default)(GeoJsonLayer, "layerName", 'GeoJsonLayer');
(0, _defineProperty2.default)(GeoJsonLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../utils":"node_modules/@deck.gl/layers/dist/esm/utils.js","./geojson-binary":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js","./sub-layer-map":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js","./geojson":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js","./geojson-layer-props":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js"}],"node_modules/@deck.gl/layers/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArcLayer", {
  enumerable: true,
  get: function () {
    return _arcLayer.default;
  }
});
Object.defineProperty(exports, "BitmapLayer", {
  enumerable: true,
  get: function () {
    return _bitmapLayer.default;
  }
});
Object.defineProperty(exports, "ColumnLayer", {
  enumerable: true,
  get: function () {
    return _columnLayer.default;
  }
});
Object.defineProperty(exports, "GeoJsonLayer", {
  enumerable: true,
  get: function () {
    return _geojsonLayer.default;
  }
});
Object.defineProperty(exports, "GridCellLayer", {
  enumerable: true,
  get: function () {
    return _gridCellLayer.default;
  }
});
Object.defineProperty(exports, "IconLayer", {
  enumerable: true,
  get: function () {
    return _iconLayer.default;
  }
});
Object.defineProperty(exports, "LineLayer", {
  enumerable: true,
  get: function () {
    return _lineLayer.default;
  }
});
Object.defineProperty(exports, "PathLayer", {
  enumerable: true,
  get: function () {
    return _pathLayer.default;
  }
});
Object.defineProperty(exports, "PointCloudLayer", {
  enumerable: true,
  get: function () {
    return _pointCloudLayer.default;
  }
});
Object.defineProperty(exports, "PolygonLayer", {
  enumerable: true,
  get: function () {
    return _polygonLayer.default;
  }
});
Object.defineProperty(exports, "ScatterplotLayer", {
  enumerable: true,
  get: function () {
    return _scatterplotLayer.default;
  }
});
Object.defineProperty(exports, "SolidPolygonLayer", {
  enumerable: true,
  get: function () {
    return _solidPolygonLayer.default;
  }
});
Object.defineProperty(exports, "TextLayer", {
  enumerable: true,
  get: function () {
    return _textLayer.default;
  }
});
Object.defineProperty(exports, "_MultiIconLayer", {
  enumerable: true,
  get: function () {
    return _multiIconLayer.default;
  }
});
Object.defineProperty(exports, "_TextBackgroundLayer", {
  enumerable: true,
  get: function () {
    return _textBackgroundLayer.default;
  }
});
var _arcLayer = _interopRequireDefault(require("./arc-layer/arc-layer"));
var _bitmapLayer = _interopRequireDefault(require("./bitmap-layer/bitmap-layer"));
var _iconLayer = _interopRequireDefault(require("./icon-layer/icon-layer"));
var _lineLayer = _interopRequireDefault(require("./line-layer/line-layer"));
var _pointCloudLayer = _interopRequireDefault(require("./point-cloud-layer/point-cloud-layer"));
var _scatterplotLayer = _interopRequireDefault(require("./scatterplot-layer/scatterplot-layer"));
var _columnLayer = _interopRequireDefault(require("./column-layer/column-layer"));
var _gridCellLayer = _interopRequireDefault(require("./column-layer/grid-cell-layer"));
var _pathLayer = _interopRequireDefault(require("./path-layer/path-layer"));
var _polygonLayer = _interopRequireDefault(require("./polygon-layer/polygon-layer"));
var _geojsonLayer = _interopRequireDefault(require("./geojson-layer/geojson-layer"));
var _textLayer = _interopRequireDefault(require("./text-layer/text-layer"));
var _solidPolygonLayer = _interopRequireDefault(require("./solid-polygon-layer/solid-polygon-layer"));
var _multiIconLayer = _interopRequireDefault(require("./text-layer/multi-icon-layer/multi-icon-layer"));
var _textBackgroundLayer = _interopRequireDefault(require("./text-layer/text-background-layer/text-background-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./arc-layer/arc-layer":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js","./bitmap-layer/bitmap-layer":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js","./icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./line-layer/line-layer":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js","./point-cloud-layer/point-cloud-layer":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js","./scatterplot-layer/scatterplot-layer":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","./column-layer/column-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js","./column-layer/grid-cell-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","./path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","./polygon-layer/polygon-layer":"node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js","./geojson-layer/geojson-layer":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js","./text-layer/text-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","./solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","./text-layer/multi-icon-layer/multi-icon-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./text-layer/text-background-layer/text-background-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"}],"node_modules/@here/xyz-maps-common/dist/xyz-maps-common.esm.min.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec3 = exports.parseJSONArray = exports.global = exports.geotools = exports.geometry = exports.default = exports.TaskManager = exports.Task = exports.Set = exports.Queue = exports.Map = exports.Listener = exports.LRU = exports.JSUtils = void 0;
/*
 * @here/xyz-maps-common
 * (c) 2019-2022 HERE
 */
var t = "undefined" != typeof window ? window : global,
  e = 0,
  n = function () {
    function t(t, n, r, i, o, a, s, u) {
      this.id = ++e, this.exec = r, i && (this.init = i), this.delay = 0 ^ u, this.name = s, this.time = o || 100, this.priority = Math.max(Math.min(0 ^ n, 5), 1), this.manager = t, a && (this.onDone = a);
    }
    return t.prototype.start = function (t) {
      var e = this;
      return e._data = t, e.manager.start(e);
    }, t.prototype.restart = function (t) {
      void 0 === t && (t = {});
      var e = this._data;
      this.cancel(), this.canceled = !1, this.paused = !1, this.delayed = null, this.heap = null, this._data = e, t.init && (this.init = t.init), t.priority && (this.priority = t.priority), t.onDone && (this.onDone = t.onDone), this.start();
    }, t.prototype.init = function (t) {
      return t;
    }, t.prototype.cancel = function () {
      var t = this;
      return t._data = null, t.manager.cancel(t);
    }, t;
  }();
exports.Task = n;
exports.global = t;
n.prototype.CONTINUE = !0, n.prototype.BREAK = !1, n.prototype.onDone = null, n.prototype.heap = null, n.prototype.paused = !1, n.prototype.delayed = null, n.prototype.yielded = !1, n.prototype.canceled = !1;
var r,
  i = 1e3 / 60,
  o = 0,
  a = function () {
    function e(e) {
      this.time = i, this._delayed = null, this.now = Date.now;
      var n = this;
      if (n.queue = [[], [], [], [], [], []], n.id = o++, n.active = !1, e > 1 && (n.time = e || i), t.postMessage) {
        var r = "tm-" + n.id;
        t.addEventListener("message", function (e) {
          e.source == t && e.data == r && (e.stopPropagation(), n.runner());
        }, !0), n._resume = function () {
          n.active = !0, t.postMessage(r, "*");
        };
      } else n._resume = function () {
        n.active = !0, setTimeout(n.runner.bind(n), 0);
      };
    }
    return e.prototype.runner = function (t) {
      var e,
        n,
        r,
        i,
        o,
        a,
        s,
        u,
        h,
        c = this,
        l = !0;
      if (t = t || c.now(), c.active) {
        for (; (l = c.now() - t < c.time) && (c.task = a = c._next());) {
          for (h = !1, s = !1, a.paused ? (a.paused = !1, u = a.heap) : (r = c.now(), u = a.init(a._data)); !s;) if (i = r || c.now(), s = !a.exec(u) || a.canceled, n = (o = c.now()) - i, r = null, e = o - t > c.time, c.task = null, !s && (a.paused || n >= a.time) || e) {
            if (s || (c._insert(c.task = a, !0), a.paused = !0, a.heap = u), e) return s && !a.canceled && (a.started = !1, a.onDone && a.onDone(u)), c._resume();
            h = !0;
            break;
          }
          h || (a.paused = !1, a.heap = null, a.canceled || (a.started = !1, a.onDone && a.onDone(u)));
        }
        if (!l) return c._resume();
        c.active = !1;
      } else c._resume();
    }, e.prototype.setExclusiveTime = function (t) {
      this.time = 0 ^ t;
    }, e.prototype._next = function () {
      var e,
        n = this,
        r = n.queue,
        i = r[0][0],
        o = n.now();
      if (i && o >= i.delayed) return n._delayed && t.clearTimeout(n._delayed), n.queue[0].shift();
      for (var a = 1, s = r.length; a < s; a++) if (e = r[a].shift()) return e;
      i && (n._delayed && t.clearTimeout(n._delayed), n._delayed = t.setTimeout(function () {
        n._delayed = null, n.active = !0, n.runner();
      }, i.delayed - o));
    }, e.prototype.create = function (t) {
      return new n(this, t.priority, t.exec, t.init, t.time, t.onDone, t.name, t.delay);
    }, e.prototype._insert = function (t, e) {
      var n;
      if (t.delay) {
        t.delayed = this.now() + t.delay;
        for (var r = 0, i = (n = this.queue[0]).length - 1, o = void 0; r <= i;) if (n[o = (r + i) / 2 | 0].delayed > t.delayed) i = o - 1;else if (r = o + 1, n[o].delayed == t.delayed) break;
        n.splice(r, 0, t);
      } else n = this.queue[t.priority], e ? n.unshift(t) : n.push(t);
    }, e.prototype.isWaiting = function (t) {
      return -1 != this.queue[t.delay ? 0 : t.priority].indexOf(t);
    }, e.prototype.start = function (t, e) {
      var n = this.task;
      t.started || (t.started = !0, t != n && (t.canceled = !1, this._insert(t), this.active ? n && n.priority > t.priority && (n.paused = !0) : (this.active = !!e, this.runner())));
    }, e.prototype.cancel = function (t) {
      t.canceled = !0, t.paused = !1, t.started = !1;
      var e = t == this.task,
        n = t.delay ? 0 : t.priority,
        r = this.queue[n],
        i = r.indexOf(t);
      return -1 != i && r.splice(i, 1), e && (this.task = null), e;
    }, e;
  }(),
  s = {
    getInstance: function (t) {
      return r ? "number" == typeof t && (r.time = t) : r = this.createInstance(t), r;
    },
    createInstance: function (t) {
      return this.active = !0, new a(t);
    },
    active: !1
  },
  u = function (t, e, n) {
    for (var r = -1, i = 0; i < t.length; i++) if (t[i][0] == e && t[i][1] == n) {
      r = i;
      break;
    }
    return r;
  },
  h = function () {
    function t(t) {
      this._l = {}, this._sync = !1, this._exec = {};
      for (var e = 0; e < t.length; e++) this.addEvent(t[e]);
    }
    return t.prototype.addEvent = function (t) {
      this._l[t] || (this._l[t] = [], this._exec[t] = undefined);
    }, t.prototype.sync = function (t) {
      return this._sync = !!t, this;
    }, t.prototype.removeEvent = function (t) {
      delete this._l[t];
    }, t.prototype.getEvents = function () {
      var t = [];
      for (var e in this._l) t[t.length] = e;
      return t;
    }, t.prototype.get = function (t) {
      var e = this._l[t];
      return e && e.slice();
    }, t.prototype.isDefined = function (t) {
      return !!this._l[t];
    }, t.prototype.isListened = function (t) {
      return this._l[t] && this._l[t].length;
    }, t.prototype.add = function (t, e, n) {
      var r = !1;
      return this._l.hasOwnProperty(t) && -1 == u(this._l[t], e, n) && (this._l[t].push([e, n]), r = !0), r;
    }, t.prototype.remove = function (t, e, n) {
      if (this._l.hasOwnProperty(t)) {
        var r = u(this._l[t], e, n);
        if (-1 != r) return this._exec[t]--, this._l[t].splice(r, 1), !0;
      }
      return !1;
    }, t.prototype.trigger = function (t, e, n, r) {
      var i,
        o = !1;
      if (this._l[t]) {
        var a = this._l[t].length;
        for (this._exec[t] = 0; this._exec[t] < a; this._exec[t]++) if (o = !0, i = this._l[t][this._exec[t]]) {
          if (r && !r(i)) continue;
          var s = i[0],
            u = i[1];
          n || this._sync ? Array.isArray(e) ? s.apply(u, e) : s.call(u, e) : function (t, e, n) {
            setTimeout(function () {
              Array.isArray(n) ? t.apply(e, n) : t.call(e, n);
            }, 0);
          }(s, u, e);
        }
        this._exec[t] = undefined;
      }
      return o;
    }, t;
  }(),
  c = function (t, e) {
    this.key = t, this.data = e;
  };
exports.Listener = h;
exports.TaskManager = s;
c.prototype.data = null, c.prototype.next = null, c.prototype.prev = null;
var l = function () {
    function t(t) {
      this.length = 0, this.head = null, this.tail = null, this.max = t || 5e3, this._ = {}, this.tail = null;
    }
    return t.prototype.setSize = function (t) {
      if (this.length > t) for (var e = this.length - t; e--;) this.remove(this.tail.key);
      this.max = t;
    }, t.prototype.get = function (t) {
      var e, n, r;
      return (e = this._[t]) && (e != this.head && (this.tail == e && (this.tail = e.next), n = e.prev, r = e.next, n && (n.next = e.next || e), r && (r.prev = n), (n = this.head) && (n.next = e), e.prev = this.head, e.next = null, this.head = e), e = e.data), e;
    }, t.prototype.toArray = function () {
      for (var t = [], e = this.tail, n = 0; e;) t[n++] = e.data, e = e.next;
      return t;
    }, t.prototype.forEach = function (t) {
      for (var e = this.tail, n = 0; e;) t(e.data, n++), e = e.next;
    }, t.prototype.clear = function () {
      this._ = {}, this.head = null, this.tail = null, this.length = 0;
    }, t.prototype.remove = function (t) {
      var e, n, r;
      return (e = this._[t]) && (n = e.prev, r = e.next, n && (n.next = r), r && (r.prev = n), r || (this.head = n), n || (this.tail = r), delete this._[t], e = e.data, this.length--), e;
    }, t.prototype.set = function (t, e) {
      var n, r, i;
      return (n = this._[t]) ? (n.data = e, n != this.head && this.get(t)) : (this.length == this.max ? (i = this.tail.data, delete this._[this.tail.key], this.tail = this.tail.next, this.tail.prev = null) : this.length++, n = new c(t, e), this._[t] = n, (r = this.head) ? (n.prev = r, r.next = n) : this.tail = n, this.head = n), i;
    }, t;
  }(),
  p = s.getInstance(13),
  f = function (t, e, n) {
    n = n || p;
    var r = t.indexOf("["),
      i = t.lastIndexOf("]"),
      o = function (e, n) {
        e.grp = 20, e.elements.push.apply(e.elements, JSON.parse("[" + t.slice(e.start, n) + "]")), e.start = null;
      };
    n.create({
      name: "PJA",
      priority: 4,
      time: 4,
      onDone: function (n) {
        if (e) {
          var o = void 0,
            a = n.elements;
          if (a.length) {
            if (-1 != t.indexOf('"type":"FeatureCollection"')) {
              var s = JSON.parse(t.substr(0, r + 1) + t.substr(i));
              s.features = a, o = s;
            } else o = a;
          } else o = JSON.parse(t);
          e(o);
        }
      },
      init: function () {
        return {
          i: r,
          open: 0,
          start: null,
          len: i,
          elements: [],
          grp: 20,
          last: null
        };
      },
      exec: function (e) {
        var n,
          r,
          i = e.elements,
          a = e.len;
        if (e.i < a) {
          for (; (n = e.i++) < a;) if ('"' != (r = t.charAt(n))) {
            if ("{" == r) e.open++, null == e.start && (e.start = n);else if ("}" == r) {
              if (0 == --e.open) return --e.grp && n < a - 2 || (e.grp = 20, i.push.apply(i, JSON.parse("[" + t.slice(e.start, e.last = n + 1) + "]")), e.start = null), this.CONTINUE;
            } else if (0 == e.open && !isNaN(r)) {
              20 != e.grp && o(e, n - 1);
              var s = t.substr(n),
                u = s.search("[0-9](]|,)") + 1;
              i.push(parseFloat(s.substring(0, u))), e.i = n + u;
            }
          } else e.i = t.indexOf('"', n + 1) + 1;
          20 != e.grp && null != e.last && i.push.apply(i, JSON.parse("[" + t.slice(e.last + 1, t.lastIndexOf("]")) + "]"));
        }
      }
    }).start();
  },
  d = function (t, e, n) {
    if (null == n || "object" != typeof n) return n;
    if (n.constructor != Object && n.constructor != Array) return n;
    if (n.constructor == Date || n.constructor == RegExp || n.constructor == Function || n.constructor == String || n.constructor == Number || n.constructor == Boolean) return new n.constructor(n);
    for (var r in e = e || new n.constructor(), n) e[r] = d(t, t ? e[r] : null, n[r]);
    return e;
  },
  y = function (t, e) {
    for (var n in e) "constructor" != n && (t[n] = e[n]);
    return t;
  },
  v = function (t) {
    var e, n;
    if ("object" != typeof t) return t;
    if (!t) return t;
    if ("[object Array]" === Object.prototype.toString.apply(t)) {
      for (e = [], n = 0; n < t.length; n += 1) e[n] = v(t[n]);
      return e;
    }
    for (n in e = {}, t) t.hasOwnProperty(n) && (e[n] = v(t[n]));
    return e;
  },
  _ = {
    loglevel: "debug",
    dump: function (t, e) {
      var n = !!_.loglevel,
        r = Array.prototype.slice.call(arguments),
        i = r[r.length - 1],
        o = window.console;
      if (n && o && (i in o ? r.pop() : i = "log", !0 === n || n === i)) if (Function.prototype.bind && "object" == typeof o.log) {
        var a = Function.prototype.bind.call(o[i], o);
        a.apply(o, r);
      } else o[i].apply(o, r);
      return _;
    },
    extend: function (t, e, n) {
      return "boolean" != typeof t && (n = e, e = t, t = !1), d(t, e, n);
    },
    clone: v,
    createObject: Object.create || function (t) {
      var e = function () {};
      return e.prototype = t, new e();
    },
    inheritClass: function (t, e, n) {
      var r = e.prototype,
        i = t.prototype;
      for (var o in "object" == typeof e && (n = e, e.constructor == Object.prototype.constructor && (e.constructor = function () {
        t.apply(this, arguments);
      }), e = e.constructor), e.prototype = _.createObject(i), r && r != Object.prototype && y(e.prototype, r), t) e[o] = t[o];
      return n && y(e.prototype, n), e;
    },
    isFunction: function (t) {
      return "function" == typeof t;
    },
    isNumeric: function (t) {
      return !isNaN(+t) && isFinite(t);
    },
    isPlainObject: function (t) {
      if (!t || "object" != typeof t || t.nodeType || t == t.window) return !1;
      try {
        if (t.constructor && !t.hasOwnProperty("constructor") && !t.constructor.prototype.hasOwnProperty("isPrototypeOf")) return !1;
      } catch (t) {
        return !1;
      }
      var e;
      for (e in t);
      return undefined === e || t.hasOwnProperty(e);
    },
    String: {
      round: function (t, e) {
        return e ? Number(t.toFixed(e)) : Math.round(t);
      },
      random: function (t) {
        t = t || 16;
        for (var e = "", n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz", r = n.length, i = 0; i < t; i++) e += n.charAt(Math.random() * r ^ 0);
        return e;
      }
    }
  },
  g = Math.PI / 180,
  m = 180 / Math.PI,
  M = {
    calcBearing: function (t, e) {
      var n, r, i, o, a;
      return n = Math.PI / 180, r = t[1] * n, i = e[1] * n, o = t[0] * n, a = e[0] * n, (Math.atan2(Math.cos(r) * Math.sin(i) - Math.sin(r) * Math.cos(i) * Math.cos(a - o), Math.sin(a - o) * Math.cos(i)) / n + 360) % 360;
    },
    movePoint: function (t, e, n, r) {
      var i = e / (r = undefined === r ? 6371e3 : r),
        o = n * g,
        a = t[1] * g,
        s = t[0] * g,
        u = Math.asin(Math.sin(a) * Math.cos(i) + Math.cos(a) * Math.sin(i) * Math.cos(o)),
        h = s + Math.atan2(Math.sin(o) * Math.sin(i) * Math.cos(a), Math.cos(i) - Math.sin(a) * Math.sin(u));
      return [(h = (h + 3 * Math.PI) % (2 * Math.PI) - Math.PI) * m, u * m];
    },
    getPointBBox: function (t, e) {
      var n = t[1],
        r = t[0],
        i = Math.asin(e / (6371e3 * Math.cos(Math.PI * n / 180))) * m,
        o = Math.asin(e / 6371e3) * m;
      return [r - i, n - o, r + i, n + o];
    },
    mergeBBoxes: function (t, e) {
      return t[0] > e[0] && (t[0] = e[0]), t[1] > e[1] && (t[1] = e[1]), t[2] < e[2] && (t[2] = e[2]), t[3] < e[3] && (t[3] = e[3]), t;
    },
    extendBBox: function (t, e) {
      var n = Math.abs(Math.asin(e / (6371e3 * Math.cos(t[0] * g)))) * m,
        r = Math.abs(Math.asin(e / (6371e3 * Math.cos(t[2] * g)))) * m,
        i = Math.abs(Math.asin(e / 6371e3)) * m;
      return [t[0] - n, t[1] - i, t[2] + r, t[3] + i];
    },
    distance: function (t, e) {
      var n = g * (e[1] - t[1]),
        r = g * (e[0] - t[0]),
        i = Math.sin(n / 2) * Math.sin(n / 2) + Math.cos(g * t[1]) * Math.cos(g * e[1]) * Math.sin(r / 2) * Math.sin(r / 2),
        o = 6371e3 * (2 * Math.atan2(Math.sqrt(i), Math.sqrt(1 - i)));
      if (null != t[2] && null != e[2]) {
        var a = t[2] - e[2];
        o = Math.sqrt(o * o + a * a);
      }
      return o;
    }
  },
  x = {
    centroid: function (t) {
      for (var e, n, r = t[0], i = r[0][0], o = r[0][1], a = 0, s = 0, u = 0, h = 0, c = r.length, l = c - 1, p = void 0, f = void 0, d = void 0; h < c; l = h, h++) e = r[h][0] - i, n = r[h][1] - o, s += (e + (p = r[l][0] - i)) * (d = n * p - (f = r[l][1] - o) * e), u += (n + f) * d, a += d;
      return (a *= 3) ? [s / a + i, u / a + o] : [e, n];
    }
  },
  b = function () {
    function t(t) {
      if (this.size = 0, this._ = [], t) for (var e = 0; e < t.length; e++) this.add(t[e]);
    }
    return t.prototype.add = function (t) {
      var e = !this.has(t);
      return e && (this.size = this._.push(t)), e;
    }, t.prototype.clear = function () {
      this.size = this._.length = 0;
    }, t.prototype.delete = function (t) {
      var e = this._.indexOf(t),
        n = -1 != e;
      return n && (this._.splice(e, 1), this.size--), n;
    }, t.prototype.has = function (t) {
      return -1 != this._.indexOf(t);
    }, t.prototype.toArray = function () {
      return this._.slice(0);
    }, t;
  }(),
  O = function () {
    function t(t) {
      if (this._ = {}, this.size = 0, t) for (var e = 0; e < t.length; e++) this.set(t[e][0], t[e][1]);
    }
    return t.prototype.clear = function () {
      this.size = 0, this._ = {};
    }, t.prototype.delete = function (t) {
      var e = this.has(t);
      return e && (delete this._[t], this.size--), e;
    }, t.prototype.get = function (t) {
      return this._[t];
    }, t.prototype.has = function (t) {
      return null != this._[t];
    }, t.prototype.set = function (t, e) {
      var n = !this.has(t);
      return n && (this.size++, this._[t] = e), n;
    }, t.prototype.values = function () {
      var t = this._,
        e = [];
      for (var n in t) e[e.length] = t[n];
      return e;
    }, t.prototype.keys = function () {
      var t = this._,
        e = [];
      for (var n in t) e[e.length] = n;
      return e;
    }, t.prototype.forEach = function (t) {
      var e = this._;
      for (var n in e) t(e[n], n, this);
    }, t;
  }(),
  w = function () {
    function t() {
      this.queue = [];
    }
    return t.prototype.add = function (t) {
      if ("function" == typeof t) return this.queue.push(t);
    }, t.prototype.done = function (t, e, n) {
      for (var r = this.queue; r.length;) r.shift().apply(void 0, arguments);
    }, t;
  }(),
  P = Object.freeze({
    __proto__: null,
    sub: function (t, e, n) {
      return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t;
    },
    add: function (t, e, n) {
      return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t;
    },
    multiply: function (t, e, n) {
      return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t;
    },
    scale: function (t, e, n) {
      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t;
    },
    normalize: function (t, e) {
      var n = e[0],
        r = e[1],
        i = e[2],
        o = n * n + r * r + i * i;
      return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o, t;
    },
    cross: function (t, e, n) {
      var r = e[0],
        i = e[1],
        o = e[2],
        a = n[0],
        s = n[1],
        u = n[2];
      return t[0] = i * u - o * s, t[1] = o * a - r * u, t[2] = r * s - i * a, t;
    },
    transform: function (t, e, n) {
      var r = e[0],
        i = e[1],
        o = e[2] || 0,
        a = n[3] * r + n[7] * i + n[11] * o + n[15];
      return a || (a = 1), t[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a, t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a, t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a, t;
    },
    dot: function (t, e) {
      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    }
  }),
  N = t;
exports.vec3 = P;
exports.Queue = w;
exports.Map = O;
exports.Set = b;
exports.geometry = x;
exports.geotools = M;
exports.JSUtils = _;
exports.parseJSONArray = f;
exports.LRU = l;
"here.xyz.maps".split(".").forEach(function (t) {
  return N = N[t] = N[t] || {};
}), t.HERE = t.here;
var j = {
  LRU: l,
  TaskManager: s,
  Listener: h,
  parseJSONArray: f,
  JSUtils: _,
  geotools: M,
  global: t,
  Queue: w,
  Set: b,
  Map: O,
  vec3: P,
  geometry: x
};
exports.default = j;
N.common = j;
},{}],"node_modules/@here/xyz-maps-core/dist/xyz-maps-core.min.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*
 * @here/xyz-maps-core
 * (c) 2019-2022 HERE
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.here = global.here || {}, global.here.xyz = global.here.xyz || {}, global.here.xyz.maps = factory()));
})(this, (function () { 'use strict';

	let shared;
	let worker;
	function define(dep, factory) {
	    if (!shared) {
	        shared = factory;
	    } else if (!worker) {
	        worker = factory;
	    } else {
	        const xyz = here.xyz.maps;
	        const sharedExports = {};
	        shared(sharedExports);
	        xyz.__workerURL = window.URL.createObjectURL(new Blob(['var shared={};('+shared+')(shared);('+worker+')(shared);'], {type: 'text/javascript'}));
	        factory(xyz, sharedExports, xyz.common);
	    }
	}


	define(["exports"],(function(t){"use strict";
	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */var e=function(t,i){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);},e(t,i)};function i(t,i){if("function"!=typeof i&&null!==i)throw new TypeError("Class extends value "+String(i)+" is not a constructor or null");function r(){this.constructor=t;}e(t,i),t.prototype=null===i?Object.create(i):(r.prototype=i.prototype,new r);}t.__assign=function(){return t.__assign=Object.assign||function(t){for(var e,i=1,r=arguments.length;i<r;i++)for(var n in e=arguments[i])Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t},t.__assign.apply(this,arguments)};var r=function(){function t(t){this.bO=0,"number"==typeof t&&(t=new ArrayBuffer(t)),this.dV=new DataView(t),this.aB=t;}return t.prototype.setUint16Array=function(t){var e=this.bO,i=t.length;this.dV.setUint32(e,i),new Uint16Array(this.aB,e+4,i).set(t),this.bO+=4+2*i;},t.prototype.setLayer=function(t,e){var i=this.dV,r=this.bO;i.setUint16(r,Number(t)),i.setUint32(r+2,e),this.bO+=6;},t.prototype.setFeature=function(t,e){this.dV.setUint16(this.bO,t),this.bO+=2,this.setUint16Array(e);},t.prototype.getLayers=function(){for(var t=this.dV,e=t.byteLength,i=0,r={};i<e;){var n=t.getUint16(i),s=2*t.getUint32(i+2);i+=6,r[n]={offset:i,length:s,features:null},i+=s;}return r},t.prototype.getFeatures=function(t){if(t.features)return t.features;for(var e=t.features={},i=this.dV,r=this.aB,n=t.offset,s=n+t.length;n<s;){var o=i.getUint16(n),a=i.getUint32(n+2);n+=6,e[o]=new Uint16Array(r,n,a),n+=2*a;}},t.prototype.getBuffer=function(){return this.aB},t}(),n=function(){function t(t){for(var e in this.withCredentials=!1,this.responseType="",t)this[e]=t[e];}return t.prototype.send=function(t){var e=t.success,i=t.error,r=t.responseType||this.responseType,n=t.headers,s=new XMLHttpRequest,o=t.withCredentials;if(s.withCredentials=null!=o?o:this.withCredentials,s.responseType="json"==r?"text":r,s.onload=function(){var t,i,n=this.responseType;""==n||"text"==n?(i=(t=this.responseText).length,"json"==r&&204!=this.status&&(t=JSON.parse(t))):i=(t=this.response).byteLength,this.status>=200&&this.status<=226&&e(t,i);},s.onreadystatechange=function(){4==this.readyState&&(this.status<200||this.status>=300)&&(this.onload=null,0!==this.status&&i&&i(this));},s.open(t.type||"GET",t.url,!0),n)for(var a in n)s.setRequestHeader(a,n[a]);return s.send(t.data||null),s},t}(),s={},o=/{([xX]|(COL))}/,a=/{([yY]|(ROW))}/,h=/{([zZ]|(LEVEL))}/,u=/{((qk)|(QK)|(quadkey)|(QUADKEY))}/,f=/{SUBDOMAIN_INT_1_4}/,p=/{SUBDOMAIN_INT}/,c=/{SUBDOMAIN_CHAR}/,l=function(t){function e(e){var i=t.call(this,"Service request failed with HTTP status: '"+e.status+" "+e.statusText+"'")||this;i.name="NetworkError";var r=i,n=e.responseType;return r.statusCode=e.status,""!=n&&"text"!=n||(r.responseText=e.responseText||null),i}return i(e,t),e}(Error),d=function(){function e(e){this.withCredentials=!1,this.headers=null,this.store=null,this.baseUrl=null,this.q={};var i=e.responseType||"json",r=e.src||e.url,o=!!e.withCredentials;this.withCredentials=o,this.baseUrl=r,this.headers=t.__assign(t.__assign({},s),e.headers||{}),"function"==typeof r&&(this.getUrl=function(t){return r(t.z,t.y,t.x,t.quadkey)}),this.http=new n({responseType:i,withCredentials:o}),this.tileType=e.tileType;}return e.createImageFromBlob=function(t,e){var i=new Image;return i.onload=function(t){window.URL.revokeObjectURL(i.src),e&&e(i);},i.src=window.URL.createObjectURL(t),i},e.prototype.getUrl=function(t){var e=4*Math.random()^0;return this.baseUrl.replace(f,e+1).replace(p,e).replace(c,"abcd"[e]).replace(u,t.quadkey).replace(h,t.z).replace(o,t.x).replace(a,t.y)},e.prototype.setUrl=function(t){this.baseUrl=t;},e.prototype.load=function(t,i,r){var n,s=this.getUrl(t),o=t.quadkey,a=this.q,h={id:o,url:s,success:i,error:r},u=this.tileType||t.type;"image"==u?(h.responseType="blob",h.success=function(t){a[o]=n,e.createImageFromBlob(t,(function(t){delete a[o],n._aborted||i(t);}));}):("json"==u&&(h.success=function(t,e){i("FeatureCollection"==t.type?t.features:t,e);}),h.headers=this.headers),n=this.send(h);},e.prototype.abort=function(t){var e=this.q,i=t.quadkey,r=e[i];r&&("image"==t.type&&(r.onload=undefined,r._aborted=!0),r.abort&&r.abort(),delete e[i]);},e.prototype.send=function(t){var e=t.id||t.key||Math.random(),i=this.q,r=t.success,n=t;n.success=function(t,n){delete i[e],r(t,n);};var s=t.error;return n.error=function(t){delete i[e],s&&s(new l(t),t);},i[e]=this.http.send(n)},e}(),y={read:function(t,e,i,r,n){var s,o,a=8*n-r-1,h=(1<<a)-1,u=h>>1,f=-7,p=i?n-1:0,c=i?-1:1,l=t[e+p];for(p+=c,s=l&(1<<-f)-1,l>>=-f,f+=a;f>0;s=256*s+t[e+p],p+=c,f-=8);for(o=s&(1<<-f)-1,s>>=-f,f+=r;f>0;o=256*o+t[e+p],p+=c,f-=8);if(0===s)s=1-u;else {if(s===h)return o?NaN:1/0*(l?-1:1);o+=Math.pow(2,r),s-=u;}return (l?-1:1)*o*Math.pow(2,s-r)},write:function(t,e,i,r,n,s){var o,a,h,u=8*s-n-1,f=(1<<u)-1,p=f>>1,c=23===n?Math.pow(2,-24)-Math.pow(2,-77):0,l=r?0:s-1,d=r?1:-1,y=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,o=f):(o=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-o))<1&&(o--,h*=2),(e+=o+p>=1?c/h:c*Math.pow(2,1-p))*h>=2&&(o++,h/=2),o+p>=f?(a=0,o=f):o+p>=1?(a=(e*h-1)*Math.pow(2,n),o+=p):(a=e*Math.pow(2,p-1)*Math.pow(2,n),o=0));n>=8;t[i+l]=255&a,l+=d,a/=256,n-=8);for(o=o<<n|a,u+=n;u>0;t[i+l]=255&o,l+=d,o/=256,u-=8);t[i+l-d]|=128*y;}},w=g,v=y;function g(t){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(t)?t:new Uint8Array(t||0),this.pos=0,this.type=0,this.length=this.buf.length;}g.Varint=0,g.Fixed64=1,g.Bytes=2,g.Fixed32=5;var x=4294967296,b=1/x,F="undefined"==typeof TextDecoder?null:new TextDecoder("utf8");function _(t){return t.type===g.Bytes?t.readVarint()+t.pos:t.pos+1}function V(t,e,i){return i?4294967296*e+(t>>>0):4294967296*(e>>>0)+(t>>>0)}function M(t,e,i){var r=e<=16383?1:e<=2097151?2:e<=268435455?3:Math.floor(Math.log(e)/(7*Math.LN2));i.realloc(r);for(var n=i.pos-1;n>=t;n--)i.buf[n+r]=i.buf[n];}function S(t,e){for(var i=0;i<t.length;i++)e.writeVarint(t[i]);}function B(t,e){for(var i=0;i<t.length;i++)e.writeSVarint(t[i]);}function T(t,e){for(var i=0;i<t.length;i++)e.writeFloat(t[i]);}function m(t,e){for(var i=0;i<t.length;i++)e.writeDouble(t[i]);}function k(t,e){for(var i=0;i<t.length;i++)e.writeBoolean(t[i]);}function P(t,e){for(var i=0;i<t.length;i++)e.writeFixed32(t[i]);}function U(t,e){for(var i=0;i<t.length;i++)e.writeSFixed32(t[i]);}function O(t,e){for(var i=0;i<t.length;i++)e.writeFixed64(t[i]);}function A(t,e){for(var i=0;i<t.length;i++)e.writeSFixed64(t[i]);}function q(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+16777216*t[e+3]}function C(t,e,i){t[i]=e,t[i+1]=e>>>8,t[i+2]=e>>>16,t[i+3]=e>>>24;}function D(t,e){return (t[e]|t[e+1]<<8|t[e+2]<<16)+(t[e+3]<<24)}g.prototype={destroy:function(){this.buf=null;},readFields:function(t,e,i){for(i=i||this.length;this.pos<i;){var r=this.readVarint(),n=r>>3,s=this.pos;this.type=7&r,t(n,e,this),this.pos===s&&this.skip(r);}return e},readMessage:function(t,e){return this.readFields(t,e,this.readVarint()+this.pos)},readFixed32:function(){var t=q(this.buf,this.pos);return this.pos+=4,t},readSFixed32:function(){var t=D(this.buf,this.pos);return this.pos+=4,t},readFixed64:function(){var t=q(this.buf,this.pos)+q(this.buf,this.pos+4)*x;return this.pos+=8,t},readSFixed64:function(){var t=q(this.buf,this.pos)+D(this.buf,this.pos+4)*x;return this.pos+=8,t},readFloat:function(){var t=v.read(this.buf,this.pos,!0,23,4);return this.pos+=4,t},readDouble:function(){var t=v.read(this.buf,this.pos,!0,52,8);return this.pos+=8,t},readVarint:function(t){var e,i,r=this.buf;return e=127&(i=r[this.pos++]),i<128?e:(e|=(127&(i=r[this.pos++]))<<7,i<128?e:(e|=(127&(i=r[this.pos++]))<<14,i<128?e:(e|=(127&(i=r[this.pos++]))<<21,i<128?e:function(t,e,i){var r,n,s=i.buf;if(n=s[i.pos++],r=(112&n)>>4,n<128)return V(t,r,e);if(n=s[i.pos++],r|=(127&n)<<3,n<128)return V(t,r,e);if(n=s[i.pos++],r|=(127&n)<<10,n<128)return V(t,r,e);if(n=s[i.pos++],r|=(127&n)<<17,n<128)return V(t,r,e);if(n=s[i.pos++],r|=(127&n)<<24,n<128)return V(t,r,e);if(n=s[i.pos++],r|=(1&n)<<31,n<128)return V(t,r,e);throw new Error("Expected varint not more than 10 bytes")}(e|=(15&(i=r[this.pos]))<<28,t,this))))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var t=this.readVarint();return t%2==1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,e=this.pos;return this.pos=t,t-e>=12&&F?function(t,e,i){return F.decode(t.subarray(e,i))}(this.buf,e,t):function(t,e,i){var r="",n=e;for(;n<i;){var s,o,a,h=t[n],u=null,f=h>239?4:h>223?3:h>191?2:1;if(n+f>i)break;1===f?h<128&&(u=h):2===f?128==(192&(s=t[n+1]))&&(u=(31&h)<<6|63&s)<=127&&(u=null):3===f?(s=t[n+1],o=t[n+2],128==(192&s)&&128==(192&o)&&((u=(15&h)<<12|(63&s)<<6|63&o)<=2047||u>=55296&&u<=57343)&&(u=null)):4===f&&(s=t[n+1],o=t[n+2],a=t[n+3],128==(192&s)&&128==(192&o)&&128==(192&a)&&((u=(15&h)<<18|(63&s)<<12|(63&o)<<6|63&a)<=65535||u>=1114112)&&(u=null)),null===u?(u=65533,f=1):u>65535&&(u-=65536,r+=String.fromCharCode(u>>>10&1023|55296),u=56320|1023&u),r+=String.fromCharCode(u),n+=f;}return r}(this.buf,e,t)},readBytes:function(){var t=this.readVarint()+this.pos,e=this.buf.subarray(this.pos,t);return this.pos=t,e},readPackedVarint:function(t,e){if(this.type!==g.Bytes)return t.push(this.readVarint(e));var i=_(this);for(t=t||[];this.pos<i;)t.push(this.readVarint(e));return t},readPackedSVarint:function(t){if(this.type!==g.Bytes)return t.push(this.readSVarint());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readSVarint());return t},readPackedBoolean:function(t){if(this.type!==g.Bytes)return t.push(this.readBoolean());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readBoolean());return t},readPackedFloat:function(t){if(this.type!==g.Bytes)return t.push(this.readFloat());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readFloat());return t},readPackedDouble:function(t){if(this.type!==g.Bytes)return t.push(this.readDouble());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readDouble());return t},readPackedFixed32:function(t){if(this.type!==g.Bytes)return t.push(this.readFixed32());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readFixed32());return t},readPackedSFixed32:function(t){if(this.type!==g.Bytes)return t.push(this.readSFixed32());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed32());return t},readPackedFixed64:function(t){if(this.type!==g.Bytes)return t.push(this.readFixed64());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readFixed64());return t},readPackedSFixed64:function(t){if(this.type!==g.Bytes)return t.push(this.readSFixed64());var e=_(this);for(t=t||[];this.pos<e;)t.push(this.readSFixed64());return t},skip:function(t){var e=7&t;if(e===g.Varint)for(;this.buf[this.pos++]>127;);else if(e===g.Bytes)this.pos=this.readVarint()+this.pos;else if(e===g.Fixed32)this.pos+=4;else {if(e!==g.Fixed64)throw new Error("Unimplemented type: "+e);this.pos+=8;}},writeTag:function(t,e){this.writeVarint(t<<3|e);},realloc:function(t){for(var e=this.length||16;e<this.pos+t;)e*=2;if(e!==this.length){var i=new Uint8Array(e);i.set(this.buf),this.buf=i,this.length=e;}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(t){this.realloc(4),C(this.buf,t,this.pos),this.pos+=4;},writeSFixed32:function(t){this.realloc(4),C(this.buf,t,this.pos),this.pos+=4;},writeFixed64:function(t){this.realloc(8),C(this.buf,-1&t,this.pos),C(this.buf,Math.floor(t*b),this.pos+4),this.pos+=8;},writeSFixed64:function(t){this.realloc(8),C(this.buf,-1&t,this.pos),C(this.buf,Math.floor(t*b),this.pos+4),this.pos+=8;},writeVarint:function(t){(t=+t||0)>268435455||t<0?function(t,e){var i,r;t>=0?(i=t%4294967296|0,r=t/4294967296|0):(r=~(-t/4294967296),4294967295^(i=~(-t%4294967296))?i=i+1|0:(i=0,r=r+1|0));if(t>=0x10000000000000000||t<-0x10000000000000000)throw new Error("Given varint doesn't fit into 10 bytes");e.realloc(10),function(t,e,i){i.buf[i.pos++]=127&t|128,t>>>=7,i.buf[i.pos++]=127&t|128,t>>>=7,i.buf[i.pos++]=127&t|128,t>>>=7,i.buf[i.pos++]=127&t|128,t>>>=7,i.buf[i.pos]=127&t;}(i,0,e),function(t,e){var i=(7&t)<<4;if(e.buf[e.pos++]|=i|((t>>>=3)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;if(e.buf[e.pos++]=127&t|((t>>>=7)?128:0),!t)return;e.buf[e.pos++]=127&t;}(r,e);}(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127))));},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t);},writeBoolean:function(t){this.writeVarint(Boolean(t));},writeString:function(t){t=String(t),this.realloc(4*t.length),this.pos++;var e=this.pos;this.pos=function(t,e,i){for(var r,n,s=0;s<e.length;s++){if((r=e.charCodeAt(s))>55295&&r<57344){if(!n){r>56319||s+1===e.length?(t[i++]=239,t[i++]=191,t[i++]=189):n=r;continue}if(r<56320){t[i++]=239,t[i++]=191,t[i++]=189,n=r;continue}r=n-55296<<10|r-56320|65536,n=null;}else n&&(t[i++]=239,t[i++]=191,t[i++]=189,n=null);r<128?t[i++]=r:(r<2048?t[i++]=r>>6|192:(r<65536?t[i++]=r>>12|224:(t[i++]=r>>18|240,t[i++]=r>>12&63|128),t[i++]=r>>6&63|128),t[i++]=63&r|128);}return i}(this.buf,t,this.pos);var i=this.pos-e;i>=128&&M(e,i,this),this.pos=e-1,this.writeVarint(i),this.pos+=i;},writeFloat:function(t){this.realloc(4),v.write(this.buf,t,this.pos,!0,23,4),this.pos+=4;},writeDouble:function(t){this.realloc(8),v.write(this.buf,t,this.pos,!0,52,8),this.pos+=8;},writeBytes:function(t){var e=t.length;this.writeVarint(e),this.realloc(e);for(var i=0;i<e;i++)this.buf[this.pos++]=t[i];},writeRawMessage:function(t,e){this.pos++;var i=this.pos;t(e,this);var r=this.pos-i;r>=128&&M(i,r,this),this.pos=i-1,this.writeVarint(r),this.pos+=r;},writeMessage:function(t,e,i){this.writeTag(t,g.Bytes),this.writeRawMessage(e,i);},writePackedVarint:function(t,e){e.length&&this.writeMessage(t,S,e);},writePackedSVarint:function(t,e){e.length&&this.writeMessage(t,B,e);},writePackedBoolean:function(t,e){e.length&&this.writeMessage(t,k,e);},writePackedFloat:function(t,e){e.length&&this.writeMessage(t,T,e);},writePackedDouble:function(t,e){e.length&&this.writeMessage(t,m,e);},writePackedFixed32:function(t,e){e.length&&this.writeMessage(t,P,e);},writePackedSFixed32:function(t,e){e.length&&this.writeMessage(t,U,e);},writePackedFixed64:function(t,e){e.length&&this.writeMessage(t,O,e);},writePackedSFixed64:function(t,e){e.length&&this.writeMessage(t,A,e);},writeBytesField:function(t,e){this.writeTag(t,g.Bytes),this.writeBytes(e);},writeFixed32Field:function(t,e){this.writeTag(t,g.Fixed32),this.writeFixed32(e);},writeSFixed32Field:function(t,e){this.writeTag(t,g.Fixed32),this.writeSFixed32(e);},writeFixed64Field:function(t,e){this.writeTag(t,g.Fixed64),this.writeFixed64(e);},writeSFixed64Field:function(t,e){this.writeTag(t,g.Fixed64),this.writeSFixed64(e);},writeVarintField:function(t,e){this.writeTag(t,g.Varint),this.writeVarint(e);},writeSVarintField:function(t,e){this.writeTag(t,g.Varint),this.writeSVarint(e);},writeStringField:function(t,e){this.writeTag(t,g.Bytes),this.writeString(e);},writeFloatField:function(t,e){this.writeTag(t,g.Fixed32),this.writeFloat(e);},writeDoubleField:function(t,e){this.writeTag(t,g.Fixed64),this.writeDouble(e);},writeBooleanField:function(t,e){this.writeVarintField(t,Boolean(e));}};var L={},N=E;function E(t,e){this.x=t,this.y=e;}E.prototype={clone:function(){return new E(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},multByPoint:function(t){return this.clone()._multByPoint(t)},divByPoint:function(t){return this.clone()._divByPoint(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},rotateAround:function(t,e){return this.clone()._rotateAround(t,e)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var e=t.x-this.x,i=t.y-this.y;return e*e+i*i},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,e){return Math.atan2(this.x*e-this.y*t,this.x*t+this.y*e)},_matMult:function(t){var e=t[0]*this.x+t[1]*this.y,i=t[2]*this.x+t[3]*this.y;return this.x=e,this.y=i,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_multByPoint:function(t){return this.x*=t.x,this.y*=t.y,this},_divByPoint:function(t){return this.x/=t.x,this.y/=t.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var e=Math.cos(t),i=Math.sin(t),r=e*this.x-i*this.y,n=i*this.x+e*this.y;return this.x=r,this.y=n,this},_rotateAround:function(t,e){var i=Math.cos(t),r=Math.sin(t),n=e.x+i*(this.x-e.x)-r*(this.y-e.y),s=e.y+r*(this.x-e.x)+i*(this.y-e.y);return this.x=n,this.y=s,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},E.convert=function(t){return t instanceof E?t:Array.isArray(t)?new E(t[0],t[1]):t};var j=N,I=R;function R(t,e,i,r,n){this.properties={},this.extent=i,this.type=0,this._pbf=t,this._geometry=-1,this._keys=r,this._values=n,t.readFields(G,this,e);}function G(t,e,i){1==t?e.id=i.readVarint():2==t?function(t,e){var i=t.readVarint()+t.pos;for(;t.pos<i;){var r=e._keys[t.readVarint()],n=e._values[t.readVarint()];e.properties[r]=n;}}(i,e):3==t?e.type=i.readVarint():4==t&&(e._geometry=i.pos);}function H(t){for(var e,i,r=0,n=0,s=t.length,o=s-1;n<s;o=n++)e=t[n],r+=((i=t[o]).x-e.x)*(e.y+i.y);return r}R.types=["Unknown","Point","LineString","Polygon"],R.prototype.loadGeometry=function(){var t=this._pbf;t.pos=this._geometry;for(var e,i=t.readVarint()+t.pos,r=1,n=0,s=0,o=0,a=[];t.pos<i;){if(n<=0){var h=t.readVarint();r=7&h,n=h>>3;}if(n--,1===r||2===r)s+=t.readSVarint(),o+=t.readSVarint(),1===r&&(e&&a.push(e),e=[]),e.push(new j(s,o));else {if(7!==r)throw new Error("unknown command "+r);e&&e.push(e[0].clone());}}return e&&a.push(e),a},R.prototype.bbox=function(){var t=this._pbf;t.pos=this._geometry;for(var e=t.readVarint()+t.pos,i=1,r=0,n=0,s=0,o=1/0,a=-1/0,h=1/0,u=-1/0;t.pos<e;){if(r<=0){var f=t.readVarint();i=7&f,r=f>>3;}if(r--,1===i||2===i)(n+=t.readSVarint())<o&&(o=n),n>a&&(a=n),(s+=t.readSVarint())<h&&(h=s),s>u&&(u=s);else if(7!==i)throw new Error("unknown command "+i)}return [o,h,a,u]},R.prototype.toGeoJSON=function(t,e,i){var r,n,s=this.extent*Math.pow(2,i),o=this.extent*t,a=this.extent*e,h=this.loadGeometry(),u=R.types[this.type];function f(t){for(var e=0;e<t.length;e++){var i=t[e],r=180-360*(i.y+a)/s;t[e]=[360*(i.x+o)/s-180,360/Math.PI*Math.atan(Math.exp(r*Math.PI/180))-90];}}switch(this.type){case 1:var p=[];for(r=0;r<h.length;r++)p[r]=h[r][0];f(h=p);break;case 2:for(r=0;r<h.length;r++)f(h[r]);break;case 3:for(h=function(t){var e=t.length;if(e<=1)return [t];for(var i,r,n=[],s=0;s<e;s++){var o=H(t[s]);0!==o&&(void 0===r&&(r=o<0),r===o<0?(i&&n.push(i),i=[t[s]]):i.push(t[s]));}i&&n.push(i);return n}(h),r=0;r<h.length;r++)for(n=0;n<h[r].length;n++)f(h[r][n]);}1===h.length?h=h[0]:u="Multi"+u;var c={type:"Feature",geometry:{type:u,coordinates:h},properties:this.properties};return "id"in this&&(c.id=this.id),c};var W=I,z=X;function X(t,e){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=t,this._keys=[],this._values=[],this._features=[],t.readFields(Y,this,e),this.length=this._features.length;}function Y(t,e,i){15===t?e.version=i.readVarint():1===t?e.name=i.readString():5===t?e.extent=i.readVarint():2===t?e._features.push(i.pos):3===t?e._keys.push(i.readString()):4===t&&e._values.push(function(t){var e=null,i=t.readVarint()+t.pos;for(;t.pos<i;){var r=t.readVarint()>>3;e=1===r?t.readString():2===r?t.readFloat():3===r?t.readDouble():4===r?t.readVarint64():5===r?t.readVarint():6===r?t.readSVarint():7===r?t.readBoolean():null;}return e}(i));}X.prototype.feature=function(t){if(t<0||t>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[t];var e=this._pbf.readVarint()+this._pbf.pos;return new W(this._pbf,e,this.extent,this._keys,this._values)};var J=z,K=function(t,e){this.layers=t.readFields(Q,{},e);};function Q(t,e,i){if(3===t){var r=new J(i,i.readVarint()+i.pos);r.length&&(e[r.name]=r);}}var Z=L.VectorTile=K;L.VectorTileFeature=I,L.VectorTileLayer=z,t.HTTPLoader=d,t.VectorTile=Z,t.XYZBin=r,t.__extends=i,t.pbf=w,t.vectorTile=L;}));

	define(["./shared"],(function(e){"use strict";var n={exports:{}};function r(e,n,r){r=r||2;var i,u,a,o,f,l,h,y=n&&n.length,c=y?n[0]*r:e.length,d=t(e,0,c,r,!0),g=[];if(!d||d.next===d.prev)return g;if(y&&(d=function(e,n,r,i){var x,u,a,o=[];for(x=0,u=n.length;x<u;x++)(a=t(e,n[x]*i,x<u-1?n[x+1]*i:e.length,i,!1))===a.next&&(a.steiner=!0),o.push(p(a));for(o.sort(v),x=0;x<o.length;x++)r=s(o[x],r);return r}(e,n,d,r)),e.length>80*r){i=a=e[0],u=o=e[1];for(var Z=r;Z<c;Z+=r)(f=e[Z])<i&&(i=f),(l=e[Z+1])<u&&(u=l),f>a&&(a=f),l>o&&(o=l);h=0!==(h=Math.max(a-i,o-u))?32767/h:0;}return x(d,g,r,i,u,h,0),g}function t(e,n,r,t,i){var x,u;if(i===q(e,n,r,t)>0)for(x=n;x<r;x+=t)u=M(x,e[x],e[x+1],u);else for(x=r-t;x>=n;x-=t)u=M(x,e[x],e[x+1],u);return u&&g(u,u.next)&&(z(u),u=u.next),u}function i(e,n){if(!e)return e;n||(n=e);var r,t=e;do{if(r=!1,t.steiner||!g(t,t.next)&&0!==d(t.prev,t,t.next))t=t.next;else {if(z(t),(t=n=t.prev)===t.next)break;r=!0;}}while(r||t!==n);return n}function x(e,n,r,t,v,s,l){if(e){!l&&s&&function(e,n,r,t){var i=e;do{0===i.z&&(i.z=h(i.x,i.y,n,r,t)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;}while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,function(e){var n,r,t,i,x,u,a,o,f=1;do{for(r=e,e=null,x=null,u=0;r;){for(u++,t=r,a=0,n=0;n<f&&(a++,t=t.nextZ);n++);for(o=f;a>0||o>0&&t;)0!==a&&(0===o||!t||r.z<=t.z)?(i=r,r=r.nextZ,a--):(i=t,t=t.nextZ,o--),x?x.nextZ=i:e=i,i.prevZ=x,x=i;r=t;}x.nextZ=null,f*=2;}while(u>1)}(i);}(e,t,v,s);for(var p,y,c=e;e.prev!==e.next;)if(p=e.prev,y=e.next,s?a(e,t,v,s):u(e))n.push(p.i/r|0),n.push(e.i/r|0),n.push(y.i/r|0),z(e),e=y.next,c=y.next;else if((e=y)===c){l?1===l?x(e=o(i(e),n,r),n,r,t,v,s,2):2===l&&f(e,n,r,t,v,s):x(i(e),n,r,t,v,s,1);break}}}function u(e){var n=e.prev,r=e,t=e.next;if(d(n,r,t)>=0)return !1;for(var i=n.x,x=r.x,u=t.x,a=n.y,o=r.y,f=t.y,v=i<x?i<u?i:u:x<u?x:u,s=a<o?a<f?a:f:o<f?o:f,l=i>x?i>u?i:u:x>u?x:u,h=a>o?a>f?a:f:o>f?o:f,p=t.next;p!==n;){if(p.x>=v&&p.x<=l&&p.y>=s&&p.y<=h&&y(i,a,x,o,u,f,p.x,p.y)&&d(p.prev,p,p.next)>=0)return !1;p=p.next;}return !0}function a(e,n,r,t){var i=e.prev,x=e,u=e.next;if(d(i,x,u)>=0)return !1;for(var a=i.x,o=x.x,f=u.x,v=i.y,s=x.y,l=u.y,p=a<o?a<f?a:f:o<f?o:f,c=v<s?v<l?v:l:s<l?s:l,g=a>o?a>f?a:f:o>f?o:f,Z=v>s?v>l?v:l:s>l?s:l,w=h(p,c,n,r,t),m=h(g,Z,n,r,t),b=e.prevZ,k=e.nextZ;b&&b.z>=w&&k&&k.z<=m;){if(b.x>=p&&b.x<=g&&b.y>=c&&b.y<=Z&&b!==i&&b!==u&&y(a,v,o,s,f,l,b.x,b.y)&&d(b.prev,b,b.next)>=0)return !1;if(b=b.prevZ,k.x>=p&&k.x<=g&&k.y>=c&&k.y<=Z&&k!==i&&k!==u&&y(a,v,o,s,f,l,k.x,k.y)&&d(k.prev,k,k.next)>=0)return !1;k=k.nextZ;}for(;b&&b.z>=w;){if(b.x>=p&&b.x<=g&&b.y>=c&&b.y<=Z&&b!==i&&b!==u&&y(a,v,o,s,f,l,b.x,b.y)&&d(b.prev,b,b.next)>=0)return !1;b=b.prevZ;}for(;k&&k.z<=m;){if(k.x>=p&&k.x<=g&&k.y>=c&&k.y<=Z&&k!==i&&k!==u&&y(a,v,o,s,f,l,k.x,k.y)&&d(k.prev,k,k.next)>=0)return !1;k=k.nextZ;}return !0}function o(e,n,r){var t=e;do{var x=t.prev,u=t.next.next;!g(x,u)&&Z(x,t,t.next,u)&&b(x,u)&&b(u,x)&&(n.push(x.i/r|0),n.push(t.i/r|0),n.push(u.i/r|0),z(t),z(t.next),t=e=u),t=t.next;}while(t!==e);return i(t)}function f(e,n,r,t,u,a){var o=e;do{for(var f=o.next.next;f!==o.prev;){if(o.i!==f.i&&c(o,f)){var v=k(o,f);return o=i(o,o.next),v=i(v,v.next),x(o,n,r,t,u,a,0),void x(v,n,r,t,u,a,0)}f=f.next;}o=o.next;}while(o!==e)}function v(e,n){return e.x-n.x}function s(e,n){var r=function(e,n){var r,t=n,i=e.x,x=e.y,u=-1/0;do{if(x<=t.y&&x>=t.next.y&&t.next.y!==t.y){var a=t.x+(x-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(a<=i&&a>u&&(u=a,r=t.x<t.next.x?t:t.next,a===i))return r}t=t.next;}while(t!==n);if(!r)return null;var o,f=r,v=r.x,s=r.y,h=1/0;t=r;do{i>=t.x&&t.x>=v&&i!==t.x&&y(x<s?i:u,x,v,s,x<s?u:i,x,t.x,t.y)&&(o=Math.abs(x-t.y)/(i-t.x),b(t,e)&&(o<h||o===h&&(t.x>r.x||t.x===r.x&&l(r,t)))&&(r=t,h=o)),t=t.next;}while(t!==f);return r}(e,n);if(!r)return n;var t=k(r,e);return i(t,t.next),i(r,r.next)}function l(e,n){return d(e.prev,e,n.prev)<0&&d(n.next,e,e.next)<0}function h(e,n,r,t,i){return (e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))|(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-t)*i|0)|n<<8))|n<<4))|n<<2))|n<<1))<<1}function p(e){var n=e,r=e;do{(n.x<r.x||n.x===r.x&&n.y<r.y)&&(r=n),n=n.next;}while(n!==e);return r}function y(e,n,r,t,i,x,u,a){return (i-u)*(n-a)>=(e-u)*(x-a)&&(e-u)*(t-a)>=(r-u)*(n-a)&&(r-u)*(x-a)>=(i-u)*(t-a)}function c(e,n){return e.next.i!==n.i&&e.prev.i!==n.i&&!function(e,n){var r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==n.i&&r.next.i!==n.i&&Z(r,r.next,e,n))return !0;r=r.next;}while(r!==e);return !1}(e,n)&&(b(e,n)&&b(n,e)&&function(e,n){var r=e,t=!1,i=(e.x+n.x)/2,x=(e.y+n.y)/2;do{r.y>x!=r.next.y>x&&r.next.y!==r.y&&i<(r.next.x-r.x)*(x-r.y)/(r.next.y-r.y)+r.x&&(t=!t),r=r.next;}while(r!==e);return t}(e,n)&&(d(e.prev,e,n.prev)||d(e,n.prev,n))||g(e,n)&&d(e.prev,e,e.next)>0&&d(n.prev,n,n.next)>0)}function d(e,n,r){return (n.y-e.y)*(r.x-n.x)-(n.x-e.x)*(r.y-n.y)}function g(e,n){return e.x===n.x&&e.y===n.y}function Z(e,n,r,t){var i=m(d(e,n,r)),x=m(d(e,n,t)),u=m(d(r,t,e)),a=m(d(r,t,n));return i!==x&&u!==a||(!(0!==i||!w(e,r,n))||(!(0!==x||!w(e,t,n))||(!(0!==u||!w(r,e,t))||!(0!==a||!w(r,n,t)))))}function w(e,n,r){return n.x<=Math.max(e.x,r.x)&&n.x>=Math.min(e.x,r.x)&&n.y<=Math.max(e.y,r.y)&&n.y>=Math.min(e.y,r.y)}function m(e){return e>0?1:e<0?-1:0}function b(e,n){return d(e.prev,e,e.next)<0?d(e,n,e.next)>=0&&d(e,e.prev,n)>=0:d(e,n,e.prev)<0||d(e,e.next,n)<0}function k(e,n){var r=new V(e.i,e.x,e.y),t=new V(n.i,n.x,n.y),i=e.next,x=n.prev;return e.next=n,n.prev=e,r.next=i,i.prev=r,t.next=r,r.prev=t,x.next=t,t.prev=x,t}function M(e,n,r,t){var i=new V(e,n,r);return t?(i.next=t.next,i.prev=t,t.next.prev=i,t.next=i):(i.prev=i,i.next=i),i}function z(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ);}function V(e,n,r){this.i=e,this.x=n,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1;}function q(e,n,r,t){for(var i=0,x=n,u=r-t;x<r;x+=t)i+=(e[u]-e[x])*(e[x+1]+e[u+1]),u=x;return i}n.exports=r,n.exports.default=r,r.deviation=function(e,n,r,t){var i=n&&n.length,x=i?n[0]*r:e.length,u=Math.abs(q(e,0,x,r));if(i)for(var a=0,o=n.length;a<o;a++){var f=n[a]*r,v=a<o-1?n[a+1]*r:e.length;u-=Math.abs(q(e,f,v,r));}var s=0;for(a=0;a<t.length;a+=3){var l=t[a]*r,h=t[a+1]*r,p=t[a+2]*r;s+=Math.abs((e[l]-e[p])*(e[h+1]-e[l+1])-(e[l]-e[h])*(e[p+1]-e[l+1]));}return 0===u&&0===s?0:Math.abs((s-u)/u)},r.flatten=function(e){for(var n=e[0][0].length,r={vertices:[],holes:[],dimensions:n},t=0,i=0;i<e.length;i++){for(var x=0;x<e[i].length;x++)for(var u=0;u<n;u++)r.vertices.push(e[i][x][u]);i>0&&(t+=e[i-1].length,r.holes.push(t));}return r};var L=function(e){var n=e._pbf;n.pos=e._geometry;for(var r,t=n.readVarint()+n.pos,i=1,x=0,u=0,a=0,o=[];n.pos<t;){if(x<=0){var f=n.readVarint();i=7&f,x=f>>3;}if(x--,1===i||2===i)u+=n.readSVarint(),a+=n.readSVarint(),1===i&&(r&&o.push(r),r=[]),r.push([u,a]);else {if(7!==i)throw new Error("unknown command "+i);r&&r.push(r[0].slice());}}return r&&o.push(r),o};function T(e){var n=e.length;if(n<=1)return [e];for(var r,t,i=[],x=0;x<n;x++){var u=E(e[x]);0!==u&&(void 0===t&&(t=u<0),t===u<0?(r&&i.push(r),r=[e[x]]):r.push(e[x]));}return r&&i.push(r),i}function E(e){for(var n,r,t=0,i=0,x=e.length,u=x-1;i<x;u=i++)n=e[i],t+=((r=e[u])[0]-n[0])*(n[1]+r[1]);return t}var _=function(e,n){void 0===n&&(n=[]);for(var r=[],t=0,i=0;i<e.length;i++){for(var x=0;x<e[i].length;x++)n[n.length]=e[i][x][0],n[n.length]=e[i][x][1];i>0&&(t+=e[i-1].length,r[r.length]=t);}return {vertices:n,holes:r,dimensions:e[0][0].length}},W={id:"MVTWorker",Worker:function(r){function t(){return null!==r&&r.apply(this,arguments)||this}return e.__extends(t,r),t.prototype.process=function(r,t,i,x){var u=function(r,t,i,x){var u=new e.VectorTile(new e.pbf(r)),a={},o=0,f=0,v=0;for(var s in u.layers){for(var l=u.layers[s],h=0,p=a[o++]={length:0,features:{}};h<l.length;){if(3==(S=l.feature(h)).type){for(var y=[],c=[],d=0,g=0,Z=T(L(S));g<Z.length;g++){var w=Z[g],m=_(w),b=n.exports(m.vertices,m.holes,m.dimensions);c.push(d);for(var k=0,M=b;k<M.length;k++){var z=M[k];y[y.length]=d+z;}d+=m.vertices.length/m.dimensions;}p.features[h]={tris:y,verts:[],polys:c,holes:[]},p.length+=y.length+2+1;}h++;}p.length&&(v++,f+=2*p.length);}var V=new e.XYZBin(6*v+f);if(f>0)for(var q in a){var E=(p=a[q]).length;if(E){V.setLayer(q,E);var W=p.features;for(var B in W){var S;b=(S=W[B]).tris,V.setFeature(Number(B),b);}}}return V.getBuffer()}(r);return {data:{mvt:r,triangles:u},transfer:[r,u]}},t}(function(){function n(){var n=this.loader=new e.HTTPLoader({responseType:"arraybuffer"}),r=this;self.addEventListener("message",(function(e){var t=e.data,i=t.msg,x=t.quadkey,u=t.url,a=t.x,o=t.y,f=t.z;switch(i){case"abort":n.abort({quadkey:x});break;case"load":n.baseUrl=u,n.load({quadkey:x},(function(e){var n=r.process(e,a,o,f),t=n.data,i=n.transfer;self.postMessage({msg:"success",url:u,quadkey:x,data:t},i);}),(function(e){self.postMessage({msg:"error",url:u,quadkey:x,data:e});}));}}));}return n.prototype.process=function(e,n,r,t){return {data:e,transfer:[e]}},n}())},B=[W];self.addEventListener("message",(function e(n){var r=n.data,t=r.msg,i=r.worker;if(r.payload,"init"==t){var x=B.find((function(e){return e.id==i})).Worker;x&&(new x,x=null),B=null,self.removeEventListener("message",e);}}));}));

	define(["exports","./shared","@here/xyz-maps-common"],(function(e,t,r){"use strict";function o(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var o=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:function(){return e[r]}});}})),t.default=e,Object.freeze(t)}var n=o(r),i=function(e,t){this.x=e,this.y=t;},a=function(e,t,r,o){this.minX=e,this.minY=t,this.maxX=r,this.maxY=o;},s=function(e,t){this.longitude=e,this.latitude=t;},u=function(e,t,r,o){this.minLon=e,this.minLat=t,this.maxLon=r,this.maxLat=o;},p=[{zIndex:0,type:"Circle",radius:6,fill:"#ff0000"}],l=[{zIndex:0,type:"Line",strokeWidth:10,stroke:"#ff0000"}],c=[{zIndex:0,type:"Polygon",strokeWidth:1,stroke:"#ffffff",fill:"#ff0000"}],h={styleGroups:{Point:p,MultiPoint:p,LineString:l,MultiLineString:l,Polygon:c,MultiPolygon:c},assign:function(e){return e.geometry.type}};function f(e,t){for(var r in t)e[r]=t[r];return e}var d=[],y=function(){function e(e,t){this.styleGroups=null,this._c=null;var r=function(e,t){if("object"!=typeof e||null===e)return e;for(var o in t=t||(Array.isArray(e)?[]:{}),e)t[o]=r(e[o]);return t};for(var o in e)this[o]="styleGroups"==o?r(e.styleGroups,{}):e[o];this._c=t||{};}return e.prototype.assign=function(e,t){return e.geometry.type},e.prototype.getCustomStyleGroup=function(e){return this._c[e.id]},e.prototype.getStyleGroup=function(e,t,r){var o=this._c[e.id];return (null==o||r)&&"object"!=typeof(o=this.assign(e,t))&&(o=this.styleGroups[o]),o},e.prototype.setStyleGroup=function(e,t,r){var o=e.id,n=this._c;return t&&r&&(t=this.merge(this.getStyleGroup(e),t)),t?n[o]=t:null===t||!1===t?t=n[o]=d:n[o]&&delete n[o],t},e.prototype.merge=function(e,t){if(null===t||!1===t)return null;for(var r,o=[],n=0,i=e.length;n<i;n++)r=f({},e[n]),t[n]&&f(r,t[n]),o[n]=r;return o},e}(),v=function(){function e(e){this.name="",this.__type="Layer";var t=this;for(var o in e)t[o]=e[o];null==t.id&&(t.id="L-"+(1e8*Math.random()^0)),t._l=new r.Listener(["layerAdd","layerRemove"]);}return e.prototype.addEventListener=function(e,t,r){var o=this._l;if(o.isDefined(e))return o.add(e,t,r)},e.prototype.removeEventListener=function(e,t,r){var o=this._l;if(o.isDefined(e))return o.remove(e,t,r)},e.prototype.dispatchEvent=function(e,t){t.layer=this;var r=new CustomEvent(e,{detail:t});this._l.trigger(e,r,!0);},e}(),g="featureRemove",m="featureAdd",x="featureCoordinatesChange",_="styleGroupChange",L="styleChange",w="viewportReady",T="clear",b=function(e){function r(r){var o=this,n=r.pointerEvents;delete r.pointerEvents,(o=e.call(this,t.__assign({min:15,max:32,tiled:!0},r))||this)._p=[],o._sd=null,o._pev=!0,o.__type="Layer",o.margin=20,o.tiled=!0,o.levelOffset=0,o.custom=!1;var i=o;[m,g,x,T,_,w,L].forEach((function(e){return i._l.addEvent(e)})),"boolean"==typeof n&&o.pointerEvents(n);var a,s=r.providers||r.provider,u=256,p=function(e,t,r){for(var o=e;o<=t;o++)i._p[o]=r;};if(s instanceof Array)for(var l=0,c=s;l<c.length;l++){var f=c[l];p(f.min,f.max,f.provider);}else {u=o.tileSize?s.size=o.tileSize:Math.max(u,s.size);var d=Number(512==u),y=i.min,v=i.max;p(y-d,v-d,s),i._fp=s,s.minLevel=y,s.maxLevel=v;}o.tileSize||u%256||(o.tileSize=u),o.levelOffset=Math.round(Math.log(o.tileSize)/Math.log(2)-8),i._p.forEach((function(e,t){e&&("FeatureProvider"==e.__type&&(e.addEventListener(m,i._eventProxy,i),e.addEventListener(g,i._eventProxy,i),e.addEventListener(x,i._eventProxy,i)),e.addEventListener(T,i._eventProxy,i));})),i.setMargin(i.getMargin());var b=o._fp&&o._fp.styles;return (a=r.style||r.styles||b||h)&&i.setStyle(a),["style","styles","provider","providers"].forEach((function(e){delete i[e];})),o}return t.__extends(r,e),r.prototype.getProvider=function(e){return e?this._p[Math.floor(e)-this.levelOffset]:this._fp},r.prototype.addEventListener=function(t,r,o){var n;return this._l.isDefined(t)?e.prototype.addEventListener.call(this,t,r,o):null===(n=this._fp)||void 0===n?void 0:n.addEventListener(t,r,o)},r.prototype.removeEventListener=function(t,r,o){return this._l.isDefined(t)?e.prototype.removeEventListener.call(this,t,r,o):this._fp.removeEventListener(t,r,o)},r.prototype._eventProxy=function(e){var t=e.type,r=e.detail;r.layer=this,t==g&&this.setStyleGroup(r.feature),this._l.trigger(t,e,!0);},r.prototype.setFeatureCoordinates=function(e,t){return this._fp.setFeatureCoordinates(e,t)},r.prototype.addFeature=function(e,t){var r=this._fp;if(r.addFeature){var o=r.addFeature(e);return t&&this.setStyleGroup(o,t),o}},r.prototype.removeFeature=function(e){var t=this._fp;if(t.removeFeature)return t.removeFeature(e)},r.prototype.setStyleGroup=function(e,t,r){this._sd&&this.dispatchEvent(_,{feature:e,styleGroup:this._sd.setStyleGroup(e,t,r)});},r.prototype.getStyleGroup=function(e,t,r){var o;return null===(o=this._sd)||void 0===o?void 0:o.getStyleGroup(e,t,r)},r.prototype._getCustomStyleGroup=function(e){var t;return null===(t=this._sd)||void 0===t?void 0:t.getCustomStyleGroup(e)},r.prototype.search=function(e,t){var r=this._fp;if(r&&r.search)return r.search.apply(this._fp,arguments)},r.prototype.getTile=function(e,t){var r=e.length,o=this._p[r];if(o)return o.getTile(e,t)},r.prototype.cancelTile=function(e,t){var r="string"==typeof e?e.length:e.quadkey.length,o=this._p[r];if(o&&o.cancel)return o.cancel(e,t)},r.prototype.getCachedTile=function(e){var t=e.length,r=this._p[t];if(r)return r.getCachedTile(e)},r.prototype.setStyle=function(e,t){void 0===t&&(t=!1);var r=function(e){return "function"==typeof e};r(e.getStyleGroup)&&r(e.setStyleGroup)||(e=new y(e,t&&this._sd&&this._sd._c)),this._sd=e,this.dispatchEvent(L,{style:e});},r.prototype.getStyle=function(){return this._sd},r.prototype.getMargin=function(){return this.margin},r.prototype.setMargin=function(e){void 0===e&&(e=0),e=Number(e);for(var t=this._p,r=t.length;r--;)t[r]&&t[r].setMargin(e);return this.margin=e},r.prototype.pointerEvents=function(e){return null!=e&&(this._pev=!!e),this._pev},r.prototype.getCopyright=function(e){for(var t,r=this._p.filter((function(e,t,r){return r.indexOf(e)===t})),o=[],n=0,i=function(t){t.length&&o.push.apply(o,t),--n||e&&e(o);};t=r.pop();)t&&t.getCopyright&&(n++,t.getCopyright(i));},r}(v);b.prototype.modifyFeatureCoordinates=b.prototype.setFeatureCoordinates;var P=function(e){function r(t,r,o){var n=e.call(this,r)||this;return n.cbs=new Map,o||(o=new ArrayBuffer(0)),n.worker=new Worker(window.here.xyz.maps.__workerURL),n.worker.postMessage({msg:"init",worker:t,payload:o},[o]),n.worker.addEventListener("message",n.receiveMessage.bind(n)),n}return t.__extends(r,e),r.prototype.processData=function(e){return e.data},r.prototype.receiveMessage=function(e){var t=e.data;if("success"===t.msg){var r=t.quadkey,o=this.cbs.get(r);o&&(this.cbs.delete(r),o.success(this.processData(t.data)));}},r.prototype.load=function(e,t,r){var o=this.getUrl(e),n=e.quadkey,i=e.x,a=e.y,s=e.z;this.cbs.set(n,{tile:e,success:t,error:r}),this.worker.postMessage({msg:"load",url:o,quadkey:n,x:i,y:a,z:s});},r.prototype.abort=function(e){var t=this.getUrl(e),r=e.quadkey,o=e.x,n=e.y,i=e.z;this.cbs.get(r)&&(this.cbs.delete(r),this.worker.postMessage({msg:"abort",url:t,quadkey:r,x:o,y:n,z:i}));},r}(t.HTTPLoader),M=function(e){function r(t){return e.call(this,"MVTWorker",t)||this}return t.__extends(r,e),r.prototype.processData=function(e){var r=new t.XYZBin(e.triangles),o=r.getLayers();for(var n in o)r.getFeatures(o[n]);return {mvt:e.mvt,xyz:o}},r}(P),E=function(){function e(e,t){this._m=0,this.id=e.id,this.properties=e.properties,this.geometry=e.geometry,this.bbox=e.bbox,this._provider=t;}return e.prototype.toJSON=function(){return r.JSUtils.clone({id:this.id,type:this.type,bbox:this.bbox,properties:this.properties,geometry:{type:this.geometry.type,coordinates:this.geometry.coordinates}})},e.prototype.getProvider=function(){return this._provider},e.prototype.getBBox=function(){return this._provider.decBBox(this)},e}();E.prototype.type="Feature";"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var F=t.vectorTile.VectorTile,S=t.vectorTile.VectorTileFeature;S.prototype.loadGeometry=function(){var e=this._pbf;e.pos=this._geometry;for(var t,r=e.readVarint()+e.pos,o=1,n=0,i=0,a=0,s=[];e.pos<r;){if(n<=0){var u=e.readVarint();o=7&u,n=u>>3;}if(n--,1===o||2===o)i+=e.readSVarint(),a+=e.readSVarint(),1===o&&(t&&s.push(t),t=[]),t.push([i,a]);else {if(7!==o)throw new Error("unknown command "+o);t&&t.push(t[0].slice());}}return t&&s.push(t),s};var B=r.TaskManager.getInstance(),R=0;function O(e){for(var t,r,o=0,n=0,i=e.length,a=i-1;n<i;a=n++)t=e[n],o+=((r=e[a])[0]-t[0])*(t[1]+r[1]);return o}var k=function(e,t){return 360*e/t-180},C=function(e,t){var r=180-360*e/t;return 360/Math.PI*Math.atan(Math.exp(r*Math.PI/180))-90},U=function(e,t,r,o,n){var i=e.loadGeometry();switch(e.type){case 1:for(var a=[],s=0;s<i.length;s++)a[s]=i[s][0];n(i=a,t,r,o,e);break;case 2:for(s=0;s<i.length;s++)n(i[s],t,r,o,e);break;case 3:i=function(e){var t=e.length;if(t<=1)return [e];for(var r,o,n=[],i=0;i<t;i++){var a=O(e[i]);0!==a&&(void 0===o&&(o=a<0),o===a<0?(r&&n.push(r),r=[e[i]]):r.push(e[i]));}return r&&n.push(r),n}(i);for(s=0;s<i.length;s++)for(var u=0;u<i[s].length;u++)n(i[s][u],t,r,o,e);}return i};function z(e,t,r){var o=function(e,t,r,o){var n=1/0,i=-n,a=n,s=-a,u=e.extent*(1<<o),p=e.extent*t,l=e.extent*r,c=S.types[e.type];return U(e,t,r,o,(function(e){for(var t=0,r=e;t<r.length;t++){var o=r[t],u=o[0],p=o[1];u<n&&(n=u),u>i&&(i=u),p<a&&(a=p),p>s&&(s=p);}})).length>1&&(c="Multi"+c),{bbox:[k(n+p,u),C(s+l,u),k(i+p,u),C(a+l,u)],type:c}}(e,t.x,t.y,t.z),n={type:"Feature",geometry:new D(o.type,e,t),properties:e.properties};return "id"in e&&(n.id=e.id),r&&(n.bbox=o.bbox),n}var I=function(e,t,r,o,n){for(var i=n.extent,a=1<<o,s=0,u=e;s<u.length;s++){var p=u[s];p[0]=(t+p[0]/i)/a,p[1]=(r+p[1]/i)/a;}},D=function(){function e(e,t,r){this.type=e,this._vtf=t,this.__xyz=r;}return e.prototype._coordinates=function(){var e=this.type,t=this.__xyz,r=t.x,o=t.y,n=t.z,i=U(this._vtf,r,o,n,I);return "Point"!=e&&"Polygon"!=e&&"LineString"!=e||(i=i[0]),i},Object.defineProperty(e.prototype,"coordinates",{get:function(){var e=this.__xyz,t=e.x,r=e.y,o=e.z;return function(e,t,r,o){var n=e.extent*(1<<o),i=e.extent*t,a=e.extent*r,s=U(e,t,r,o,(function(e){for(var t=0;t<e.length;t++){var r=e[t],o=k(r[0]+i,n),s=C(r[1]+a,n);e[t]=[o,s];}}));return 1===s.length&&(s=s[0]),s}(this._vtf,t,r,o)},enumerable:!1,configurable:!0}),e}();function Y(e){B.create({init:function(){var r=[],o=new F(new t.pbf(e.data.mvt)),n=e.tile;for(var i in o.layers)r.push(i);return {xyz:{x:n.x,y:n.y,z:n.z},mvt:o,xyzLayers:e.data.xyz,layers:r,l:0,f:0,geojson:[]}},priority:4,exec:function(e){for(var t,r,o,n,i=e.mvt,a=e.xyz,s=e.layers,u=e.xyzLayers,p=e.l,l=e.f,c=e.geojson;p<s.length;){for(t=i.layers[s[p]],n={x:a.x,y:a.y,z:a.z,l:t.name};l<t.length;){if("MultiPolygon"==(o=(r=z(t.feature(l),n,!0)).geometry.type)||"Polygon"==o){var h=u[p]&&u[p].features[l];h&&(r.geometry._xyz=h);}if(r.id=++R,l++,null==r.properties.layer&&(r.properties.layer=t.name),c.push(r),!(l%16))return e.f=l,this.CONTINUE}return e.l=++p,e.f=0,this.CONTINUE}return this.BREAK},onDone:function(t){e.ready(t.geojson);}}).start();}var X=Math.PI,q=X/180,A=2*X*(19113026/3),j=Array.from({length:33},(function(e,t){return 40075017/256/(1<<t)})),G=function(e,t){return (e+180)/360*t},H=function(e,t){return (180-180/X*Math.log(Math.tan(X/4+e*X/360)))*t/360},J=function(e,t){return 360*e/t-180},N=function(e,t){var r=180-360*e/t;return 360/X*Math.atan(Math.exp(r*q))-90},V=function(e){return void 0===e&&(e=0),A*Math.cos(e*q)},Z={mapSizePixel:function(e,t){return Math.pow(2,t)*e},lon2x:G,lat2y:H,x2lon:J,y2lat:N,pixelToGeo:function(e,t,r){return new s(J(e,r),N(t,r))},geoToPixel:function(e,t,r){return new i(G(e,r),H(t,r))},meterToPixel:function(e,t){return e/j[t]},pixelToMeter:function(e,t){return e*j[t]},getGroundResolution:function(e){return j[e]},alt2z:function(e,t){return e/V(t)},earthCircumference:V},W=r.global.Math,K=256,Q=85.05112878,$=-85.05112878,ee=function(e,t,r){var o=1<<r;return [W.floor(Z.lon2x(e,o)),W.floor(Z.lat2y(t,o)),r]},te=function(e){"number"==typeof e&&(e=String(e));for(var t=e.length,r=0,o=0,n=0;n<t;++n)switch(r*=2,o*=2,e[n]){case"1":o++;break;case"3":o++;case"2":r++;}return [t,r,o]},re=function(e,t,r){for(var o,n="";e-- >0;)n+=(0!=(r&(o=1<<e)))+2*(0!=(t&o));return n},oe=function(e,t,r){var o=K<<e,n=K*r,i=K*t;return [Z.x2lon(n,o),Z.y2lat(i+K,o),Z.x2lon(n+K,o),Z.y2lat(i,o)]},ne=function(e,t){for(var r=[],o=t[1]-e[1]+1,n=t[0]-e[0]+1,i=e[2],a=0;a<o;a++)for(var s=0;s<n;s++)r[r.length]=re(i,e[1]+a,e[0]+s);return r},ie={geoToGrid:ee,pixelToGrid:function(e,t,r){return [W.floor(e),W.floor(t),r]},quadToGrid:te,tileXYToQuadKey:re,getGeoBounds:oe,getTilesOfLevel:function(e,t){var r=[e],o=0,n=r.length,i=e.length;if(t<=i)return [e.substring(0,t)];for(;i<t;){for(;o<n;o++)r.push(r[o]+"0",r[o]+"1",r[o]+"2",r[o]+"3");o=n,n=r.length,i++;}return r.slice(o)},getTilesIds:ne,getTilesInRect:function(e,t,r,o,n){r>=180&&(r=179.999999),e<=-180&&(e=-180),o>=Q&&(o=85.05112778),t<$&&(t=-85.05112778);var i=ee(e,o,n),a=ee(r,t,n);return ne(i,a)}},ae={exports:{}};ae.exports=function(){function e(e,o,n,i,a){!function e(r,o,n,i,a){for(;i>n;){if(i-n>600){var s=i-n+1,u=o-n+1,p=Math.log(s),l=.5*Math.exp(2*p/3),c=.5*Math.sqrt(p*l*(s-l)/s)*(u-s/2<0?-1:1);e(r,o,Math.max(n,Math.floor(o-u*l/s+c)),Math.min(i,Math.floor(o+(s-u)*l/s+c)),a);}var h=r[o],f=n,d=i;for(t(r,n,o),a(r[i],h)>0&&t(r,n,i);f<d;){for(t(r,f,d),f++,d--;a(r[f],h)<0;)f++;for(;a(r[d],h)>0;)d--;}0===a(r[n],h)?t(r,n,d):t(r,++d,i),d<=o&&(n=d+1),o<=d&&(i=d-1);}}(e,o,n||0,i||e.length-1,a||r);}function t(e,t,r){var o=e[t];e[t]=e[r],e[r]=o;}function r(e,t){return e<t?-1:e>t?1:0}var o=function(e){void 0===e&&(e=9),this._maxEntries=Math.max(4,e),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear();};function n(e,t,r){if(!r)return t.indexOf(e);for(var o=0;o<t.length;o++)if(r(e,t[o]))return o;return -1}function i(e,t){a(e,0,e.children.length,t,e);}function a(e,t,r,o,n){n||(n=d(null)),n.minX=1/0,n.minY=1/0,n.maxX=-1/0,n.maxY=-1/0;for(var i=t;i<r;i++){var a=e.children[i];s(n,e.leaf?o(a):a);}return n}function s(e,t){return e.minX=Math.min(e.minX,t.minX),e.minY=Math.min(e.minY,t.minY),e.maxX=Math.max(e.maxX,t.maxX),e.maxY=Math.max(e.maxY,t.maxY),e}function u(e,t){return e.minX-t.minX}function p(e,t){return e.minY-t.minY}function l(e){return (e.maxX-e.minX)*(e.maxY-e.minY)}function c(e){return e.maxX-e.minX+(e.maxY-e.minY)}function h(e,t){return e.minX<=t.minX&&e.minY<=t.minY&&t.maxX<=e.maxX&&t.maxY<=e.maxY}function f(e,t){return t.minX<=e.maxX&&t.minY<=e.maxY&&t.maxX>=e.minX&&t.maxY>=e.minY}function d(e){return {children:e,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function y(t,r,o,n,i){for(var a=[r,o];a.length;)if(!((o=a.pop())-(r=a.pop())<=n)){var s=r+Math.ceil((o-r)/n/2)*n;e(t,s,r,o,i),a.push(r,s,s,o);}}return o.prototype.all=function(){return this._all(this.data,[])},o.prototype.search=function(e){var t=this.data,r=[];if(!f(e,t))return r;for(var o=this.toBBox,n=[];t;){for(var i=0;i<t.children.length;i++){var a=t.children[i],s=t.leaf?o(a):a;f(e,s)&&(t.leaf?r.push(a):h(e,s)?this._all(a,r):n.push(a));}t=n.pop();}return r},o.prototype.collides=function(e){var t=this.data;if(!f(e,t))return !1;for(var r=[];t;){for(var o=0;o<t.children.length;o++){var n=t.children[o],i=t.leaf?this.toBBox(n):n;if(f(e,i)){if(t.leaf||h(e,i))return !0;r.push(n);}}t=r.pop();}return !1},o.prototype.load=function(e){if(!e||!e.length)return this;if(e.length<this._minEntries){for(var t=0;t<e.length;t++)this.insert(e[t]);return this}var r=this._build(e.slice(),0,e.length-1,0);if(this.data.children.length)if(this.data.height===r.height)this._splitRoot(this.data,r);else {if(this.data.height<r.height){var o=this.data;this.data=r,r=o;}this._insert(r,this.data.height-r.height-1,!0);}else this.data=r;return this},o.prototype.insert=function(e){return e&&this._insert(e,this.data.height-1),this},o.prototype.clear=function(){return this.data=d([]),this},o.prototype.remove=function(e,t){if(!e)return this;for(var r,o,i,a=this.data,s=this.toBBox(e),u=[],p=[];a||u.length;){if(a||(a=u.pop(),o=u[u.length-1],r=p.pop(),i=!0),a.leaf){var l=n(e,a.children,t);if(-1!==l)return a.children.splice(l,1),u.push(a),this._condense(u),this}i||a.leaf||!h(a,s)?o?(r++,a=o.children[r],i=!1):a=null:(u.push(a),p.push(r),r=0,o=a,a=a.children[0]);}return this},o.prototype.toBBox=function(e){return e},o.prototype.compareMinX=function(e,t){return e.minX-t.minX},o.prototype.compareMinY=function(e,t){return e.minY-t.minY},o.prototype.toJSON=function(){return this.data},o.prototype.fromJSON=function(e){return this.data=e,this},o.prototype._all=function(e,t){for(var r=[];e;)e.leaf?t.push.apply(t,e.children):r.push.apply(r,e.children),e=r.pop();return t},o.prototype._build=function(e,t,r,o){var n,a=r-t+1,s=this._maxEntries;if(a<=s)return i(n=d(e.slice(t,r+1)),this.toBBox),n;o||(o=Math.ceil(Math.log(a)/Math.log(s)),s=Math.ceil(a/Math.pow(s,o-1))),(n=d([])).leaf=!1,n.height=o;var u=Math.ceil(a/s),p=u*Math.ceil(Math.sqrt(s));y(e,t,r,p,this.compareMinX);for(var l=t;l<=r;l+=p){var c=Math.min(l+p-1,r);y(e,l,c,u,this.compareMinY);for(var h=l;h<=c;h+=u){var f=Math.min(h+u-1,c);n.children.push(this._build(e,h,f,o-1));}}return i(n,this.toBBox),n},o.prototype._chooseSubtree=function(e,t,r,o){for(;o.push(t),!t.leaf&&o.length-1!==r;){for(var n=1/0,i=1/0,a=void 0,s=0;s<t.children.length;s++){var u=t.children[s],p=l(u),c=(h=e,f=u,(Math.max(f.maxX,h.maxX)-Math.min(f.minX,h.minX))*(Math.max(f.maxY,h.maxY)-Math.min(f.minY,h.minY))-p);c<i?(i=c,n=p<n?p:n,a=u):c===i&&p<n&&(n=p,a=u);}t=a||t.children[0];}var h,f;return t},o.prototype._insert=function(e,t,r){var o=r?e:this.toBBox(e),n=[],i=this._chooseSubtree(o,this.data,t,n);for(i.children.push(e),s(i,o);t>=0&&n[t].children.length>this._maxEntries;)this._split(n,t),t--;this._adjustParentBBoxes(o,n,t);},o.prototype._split=function(e,t){var r=e[t],o=r.children.length,n=this._minEntries;this._chooseSplitAxis(r,n,o);var a=this._chooseSplitIndex(r,n,o),s=d(r.children.splice(a,r.children.length-a));s.height=r.height,s.leaf=r.leaf,i(r,this.toBBox),i(s,this.toBBox),t?e[t-1].children.push(s):this._splitRoot(r,s);},o.prototype._splitRoot=function(e,t){this.data=d([e,t]),this.data.height=e.height+1,this.data.leaf=!1,i(this.data,this.toBBox);},o.prototype._chooseSplitIndex=function(e,t,r){for(var o,n,i,s,u,p,c,h=1/0,f=1/0,d=t;d<=r-t;d++){var y=a(e,0,d,this.toBBox),v=a(e,d,r,this.toBBox),g=(n=y,i=v,s=void 0,u=void 0,p=void 0,c=void 0,s=Math.max(n.minX,i.minX),u=Math.max(n.minY,i.minY),p=Math.min(n.maxX,i.maxX),c=Math.min(n.maxY,i.maxY),Math.max(0,p-s)*Math.max(0,c-u)),m=l(y)+l(v);g<h?(h=g,o=d,f=m<f?m:f):g===h&&m<f&&(f=m,o=d);}return o||r-t},o.prototype._chooseSplitAxis=function(e,t,r){var o=e.leaf?this.compareMinX:u,n=e.leaf?this.compareMinY:p;this._allDistMargin(e,t,r,o)<this._allDistMargin(e,t,r,n)&&e.children.sort(o);},o.prototype._allDistMargin=function(e,t,r,o){e.children.sort(o);for(var n=this.toBBox,i=a(e,0,t,n),u=a(e,r-t,r,n),p=c(i)+c(u),l=t;l<r-t;l++){var h=e.children[l];s(i,e.leaf?n(h):h),p+=c(i);}for(var f=r-t-1;f>=t;f--){var d=e.children[f];s(u,e.leaf?n(d):d),p+=c(u);}return p},o.prototype._adjustParentBBoxes=function(e,t,r){for(var o=r;o>=0;o--)s(t[o],e);},o.prototype._condense=function(e){for(var t=e.length-1,r=void 0;t>=0;t--)0===e[t].children.length?t>0?(r=e[t-1].children).splice(r.indexOf(e[t]),1):this.clear():i(e[t],this.toBBox);},o}();var se=function(e){function r(t){return e.call(this,t)||this}return t.__extends(r,e),r.prototype.toBBox=function(e){var t=e.bbox;return {minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]}},r.prototype.compareMinX=function(e,t){return e.bbox[0]-t.bbox[0]},r.prototype.compareMinY=function(e,t){return e.bbox[1]-t.bbox[1]},r}(ae.exports),ue=256,pe=null,le=function(){function e(e,t,r,o){var n=te(e);this.quadkey=e,this.z=n[0],this.y=n[1],this.x=n[2],this.type=t,this.bounds=oe(n[0],n[1],n[2]),this.expire=o,this.clipped=r;}return e.prototype.expired=function(e){return (e=e||Date.now())-this.loadStopTs>1e3*this.expire},e.prototype.add=function(e){var t=this.data;t&&-1==t.indexOf(e)&&(t.push(e),this.tree&&this.tree.insert(e));},e.prototype.remove=function(e){var t=this.data.indexOf(e);-1!==t&&(this.data.splice(t,1),this.tree&&this.tree.remove(e));},e.prototype.search=function(e){if(this.data)return this.tree||(this.tree=new se(9),this.tree.load(this.data)),this.tree.search(e)},e.prototype.isLoaded=function(){return "number"==typeof this.loadStopTs},e.prototype.getContentBounds=function(){if(!this.cbnds){var e=this.bounds,t=this.provider,r=t.margin;if(r){var o=t.size,n=o<<this.z,i=Z.lon2x(e[0],n),a=Z.lat2y(e[1],n);this.cbnds=[Z.x2lon(i-r,n),Z.y2lat(a+r,n),Z.x2lon(i+r+o,n),Z.y2lat(a-r-o,n)];}else this.cbnds=this.bounds;}return this.cbnds},e.prototype.project=function(e,t){var r=ue<<this.z,o=this.x*ue,n=this.y*ue;return [Math.round(Z.lon2x(e,r)-o),Math.round(Z.lat2y(t,r)-n)]},e.prototype.lon2x=function(e,t){void 0===t&&(t=ue);var r=t<<this.z,o=this.x*t;return Z.lon2x(e,r)-o},e.prototype.lat2y=function(e,t){void 0===t&&(t=ue);var r=t<<this.z,o=this.y*t;return Z.lat2y(e,r)-o},e.prototype.isInside=function(e){var t=this.bounds,r=e[0],o=e[1];return r>t[0]&&r<=t[2]&&o>t[1]&&o<=t[3]},e}(),ce=le.prototype;ce.expire=1/0,ce.error=pe,ce.canvasX=pe,ce.canvasY=pe;var he=function(e){function r(t,r,o,n){var i=e.call(this,t,r,o,n)||this;return i.s=1<<i.z,i}return t.__extends(r,e),r.prototype.lon2x=function(e,t){return void 0===t&&(t=256),(e*this.s-this.x)*t},r.prototype.lat2y=function(e,t){return void 0===t&&(t=256),(e*this.s-this.y)*t},r.prototype.isInside=function(e){var t=e[0]*this.s-this.x,r=e[1]*this.s-this.y;return !(t<0||t>1||r<0||r>1)},r}(le),fe=function(){function e(e,t,o){this.lvl=e,this.main="object"==typeof t?t:new r.LRU(t||256),this.sub="object"==typeof o?o:new r.LRU(t||1024);}return e.prototype.forEach=function(e){this.main.forEach(e),this.sub.forEach(e);},e.prototype.clear=function(){this.main.clear(),this.sub.clear();},e.prototype.getCache=function(e){return e==this.lvl?this.main:this.sub},e.prototype.remove=function(e){this.getCache(e.z).remove(e.quadkey);},e.prototype.get=function(e){return this.getCache(e.length).get(e)},e.prototype.set=function(e){var t=this.getCache(e.z).set(e.quadkey,e),r=this._onDrop;t&&r&&r(t);},e.prototype.onDrop=function(e){this._onDrop=e;},e}(),de=function(){function e(e){this.margin=0,this.Tile=le,this.size=256,this.expire=Infinity,this.clipped=!1;var t=this;for(var o in e=e||{})this[o]=e[o];null==this.id&&(this.id="TP-"+(1e6*Math.random()^0)),t.storage=e.storage||new fe(t.level),t.initStorage(t.storage),this.listeners=new r.Listener(["clear","error"]);}return e.prototype.dispatchEvent=function(e,t){t.provider=this;var r=new CustomEvent(e,{detail:t});this.listeners.trigger(e,r,!0);},e.prototype.initStorage=function(e){e.onDrop((function(e){return e.provider._removeTile(e)}));},e.prototype.addEventListener=function(e,t,r){return this.listeners.add(e,t,r)},e.prototype.removeEventListener=function(e,t,r){return this.listeners.remove(e,t,r)},e.prototype.clear=function(e){this.storage.clear();},e.prototype.getCachedTile=function(e){return this.storage.get(e)},e.prototype.setMargin=function(e){void 0===e&&(e=0),this.margin=Number(e),this.storage.forEach((function(e){return e.cbnds=null}));},e.prototype.getCachedTilesOfBBox=function(e,t){var r=e[0],o=e[1],n=e[2],i=e[3],a=[];return t^=0,this.storage.forEach((function(e){var s,u,p,l,c,h,f,d=e.getContentBounds();s=d[0],u=d[2],p=d[1],l=d[3],c=r,h=o,f=i,s<=n&&c<=u&&p<=f&&h<=l&&(!t||e.z==t)&&(a[a.length]=e);})),a},e.prototype.config=function(e){for(var t in e=e||{})this.config[t]=e[t];return this},e.prototype.createTile=function(e){var t=new this.Tile(e,this.dataType,this.clipped,this.expire);return t.provider=this,t},e}();de.prototype.__type="Provider";var ye,ve=function(e,t){var r,o;t&&((r=e[0])<t[0]&&(t[0]=r),r>t[2]&&(t[2]=r),(o=e[1])<t[1]&&(t[1]=o),o>t[3]&&(t[3]=o));},ge=function(e,t){for(var r=e.length;r--;)ve(e[r],t);},me=function(e,t){var r=e.geometry.type,o=e.geometry.coordinates;if("Point"==r)t?ve(o,t):t=[o[0],o[1],o[0],o[1]];else if(t=t||[1/0,1/0,-1/0,-1/0],"MultiLineString"==r)for(var n=0;n<o.length;n++)ge(o[n],t);else if("MultiPolygon"==r)for(var i=0;i<o.length;i++)ge(o[i][0],t);else if("LineString"==r||"MultiPoint"==r)ge(o,t);else {if("Polygon"!=r)return !1;ge(o[0],t);}return t},xe={calcBBox:me},_e="featureRemove",Le="featureAdd",we="featureCoordinatesChange";function Te(e){this.feature=e;}Te.prototype.cnt=0;var be=function(e){function o(t){var r=e.call(this,t)||this;return r.IDPOOL={},r.dataType="json",r.ignore=!1,r.cnt=0,r.__type="FeatureProvider",r.tree=new se(9),r.Feature=r.Feature||E,[Le,_e,we].forEach((function(e){return r.listeners.addEvent(e)})),r}return t.__extends(o,e),o.prototype.isDroppable=function(e){return !0},o.prototype.loadTileData=function(e,t,r){for(var o,n,i,a=this,s=[],u=t.length,p=0;p<u;p++)!1!==(o=a.prepareFeature(i=t[p]))?(i=o,(n=a._insert(i,e))?(i=n,s[s.length]=i):a.tree||(s[s.length]=a.getFeature(i.id))):(t.splice(p--,1),u--);t=s,a.tree&&a.tree.load(t),r(t=a.clipped?t:a.search(e.getContentBounds()));},o.prototype.addFeature=function(e){var t,r,o=this;if("object"==typeof e){if("FeatureCollection"==e.type&&(e=e.features||[]),Array.isArray(e)){for(var n=[],i=0,a=e.length;i<a;i++)n[i]=o.addFeature(e[i]);return n}if(o.isFeatureInstance(e,E)){var s=e.getProvider();s&&s!=o&&(e=e.toJSON());}if(!1!==(t=o.prepareFeature(e))){if((r=o._insert(t))!=ye){e=r;for(var u=o.getCachedTilesOfBBox(o.decBBox(e)),p=0,l=void 0;p<u.length;p++)(l=u[p]).add(e),l.z==o.level&&this._mark(e,l);o.tree&&o.tree.insert(e),o.ignore||o.dispatchEvent(Le,{feature:e,tiles:u});}}else e=null;return e}},o.prototype.addEventListener=function(t,r,o){return e.prototype.addEventListener.call(this,t,r,o)},o.prototype.removeEventListener=function(t,r,o){return e.prototype.removeEventListener.call(this,t,r,o)},o.prototype.all=function(){var e=this;return e.tree?e.tree.all():e._s({minX:-180,maxX:180,minY:-90,maxY:90})},o.prototype.getFeature=function(e){if(this.IDPOOL[e])return this.IDPOOL[e].feature},o.prototype.getFeatures=function(e){e instanceof Array||(e=[e]);for(var t=[],r=0;r<e.length;r++)t[r]=this.getFeature(e[r]);return 1==t.length?t[0]:t},o.prototype.getTile=function(e,t){var r=this,o=r.storage,n=o.get(e);return n===ye&&(o.set(n=r.createTile(e)),n.loadStartTs=n.loadStopTs=Date.now(),n.data=r.search(n.getContentBounds())),t&&t(n),n},o.prototype.setFilter=function(e){this.filter="function"==typeof e?e:ye;},o.prototype.getFeatureClass=function(e){return this.Feature},o.prototype.isFeatureInstance=function(e,t){return e instanceof t},o.prototype.createFeature=function(e,t){return new t(e,this)},o.prototype.search=function(e,t){var o,n,i=this;if("object"==typeof e)if(t)for(var a in e)t[a]=e[a];else t=e;var s=t&&t.radius||1;if(e instanceof Array)n=4==e.length?e:r.geotools.getPointBBox(e,s);else {if("number"==typeof e||"string"==typeof e||!e)return i.getFeatures(e);if(e.longitude!=ye&&e.latitude!=ye)n=r.geotools.getPointBBox([e.longitude,e.latitude],s);else if(e.minLon!=ye&&e.minLat!=ye&&e.maxLon!=ye&&e.maxLat!=ye)n=[e.minLon,e.minLat,e.maxLon,e.maxLat];else {if(o=e.point||e.rect||e.viewport)return i.search(o,t);if(e.id||e.ids)return i.getFeatures(e.id||e.ids)}}return n={minX:n[0],minY:n[1],maxX:n[2],maxY:n[3]},i._s(n)},o.prototype.exists=function(e){return this.IDPOOL[e.id]},o.prototype.setFeatureCoordinates=function(e,t){var r=e;if(e=this.getFeature(e.id)){var o=e.getBBox(),n=e.geometry,i=n.coordinates;this.ignore=!0,this.removeFeature(e),n._xyz&&delete n._xyz,n.coordinates=this.encCoord(n.type,t),e.bbox=null,this.addFeature(e),this.ignore=!1,this.dispatchEvent(we,{feature:e,prevBBox:o,prevCoordinates:i,provider:this});}else r.geometry.coordinates=t,r.bbox=null,this.updateBBox(r);},o.prototype.removeFeature=function(e){if(e){if("FeatureCollection"==e.type&&(e=e.features),Array.isArray(e)){for(var t=[],r=0,o=e.length;r<o;r++)t[r]=this.removeFeature(e[r]);return t}if(e=this.getFeature(e.id)){for(var n=this.getCachedTilesOfBBox(this.decBBox(e)),i=void 0,a=0;a<n.length;a++)(i=n[a]).isLoaded()&&i.remove(e);this.cnt--,delete this.IDPOOL[e.id],this.tree&&this.tree.remove(e),this.ignore||this.dispatchEvent(_e,{feature:e,tiles:n});}}return e},o.prototype.clear=function(e){var t,r=this,o=null;if(4==arguments.length&&(e=Array.prototype.slice.call(arguments)),e instanceof Array){o=r.getCachedTilesOfBBox(e,r.level);for(var n=0,i=void 0;n<o.length;n++)i=o[n],r._removeTile(i,!1),o[n]=i.quadkey;}else if(0==arguments.length){var a={},s=r.IDPOOL,u=0;for(var p in r.tree&&r.tree.clear(),s)t=r.getFeature(p),r.isDroppable(t)||(a[p]=new Te(t),u++,r.tree&&r.tree.insert(t));r.cnt=u,r.IDPOOL=a,de.prototype.clear.call(this,e);}r.dispatchEvent("clear",{tiles:o});},o.prototype._insert=function(e,t){var r=e.id,o=null,n=this.getFeatureClass(e),i=this.filter;return i&&!i(e)||(this.IDPOOL[r]===ye&&(this.cnt++,this.isFeatureInstance(e,n)?e._provider=this:e=this.createFeature(e,n),this.updateBBox(e),this.IDPOOL[r]=new Te(e),o=e),t&&this._mark(e,t)),o},o.prototype._mark=function(e,t){var r=this.IDPOOL[e.id];r[t.quadkey]||(r.cnt++,r[t.quadkey]=!0);},o.prototype._removeTile=function(e,t){var r,o=e.quadkey;if(this.storage.remove(e),r=e.data)for(var n=0;n<r.length;n++)this._dropFeature(r[n],o,t);},o.prototype._dropFeature=function(e,t,r){var o=this,n=o.IDPOOL[e.id];n&&(n[t]&&(n[t]=ye,n.cnt--),o.isDroppable(e)&&(n.cnt||(o.cnt--,delete o.IDPOOL[e.id],o.tree&&o.tree.remove(e),r&&o.dispatchEvent(_e,{feature:e}))));},o.prototype._s=function(e){if(this.tree)return this.tree.search(e);var t,r,o=1e8*Math.random()^0,n=this.level;return this.storage.forEach((function(i){if(i.z==n&&i.isLoaded()&&(r=i.search(e)).length)if(t)for(var a=0,s=r;a<s.length;a++){(l=s[a])._m!=o&&(l._m=o,t[t.length]=l);}else for(var u=0,p=t=r;u<p.length;u++){var l;(l=p[u])._m=o;}})),t||[]},o.prototype.encCoord=function(e,t){return t},o.prototype.decCoord=function(e){return e.geometry.coordinates},o.prototype.decBBox=function(e){return e.bbox},o.prototype.prepareFeature=function(e){return e.id==ye&&(e.id=1e8*Math.random()^0),e.bbox?(6===e.bbox.length&&(e.bbox=[e.bbox[0],e.bbox[1],e.bbox[3],e.bbox[4]]),e):this.updateBBox(e)&&e},o.prototype.updateBBox=function(e){if(!e.bbox){var t=me(e);if(!t)return !1;e.bbox=t,e.geometry._c&&(e.geometry._c=null);}return !0},o}(de);be.prototype.modifyFeatureCoordinates=be.prototype.setFeatureCoordinates;var Pe=function(){function e(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.executing=0,this.parallel=16,this.q=[],this.lq={},this.src=e;}return e.prototype.exec=function(){for(var e=this,t=e.q;t.length&&e.executing<e.parallel;)e.fire(t.pop(),t.pop(),t.pop());},e.prototype.fire=function(e,t,r,o){var n=this,i=n.src,a=n.lq;o^=0;n.executing++,a[e.quadkey]=[e,t,r,o],i[o].load(e,(function(r,o){n.executing--,delete a[e.quadkey],n.exec(),t(r,o);}),(function(t,o){r(t,o),n.executing--,delete a[e.quadkey],n.exec();}));},e.prototype.tile=function(e,t,r){this.q.push(r,t,e),this.exec();},e.prototype.abort=function(e){var t,r,o=this,n=o.q,i=o.lq,a=o.src,s=!0;return -1!==(t=n.indexOf(e))?n.splice(t-2,3):(r=i[e.quadkey])?(o.executing--,delete i[e.quadkey],a[r[3]].abort(e)):s=!1,o.exec(),s},e.prototype.store=function(e,t){var r=this.src;for(var o in r)if(r[o].store){r[o].store(e,t);break}},e.prototype.clear=function(){this.src.forEach((function(e){e.clear&&e.clear();}));},e.prototype.setUrl=function(){var e=this.src;for(var t in e)e[t].setUrl&&e[t].setUrl.apply(e[t],arguments);},e}();Pe.prototype;var Me=function(){function e(e,t){this.c=0,this.cbs=[],this.qks=t,this.tile=e;}return e.prototype.receive=function(e){var t=this;if(!t.ready){var r=t.tile,o=t.qks,n=o.indexOf(e.quadkey);if(-1!=n&&(o[n]=null,++t.c==o.length)){t.ready=!0,r.processedData=undefined;var i=e.error;i?r.error=i:r.data=r.provider.search(r.getContentBounds()),r.loadStopTs=Date.now(),t.exec(),r.onLoaded.length=0,t.qks=null;}}},e.prototype.exec=function(){for(var e=this.cbs,t=e.length,r=this.tile,o=0;o<t;)e[o++](r,r.error);e.length=0;},e.prototype.add=function(e){var t=this.cbs;if("function"==typeof e&&-1==t.indexOf(e))return t.push(e),!0},e.prototype.remove=function(e){var t=this.cbs,r=t.indexOf(e);return -1!=r&&t.splice(r,1),t.length},e}();Me.prototype.ready=!1;var Ee,Fe,Se=function(e){return "function"==typeof e},Be=function(e){return Se(e)},Re=function(e){return function(t,r,o){var n={data:t,provider:this,ready:r};o&&(n.tile={x:o.x,y:o.y,z:o.z}),function(e,t){void 0===t&&(t={});var r,o,n=t.ready;r=Be(e)?e(t):t.data,!(o=r)||"object"!=typeof o&&"function"!=typeof o||"function"!=typeof o.then?void 0!==r&&n(r):r.then(n);}(e,n);}},Oe=function(){function e(e){var t=e.loader;if(!t)throw new Error("no tile loader defined.");t instanceof Pe||(t=new Pe(t)),this.loader=t,this.provider=e.provider;var r=e.preProcessor;this.preprocess=Re(r),"function"==typeof e.processTileResponse&&(this.processTileResponse=e.processTileResponse);}return e.prototype.cancel=function(e,t){var r,o=this.provider,n=o.storage,i=t==Ee;if(r=e instanceof o.Tile?e:n.get(e)){var a=r.onLoaded;a&&(i?a.length=0:a.splice(a.indexOf(t),1),a.length||this.loader.abort(r)&&n.remove(r));}},e.prototype.execTile=function(e){var t,r=e.onLoaded;if(r){for(var o=0,n=r.length;o<n;o++)(t=r[o])instanceof Me?t.receive(e):t(e);r.length=0;}},e.prototype.processTileResponse=function(e,t,r,o){r(t);},e.prototype.handleTileResponse=function(e,t,r,o){var n=this;e.loadStopTs=Date.now(),this.processTileResponse(e,t,(function(t){e.data=t,n.execTile(e),o&&o();}),r);},e.prototype.completeTile=function(e,t){this.handleTileResponse(e,t);},e.prototype.getTile=function(e,t){var r,o=this,n=this.provider,i=n.storage;if((r=i.get(e))==Ee)(r=n.createTile(e)).onLoaded=[],r.data=[],i.set(r);else if(r.isLoaded())return t&&t(r,r.error),r;return t&&-1==r.onLoaded.indexOf(t)&&r.onLoaded.push(t),r.loadStartTs||(r.loadStartTs=Date.now(),this.loader.tile(r,(function(e,t){o.preprocess(e,(function(e){return o.completeTile(r,e)}),r);}),(function(e,t){r.error=e,o.handleTileResponse(r,void 0,t,(function(){return n.listeners.trigger("error",[e,r],!0)}));}))),r},e.prototype.drop=function(e){this.provider.storage.remove(e),e.isLoaded()||this.loader.abort(e);},e}(),ke=function(e){function r(t){var r=e.call(this,t)||this;return r.dep={},r.level=t.level,r}return t.__extends(r,e),r.prototype.cancel=function(e,t){var r,o,n=this.provider,i=n.storage,a=t==Fe;if(o=e instanceof n.Tile?e:i.get(e)){e=o.quadkey,r=ie.getTilesOfLevel(e,this.level);for(var s=0,u=void 0,p=void 0;s<r.length;s++)if(u=(p=r[s])==e?o:i.get(p)){var l=u.onLoaded,c=void 0;l&&(a?o.onLoaded.length=0:n.level&&o.z!=n.level?-1!=(c=l.indexOf(o.onLoaded[0]))&&(l[c].remove(t)||l.splice(c,1)):l.splice(l.indexOf(t),1),l.length||this.loader.abort(u)&&i.remove(u));}}},r.prototype.clear=function(){this.loader.clear(),this.dep={};},r.prototype.createTile=function(e){var t,r,o=this.provider.createTile(e),n=o.z,i=this.level;if(i&&n!=i&&(n>i?t=[e.substr(0,i)]:n<i&&(t=ie.getTilesOfLevel(e,i)),t))for(var a=0,s=t.length;a<s;a++){var u=t[a];(r=this.dep[u])||(r=this.dep[u]=[]),r[r.length]=o;}return o},r.prototype.getTile=function(e,t){var r,o=this,n=this.provider,i=n.storage,a=this.level;if((r=i.get(e))==Fe)(r=this.createTile(e)).onLoaded=[],r.data=[],i.set(r);else if(r.isLoaded())return t&&t(r,r.error),r;if(e.length!=a){var s=ie.getTilesOfLevel(e,a),u=void 0,p=void 0;r.loadStartTs=Date.now(),r.onLoaded.length?p=r.onLoaded[0]:(p=new Me(r,s),r.onLoaded.push(p)),p.add(t);for(var l=0;l<s.length;l++)(u=i.get(s[l]))==Fe?u=n.getTile(s[l],p):u.isLoaded()?p.receive(u):-1==u.onLoaded.indexOf(p)&&u.onLoaded.push(p);}else t&&-1==r.onLoaded.indexOf(t)&&r.onLoaded.push(t),r.loadStartTs||(r.loadStartTs=Date.now(),this.loader.tile(r,(function(e){o.preprocess(e,(function(e){return o.completeTile(r,e)}),r);}),(function(e,t){r.error=e,o.handleTileResponse(r,void 0,t,(function(){return n.listeners.trigger("error",[e,r],!0)}));})));return r},r.prototype.drop=function(t){var r,o=t.quadkey,n=this.provider.storage;if(r=this.dep[o]){for(var i=0;i<r.length;i++)n.remove(r[i]);delete this.dep[o];}e.prototype.drop.call(this,t);},r}(Oe),Ce=function(e){function r(r){var o=e.call(this,t.__assign({minLevel:8,maxLevel:20,staticData:!1},r))||this;o.sizeKB=0;var n=o,i=r.loader;if(!i)throw new Error("no tile loader defined.");i instanceof Pe||(i=new Pe(i));var a=r.preProcessor;return o.remoteTileLoader=new ke({provider:n,loader:i,level:n.level,preProcessor:a,processTileResponse:function(e,t,r){if(e.error)return r(e.data);o.loadTileData(e,t,r);}}),o}return t.__extends(r,e),r.prototype.cancel=function(e,t){this.remoteTileLoader.cancel(e,t);},r.prototype.getLoader=function(){return this.remoteTileLoader.loader},r.prototype.config=function(t){return e.prototype.config.call(this,t)},r.prototype.clear=function(t){0==arguments.length&&this.remoteTileLoader.clear(),e.prototype.clear.apply(this,arguments);},r.prototype.getTile=function(e,t){return this.remoteTileLoader.getTile(e,t)},r.prototype._removeTile=function(t,r){this.remoteTileLoader.drop(t),e.prototype._removeTile.call(this,t,r);},r}(be),Ue=function(e){function r(){return null!==e&&e.apply(this,arguments)||this}return t.__extends(r,e),r.prototype.getMvtLayer=function(){return this.geometry.__xyz.l},r}(E),ze=function(e){function o(t){var o=e.call(this,r.JSUtils.extend({loader:t.loader||new M(t),margin:0,Tile:he,Feature:Ue,preProcessor:Y},t))||this;return o.c=null,o.clipped=!0,o.tree=null,o}return t.__extends(o,e),o.prototype.decCoord=function(e){return e.geometry._coordinates()},o.prototype.getCopyright=function(e){var t=this,o=t.url;"function"==typeof o&&(o=o(0,0,0,""));var n=(null==o?void 0:o.match)&&o.match(/.*xyz+.*here\.com\/tiles\/[a-zA-Z]+[\.\d]*\//),i=t.c;e&&(null==i?n?((i=new r.Queue).add(e),t.c=i,t.getLoader().src[0].send({url:n+"copyright",responseType:"json",success:function(e){t.c=e,i.done(e);}})):e(t.c=[]):i instanceof r.Queue?i.add(e):e(i));},o}(Ce),Ie={backgroundColor:"#555555",strokeWidthZoomScale:function(e){return e>17?1:e>14?.5:.25},styleGroups:{earth:[{zIndex:1,type:"Polygon",fill:"#555555"}],landuse:[{zIndex:2,type:"Polygon",fill:"#666666"}],water:[{zIndex:3,type:"Polygon",fill:"#353535"}],roads:[{zIndex:4,type:"Line",stroke:"#ffffff",strokeWidth:4}],highway:[{zIndex:5,type:"Line",stroke:"#ffffff",strokeWidth:6}],buildings:[{zIndex:6,type:"Polygon",fill:"#999999"}]},assign:function(e,t){var r=e.properties,o=r.kind,n=r.layer,i=e.geometry.type;if("water"!=n||"LineString"!=i&&"MultiLineString"!=i){if("roads"==n){if("rail"==o||"ferry"==o)return;if("highway"==o)return o}return n}}},De=function(e){function o(o){var n=o.remote,i=n.url,a=n.min||1,s=n.max||16,u=o.tileSize||n.tileSize,p=o.name||"",l=o.max||32,c=new M(n),h=[];if(!u){var f="string"==typeof i&&i.match(/256|512|1024|2048|4096/);u=f?Number(f[0]):512;}for(var d=new r.LRU(256/Math.pow(2,0)),y=new r.LRU(4*d.max),v=a;v<=s;v++)h.push({min:v,max:v==s?l:v,provider:new ze({name:p+"-L"+v,url:i,level:v-0,loader:c,size:u,storage:new fe(v-0,d,y)})});return e.call(this,t.__assign(t.__assign({min:a,max:l,style:Ie,margin:0,pointerEvents:!1},o),{tileSize:u,providers:h}))||this}return t.__extends(o,e),o.prototype.getProvider=function(e){var t=Math.floor(e)-this.levelOffset;return this._p[t]},o.prototype.getCopyright=function(e){this.getProvider(this.max).getCopyright(e);},o}(b),Ye=function(e){function r(t){var r=e.call(this,t||{})||this;r.custom=!0,r.style={},r.tiled=!1;var o=r,n=o.onLayerAdd,i=o.onLayerRemove;return n&&o.addEventListener("layerAdd",o.onLayerAdd=function(e){o.init(),n.call(o,e);}),i&&o.addEventListener("layerRemove",o.onLayerRemove=i.bind(o)),r}return t.__extends(r,e),r.prototype.init=function(){var e=this.renderOptions||(this.renderOptions={}),t=e.mode||(e.mode="2d");this.flat="2d"==t;},r.prototype.onLayerAdd=function(e){},r.prototype.onLayerRemove=function(e){},r.prototype.render=function(e,t){},r.prototype.pointerEvents=function(e){return !1},r.prototype.getCopyright=function(){},r.prototype.getStyle=function(){return this.style},r}(v);function Xe(e,t,r){var o=new XMLHttpRequest;return o.onload=function(){t(JSON.parse(this.responseText));},o.onreadystatechange=function(){var e=this.status;4==this.readyState&&(e<200||e>=300)&&0!==e&&r&&r(this);},o.open("GET",e,!0),o.send(),o}var qe=function(){function e(e){var t=".json";(e=e||{}).host=e.host||"geocoder.api.here.com",e.version=e.version||"6.2",this.url="https://"+e.host+"/"+e.version+"/geocode"+t,this.reverseUrl="https://reverse."+e.host+"/"+e.version+"/reversegeocode"+t,this.cfg=e;}return e.prototype.createUrl=function(e,t){var r="";for(var o in t=t||{})r+="&"+o+"="+encodeURIComponent(t[o]);return this.reverseUrl+"?app_id="+this.cfg.app_id+"&app_code="+this.cfg.app_code+r},e.prototype.geocode=function(e,t,r){Xe(this.createUrl(this.url,e),t,r);},e.prototype.reverseGeocode=function(e,t,r){Xe(this.createUrl(this.reverseUrl,e),t,r);},e.prototype.getIsoCountryCode=function(e,t,r){var o={mode:"retrieveAddresses",maxresults:1,jsonattributes:1};o.prox=e instanceof Array?e[1]+","+e[0]:e.latitude+","+e.longitude,this.reverseGeocode(o,(function(e){var r=null;try{r=e.response.view[0].result[0].location.address.country;}catch(e){}t&&t(r,e);}),r);},e}(),Ae=function(){function e(e){this.cache=new r.LRU(e||256);}return e.prototype.forEach=function(e){this.cache.forEach(e);},e.prototype.clear=function(){this.cache.clear();},e.prototype.remove=function(e){this.cache.remove(e.quadkey);},e.prototype.get=function(e){return this.cache.get(e)},e.prototype.set=function(e){var t=this.cache.set(e.quadkey,e),r=this._onDrop;t&&r&&r(t);},e.prototype.onDrop=function(e){this._onDrop=e;},e}(),je=function(e){function r(r){var o=e.call(this,t.__assign({storage:new Ae(512)},r))||this;if(o.name="",o.opacity=1,o.dataType="image","string"==typeof r.errorImage){var n=new Image;n.src=r.errorImage,o.errorImage=n;}return o.tileLoader=new Oe({provider:o,loader:new Pe(new t.HTTPLoader({url:r.url,headers:{Accept:"*/*"}})),preProcessor:r.preProcessor,processTileResponse:function(e,r,n,i){if(e.error)if(o.errorImage)r=o.errorImage;else if(404==e.error.statusCode){var a=i.response;if(a instanceof Blob&&a.type.startsWith("image"))return t.HTTPLoader.createImageFromBlob(a,(function(e){n(e);}))}n(r);}}),o}return t.__extends(r,e),r.prototype.getTile=function(e,t){return this.tileLoader.getTile(e,t)},r.prototype._removeTile=function(e){this.tileLoader.drop(e);},r.prototype.clear=function(e){var t=this,r=null;if(e instanceof Array){r=t.getCachedTilesOfBBox(e,t.level);for(var o=0,n=void 0;o<r.length;o++)n=r[o],this.tileLoader.drop(n),r[o]=n.quadkey;}else 0==arguments.length&&this.storage.clear();t.dispatchEvent("clear",{tiles:r});},r.prototype.cancel=function(e){return this.tileLoader.cancel(e)},r}(de);je.prototype.__type="ImageProvider";var Ge,He=function(e){function o(r){var o=e.call(this,t.__assign({editable:!0,enforceRandomFeatureId:!0},r))||this;return o.blocked={},o}return t.__extends(o,e),o.prototype.detectFeatureClass=function(e){switch(e.geometry.type){case"Point":return "MARKER";case"LineString":return "LINE";case"Polygon":case"MultiPolygon":return "AREA"}},o.prototype.getFeatureProperties=function(e){return e.properties},o.prototype.readRoutingPoint=function(e){return {link:this.readRoutingLink(e),position:this.readRoutingPosition(e)}},o.prototype.blockFeature=function(e,t){var r=e.id||e,o=typeof r;"string"!=o&&"number"!=o||(t?this.blocked[r]=!0:delete this.blocked[r]);},o.prototype._insert=function(t,r){return this.blocked[t.id]?null:e.prototype._insert.call(this,t,r)},o.prototype.reserveId=function(e,t){setTimeout((function(){return t(e.map((function(e){return e.id})))}),0);},o.prototype.isoCC=function(e,t){return !0},o.prototype.prepareFeature=function(e){return e.properties||(e.properties={}),null==e.id&&(e.id=r.JSUtils.String.random()),e},o}(be),Je="Method not implemented.",Ne=function(e){function r(t,r){var o=e.call(this,t)||this;return o.name="FeatureError",o.feature=r,o}return t.__extends(r,e),r}(Error),Ve=function(e){function o(r){var o=e.call(this,t.__assign({minLevel:8,maxLevel:20,staticData:!1},r))||this;o.sizeKB=0,o._clearOnCommit=!0;var n=o,i=r.loader;if(!i)throw new Error("no tile loader defined.");i instanceof Pe||(i=new Pe(i));var a,s=r.preProcessor;return n.preprocess=Re(s||r.preprocessor),n.postprocess=Re(r.postProcessor),o.remoteTileLoader=new ke({provider:n,loader:i,level:n.level,preProcessor:s,processTileResponse:function(e,t,r){if(e.error)return r(e.data);o.loadTileData(e,t,r);}}),n.commit&&(n.commit=(a=n.commit,function(e,t,r){var o,i=this,s=this.postProcessor,u=function(e){Array.isArray(e)||(e=[e]);for(var t,r=e.length;r--;)(t=(e[r]=E.prototype.toJSON.call(e[r])).properties)&&delete t["@ns:com:here:editor"];return e};return "object"==typeof e&&(e.put=u(e.put||[]),e.remove=u(e.remove||[]),Se(s))?(n.postprocess(e,(function(e){o=a.call(i,e,t,r);})),o):a.call(this,e,t,r)})),o}return t.__extends(o,e),o.prototype.getFeatures=function(t,r){var o=this;r=r||{},t instanceof Array||("object"==typeof t&&(t.remote&&(r.remote=t.remote),t.onload&&(r.onload=t.onload),t=t.ids||t.id),t=[].concat(t));var n=this,i=!0,a=r.onload,s=r.remote;(l=e.prototype.getFeatures.call(this,t))instanceof Array||(l=[l]);for(var u=0;u<l.length;u++)l[u]||(l[u]=t[u],i=!1);function p(){return 1==(l=l.map((function(e){return "object"==typeof e?e:Ge}))).length?l[0]:l}if(i||!s){var l=p();return a&&a(l),l}t=l.filter((function(e){return "object"!=typeof e}));var c=function(e){var t=r.onerror;t&&t(e);};n._requestFeatures(t,(function(e){for(var t=0,r=e;t<r.length;t++){var i=r[t],s=i.geometry;if(!s||!s.type||!s.coordinates)return void c(new Ne("Invalid geometry",i))}o.preprocess(e,(function(e){for(var t=0,r=e;t<r.length;t++){var o=r[t];l[l.indexOf(o.id)]=n.addFeature(o);}a&&a(p());}));}),c,r);},o.prototype.cancel=function(e,t){this.remoteTileLoader.cancel(e,t);},o.prototype.search=function(e,t){var o,n,i=this;if("object"==typeof e)if(t)for(var a in e)t[a]=e[a];else t=e;var s=(t=t||{}).onload,u=t.radius,p=t.remote,l=t.onerror;if(u==Ge&&(u=1),e instanceof Array)n=4==e.length?e:r.geotools.getPointBBox(e,u);else {if("number"==typeof e||"string"==typeof e||!e)return i.getFeatures(e,t);if(e.longitude!=Ge&&e.latitude!=Ge)n=r.geotools.getPointBBox([e.longitude,e.latitude],u);else if(e.minLon!=Ge&&e.minLat!=Ge&&e.maxLon!=Ge&&e.maxLat!=Ge)n=[e.minLon,e.minLat,e.maxLon,e.maxLat];else {if(o=e.point||e.rect||e.viewport)return i.search(o,t);if(e.id||e.ids)return i.getFeatures(e.id||e.ids,t)}}if(n={minX:n[0],minY:n[1],maxX:n[2],maxY:n[3]},p){for(var c,h=ie.getTilesInRect(n.minX,n.minY,n.maxX,n.maxY,i.level),f=function(e){h.splice(h.indexOf(e.quadkey),1),c=c||e.error,h.length||(c?l(c):s&&s(i._s(n)));},d=0;d<h.length;d++){var y=h[d],v=i.getCachedTile(y);if(v&&v.isLoaded()){if(v.error)return void(l&&l(v.error));h.splice(d--,1);}else i.getTile(y,f);}if(h.length)return}var g=i._s(n);return s&&s(g),g},o.prototype.getLoader=function(){return this.remoteTileLoader.loader},o.prototype.config=function(t){return e.prototype.config.call(this,t)},o.prototype.clear=function(t){0==arguments.length&&this.remoteTileLoader.clear(),e.prototype.clear.apply(this,arguments);},o.prototype.getTile=function(e,t){return this.remoteTileLoader.getTile(e,t)},o.prototype._removeTile=function(t,r){this.remoteTileLoader.drop(t),e.prototype._removeTile.call(this,t,r);},o.prototype.readDirection=function(e){throw new Error(Je)},o.prototype.readPedestrianOnly=function(e){throw new Error(Je)},o.prototype.writeTurnRestriction=function(e,t,r){throw new Error(Je)},o.prototype.readRoutingProvider=function(e,t){return this.id},o.prototype.readRoutingPosition=function(e){throw new Error(Je)},o.prototype.readRoutingLink=function(e){throw new Error(Je)},o.prototype.writeRoutingPosition=function(e,t){throw new Error(Je)},o.prototype.writeRoutingLink=function(e,t){throw new Error(Je)},o.prototype.readTurnRestriction=function(e,t){throw new Error(Je)},o.prototype.writeRoutingPoint=function(e,t,r){this.writeRoutingLink(e,t),this.writeRoutingPosition(e,r);},o.prototype.writeEditState=function(e,t){},o.prototype.readFeatureHeight=function(e){return null},o.prototype.writeFeatureHeight=function(e,t){throw new Error(Je)},o.prototype.reserveId=function(e,t){for(var o,n=e.length,i=[];n--;)"string"==typeof(o=e[n].id)&&o.length>15?i.push(e[n].id):i.push(r.JSUtils.String.random(16));setTimeout((function(){t(i.reverse());}),0);},o.prototype.isDroppable=function(e){var t=e.editState&&e.editState();return !t||!t.modified&&!t.removed&&!t.split},o}(He),Ze="Method not implemented.",We=function(e){function o(r){var o=this,n=r.loader;return n?n instanceof Pe||(n=new Pe(n)):n=new Pe(new t.HTTPLoader({url:r.url,withCredentials:r.withCredentials,headers:r.headers})),r.loader=n,(o=e.call(this,r)||this).setParams(r.params||{}),o.setHeaders(r.headers||{}),o}return t.__extends(o,e),o.prototype._httpLoader=function(){var e=this.remoteTileLoader.loader.src;return e[e.length-1]},o.prototype.getHeader=function(e){return this._httpLoader().headers[e]||null},o.prototype.getHeaders=function(){return r.JSUtils.clone(this._httpLoader().headers)},o.prototype.setHeader=function(e,t){var r=this.getHeaders();r[e]=t,this._httpLoader().headers=r,this.headers=r;},o.prototype.setHeaders=function(e){var t=this.getHeaders();r.JSUtils.extend(t,e),this._httpLoader().headers=t,this.headers=t;},o.prototype.getParams=function(){return this.params},o.prototype.getParam=function(e){return this.params[e]||null},o.prototype.setParams=function(e){var t=this._httpLoader(),o=t.baseUrl,n=this.params||{};if(r.JSUtils.extend(n,e),this.params=n,"string"==typeof o){n=r.JSUtils.extend(function(e,t){return t=t||{},e.split(/\?|\&/).slice(1).map((function(e){e=e.split(/\=/),t[e[0]]=e[1];})),t}(o),n);var i=o.split(/\?/)[0],a="?";for(var s in n){var u=n[s];void 0===u?delete n[s]:(i+=a+s+"="+u,a="&");}t.setUrl(i);}},o.prototype.setParam=function(e,t){var r={};r[e]=t,this.setParams(r);},o.prototype.config=function(t){return e.prototype.config.call(this,t),t&&t.url&&this.setParams({}),this},o.prototype.commit=function(e,t,r,o){throw new Error(Ze)},o.prototype._requestFeatures=function(e,t,r,o){throw new Error(Ze)},o.prototype.readZLevels=function(e){throw new Error(Ze)},o.prototype.writeZLevels=function(e,t){throw new Error(Ze)},o}(Ve);We.prototype.getFeatureUrl=We.prototype.getLayerUrl=We.prototype.getTileUrl=function(){throw new Error(Ze)};var Ke="Method not implemented.",Qe=function(e){function o(t){return t.level=t.level||13,t.headers=r.JSUtils.extend({Accept:"application/geo+json"},t.headers||{}),e.call(this,t)||this}return t.__extends(o,e),o.prototype.getFeatureUrl=function(e,t){throw new Error(Ke)},o.prototype.getLayerUrl=function(e){throw new Error(Ke)},o.prototype.getTileUrl=function(e){throw new Error(Ke)},o}(We),$e="Method not implemented.",et=function(e){function r(r){var o=e.call(this,t.__assign({minLevel:8,maxLevel:20,storage:new Ae(512),editable:!1,size:512},r))||this;return o._clearOnCommit=!1,delete o.level,o.editable||(o.Feature=E,o.detectFeatureClass=function(){return null}),o}return t.__extends(r,e),r.prototype.cancel=function(e){},r.prototype.delete=function(e){this.tree.remove(e);},r.prototype.import=function(e){var t=this;t.tree.fromJSON(e);for(var r=(e=t.tree.all()).length;r--;)t._insert(e[r]);},r.prototype.initStorage=function(e){},r.prototype.commit=function(e,t,r){return "function"==typeof t&&setTimeout((function(){return t({})}),0),!0},r.prototype.readDirection=function(e){throw new Error($e)},r.prototype.readPedestrianOnly=function(e){throw new Error($e)},r.prototype.writeTurnRestriction=function(e,t,r){throw new Error($e)},r.prototype.readRoutingProvider=function(e,t){return this.id},r.prototype.readRoutingPosition=function(e){throw new Error($e)},r.prototype.readRoutingLink=function(e){throw new Error($e)},r.prototype.writeRoutingPosition=function(e,t){throw new Error($e)},r.prototype.writeRoutingLink=function(e,t){throw new Error($e)},r.prototype.readTurnRestriction=function(e,t){throw new Error($e)},r.prototype.writeRoutingPoint=function(e,t,r){this.writeRoutingLink(e,t),this.writeRoutingPosition(e,r);},r.prototype.readZLevels=function(e){throw new Error("Method not implemented.")},r.prototype.writeZLevels=function(e,t){throw new Error("Method not implemented.")},r.prototype.writeEditState=function(e,t){},r.prototype.readFeatureHeight=function(e){return null},r.prototype.writeFeatureHeight=function(e,t){throw new Error($e)},r}(He),tt={environment:"prd",space:"",credentials:{access_token:""},withCredentials:!1,tags:!1,https:!0,clip:!1,url:null,headers:null,propertySearch:null,editable:!0,level:0},rt="@ns:com:here:xyz",ot="http://",nt={prd:ot+"xyz.api.here.com/hub/spaces"},it=function(e,t){return (e=r.JSUtils.extend(r.JSUtils.clone(tt),e)).params=r.JSUtils.extend(e.params||{},e.credentials),delete e.credentials,Be(t)&&(e.preProcessor=t),e.url||(e.url=nt[e.environment]),e.https&&(e.url=e.url.replace(ot,"https://")),e},at=function(e){function o(t){var r=e.call(this,it(t,arguments[1]))||this;return r.definition=null,r.setUrl(r.getTileUrl(r.space)),t.propertySearch&&r.setPropertySearch(t.propertySearch),r}return t.__extends(o,e),o.prototype.getHttpLoader=function(){var e=this.getLoader().src;return e[e.length-1]},o.prototype.config=function(t){var r=null==t?void 0:t.credentials;return r&&(delete t.credentials,this.setParams(r)),e.prototype.config.call(this,t)},o.prototype.commit=function(e,t,r){var o=this.getHttpLoader(),n=0,i=function(e){!--n&&t&&t(e);},a=function(e){r&&r(e);};if("object"==typeof e){var s=e.put||[],u=e.remove||[];s.length&&(n++,o.send(this.createUpdateFeatureRequest(s,{success:i,error:a}))),u.length&&(n++,o.send(this.createRemoveFeatureRequest(u,{success:i,error:a})));}},o.prototype.getLayerUrl=function(e){return this.url+"/"+e},o.prototype.getTileUrl=function(e){return this._addUrlFilters(this.getLayerUrl(e)+"/tile/quadkey/{QUADKEY}?margin="+this.margin+"&clip="+!!this.clip)},o.prototype.getFeatureUrl=function(e,t){return t instanceof Array||(t=[t]),this.getLayerUrl(e)+"/features?id="+t.join("&id=")},o.prototype.createUpdateFeatureRequest=function(e,r){void 0===r&&(r={});var o=this,n=o._addUrlCredentials(o.getLayerUrl(o.space)+"/features","?");return t.__assign({type:"POST",url:n,headers:t.__assign(t.__assign({},o.headers),{"Content-Type":"application/geo+json"}),data:JSON.stringify({type:"FeatureCollection",features:e})},r)},o.prototype.createRemoveFeatureRequest=function(e,r){void 0===r&&(r={});var o=this,n=o._addUrlCredentials(o.getLayerUrl(o.space)+"/features","?");return t.__assign({type:"DELETE",url:n+"&id="+e.map((function(e){return e.id})).join(","),headers:t.__assign(t.__assign({},o.headers),{Accept:"application/json"})},r)},o.prototype.prepareFeature=function(t){var r=(t=e.prototype.prepareFeature.call(this,t)).properties;return r[rt]||(r[rt]={}),t},o.prototype.setMargin=function(e){Qe.prototype.setMargin.call(this,e),this.setUrl(this.getTileUrl(this.space));},o.prototype.setUrl=function(e){this._httpLoader().setUrl(this._addUrlCredentials(e));},o.prototype.setTags=function(e){"string"==typeof e&&(e=[e]),this.tags=e,this.setUrl(this.getTileUrl(this.space)),this.clear();},o.prototype.setPropertySearch=function(e,t,o){var n,i="";for(var a in "string"==typeof e?(n={})[e]={operator:t,value:o}:n=e,n){var s=n[a];t=s.operator.replace(">=","=gte=").replace("<=","=lte=").replace(">","=gt=").replace("<","=lt="),(o=null==s.values?s.value:s.values)instanceof Array||(o=[o]),o=o.map((function(e){return "string"==typeof e&&(r.JSUtils.isNumeric(e)||"true"==e||"false"==e||"null"==e)&&(e='"'+e+'"'),encodeURIComponent(e)}));var u=a.slice(0,2);"f."!=u&&"p."!=u&&(a="p."+a),i+=a+t+o+"&";}this.psf=i.slice(0,-1),this.setUrl(this.getTileUrl(this.space)),this.clear();},o.prototype.getCopyright=function(e,t){this.getDefinition((function(t){e&&e(t.copyright||[]);}),t);},o.prototype.getDefinition=function(e,o){var n=this,i=n.getHttpLoader(),a=n.definition;if(null==a){var s=new r.Queue;a=this.definition=s,i.send({url:n._addUrlCredentials(n.getLayerUrl(n.space),"?"),id:"def",success:function(e){n.definition=e,s.done(e);},error:function(e){n.definition=[],o&&o(e);},headers:t.__assign(t.__assign({},this.headers),{Accept:"application/json"})});}e&&(a instanceof r.Queue?a.add(e):e(a));},o.prototype._requestFeatures=function(e,t,r,o){this.getHttpLoader().send({id:e.join("&"),url:this._addUrlCredentials(this.getFeatureUrl(this.space,e)),success:function(e){t(e.features);},headers:this.headers,error:r});},o.prototype._addUrlCredentials=function(e,t){return e=function(e,t,r){for(var o in t)e+=r+o+"="+t[o],r="&";return e}(e,this.params,t||"&"),e},o.prototype._addUrlFilters=function(e){var t=this.tags,r=this.psf;return t&&t.length&&(e+="&tags="+t.join(",")),r&&(e+="&"+r),e},o}(Qe),st=function(e){function r(r){var o,n=this;return n=e.call(this,function(e){var r=t.__assign(t.__assign({url:"http://interactive.data.api.platform.here.com/interactive/v1",https:!0,space:e.layer},e),{credentials:t.__assign({},e.credentials)});return delete r.credentials.token,r}(r))||this,n.definition=[],n.token=null===(o=r.credentials)||void 0===o?void 0:o.token,n}return t.__extends(r,e),r.prototype.addRequestToken=function(e){return (e.headers=e.headers||{}).Authorization="Bearer "+this.token,e},r.prototype.createUpdateFeatureRequest=function(t,r){return void 0===r&&(r={}),this.addRequestToken(e.prototype.createUpdateFeatureRequest.call(this,t,r))},r.prototype.createRemoveFeatureRequest=function(t,r){return void 0===r&&(r={}),this.addRequestToken(e.prototype.createRemoveFeatureRequest.call(this,t,r))},r.prototype.getLayerUrl=function(e){return this.url+"/catalogs/"+this.catalog+"/layers/"+e},r.prototype.config=function(t){var r,o=null===(r=null==t?void 0:t.credentials)||void 0===r?void 0:r.token;return o&&(this.token=o,delete t.credentials.token),e.prototype.config.call(this,t)},r}(at),ut=Z,pt=t.__assign({name:"xyz-maps"},{version:"0.32.0",revision:"f28fa04",date:"2022-10-14T17:30:53Z"}),lt=n.global.here.xyz.maps;lt.common=n;var ct=lt.geo={Point:s,Rect:u},ht=lt.pixel={Point:i,Rect:a},ft=lt.layers={TileLayer:b,MVTLayer:De,CustomLayer:Ye},dt=lt.features={Feature:E},yt=lt.tile={Tile:le,Utils:ie};lt.build=pt;var vt=lt.providers={ImageProvider:je,GeoJSONProvider:Qe,FeatureProvider:be,LocalProvider:et,RemoteTileProvider:Ce,EditableRemoteTileProvider:Ve,SpaceProvider:at,IMLProvider:st,MVTProvider:ze,EditableFeatureProvider:He},gt=lt.projection={webMercator:ut},mt=lt.loaders={HTTPLoader:t.HTTPLoader,Manager:Pe},xt=lt.service||{Geocoder:qe},_t={tile:yt,layers:ft,geo:ct,pixel:ht,features:dt,providers:vt,projection:gt,loaders:mt,service:xt,build:pt,common:n};e.CustomLayer=Ye,e.DEFAULT_LAYER_MAX_ZOOM=32,e.DEFAULT_LAYER_MIN_ZOOM=15,e.EditableFeatureProvider=He,e.EditableRemoteTileProvider=Ve,e.Feature=E,e.FeatureProvider=be,e.GeoCoder=qe,e.GeoJSONProvider=Qe,e.GeoPoint=s,e.GeoRect=u,e.HTTPProvider=We,e.IMLProvider=st,e.ImageProvider=je,e.Layer=v,e.LocalProvider=et,e.MVTLayer=De,e.MVTProvider=ze,e.PixelPoint=i,e.PixelRect=a,e.RemoteTileProvider=Ce,e.SpaceProvider=at,e.Tile=le,e.TileLayer=b,e.build=pt,e.default=_t,e.features=dt,e.layers=ft,e.loaders=mt,e.pixel=ht,e.projection=gt,e.providers=vt,e.service=xt,e.tile=yt,e.tileUtils=ie,e.utils=xe,e.webMercator=ut,Object.defineProperty(e,"__esModule",{value:!0});}));

	let xyz = window;
	'here.xyz.maps'.split('.').forEach((ns) => xyz = (xyz[ns] = xyz[ns] || {}));
	var xyz$1 = xyz;

	return xyz$1;

}));

},{}],"node_modules/@here/xyz-maps-display/dist/xyz-maps-display.esm.min.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.styleTools = exports.default = exports.MapEvent = exports.Map = void 0;
var _xyzMapsCommon = require("@here/xyz-maps-common");
var _xyzMapsCore = require("@here/xyz-maps-core");
/*
 * @here/xyz-maps-display
 * (c) 2019-2022 HERE
 */

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var v = function (t, e) {
  return v = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (t, e) {
    t.__proto__ = e;
  } || function (t, e) {
    for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
  }, v(t, e);
};
function y(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  function i() {
    this.constructor = t;
  }
  v(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i());
}
var g = function () {
  return g = Object.assign || function (t) {
    for (var e, i = 1, r = arguments.length; i < r; i++) for (var n in e = arguments[i]) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    return t;
  }, g.apply(this, arguments);
};
function m(t, e, i, r) {
  return new (i || (i = Promise))(function (n, o) {
    function a(t) {
      try {
        l(r.next(t));
      } catch (t) {
        o(t);
      }
    }
    function s(t) {
      try {
        l(r.throw(t));
      } catch (t) {
        o(t);
      }
    }
    function l(t) {
      var e;
      t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function (t) {
        t(e);
      })).then(a, s);
    }
    l((r = r.apply(t, e || [])).next());
  });
}
function x(t, e) {
  var i,
    r,
    n,
    o,
    a = {
      label: 0,
      sent: function () {
        if (1 & n[0]) throw n[1];
        return n[1];
      },
      trys: [],
      ops: []
    };
  return o = {
    next: s(0),
    throw: s(1),
    return: s(2)
  }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
    return this;
  }), o;
  function s(o) {
    return function (s) {
      return function (o) {
        if (i) throw new TypeError("Generator is already executing.");
        for (; a;) try {
          if (i = 1, r && (n = 2 & o[0] ? r.return : o[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, o[1])).done) return n;
          switch (r = 0, n && (o = [2 & o[0], n.value]), o[0]) {
            case 0:
            case 1:
              n = o;
              break;
            case 4:
              return a.label++, {
                value: o[1],
                done: !1
              };
            case 5:
              a.label++, r = o[1], o = [0];
              continue;
            case 7:
              o = a.ops.pop(), a.trys.pop();
              continue;
            default:
              if (!(n = a.trys, (n = n.length > 0 && n[n.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                a = 0;
                continue;
              }
              if (3 === o[0] && (!n || o[1] > n[0] && o[1] < n[3])) {
                a.label = o[1];
                break;
              }
              if (6 === o[0] && a.label < n[1]) {
                a.label = n[1], n = o;
                break;
              }
              if (n && a.label < n[2]) {
                a.label = n[2], a.ops.push(o);
                break;
              }
              n[2] && a.ops.pop(), a.trys.pop();
              continue;
          }
          o = e.call(t, a);
        } catch (t) {
          o = [6, t], r = 0;
        } finally {
          i = n = 0;
        }
        if (5 & o[0]) throw o[1];
        return {
          value: o[0] ? o[1] : void 0,
          done: !0
        };
      }([o, s]);
    };
  }
}
var _ = function (t, e, i, r) {
    ("string" == typeof e ? [e] : e).forEach(function (e) {
      t.addEventListener(e, i, r);
    });
  },
  w = function (t, e, i, r) {
    ("string" == typeof e ? [e] : e).forEach(function (e) {
      t.removeEventListener(e, i, r);
    });
  },
  b = function (t, e) {
    return Math.round(parseFloat((r = e, (o = (i = t).ownerDocument.defaultView.getComputedStyle(i, null)) && "" === (n = o.getPropertyValue(r)) && (n = i.style[r]), n))) || 0;
    var i, r, n, o;
  },
  T = function (t, e, i, r) {
    this.lrTs = !1, this.x = t, this.y = e, this.size = i, this.tile = r;
  },
  L = function () {
    function t(t, e) {
      this.ready = !1, this.cnt = 0, this.z = {}, this.zLength = 0, this.zd = !1, this._z3d = 1 / 0, this.layer = t, this.tileSize = t.tileSize || null, this.layers = e, this.id = Math.floor(1e16 * Math.random());
    }
    return t.prototype.getZ = function (t) {
      var e = this.z;
      if (this.zd) {
        var i = 0;
        for (var r in e) e[r] = i++;
        this.zLength = i, this.zd = !1, this.z3d = e[this._z3d];
      }
      return e[t] || 0;
    }, t.prototype.getAbsoluteZ = function (t) {
      for (var e = this.index, i = this.layers, r = 0, n = 0; r < e;) n += i[r++].zLength;
      return null != t && (n += this.getZ(t)), n;
    }, t.prototype.addZ = function (t, e) {
      var i = this.z;
      null == i[t] && (i[t] = 0, this.zd = !0, e && t < this._z3d && (this._z3d = t));
    }, t.prototype.getZ3d = function () {
      for (var t, e = this.layers, i = 0, r = 0; t = e[i++];) {
        if (t._z3d >= 0) return r + t.z3d;
        r += t.zLength;
      }
      return r;
    }, t;
  }(),
  S = function (t) {
    function e() {
      for (var i = [], r = 0; r < arguments.length; r++) i[r] = arguments[r];
      var n = t.apply(this, i) || this;
      return n._map = {}, Object.setPrototypeOf(n, e.prototype), n;
    }
    return y(e, t), e.prototype.indexOf = function (e) {
      var i = this._map[e.id];
      return t.prototype.indexOf.call(this, i);
    }, e.prototype.fixZ = function () {
      for (var t = 0; t < this.length; t++) this[t].index = t;
    }, e.prototype.add = function (e, i) {
      var r,
        n = e.id,
        o = this._map[n];
      return o ? (this.splice(t.prototype.indexOf.call(this, o), 1), this.splice(i, 0, o), r = !1) : (o = this._map[n] = new L(e, this), this.splice(i, 0, o), r = !0), this.fixZ(), r;
    }, e.prototype.remove = function (t) {
      var e = this.indexOf(t);
      return -1 !== e && (this.splice(e, 1), delete this._map[t.id], this.fixZ()), e;
    }, e.prototype.get = function (t) {
      return "string" != typeof t && (t = t.id), this._map[t];
    }, e.prototype.reset = function (t) {
      for (var e, i = new Set(), r = 0; r < this.length; r++) {
        var n = this[r];
        if (e = n.layer, n.error = !1, n.cnt = 0, n.tiles = [], n.visible = t >= e.min && t <= e.max) {
          if (n.ready = !1, e.custom) continue;
          i.add(e.tileSize);
        } else n.ready = !0;
      }
      return Array.from(i);
    }, e;
  }(Array),
  A = function () {
    function t(t, e) {
      this.display = t, this.render = e;
    }
    return t.prototype.forEachTile = function (t, e) {
      t.getProvider().getCachedTilesOfBBox(t.getBBox()).forEach(e);
    }, t.prototype.remove = function (t, e, i) {
      for (var r = 0, n = e; r < n.length; r++) {
        var o = n[r];
        this.removeFromTile(t, o, i);
      }
    }, t.prototype.modifyInTile = function (t, e, i, r) {
      var n = this.isVertexDataInitialized(e);
      return !!n && (this.display.updateTile(e, n, r, t), !0);
    }, t.prototype.isVertexDataInitialized = function (t) {
      return this.display.getBucket(t.quadkey);
    }, t.prototype.addToTile = function (t, e, i) {
      var r = this.isVertexDataInitialized(e);
      r && this.display.updateTile(e, r, i, t);
    }, t.prototype.removeFromTile = function (t, e, i) {
      var r = this.isVertexDataInitialized(e);
      r && this.display.updateTile(e, r, i, t);
    }, t.prototype.add = function (t, e, i) {
      for (var r = 0, n = e; r < n.length; r++) {
        var o = n[r];
        this.addToTile(t, o, i);
      }
    }, t.prototype.updateGeometry = function (t, e, i, r) {
      for (var n = r.getProvider(), o = n.getCachedTilesOfBBox(e), a = n.getCachedTilesOfBBox(t.getBBox()), s = 0, l = a.length; s < l; s++) {
        var u = o.indexOf(a[s]);
        -1 === u ? this.addToTile(t, a[s], r) : (this.modifyInTile(t, a[s], i, r), o.splice(u, 1));
      }
      for (s = 0, l = o.length; s < l; s++) this.removeFromTile(t, o[s], r), this.removeFromTile(t, o[s], r);
    }, t.prototype.repaint = function (t, e, i) {
      var r = this;
      r.forEachTile(t, function (e) {
        var n = r.isVertexDataInitialized(e);
        n ? r.display.updateTile(e, n, i, t) : e.preview && (e.preview = undefined);
      });
    }, t.prototype.clear = function (t, e) {
      e = e || [];
      var i = this.display,
        r = i.layers.indexOf(t);
      i.buckets.forEach(function (i) {
        e.length && !function (t, e) {
          for (var i, r, n = t.length, o = 0; o < e.length; o++) if (r = t, i = e[o], n > e[o].length && (i = r, r = e[o]), 0 === i.search(r)) return !0;
        }(i.quadkey, e) || (i.clear(r), i.ready(r, !1), i.cancelTasks(t), i.luTs = null);
      }), i.update();
    }, t;
  }(),
  M = [],
  z = function () {
    function t(t, e) {
      this.display = t, "number" == typeof e ? (this.down = e, this.up = e) : (this.down = e[0], this.up = e[1]);
    }
    return t.prototype.lookUp = function (t, e, i, r, n, o) {
      var a,
        s,
        l,
        u = t.quadkey,
        h = i - r;
      if (a = Number(u[h]), o.x += a % 2 * e / 2, o.y += Number(a > 1) * e / 2, l = u.substring(0, h), this.hasData(l, n)) {
        var f = e / Math.pow(2, r);
        return s = [], this.add(s, l, o.x, o.y, f, 0, 0, e), s;
      }
      o.x /= 2, o.y /= 2;
    }, t.prototype.add = function (t, e, i, r, n, o, a, s) {
      t.push([e, i, r, n, n, 0 ^ o, 0 ^ a, s, s]);
    }, t.prototype.hasData = function (t, e) {
      var i = this.display.buckets.get(t, !0);
      if (i) return i.ready(e) && i.getData(e);
    }, t.prototype.lookDown = function (t, e, i, r, n) {
      var o,
        a,
        l,
        u,
        h,
        f,
        c = i + r;
      o = _xyzMapsCore.tileUtils.getTilesOfLevel(t.quadkey, c);
      for (var p = 0; p < o.length; p++) {
        a = l = 0, u = e;
        for (var d = 0; d < r; d++) u /= 2, a += (h = o[p][i + d]) % 2 * u, l += Number(h > 1) * u, d == r - 1 && this.hasData(o[p], n) && (f = f || [], this.add(f, o[p], 0, 0, e, a, l, u));
      }
      return f;
    }, t.prototype.create = function (t, e, i, r) {
      var n,
        o = t.quadkey.length,
        a = e.min,
        s = e.max,
        l = s - o,
        u = o - a,
        h = {
          x: 0,
          y: 0
        },
        f = 0,
        c = e.tileSize;
      i = i || this.down, (r = r || this.up) > u && (r = u), i > l && (i = l);
      for (var p = r > i ? r : i, d = t.index(e); f++ < p;) {
        if (o - f >= a && (n = this.lookUp(t, c, o, f, d, h))) return n;
        if (o + f <= s && f < i && (n = this.lookDown(t, c, o, f, d))) return n;
      }
      return M;
    }, t;
  }(),
  I = document.createElement("canvas").getContext("2d"),
  P = "abcdefghijklmnopqrstuvwxyz",
  E = (P = P + P.toUpperCase() + " 0123456789").length,
  C = {},
  k = "normal 12px Arial",
  D = function (t, e, i, r) {
    t.font = e.font || k, "number" == typeof e.strokeWidth ? t.lineWidth = e.strokeWidth : t.lineWidth = 1, t.strokeStyle = r, t.fillStyle = i, t.textAlign = e.textAlign || "start", t.lineCap = "round", t.lineJoin = "round";
  },
  O = function (t, e, i, r, n) {
    var o = n.fill,
      a = n.stroke,
      s = n.strokeWidth;
    a && 0 != s && t.strokeText(e, i, r), o && t.fillText(e, i, r);
  },
  F = function (t, e, i, r, n) {
    r = r || 128, n = n || 128, t.fillStyle = "#000", t.fillRect(0, 0, r, n), D(t, e, "#fff", "#fff"), O(t, i, 0, 0, e);
    for (var o = t.getImageData(0, 0, r, n).data, a = -1, s = -1, l = 0; l < n; l++) for (var u = 0; u < r; u++) {
      if (0 != o[4 * (l * r + u)]) {
        -1 == a && (a = l);
        break;
      }
      if (u == r - 1 && -1 !== a) {
        s = l, l = n;
        break;
      }
    }
    return t.clearRect(0, 0, r, n), {
      height: s - a,
      min: a,
      max: s
    };
  },
  R = function (t) {
    void 0 === t && (t = {});
    var e = t.font,
      i = t.strokeWidth,
      r = (e = e || k) + (i = i || 0);
    return C[r] || (I.font = e, I.textBaseline = "top", C[r] = {
      width: I.measureText(P).width / E,
      height: F(I, t, "gM").height
    }), C[r];
  },
  N = function (t, e) {
    if (!1 === e) return [t];
    null != e && !0 !== e || (e = 14);
    for (var i, r = [], n = 0, o = -1, a = 0, s = void 0, l = void 0, u = t.length; a < u; a++) l = a - n, " " == (i = t.charAt(a)) ? o = a : "\n" == i && (l = 1 / 0, o = a), l >= e && n <= o && (s = t.substring(n, o), n = o + 1, r.push(s)), a == u - 1 && n <= a && (s = t.substring(n, a + 1), r.push(s));
    return r;
  },
  B = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgrey: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    grey: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "778899",
    lightslategrey: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  },
  U = function (t) {
    return t.length < 5 ? [parseInt("".concat(t[1]).concat(t[1]), 16) / 255, parseInt("".concat(t[2]).concat(t[2]), 16) / 255, parseInt("".concat(t[3]).concat(t[3]), 16) / 255, 1] : [parseInt(t.slice(1, 3), 16) / 255, parseInt(t.slice(3, 5), 16) / 255, parseInt(t.slice(5, 7), 16) / 255, 1];
  };
for (var W in B) B[W] = U("#" + B[W]);
var G = function (t) {
    var e;
    return t && (Array.isArray(t) ? 3 == (e = t).length && (e[3] = 1) : e = "#" == t[0] ? U(t) : (e = B[t]) ? e.slice() : function (t) {
      var e = t.match(/^rgba?\s*\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*(?:\.\d+)?))?\)$/);
      return e && e.length > 3 && [e[1] / 255, e[2] / 255, e[3] / 255, null == e[4] ? 1 : Number(e[4])];
    }(t)), e;
  },
  Z = function (t, e) {
    for (var i = 0, r = [t, e]; i < r.length; i++) for (var n = r[i], o = 0; o < n.length; o++) {
      for (var a = undefined, s = undefined, l = undefined, u = undefined, h = void 0, f = (o + 1) % n.length, c = n[o], p = n[f], d = [p[1] - c[1], c[0] - p[0]], v = 0, y = t; v < y.length; v++) {
        var g = y[v];
        h = d[0] * g[0] + d[1] * g[1], (undefined === a || h < a) && (a = h), (undefined === s || h > s) && (s = h);
      }
      for (var m = 0, x = e; m < x.length; m++) {
        g = x[m];
        h = d[0] * g[0] + d[1] * g[1], (undefined === l || h < l) && (l = h), (undefined === u || h > u) && (u = h);
      }
      if (s < l || u < a) return !1;
    }
    return !0;
  },
  X = function (t, e, i, r, n) {
    var o = Math.sin(n),
      a = Math.cos(n),
      s = t - i,
      l = e - r;
    return [a * s - o * l + i, o * s + a * l + r];
  },
  Y = function (t, e, i, r, n, o) {
    return t > i && t < n && e > r && e < o;
  },
  H = function (t, e, i, r) {
    var n = t - i,
      o = e - r;
    return Math.sqrt(n * n + o * o);
  },
  j = function (t, e, i, r, n) {
    var o = (r[1] - i[1]) * (e[0] - t[0]) - (r[0] - i[0]) * (e[1] - t[1]);
    if (0 != o) {
      var a = ((r[0] - i[0]) * (t[1] - i[1]) - (r[1] - i[1]) * (t[0] - i[0])) / o,
        s = ((e[0] - t[0]) * (t[1] - i[1]) - (e[1] - t[1]) * (t[0] - i[0])) / o;
      if (0 <= a && a <= 1 && 0 <= s && s <= 1) return !n || [t[0] + a * (e[0] - t[0]), t[1] + a * (e[1] - t[1]), t[2] + a * (e[2] - t[2])];
    }
    return !1;
  },
  V = function (t) {
    return t > 47 && t < 58;
  },
  q = function () {
    function t() {
      this.fonts = {};
    }
    return t.getInstance = function () {
      return this.instance = this.instance || new t();
    }, t.prototype.getFontId = function (t, e) {
      return "".concat(t.font || "normal 12px Arial").concat(t.strokeWidth || 1).concat(e);
    }, t.prototype.initFont = function (t, e) {
      void 0 === e && (e = 1);
      var i = this.fonts,
        r = this.getFontId(t, e);
      if (!i[r]) {
        var n = 96 * e,
          o = function (t, e) {
            var i = document.createElement("canvas");
            return i.width = t, i.height = e, i;
          }(n, n),
          a = o.getContext("2d");
        a.textBaseline = "bottom";
        var s = F(a, t, "gM").height;
        a.textBaseline = "top";
        var l = F(a, t, "gM").height;
        D(a, t, "#fff", "#000"), a.setTransform(e, 0, 0, e, 0, 0);
        var u = a.lineWidth,
          h = Math.floor(u),
          f = Math.floor(u),
          c = l + 2 * f;
        i[r] = {
          name: r,
          size: 0,
          glyphs: new Map(),
          paddingX: h,
          paddingY: f,
          canvas: o,
          ctx: a,
          width: n,
          offsetX: 2 * u * e,
          scale: e,
          style: t,
          charWidthCache: new Map(),
          rowHeight: c * e,
          letterHeightBottom: s,
          letterHeight: l,
          spaceWidth: a.measureText(" ").width * e,
          baselineOffset: e * ((l - s) / 2 + f)
        };
      }
      return i[r];
    }, t.prototype.hasGlyph = function (t, e) {
      return e.glyphs.has(t);
    }, t.prototype.getGlyph = function (t, e) {
      var i,
        r = e.glyphs.get(t);
      if (!r) {
        var n = e.canvas.width,
          o = e.offsetX,
          a = e.scale;
        e.ctx.clearRect(0, 0, n, n), O(e.ctx, t, e.paddingX, e.paddingY, e.style);
        var s = e.charWidthCache.get(t);
        null == s ? s = e.ctx.measureText(t).width : e.charWidthCache.delete(t);
        var l = Math.round((s || 0) + 2 * e.paddingX) * a,
          u = e.ctx.getImageData(0, 0, l, e.rowHeight);
        r = {
          char: t,
          width: s,
          data: u,
          direction: (i = t.charCodeAt(0), function (t) {
            return t >= 32 && t <= 47 || t >= 58 && t <= 64 || t >= 91 && t <= 96 || t >= 123 && t <= 126;
          }(i) || V(i) ? 0 : function (t) {
            return t >= 1424 && t <= 1791 || t >= 1872 && t <= 1919 || t >= 2208 && t <= 2303 || t >= 64336 && t <= 65023 || t >= 65136 && t <= 65279;
          }(i) ? -1 : 1),
          advanceX: s ? u.width - o : 0
        }, e.glyphs.set(t, r), e.size++;
      }
      return r;
    }, t.prototype.getTextWidth = function (t, e) {
      for (var i = e.ctx, r = 0, n = 0, o = t; n < o.length; n++) {
        var a = o[n],
          s = e.glyphs.get(a);
        if (s) r += s.width;else {
          var l = e.charWidthCache.get(a);
          null == l && (l = i.measureText(a).width, e.charWidthCache.set(a, l)), r += l;
        }
      }
      return r;
    }, t;
  }(),
  K = q.getInstance(),
  Q = _xyzMapsCore.webMercator.meterToPixel,
  $ = _xyzMapsCore.webMercator.pixelToMeter,
  J = function (t) {
    return 0 ^ Math.min(t, 20);
  },
  tt = {
    type: 1,
    zIndex: 1,
    fill: 1,
    stroke: 1,
    strokeWidth: 1,
    radius: 1,
    width: 1,
    height: 1,
    font: 1,
    text: 1,
    textRef: 1,
    offsetX: 1,
    offsetY: 1,
    alignment: 1,
    rotation: 1,
    priority: 1,
    repeat: 1,
    collide: 1,
    offset: 1,
    from: 1,
    to: 1,
    checkLineSpace: 1,
    extrude: 1,
    extrudeBase: 1
  },
  et = new Map(),
  it = function (t, e, i) {
    var r = rt("text", t, e, i);
    if (!r && t.textRef && (null == (r = et.get(t.textRef)) && (r = new Function("f", "return f." + t.textRef), et.set(t.textRef, r)), r = r(e, i)), "" != r) return undefined !== r && "string" != typeof r && (r = String(r)), r;
  },
  rt = function (t, e, i, r) {
    var n = e[t];
    return "function" == typeof n ? n(i, r, e) : n;
  },
  nt = function (t, e) {
    void 0 === e && (e = !1);
    var i = "px",
      r = t;
    return "string" == typeof t && (r = parseFloat(t) || 0, "m" == t.charAt(t.length - 1)) ? (i = "m", [r = Math.round(10 * r) / 10, i]) : (e || (r ^= 0), [r, i]);
  },
  ot = function (t, e, i, r, n) {
    var o = rt(t, e, i, r),
      a = nt(o, n),
      s = a[0];
    if ("m" == a[1]) {
      var l = J(r);
      s = Math.pow(2, r % l) * Q(s, l);
    }
    return s;
  },
  at = function (t, e, i, r) {
    var n = rt("zIndex", t, e, i),
      o = rt("zLayer", t, e, i);
    return "number" != typeof o && (o = r + 1), 1e6 * o + n;
  },
  st = function (t, e, i, r) {
    for (var n = 0, o = J(i), a = 0, s = t; a < s.length; a++) {
      var l = s[a],
        u = at(l, e, o, r);
      u > n && (n = u);
    }
    return n;
  },
  lt = function (t, e, i, r, n) {
    for (var o, a = 0, s = 0, l = J(i), u = 0; u < t.length; u++) {
      if (o = t[u], !("Line" != rt("type", o, e, l) || n && rt("altitude", o, e, l))) {
        var h = at(o, e, l, r);
        h > s && (s = h);
        var f = ot("strokeWidth", o, e, i, !0);
        f > a && (a = f);
      }
    }
    return [a, s];
  },
  ut = function (t, e, i, r, n, o) {
    var a,
      s,
      l,
      u,
      h,
      f,
      c = J(i),
      p = rt("type", t, e, c);
    n = n || [Infinity, Infinity, -Infinity, -Infinity];
    var d = rt("fill", t, e, c),
      v = !o && rt("stroke", t, e, c);
    if ("Image" != p && !d && !v) return null;
    if ("Text" == p) {
      var y = it(t, e, c);
      if (!y) return null;
      var g = rt("strokeWidth", t, e, c),
        m = rt("font", t, e, c),
        x = K.initFont({
          font: m,
          strokeWidth: g,
          fill: d,
          stroke: v
        }, r),
        _ = void 0;
      if (h = 0, "LineString" == e.geometry.type || "MultiLineString" == e.geometry.type) h = K.getTextWidth(y, x), f = x.letterHeight;else {
        for (var w = rt("lineWrap", t, e, c), b = 0, T = _ = N(y, w); b < T.length; b++) {
          var L = T[b],
            S = K.getTextWidth(L, x);
          S > h && (h = S);
        }
        f = _.length * x.letterHeight;
      }
    } else {
      g = rt("strokeWidth", t, e, c);
      isNaN(g) && (g = 1), "Circle" == p ? f = h = 2 * ot("radius", t, e, c) ^ 0 : (h = 0 ^ ot("width", t, e, c), f = 0 ^ ((f = ot("height", t, e, c)) || h)), f += g, h += g;
    }
    var A = 0 ^ rt("offsetX", t, e, c),
      M = 0 ^ rt("offsetY", t, e, c),
      z = "Circle" != p && 0 ^ rt("rotation", t, e, c);
    if (z) {
      var I = function (t, e, i, r, n) {
        void 0 === r && (r = 0), void 0 === n && (n = 0);
        var o = r - (e *= .5),
          a = r + e,
          s = n - (i *= .5),
          l = n + i,
          u = X(o, s, r, n, t),
          h = X(a, l, r, n, t),
          f = X(o, l, r, n, t),
          c = X(a, s, r, n, t);
        return [Math.min(u[0], h[0], f[0], c[0]), Math.min(u[1], h[1], f[1], c[1]), Math.max(u[0], h[0], f[0], c[0]), Math.max(u[1], h[1], f[1], c[1])];
      }(z, h, f, A, M);
      a = I[0], l = I[1], s = I[2], u = I[3];
    } else s = (a = A - .5 * h) + h, u = (l = M - .5 * f) + f;
    return a < n[0] && (n[0] = a), s > n[2] && (n[2] = s), l < n[1] && (n[1] = l), u > n[3] && (n[3] = u), n;
  },
  ht = function (t, e, i, r, n, o) {
    for (var a, s, l = J(i), u = 0, h = 0, f = t; h < f.length; h++) {
      var c = f[h];
      if (!o || !rt("altitude", c, e, l)) s = ut(c, e, i, r, s, !0) || s, (a = at(c, e, l, n)) > u && (u = a);
    }
    if (s) return s[4] = u, s;
  },
  ft = function (t) {
    return t.type && null != t.zIndex;
  },
  ct = function (t, e, i) {
    return void 0 === e && (e = 0), void 0 === i && (i = 1), Math.min(i, Math.max(e, t));
  },
  pt = function (t, e, i, r, n) {
    return function (t, e, i) {
      return t * (1 - i) + e * i;
    }(i, r, function (t, e, i) {
      return ct((i - t) / (e - t));
    }(t, e, n));
  },
  dt = function (t, e) {
    var i,
      r,
      n,
      o,
      a,
      s = 0;
    for (var l in t) {
      var u = Number(l);
      r = t[u];
      var h = Array.isArray(r),
        f = void 0,
        c = void 0;
      if (h ? f = r : (f = (i = nt(r))[0], c = i[1]), "px" == c && (r = f), e <= u) {
        if (0 == s) return "m" == c ? t[u] : f;
        if (h) {
          for (var p = [], d = 0; d < f.length; d++) p[d] = pt(a, u, n[d], f[d], e);
          return p;
        }
        if (u - a > 1) {
          var v = n,
            y = f,
            g = c != o,
            m = "m" == c;
          return g && (m ? v = $(v, a) : y = $(y, u)), pt(a, u, v, y, e) + (g || m ? "m" : 0);
        }
        return r;
      }
      a = u, n = f, o = c, s++;
    }
    return r;
  },
  vt = function (t, e) {
    for (var i = 1; i <= 20; i++) t[i] = dt(e, i);
    return t;
  },
  yt = function (t) {
    for (var e in t) t[e] = G(t[e]);
  },
  gt = function (t) {
    var e = function (e, i) {
      return t[i];
    };
    return e.map = t, e;
  },
  mt = function (t) {
    if (!t.__p) {
      t.__p = !0;
      for (var e = 0, i = t; e < i.length; e++) {
        var r = i[e];
        for (var n in r) if (n in tt) {
          var o = r[n];
          if ("object" == typeof o && !Array.isArray(o)) {
            "stroke" != n && "fill" != n || yt(o);
            var a = vt({}, o);
            r[n] = gt(a);
          }
        }
      }
    }
  },
  xt = Object.freeze({
    __proto__: null,
    getTextString: it,
    calcBBox: ut,
    is3d: function (t, e, i) {
      for (var r = J(i), n = 0, o = t; n < o.length; n++) {
        var a = o[n];
        if (rt("altitude", a, e, r) || rt("extrude", a, e, r)) return !0;
      }
      return !1;
    },
    getExtrude: function (t, e, i) {
      for (var r = J(i), n = 0, o = t; n < o.length; n++) {
        var a = o[n],
          s = rt("extrude", a, e, r);
        if (s) return s;
      }
      return null;
    },
    getValue: rt,
    parseSizeValue: nt,
    getLineWidth: lt,
    getPixelSize: ht,
    getSizeInPixel: ot,
    merge: function (t, e) {
      if (null === e || !1 === e) return null;
      for (var i, r = [], n = 0, o = t.length; n < o; n++) {
        for (var a in i = t[n], r.push([i[0], {}]), i[1]) r[n][1][a] = i[1][a];
        if (e[n]) for (var a in r[n][0] = e[n][0], e[n][1]) r[n][1][a] = e[n][1][a];
      }
      return r;
    },
    isStyle: ft,
    getMaxZoom: st,
    parseStyleGroup: mt
  }),
  _t = function () {
    return 1;
  },
  wt = function () {
    function t(t, e) {
      this.tm = t, this.ms = e;
    }
    return t.prototype.exclusiveRuntime = function (t) {
      this.ms = t;
    }, t.prototype.spawn = function (t, e, i, r, n, o, a, s) {
      var l = this.createTask(t, e, i, r, n, o, a);
      return this.tm.start(l, s), l;
    }, t.prototype.createTask = function (t, e, i, r, n, o, a) {
      var s = [],
        l = this.ms,
        u = this.tm.create({
          time: l,
          priority: t,
          init: function () {
            if (r) {
              for (var t = r.length, o = Date.now(); t--;) r[t];
              u.time = l - (Date.now() - o);
            }
            return [i, r, n, 0, s, 300, e, {}];
          },
          name: "cluster",
          onDone: function () {
            var t = e.getStyle(),
              r = t && (t.strokeWidthZoomScale || t.LineStringZoomScale) || _t;
            s.swzs = r(i.z), a(s, this);
          },
          exec: function (t) {
            var e,
              i,
              r,
              n,
              a,
              s,
              l,
              u,
              h,
              f,
              c,
              p,
              d,
              v,
              y,
              g,
              m,
              x,
              _,
              w = t[0],
              b = t[1],
              T = t[2],
              L = t[6],
              S = b.length,
              A = t[4],
              M = w.z;
            if (b && !(t[3] >= S)) {
              for (; t[5]-- && (a = b[t[3]++]);) if (!T[s = a.id] && (T[s] = !0, r = L.getStyleGroup(a, M))) {
                r.length || (r = [r]);
                for (var z = 0, I = r.length; z < I; z++) n = r[z], ft(n) && (e = rt("zIndex", n, a, M), l = rt("type", n, a, M), y = rt("opacity", n, a, M), p = undefined, c = undefined, d = undefined, v = undefined, x = undefined, g = undefined, m = undefined, undefined, _ = undefined, undefined, "Image" == l ? i = "I" : (c = rt("fill", n, a, M), d = rt("stroke", n, a, M), v = rt("strokeWidth", n, a, M), i = "Line" == l ? "L" + ((g = rt("strokeLinecap", n, a, M)) || "*") + ((m = rt("strokeLinejoin", n, a, M)) || "*") + ((x = rt("strokeDasharray", n, a, M)) || "*") : "Text" == l ? "T" + ((p = rt("font", n, a, M) || "normal 12px Arial") || "*") : "Circle" == l ? "C" + rt("radius", n, a, M) || "*" : "R" + (_ = rt("width", n, a, M)) + (rt("height", n, a, M) || _), i += (d || "*") + (v || "*") + (c || "*")), null != y && (i += 100 * y ^ 0), null == (f = (u = A[e] = A[e] || [])[i]) ? (f = u[i] = u.length, h = u[f] = {
                  shared: {
                    font: p,
                    fill: c,
                    opacity: y,
                    stroke: d,
                    strokeWidth: v,
                    strokeLinecap: g,
                    strokeLinejoin: m,
                    strokeDasharray: x
                  },
                  data: new o()
                }) : h = u[f], h.data.add(a, n));
              }
              return t[5] = 300, t[3] < S;
            }
          }
        });
      return u;
    }, t;
  }(),
  bt = function () {
    function t(t) {
      this.tiles = {}, this.size = t;
    }
    return t.prototype.init = function (t, e, i, r, n) {
      this.cwpx = t[0], this.cwpy = t[1], this.width = i, this.height = r, this.bounds = n;
      for (var o = Infinity, a = -o, s = Infinity, l = -s, u = 0, h = n; u < h.length; u++) {
        var f = h[u],
          c = f[0],
          p = f[1];
        c < o && (o = c), c > a && (a = c), p < s && (s = p), p > l && (l = p);
      }
      this.minX = o, this.maxX = a, this.minY = s, this.maxY = l;
    }, t.prototype.getTiles = function (t, e) {
      void 0 === e && (e = this.size);
      for (var i = this.width, r = this.height, n = Math.pow(2, t) * e, o = this.bounds, a = [], l = this.cwpx * n, u = this.cwpy * n, h = (l - i / 2 + this.minX) / e, f = (u - r / 2 + this.minY) / e, c = (l + i / 2 + this.maxX - i) / e, p = (u + r / 2 + this.maxY - r) / e, d = _xyzMapsCore.tileUtils.pixelToGrid(h, f, t), v = _xyzMapsCore.tileUtils.pixelToGrid(c, p, t), y = v[0] - d[0] + 1, g = v[1] - d[1] + 1, m = (d[0] - h) * e + this.minX, x = (d[1] - f) * e + this.minY, _ = 0; _ < g; _++) for (var w = 0; w < y; w++) {
        var b = m + w * e,
          T = x + _ * e,
          L = b + e,
          S = T + e;
        if (Z(o, [[b, T], [L, T], [L, S], [b, S]])) {
          var A = _xyzMapsCore.tileUtils.tileXYToQuadKey(t, f + _, h + w);
          a.push({
            quadkey: A,
            x: b,
            y: T
          });
        }
      }
      return this.tiles[e] = a, a;
    }, t;
  }(),
  Tt = 60 / 180 * Math.PI;
exports.styleTools = xt;
function Lt(t, e, i) {
  if (e[t += "EventListener"]) for (var r in i) e[t](r, i[r]);
}
var St = function () {
    function i(t, r, n, o, a, s) {
      this.updating = !1, this._gridClip = {
        rz: 0,
        rx: 0,
        s: 0,
        top: 0
      }, this.dirty = !1, this.globalBgc = !1;
      var l = this,
        u = b(t, "width"),
        h = b(t, "height"),
        f = function (t, e, i, r, n) {
          var o,
            a = document.createElement("canvas"),
            s = a.style;
          return function (t, e, i) {
            t.setAttribute("width", e), t.setAttribute("height", i);
          }(a, e, i), a.setAttribute("oncontextmenu", "return false;"), function (t, e) {
            ["-webkit-user-select", "-moz-user-select", "-ms-user-select", "user-select"].forEach(function (i) {
              t.style[i] = e;
            });
          }(a, "none"), s.top = s.left = "0px", s.position = "absolute", 1 != n && (s.opacity = String(n)), t.querySelectorAll("canvas[type=layer]"), a.setAttribute("type", "layer"), (o = t.querySelectorAll("canvas")[r]) ? t.insertBefore(a, o) : t.appendChild(a), a;
        }(t, u, h, 0);
      l.previewer = new z(l, s), l.cluster = new wt(_xyzMapsCommon.TaskManager.getInstance(), 4), l.grid = new bt(r), l.tiles = {
        256: [],
        512: []
      }, l.render = a, l.tileSize = r, l.buckets = o, l.layers = new S(), l.w = u, l.h = h, l.canvas = f, f.className = "tmc", l.dpr = i.getPixelRatio(n), l.setSize(u, h), l.setBGColor();
      var c = new A(l, a);
      l.listeners = {
        clear: function (t) {
          var e = t.detail,
            i = e.tiles,
            r = e.layer;
          c.clear(r, i);
        },
        featureAdd: function (t) {
          var e = t.detail,
            i = e.feature,
            r = e.tiles,
            n = e.layer;
          r && c.add(i, r, n);
        },
        featureRemove: function (t) {
          var e = t.detail,
            i = e.feature,
            r = e.tiles,
            n = e.layer;
          r && c.remove(i, r, n);
        },
        featureCoordinatesChange: function (t) {
          var e = t.detail,
            i = e.feature,
            r = e.prevBBox,
            n = e.prevCoordinates,
            o = e.layer;
          c.updateGeometry(i, r, n, o);
        },
        styleGroupChange: function (t) {
          var e = t.detail,
            i = e.feature,
            r = e.styleGroup,
            n = e.layer;
          c.repaint(i, r, n);
        },
        styleChange: function (t) {
          var e = t.detail,
            i = e.layer,
            r = e.style,
            n = l.layers.indexOf(i);
          l.setLayerBgColor(r, l.layers[n]), l.buckets.tiles.forEach(function (t) {
            return t.clear(n);
          });
        }
      };
    }
    return i.getPixelRatio = function (e) {
      return (e = "auto" == e ? Math.min(2, _xyzMapsCommon.global.devicePixelRatio || 1) : e || 1) < 1 ? 1 : e;
    }, i.prototype.addLayer = function (t, e, i) {
      var r = this,
        n = r.layers,
        o = !1;
      if (n.add(t, i)) {
        var a = n.get(t);
        if (o = !0, r.buckets.forEach(function (t) {
          t.addLayer(i);
        }), Lt("add", t, r.listeners), t.custom) return o;
        a.handleTile = function (e) {
          r.isVisible(e, a) && r.handleTile(e, t);
        }, 0 == i && r.setLayerBgColor(t.getStyle(), a);
      }
      return o;
    }, i.prototype.removeLayer = function (t) {
      var e = this,
        i = this.layers,
        r = i.get(t),
        n = r.tiles,
        o = i.indexOf(t);
      if (-1 !== o) {
        e.buckets.forEach(function (e) {
          e.cancelTasks(t), e.removeLayer(o);
        });
        for (var a = 0, s = n; a < s.length; a++) {
          var l = s[a].tile.quadkey;
          e.releaseTile(l, r), e.cancel(l, t);
        }
        i.remove(t), Lt("remove", t, e.listeners);
      }
      return o;
    }, i.prototype.getBucket = function (t, e) {
      var i = this;
      return e ? i.buckets.create(t, i.layers) : i.buckets.get(t);
    }, i.prototype.handleTile = function (t, e, i, r) {
      var n,
        o = this,
        a = !1;
      if (i ? a = !0 : i = o.getBucket(t.quadkey, true), null == r && (r = o.layers.indexOf(e)), t.error && (o.layers[r].error = !0), !i.ready(r) && !i.busy(e) && (n = t.data)) {
        var s = function (e, i) {
          t.isLoaded() && e.ready(e.index(i), !0), o.update(a);
        };
        i.ready(r, !1);
        var l = e.render;
        l ? l(t, n, e, i, s) : o.prepareTile(t, n, e, i, s);
      }
    }, i.prototype.setLayerBgColor = function (t, e) {
      var i = t.backgroundColor;
      i && (e.bgColor = this.render.convertColor(i));
    }, i.prototype.isVisible = function (t, e) {
      for (var i = t.quadkey, r = 0, n = e.tiles; r < n.length; r++) {
        if (n[r].tile.quadkey == i) return !0;
      }
      return !1;
    }, i.prototype.getContext = function () {
      return this.render.getContext();
    }, i.prototype.copyCanvas2d = function (t, e, i, r) {
      void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.w), void 0 === r && (r = this.h);
      var n = this.canvas,
        o = this.dpr;
      t *= o, e *= o, i *= o, r *= o;
      var a = document.createElement("Canvas");
      return a.width = i, a.height = r, this.viewport(), a.getContext("2d").drawImage(n, t, e, i, r, 0, 0, i, r), a;
    }, i.prototype.getScreenTile = function (t, e) {
      return this.grid.tiles[e].find(function (e) {
        return e.quadkey == t;
      });
    }, i.prototype.updateTile = function (t, e, i, r) {
      if (e && !e.busy(i)) {
        var n = this,
          o = e.index(i);
        e.ready(o, !1), n.isVisible(t, n.layers[o]) && n.handleTile(t, i, e, o);
      }
    }, i.prototype.setSize = function (t, e) {
      var i = this,
        r = i.dpr,
        n = i.canvas;
      i.w = t, i.h = e, n.width = t * r, n.height = e * r, n.style.width = t + "px", n.style.height = e + "px";
    }, i.prototype.cancel = function (t, e) {
      var i = this.buckets.get(t, !0);
      i && i.cancelTasks(e);
    }, i.prototype.preview = function (t, e, i) {
      var r = this.previewer.create(t, e);
      return t.preview(i, r), r;
    }, i.prototype.initVpTiles = function (t, e, i) {
      for (var r = this, n = this.layers, o = r.tiles[i], a = r.tiles[i] = [], s = [], l = 0, u = t; l < u.length; l++) {
        var h = u[l],
          f = h.x,
          c = h.y,
          p = h.quadkey,
          d = r.getBucket(p, true),
          v = new T(f, c, i, d);
        d.i = ++this.ti, s.push(v), a.push(v);
        for (var y = 0, g = n; y < g.length; y++) {
          var m = g[y],
            x = m.layer;
          if (x.tiled) (x.tileSize || 256) == i && (m.tiles != s && (m.tiles = s), e >= x.min && e <= x.max && (r.initTile(d, m), x.getTile(p, m.handleTile)));
        }
      }
      o.forEach(function (t) {
        for (var e = t.tile.quadkey, o = 0, s = a; o < s.length; o++) {
          if (s[o].tile.quadkey == e) return;
        }
        for (var l = 0, u = n; l < u.length; l++) {
          var h = u[l];
          h.layer.tileSize == i && r.releaseTile(e, h);
        }
        r.cancel(e);
      });
    }, i.prototype.clipGridHeight = function (t) {
      var e = this,
        i = e.rz,
        r = e.rx,
        n = e.s,
        o = e._gridClip,
        a = e.centerWorld;
      if (o.rx != r || o.rz != i) {
        o.rz = i, o.rx = r, this.setView(a, n, i, -t);
        var s = this.unproject(this.w / 2, 0);
        this.setView(a, n, i, r), o.top = this.project(s[0], s[1])[1];
      }
      return o.top;
    }, i.prototype.updateGrid = function (t, e, i) {
      var r = this.centerWorld,
        n = 0 ^ t;
      this.viewChange = !0, this.sx = e, this.sy = i;
      var o = this,
        a = this.rz,
        s = this.w,
        l = this.h,
        u = s,
        h = l,
        f = this.grid,
        c = 0;
      -this.rx > Tt && (c = this.clipGridHeight(Tt));
      var p = [o.unproject(0, c), o.unproject(u - 1, c), o.unproject(u - 1, h - 1), o.unproject(0, h - 1)];
      f.init(r, a, s, l, p);
      var d = this.layers.reset(n + Math.log(this.s) / Math.LN2);
      this.ti = 0;
      for (var v = 0, y = d; v < y.length; v++) {
        var g = y[v],
          m = o.grid.getTiles(n - Number(512 == g), g);
        this.initVpTiles(m, n, g);
      }
      -1 == d.indexOf(512) && o.grid.getTiles(n - 1, 512), this.dirty = !0, o.update();
    }, i.prototype.releaseTile = function (t, e) {
      var i = e.layer,
        r = i.getCachedTile(t);
      r && r.loadStartTs && (r.isLoaded() || i.cancelTile(r, e.handleTile));
    }, i.prototype.initTile = function (t, e) {
      var i = e.index;
      e.visible ? t.ready(i) || t.preview(i) || this.preview(t, e.layer, i) : t.ready(i, !0);
    }, i.prototype.update = function (t) {
      var e = this;
      e.dirty || (e.dirty = t), e.updating || (e.updating = !0, requestAnimationFrame(function () {
        e.viewport(), e.updating = !1;
      }));
    }, i.prototype.setBGColor = function (e) {
      var i = this,
        r = i.render,
        n = e || _xyzMapsCommon.global.getComputedStyle(i.canvas.parentElement, null).getPropertyValue("background-color");
      n && "rgba(0, 0, 0, 0)" != n && "transparent" != n || (n = "#ffffff"), n = r.convertColor(n), i.globalBgc = n, r.setBackgroundColor(n);
    }, i.prototype.showGrid = function (t) {
      this.render.grid(!!t);
    }, i.prototype.setView = function (t, e, i, r, n, o) {
      this.centerWorld = t, this.setTransform(e, i, r);
    }, i.prototype.setTransform = function (t, e, i) {
      this.render.setScale(this.s = t, 0, 0), this.render.setRotation(this.rz = e, this.rx = i), this.render.applyTransform();
    }, i.prototype.getLayers = function () {
      return this.layers;
    }, i.prototype.destroy = function () {
      this.render.destroy();
      var t = this.canvas;
      t.parentElement.removeChild(t), t.width = t.height = 1;
    }, i.prototype.clearLayer = function (t) {
      var e = this.getLayers().indexOf(t);
      this.buckets.forEach(function (t) {
        t.preview(e, !1), t.ready(e, !1);
      });
    }, i.prototype.viewChangeDone = function () {
      this.viewChange = !1;
    }, i.prototype.getRenderedFeatureAt = function (t, e, i) {
      return null;
    }, i;
  }(),
  At = document.createElement("canvas"),
  Mt = At.getContext("2d");
At.width = 1, At.height = 1;
function zt() {
  var t = this,
    e = t._cbs,
    i = Math.max(t.width, t.height);
  if (t._cbs = null, i > 64) {
    var r = 64 / i;
    t = t._r[t.src] = function (t, e) {
      var i = document.createElement("canvas"),
        r = i.getContext("2d");
      return i.width = t.width * e, i.height = t.height * e, r.drawImage(t, 0, 0, i.width, i.height), i;
    }(t, r);
  } else Mt.drawImage(t, 0, 0);
  for (var n in t.ready = !0, t._r = null, e) e[n][0](t, e[n][1]);
}
var It,
  Pt = function () {
    function t() {
      this.imgData = {};
    }
    return t.prototype.isRequested = function (t) {
      return !!this.imgData[t];
    }, t.prototype.isReady = function (t) {
      return this.imgData[t] && this.imgData[t].ready;
    }, t.prototype.get = function (t, e, i, r) {
      var n = this.imgData;
      if (null == n[t]) {
        var o = n[t] = new Image();
        o.ready = !1, o._cbs = {}, e && (o._cbs[i] = [e, r]), o._r = n, o.crossOrigin = "Anonymous", o.onload = zt, o.src = t;
      } else e && (n[t].ready ? e(n[t], r) : n[t]._cbs[i] = [e, r]);
      return n[t];
    }, t;
  }(),
  Et = function () {
    function t(t, e, i) {
      this.gl = t, this.format = i || t.RGBA, e && this.set(e);
    }
    return t.prototype.bind = function () {
      var t = this.gl,
        e = this.texture;
      e && t.bindTexture(t.TEXTURE_2D, e);
    }, t.prototype.set = function (t, e, i) {
      var r = this,
        n = r.gl,
        o = r.texture,
        a = r.format,
        s = t.width,
        l = t.height,
        u = a,
        h = "number" == typeof e;
      o || (this.texture = o = n.createTexture()), n.bindTexture(n.TEXTURE_2D, o), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), h || this.width == s && !this.height && !l ? n.texSubImage2D(n.TEXTURE_2D, 0, e || 0, i || 0, a, n.UNSIGNED_BYTE, t) : (t instanceof HTMLCanvasElement || t instanceof HTMLImageElement ? n.texImage2D(n.TEXTURE_2D, 0, u, a, n.UNSIGNED_BYTE, t) : n.texImage2D(n.TEXTURE_2D, 0, u, s, l, 0, a, n.UNSIGNED_BYTE, t.pixels), this.width = s, this.height = l), s == l && function (t) {
        return 0 == (t & t - 1);
      }(l) ? (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR_MIPMAP_NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.generateMipmap(n.TEXTURE_2D)) : (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR));
    }, t.prototype.destroy = function () {
      var t = this.gl,
        e = this.texture;
      e && (t.deleteTexture(e), this.texture = null);
    }, t;
  }(),
  Ct = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }
    return y(e, t), e.prototype.destroy = function (e) {
      e && t.prototype.destroy.call(this);
    }, e;
  }(Et),
  kt = function (t, e, i, r, n) {
    this.i = t, this.u1 = e, this.v1 = r, this.u2 = i, this.v2 = n;
  },
  Dt = function () {
    function t(t) {
      var e = t.gl,
        r = t.maxImgSize || 256,
        n = Math.pow(1024 / r, 2),
        o = Math.sqrt(n);
      this.c = new _xyzMapsCommon.LRU(n), this.max = n, this.maxSize = r, this.gl = e, this.d = o;
    }
    return t.prototype.get = function (t) {
      return this.c.get(t);
    }, t.prototype.init = function () {
      var t = this;
      t.texture, t.gl;
      var e = t.maxSize,
        i = t.d;
      if (!this.texture) {
        var r = i * e;
        this.texture = new Ct(this.gl, {
          width: r,
          height: r
        });
      }
    }, t.prototype.set = function (t, e) {
      var i,
        r = this.c,
        n = this.d,
        o = this.maxSize,
        a = r.get(t),
        s = !1;
      a ? i = a.i : ((i = r.length) >= r.max && (i = (a = r.tail.data).i), s = !0);
      var l = i % n ^ 0,
        u = i / n ^ 0,
        h = l * o,
        f = u * o,
        c = h + e.width,
        p = f + e.height;
      return a ? (a.u1 = h, a.u2 = c, a.v1 = f, a.v2 = p) : a = new kt(i, h, c, f, p), (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) && (this.init(), this.texture.set(e, l * o, u * o)), s && r.set(t, a), a;
    }, t.prototype.destroy = function () {
      var t = this.texture;
      t && t.destroy(!0);
    }, t;
  }(),
  Ot = function () {
    function t(t, e) {
      this.images = new Pt(), this.atlas = new Dt({
        gl: t,
        maxImgSize: 64
      });
    }
    return t.prototype.getTexture = function () {
      return this.atlas.texture;
    }, t.prototype.get = function (t, e, i, r) {
      var n = this,
        o = n.atlas,
        a = n.images,
        s = n.onLoad,
        l = o.get(t);
      if (!l && !a.get(t, function (e) {
        l = o.set(t, e), r && r(l), s && s(l);
      }).ready) return !1;
      return l;
    }, t.prototype.destroy = function () {
      this.atlas.destroy();
    }, t;
  }(),
  Ft = window.console.error,
  Rt = function (t, e, i, r) {
    r = r || Ft;
    var n = t.createShader(i);
    return t.shaderSource(n, e), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (r("compileShader " + t.getShaderInfoLog(n)), t.deleteShader(n), null);
  },
  Nt = function (t, e, i) {
    return function (t, e, i) {
      i = i || Ft;
      for (var r = t.createProgram(), n = 0, o = e; n < o.length; n++) {
        var a = o[n];
        t.attachShader(r, a);
      }
      return t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS) ? r : (i("linkProgram " + t.getProgramInfoLog(r)), t.deleteProgram(r), null);
    }(t, [Rt(t, e, t.VERTEX_SHADER), Rt(t, i, t.FRAGMENT_SHADER)]);
  },
  Bt = function (t) {
    for (var e in t) this[e] = t[e];
  };
!function (t) {
  t[t.OPAQUE = 0] = "OPAQUE", t[t.ALPHA = 1] = "ALPHA", t[t.POST_ALPHA = 2] = "POST_ALPHA";
}(It || (It = {}));
var Ut,
  Wt = function () {
    function t(t, e, i, r, n, o) {
      this.attributes = {}, this.uniforms = {}, this.uniformSetters = {}, this.macros = {
        M_PI: 3.1415927410125732
      }, this.dpr = n, this.mode = e, this.usage = t.STATIC_DRAW, this.gl = t, this.glStates = new Bt({
        scissor: !0,
        blend: !1,
        depth: !0
      }), this.compile(i, r, o);
    }
    return t.prototype.createUniformSetter = function (t, e) {
      var i = this.gl;
      switch (t.type) {
        case i.FLOAT:
          return function (t) {
            return i.uniform1f(e, t);
          };
        case i.FLOAT_MAT4:
          return function (t) {
            return i.uniformMatrix4fv(e, !1, t);
          };
        case i.FLOAT_VEC2:
          return function (t) {
            return i.uniform2fv(e, t);
          };
        case i.FLOAT_VEC3:
          return function (t) {
            return i.uniform3fv(e, t);
          };
        case i.FLOAT_VEC4:
          return function (t) {
            return i.uniform4fv(e, t);
          };
        case i.BOOL:
        case i.SAMPLER_2D:
          return function (t) {
            return i.uniform1i(e, t);
          };
      }
      return function () {};
    }, t.prototype.buildSource = function (t, e, i) {
      i = g(g(g({}, this.macros), {
        DEVICE_PIXEL_RATIO: this.dpr.toFixed(1)
      }), i);
      var r = "";
      for (var n in i) r += "#define ".concat(n, " ").concat(i[n], "\n");
      return [r + "#define GLSLIFY 1\nvec2 round(vec2 point){vec2 fractPoint=fract(point);point+=step(0.5,fractPoint)-fractPoint;return point;}vec4 snapToScreenPixel(vec4 position,vec2 resolution){resolution*=DEVICE_PIXEL_RATIO;vec2 screenPixel=((position.xy/position.w+1.0)/2.0)*resolution;position.xy=(round(screenPixel)/resolution*2.0-1.0)*position.w;return position;}vec2 rotateZ(vec2 v,float a){float rotSin=sin(a);float rotCos=cos(a);mat2 m=mat2(rotCos,-rotSin,rotSin,rotCos);return v*m;}float toPixel(vec2 size,float zoom){float value=size.x;if(size.y>0.0){value*=zoom*size.y;}return value;}const float SCALE_UINT16_Z=9000.0/65535.0;" + t, r + e];
    }, t.prototype.compile = function (t, e, i) {
      var r = this.gl,
        n = this.buildSource(t, e, i || {}),
        o = n[0],
        a = n[1],
        s = Nt(r, o, a);
      this.prog = s;
      for (var l = r.getProgramParameter(s, r.ACTIVE_ATTRIBUTES), u = 0; u < l; ++u) {
        var h = r.getActiveAttrib(s, u).name;
        this.attributes[h] = r.getAttribLocation(s, h);
      }
      for (var f = r.getProgramParameter(s, r.ACTIVE_UNIFORMS), c = 0; c < f; c++) {
        var p = r.getActiveUniform(s, c),
          d = p.name,
          v = r.getUniformLocation(s, d);
        this.uniforms[d] = v, this.uniformSetters[p.name] = this.createUniformSetter(p, v);
      }
    }, t.prototype.setBufferCache = function (t) {
      this.buffers = t;
    }, t.prototype.getUniformLocation = function (t) {
      return this.uniforms[t];
    }, t.prototype.setUniform = function (t, e) {
      var i;
      (i = this.uniformSetters[t]) && i(e);
    }, t.prototype.initUniforms = function (t) {
      for (var e in t) {
        var i = this.uniformSetters[e];
        i && i(t[e]);
      }
    }, t.prototype.initAttributes = function (t) {
      var e,
        i,
        r = this.gl;
      for (var n in t) e = t[n], i = this.attributes[n], r.bindBuffer(r.ARRAY_BUFFER, this.buffers.get(e)), r.vertexAttribPointer(i, e.size, e.type, e.normalized, e.stride, e.offset), r.enableVertexAttribArray(i);
    }, t.prototype.initIndex = function (t) {
      var e = this.buffers,
        i = this.gl,
        r = e.get(t),
        n = !0;
      r || (r = i.createBuffer(), e.set(t, r), n = !1), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, r), n || i.bufferData(i.ELEMENT_ARRAY_BUFFER, t.data, i.STATIC_DRAW);
    }, t.prototype.pass = function (t) {
      return t == It.OPAQUE;
    }, t.prototype.draw = function (t) {
      var e = this.gl,
        i = t.texture,
        r = t.groups,
        n = this._pass == It.ALPHA && t.alpha == It.POST_ALPHA;
      n && e.colorMask(!1, !1, !1, !1), i && (e.activeTexture(e.TEXTURE0), i.bind());
      for (var o = 0, a = r; o < a.length; o++) {
        var s = a[o],
          l = s.mode || this.mode;
        s.uniforms && this.initUniforms(s.uniforms), s.index ? (this.initIndex(s.index), e.drawElements(l, s.index.length, s.index.type, 0)) : e.drawArrays(l, s.arrays.first, s.arrays.count);
      }
      n && e.colorMask(!0, !0, !0, !1);
    }, t.prototype.setStates = function (t, e, i, r) {
      var n = this.gl;
      t ? n.enable(n.SCISSOR_TEST) : n.disable(n.SCISSOR_TEST), r ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST), e ? n.enable(n.BLEND) : n.disable(n.BLEND), i ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST);
    }, t.prototype.init = function (t, e, i, r) {
      var n = this.gl,
        o = e == It.OPAQUE,
        a = this.glStates,
        s = a.blend,
        l = a.scissor,
        u = a.depth;
      this._pass = e, null != t.scissor && (l = t.scissor), null != t.blend && (s = t.blend), null != t.depth && (u = t.depth), this.setStates(l, s, u, i && !o && s && l), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA);
      var h = t.cullFace();
      h ? (n.cullFace(h), n.enable(n.CULL_FACE)) : n.disable(n.CULL_FACE), n.depthMask(!t.isFlat() || o), n.disable(n.POLYGON_OFFSET_FILL), e == It.POST_ALPHA && (n.enable(n.STENCIL_TEST), n.stencilFunc(n.GREATER, 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.REPLACE));
    }, t;
  }(),
  Gt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision lowp float;\n#define GLSLIFY 1\nattribute highp vec3 a_position;uniform float u_scale;uniform vec4 u_size;uniform mat4 u_matrix;uniform float u_strokeWidth;uniform vec2 u_topLeft;uniform float u_rotation;uniform vec4 u_offset;uniform vec2 u_offsetZ;uniform float u_zMeterToPixel;uniform bool u_alignMap;uniform vec2 u_resolution;varying vec2 vSize;varying vec2 vDir;const float EXTENT_SCALE=1.0/32.0;void main(void){if(mod(a_position.x,2.0)==1.0){vec2 dir=mod(floor(a_position.xy/2.0),2.0)*2.0-1.0;vec2 pos=floor(a_position.xy/4.0)*EXTENT_SCALE;vec2 size=vec2(toPixel(u_size.xy,u_scale),toPixel(u_size.zw,u_scale));size=(size+u_strokeWidth)*.5;float rotation=u_rotation;if(!u_alignMap){rotation*=-1.0;}vec2 pixel_offset=vec2(toPixel(u_offset.xy,u_scale),toPixel(u_offset.zw,u_scale));float z=a_position.z*SCALE_UINT16_Z+toPixel(u_offsetZ,u_scale)/u_zMeterToPixel/u_scale;if(u_alignMap){vec2 shift=(pixel_offset+rotateZ(dir*vec2(size.x,-size.y),rotation))/u_scale;gl_Position=u_matrix*vec4(u_topLeft+pos+shift,-z,1.0);}else{vec4 cpos=u_matrix*vec4(u_topLeft+pos,-z,1.0);vec2 shift=rotateZ(dir*size,rotation);vec2 offset=pixel_offset*vec2(1.0,-1.0);gl_Position=vec4(cpos.xy/cpos.w+(offset+shift)/u_resolution*2.0,cpos.z/cpos.w,1.0);}vSize=size;vDir=dir;}}", "precision lowp float;\n#define GLSLIFY 1\nuniform vec4 u_fill;uniform vec4 u_stroke;uniform float u_strokeWidth;varying vec2 vSize;varying vec2 vDir;\n#define COLOR_UNDEF -1.0\nvoid main(void){float dx=distance(vDir.x,0.0)*vSize.x;float dy=distance(vDir.y,0.0)*vSize.y;if(dx>vSize.x-u_strokeWidth||dy>vSize.y-u_strokeWidth){gl_FragColor=u_stroke;}else{gl_FragColor=u_fill;if(u_fill[0]==COLOR_UNDEF){gl_FragColor.a=0.0;};}}", i) || this;
      return r.name = "Rect", r.glStates = new Bt({
        scissor: !1,
        blend: !1,
        depth: !0
      }), r;
    }
    return y(e, t), e;
  }(Wt),
  Zt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision lowp float;\n#define GLSLIFY 1\nattribute highp vec3 a_position;uniform vec2 u_radius;uniform mat4 u_matrix;uniform vec2 u_topLeft;uniform vec4 u_offset;uniform float u_scale;uniform vec2 u_resolution;uniform bool u_alignMap;uniform float u_strokeWidth;uniform vec2 u_offsetZ;uniform float u_zMeterToPixel;varying vec2 v_position;varying float v_radius;const float EXTENT_SCALE=1.0/32.0;void main(void){if(mod(a_position.x,2.0)==1.0){vec2 dir=mod(floor(a_position.xy/2.0),2.0)*2.0-1.0;vec2 pos=floor(a_position.xy/4.0)*EXTENT_SCALE;float radius=toPixel(u_radius,u_scale);radius=radius+u_strokeWidth/2.0;v_position=dir*radius;v_radius=radius;vec2 pixel_offset=vec2(toPixel(u_offset.xy,u_scale),toPixel(u_offset.zw,u_scale));float z=a_position.z*SCALE_UINT16_Z+toPixel(u_offsetZ,u_scale)/u_zMeterToPixel/u_scale;if(u_alignMap){vec2 shift=(pixel_offset+v_position*vec2(1.0,-1.0))/u_scale;gl_Position=u_matrix*vec4(u_topLeft+pos+shift,-z,1.0);}else{vec4 cpos=u_matrix*vec4(u_topLeft+pos,-z,1.0);vec2 offset=pixel_offset*vec2(1.0,-1.0);gl_Position=vec4(cpos.xy/cpos.w+(offset+v_position)/u_resolution*2.0,cpos.z/cpos.w,1.0);}}}", "precision lowp float;\n#define GLSLIFY 1\nuniform vec4 u_fill;uniform vec4 u_stroke;uniform float u_strokeWidth;varying float v_radius;varying vec2 v_position;\n#define COLOR_UNDEF -1.0\nvoid main(void){float r=length(v_position);if(r>v_radius)discard;if(r<v_radius-u_strokeWidth){if(u_fill[0]==COLOR_UNDEF)discard;gl_FragColor=u_fill;}else{gl_FragColor=u_stroke;}}", i) || this;
      return r.name = "Circle", r.glStates = new Bt({
        scissor: !1,
        blend: !1,
        depth: !0
      }), r;
    }
    return y(e, t), e;
  }(Wt),
  Xt = "precision lowp float;\n#define GLSLIFY 1\nattribute vec3 a_position;attribute highp vec4 a_normal;attribute float a_lengthSoFar;uniform mat4 u_matrix;uniform highp vec2 u_strokeWidth;uniform highp float u_scale;uniform vec2 u_topLeft;uniform float u_texWidth;varying vec2 v_normal;varying float v_lengthSoFar;varying vec2 v_width;uniform vec2 u_offset;uniform float u_tileScale;uniform bool u_no_antialias;const float N_SCALE=1.0/8191.0;void main(void){float strokeWidth=toPixel(u_strokeWidth,u_scale);float alias=u_no_antialias? .0: strokeWidth<1. ? .65 : 1.;float width=(strokeWidth+alias)/u_scale;v_width=vec2(strokeWidth,alias*.5);vec2 dir2=mod(a_normal.zw,2.0)*2.0-1.0;vec2 aliasNormal=floor(a_normal.zw*.5)*N_SCALE;v_normal=dir2*aliasNormal;vec2 dir=mod(a_normal.xy,2.0)*2.0-1.0;vec2 normal=floor(a_normal.xy*.5)*N_SCALE;v_lengthSoFar=a_lengthSoFar/u_texWidth;float lineOffset=toPixel(u_offset,u_scale);vec2 position=a_position.xy+normal*-lineOffset/u_scale;gl_PointSize=8.0;gl_Position=u_matrix*vec4(u_topLeft+position*u_tileScale+dir*normal*width,-a_position.z,1.0);}",
  Yt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, Xt, "precision lowp float;\n#define GLSLIFY 1\nuniform sampler2D u_pattern;uniform vec4 u_fill;varying vec2 v_normal;varying float v_lengthSoFar;varying vec2 texCoord;varying vec2 v_width;void main(void){float width=length(v_normal)*(v_width.s+v_width.t);float alpha=1.0-clamp(.5*(width-v_width.s+v_width.t)/v_width.t,.0,1.);gl_FragColor=u_fill;if(v_width.t==0.0&&alpha<1.0)discard;gl_FragColor.a*=alpha;}", i) || this;
      return r.name = "Line", r.glStates = new Bt({
        blend: !0,
        scissor: !0,
        depth: !0
      }), r;
    }
    return y(e, t), e.prototype.pass = function (t) {
      return t == It.ALPHA || t == It.POST_ALPHA;
    }, e;
  }(Wt),
  Ht = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, Xt, "precision lowp float;\n#define GLSLIFY 1\nuniform vec4 u_fill;varying vec2 v_normal;varying vec2 v_width;varying float v_lengthSoFar;uniform sampler2D u_pattern;void main(void){float width=length(v_normal)*(v_width.s+v_width.t);float alpha=1.0-clamp(.5*(width-v_width.s+v_width.t)/v_width.t,.0,1.);gl_FragColor=u_fill;gl_FragColor.a*=alpha*texture2D(u_pattern,vec2(fract(v_lengthSoFar))).r;}", i) || this;
      return r.name = "Line", r.glStates = new Bt({
        blend: !0,
        scissor: !0,
        depth: !0
      }), r;
    }
    return y(e, t), e.prototype.pass = function (t) {
      return t == It.ALPHA;
    }, e.prototype.init = function (e, i, r) {
      var n = this.gl;
      t.prototype.init.call(this, e, i, r), n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA);
    }, e;
  }(Wt),
  jt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision lowp float;\n#define GLSLIFY 1\nattribute vec3 a_position;uniform vec2 u_offsetZ;uniform float u_scale;uniform float u_zMeterToPixel;uniform float u_tileScale;uniform mat4 u_matrix;uniform vec2 u_topLeft;void main(void){float z=a_position.z+u_offsetZ.x/u_zMeterToPixel/u_scale;gl_Position=u_matrix*vec4(u_topLeft+a_position.xy*u_tileScale,-z,1.0);}", "precision lowp float;\n#define GLSLIFY 1\nuniform vec4 u_fill;void main(void){gl_FragColor=u_fill;}", i) || this;
      return r.name = "Polygon", r;
    }
    return y(e, t), e;
  }(Wt),
  Vt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision lowp float;\n#define GLSLIFY 1\nattribute vec2 a_position;attribute vec2 a_textureCoord;uniform highp mat4 u_matrix;uniform highp vec2 u_topLeft;uniform highp vec2 u_resolution;varying vec2 v_textureCoord;void main(void){v_textureCoord=a_textureCoord;vec4 position=u_matrix*vec4(u_topLeft+a_position,0.0,1.0);gl_Position=snapToScreenPixel(position,u_resolution);}", "precision lowp float;\n#define GLSLIFY 1\nvarying vec2 v_textureCoord;uniform sampler2D u_sampler;void main(void){gl_FragColor=texture2D(u_sampler,v_textureCoord);}", i) || this;
      return r.name = "Image", r.glStates = new Bt({
        scissor: !0,
        blend: !1,
        depth: !0
      }), r;
    }
    return y(e, t), e;
  }(Wt),
  qt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision highp float;\n#define GLSLIFY 1\nattribute vec3 a_point;attribute vec3 a_position;attribute vec2 a_texcoord;uniform vec2 u_resolution;uniform mat4 u_matrix;uniform vec2 u_topLeft;uniform vec4 u_offset;uniform vec2 u_offsetZ;uniform float u_zMeterToPixel;uniform float u_scale;uniform float u_rotate;uniform bool u_alignMap;uniform bool u_fixedView;uniform float u_atlasScale;varying vec2 v_texcoord;varying vec4 vColor;const float EXTENT_SCALE=1.0/64.0;const float OFFSET_SCALE=1.0/32.0;const float PI_05=M_PI*0.5;const float PI_15=M_PI*1.5;const float PI_20=M_PI*2.0;mat3 rotation3dY(float angle){float s=sin(angle);float c=cos(angle);return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c);}vec3 rotateY(vec3 v,float angle){return rotation3dY(angle)*v;}vec3 rotateY(vec2 v,float angle){return rotation3dY(angle)*vec3(v,0.0);}void main(void){if(mod(a_position.x,2.0)==1.0){vec2 position=floor(a_position.xy/2.0)*EXTENT_SCALE;vec2 rotLowHi=mod(a_texcoord,32.0);float rotation=rotLowHi.y*32.0+rotLowHi.x;v_texcoord=floor(a_texcoord/32.0)*u_atlasScale;vec2 labelOffset=vec2(toPixel(u_offset.xy,u_scale),toPixel(u_offset.zw,u_scale));labelOffset*=DEVICE_PIXEL_RATIO;rotation=rotation/1024.0*PI_20;float z=a_position.z*SCALE_UINT16_Z+toPixel(u_offsetZ,u_scale)/u_zMeterToPixel/u_scale;if(u_alignMap){float absRotation=mod(u_rotate+rotation,PI_20);if(absRotation>PI_05&&absRotation<PI_15){rotation+=M_PI;labelOffset*=-1.0;}vec2 _p=a_point.xy*OFFSET_SCALE+labelOffset;vec3 p=rotateY(vec3(_p,1.0),a_point.z/32767.0*PI_20);p.xy=rotateZ(_p,rotation);p=p/u_scale/DEVICE_PIXEL_RATIO;gl_Position=u_matrix*vec4(u_topLeft+position+p.xy,p.z-z,1.0);}else{vec4 cpos=u_matrix*vec4((u_topLeft+position),-z,1.0);vec2 offset=rotateZ(a_point.xy*OFFSET_SCALE+labelOffset,rotation);gl_Position=vec4(cpos.xy/cpos.w+vec2(1,-1)*offset/DEVICE_PIXEL_RATIO/u_resolution*2.0,cpos.z/cpos.w,1.0);}if(u_fixedView){gl_Position=snapToScreenPixel(gl_Position,u_resolution);}}}", "precision mediump float;\n#define GLSLIFY 1\nvarying vec2 v_texcoord;uniform sampler2D u_texture;uniform bool u_strokeOnly;uniform vec4 u_fillColor;uniform vec4 u_strokeColor;void main(){vec4 glyph=texture2D(u_texture,v_texcoord);vec4 color;float glyphAlpha;if(u_strokeOnly){color=u_strokeColor;glyphAlpha=glyph.a;}else{color=u_fillColor;glyphAlpha=glyph.r;}gl_FragColor=glyphAlpha*vec4(color.rgb*color.a,color.a);}", i) || this;
      return r.name = "Text", r.glStates = new Bt({
        blend: !0,
        scissor: !1,
        depth: !0
      }), r;
    }
    return y(e, t), e.prototype.pass = function (t) {
      return t == It.ALPHA;
    }, e.prototype.init = function (e, i, r, n) {
      var o = this.gl;
      t.prototype.init.call(this, e, i, r), o.depthMask(!1), o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA), o.polygonOffset(0, 2048 * -n), o.enable(o.POLYGON_OFFSET_FILL);
    }, e.prototype.draw = function (e) {
      var i = this.gl,
        r = this.uniforms;
      i.uniform1f(r.u_strokeOnly, 1), t.prototype.draw.call(this, e), i.uniform1f(r.u_strokeOnly, 0), t.prototype.draw.call(this, e);
    }, e;
  }(Wt),
  Kt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision lowp float;\n#define GLSLIFY 1\nattribute vec2 a_size;attribute highp vec3 a_position;attribute vec2 a_texcoord;uniform mat4 u_matrix;uniform vec2 u_topLeft;uniform float u_scale;uniform float u_atlasScale;uniform vec4 u_offset;uniform vec2 u_offsetZ;uniform bool u_alignMap;uniform vec2 u_resolution;uniform bool u_fixedView;uniform float u_zMeterToPixel;varying float vOpacity;varying vec2 v_texcoord;const float EXTENT_SCALE=1.0/32.0;void main(void){if(mod(a_position.x,2.0)==1.0){vec2 rotLowHi=mod(a_texcoord,32.0);float rotation=rotLowHi.x+floor(rotLowHi.y*32.0);rotation=rotation/1024.0*2.0*M_PI;vec2 dir=mod(floor(a_position.xy/2.0),2.0)*2.0-1.0;vec2 pos=floor(a_position.xy/4.0)*EXTENT_SCALE;float z=a_position.z*SCALE_UINT16_Z+toPixel(u_offsetZ,u_scale)/u_zMeterToPixel/u_scale;vec2 offsetXY=vec2(toPixel(u_offset.xy,u_scale),toPixel(u_offset.zw,u_scale));if(u_alignMap){vec2 shift=rotateZ(offsetXY+dir*vec2(a_size.x,-a_size.y)*0.5,rotation)/u_scale;gl_Position=u_matrix*vec4(u_topLeft+pos+shift,-z,1.0);}else{vec4 cpos=u_matrix*vec4(u_topLeft+pos,-z,1.0);vec2 shift=rotateZ(dir*a_size,-rotation)*0.5;vec2 offset=offsetXY*vec2(1.0,-1.0);gl_Position=vec4(cpos.xy/cpos.w+(offset+shift)/u_resolution*2.0,cpos.z/cpos.w,1.0);}if(u_fixedView){gl_Position=snapToScreenPixel(gl_Position,u_resolution);}v_texcoord=floor(a_texcoord/32.0)*u_atlasScale;}}", "precision mediump float;\n#define GLSLIFY 1\nvarying vec2 v_texcoord;uniform float u_opacity;uniform sampler2D u_texture;void main(){gl_FragColor=texture2D(u_texture,v_texcoord);gl_FragColor.a*=u_opacity;}", i) || this;
      return r.name = "icon", r.glStates = new Bt({
        blend: !0,
        scissor: !1,
        depth: !0
      }), r;
    }
    return y(e, t), e.prototype.pass = function (t) {
      return t == It.ALPHA;
    }, e.prototype.init = function (e, i, r) {
      var n = this.gl;
      t.prototype.init.call(this, e, i, r), n.blendFunc(n.ONE, n.ONE_MINUS_SRC_ALPHA);
    }, e;
  }(Wt),
  Qt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, e.TRIANGLES, "precision lowp float;\n#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_normal;uniform mat4 u_matrix;uniform vec2 u_topLeft;varying vec3 v_normal;void main(void){gl_Position=u_matrix*vec4(u_topLeft+a_position.xy,-a_position.z,1.0);v_normal=a_normal;}", "precision lowp float;\n#define GLSLIFY 1\nuniform vec4 u_fill;uniform vec4 u_stroke;uniform bool u_strokePass;varying vec3 v_normal;\n#define lightDir normalize(vec3(0.5, 0.0, -1.0))\n#define top vec2(0.0)\nvoid main(void){if(u_strokePass){gl_FragColor=u_stroke;}else{if(v_normal.xy==top){gl_FragColor=u_fill;}else{float diffuse=0.3+dot(v_normal,lightDir)*0.7;gl_FragColor.rgb=u_fill.rgb*diffuse;}gl_FragColor.a=u_fill.a;}}", i) || this;
      return r.name = "Extrude", r.glStates = new Bt({
        scissor: !1,
        blend: !1,
        depth: !0
      }), r;
    }
    return y(e, t), e.prototype.init = function (e, i, r) {
      var n = this.gl;
      t.prototype.init.call(this, e, i, r), n.polygonOffset(1, 1), n.enable(n.POLYGON_OFFSET_FILL);
    }, e.prototype.draw = function (e) {
      var i = this.gl;
      t.prototype.draw.call(this, e), i.disable(i.POLYGON_OFFSET_FILL);
    }, e;
  }(Wt),
  $t = function (t) {
    function e(e, i, r) {
      var n = t.call(this, e, e.TRIANGLES, "precision mediump float;\n#define GLSLIFY 1\nvarying vec3 v_normal;attribute vec3 a_normal;attribute highp vec3 a_position;attribute highp vec3 a_point;uniform float u_scale;uniform vec4 u_size;uniform mat4 u_matrix;uniform mat4 u_inverseMatrix;uniform float u_strokeWidth;uniform vec2 u_topLeft;uniform float u_rotation;uniform vec4 u_offset;uniform bool u_alignMap;uniform vec2 u_resolution;uniform vec2 u_offsetZ;uniform float u_zMeterToPixel;\n#ifdef SPHERE\nvarying vec3 v_rayOrigin;varying vec3 v_rayDirecton;varying vec3 v_worldPos;uniform vec2 u_radius;\n#else\nvarying vec3 vPosition;varying float v_strokeWidth;\n#endif\nvarying vec3 vSize;const float EXTENT_SCALE=1.0/32.0;void main(void){\n#ifdef SPHERE\nvec3 dir=a_point*2.0-1.0;vec3 size=vec3(toPixel(u_radius,u_scale))/u_scale;\n#else\nvec3 dir=mod(a_point,2.0)*2.0-1.0;vec3 size=floor(a_point*.5)/u_scale;\n#endif\nvec3 vertexOffset=vec3(size.xy,-size.z/u_zMeterToPixel)*dir;vec3 boxCenter=vec3(u_topLeft+a_position.xy*EXTENT_SCALE,-a_position.z*SCALE_UINT16_Z);boxCenter+=vec3(toPixel(u_offset.xy,u_scale),toPixel(u_offset.zw,u_scale),-toPixel(u_offsetZ,u_scale)/u_zMeterToPixel)/u_scale;vec3 vertexPos=vec3(boxCenter.xy+rotateZ(vertexOffset.xy,u_rotation),boxCenter.z+vertexOffset.z);vertexPos.z=min(vertexPos.z,0.0);gl_Position=u_matrix*vec4(vertexPos,1.0);\n#ifdef SPHERE\nvec4 origin=u_inverseMatrix*vec4(gl_Position.xy,-1.0,gl_Position.w);v_rayOrigin=origin.xyz/origin.w;v_rayDirecton=vertexPos-v_rayOrigin;v_worldPos=boxCenter;v_rayOrigin.z*=u_zMeterToPixel;v_rayDirecton.z*=u_zMeterToPixel;v_worldPos.z*=u_zMeterToPixel;\n#else\nvPosition=vec3(vertexOffset.xy,vertexOffset.z*u_zMeterToPixel);v_strokeWidth=u_strokeWidth/u_scale;\n#endif\nvSize=size;v_normal=a_normal;}", "precision mediump float;\n#define GLSLIFY 1\nuniform vec4 u_fill;uniform vec4 u_stroke;varying vec3 vSize;\n#ifdef SPHERE\nvarying vec3 v_worldPos;varying vec3 v_rayOrigin;varying vec3 v_rayDirecton;\n#else\nvarying float v_strokeWidth;varying vec3 vPosition;const float smoothness=.25;\n#endif\nuniform float u_zMeterToPixel;varying vec3 v_normal;\n#define lightDir vec3(.5, .0, -1.0)\n#ifdef SPHERE\nfloat sphereIntersect(vec3 rayOrigin,vec3 rayDirection,vec3 spherePosition,float sphereRadius){vec3 oc=rayOrigin-spherePosition.xyz;float b=dot(oc,rayDirection);float c=dot(oc,oc)-sphereRadius*sphereRadius;float d=b*b-c;return(d<0.0)?-1.0 :-b-sqrt(d);}\n#endif\nvoid main(void){vec4 color=u_fill;vec3 normal;\n#ifdef SPHERE\nfloat radius=vSize.x;float distance=sphereIntersect(v_rayOrigin,normalize(v_rayDirecton),v_worldPos,radius);if(distance==-1.0)discard;vec3 surfacePos=normalize(v_rayDirecton)*distance+v_rayOrigin;normal=normalize(surfacePos-v_worldPos);\n#else\nvec3 size=vSize;vec3 pos=vPosition;float a=smoothstep(v_strokeWidth,v_strokeWidth+smoothness,length(abs(pos.xy)-size.xy));a*=smoothstep(v_strokeWidth,v_strokeWidth+smoothness,length(abs(pos.yz)-size.yz));a*=smoothstep(v_strokeWidth,v_strokeWidth+smoothness,length(abs(pos.xz)-size.xz));color=mix(u_stroke,u_fill,a);normal=normalize(v_normal);\n#endif\nfloat light=clamp(0.0,1.0,dot(normal,lightDir));color.rgb*=light;gl_FragColor=color;}", i, r) || this;
      return n.name = "Box", n.glStates = new Bt({
        scissor: !1,
        blend: !1,
        depth: !0
      }), n;
    }
    return y(e, t), e;
  }(Wt),
  Jt = function (t) {
    function e(e, i) {
      var r = t.call(this, e, i, {
        SPHERE: !0
      }) || this;
      return r.name = "Sphere", r;
    }
    return y(e, t), e;
  }($t),
  te = function () {
    function t(t, e, i) {
      this.attributes = {}, this.uniforms = {}, this.alpha = 0, this.flat = !0, this.groups = [], this._cullFace = 0, t && (this.addGroup(t, i), this.type = e);
    }
    return t.fromTemplateBuffer = function (e, i) {
      var r,
        n = i.flexAttributes;
      if (i.hasIndex()) {
        var o = i.index();
        if (!o.length) return null;
        r = new t(o, e, i.i32);
      } else r = new t({
        first: i.first,
        count: i.count()
      }, e);
      for (var a in n) {
        var s = n[a];
        s.data.length && r.addAttribute(a, i.trimAttribute(s));
      }
      return r.idOffsets = i.idOffsets, r.rayIntersects = i.rayIntersects, r.cullFace(i.cullFace), r;
    }, t.prototype.createIndex = function (t, e) {
      return {
        index: e ? {
          data: new Uint32Array(t),
          type: 5125,
          length: t.length
        } : {
          data: new Uint16Array(t),
          type: 5123,
          length: t.length
        }
      };
    }, t.prototype.createArrays = function (t) {
      return {
        arrays: t
      };
    }, t.prototype.addGroup = function (t, e, i) {
      if (t) {
        var r = void 0;
        return r = Array.isArray(t) ? this.createIndex(t, e) : this.createArrays(t), i && (r.mode = i), this.groups[this.groups.length] = r;
      }
    }, t.prototype.addUniform = function (t, e) {
      this.uniforms[t] = e;
    }, t.prototype.getUniform = function (t) {
      return this.uniforms[t];
    }, t.prototype.addAttribute = function (t, e) {
      var i = e.data;
      e.type = function (t) {
        return t instanceof Int8Array ? 5120 : t instanceof Uint8Array ? 5121 : t instanceof Int16Array ? 5122 : t instanceof Uint16Array ? 5123 : t instanceof Int32Array ? 5124 : t instanceof Uint32Array ? 5125 : t instanceof Float32Array ? 5126 : void 0;
      }(i), null == e.stride && (e.stride = 0), null == e.dirty && (e.dirty = !0), this.attributes[t] = e, this.size = i.length;
    }, t.prototype.getAttributes = function () {
      return this.attributes;
    }, t.prototype.destroy = function () {}, t.prototype.isPointBuffer = function () {
      var t = this.type;
      return "Line" != t && "Extrude" != t;
    }, t.prototype.isFlat = function () {
      return this.flat;
    }, t.prototype.rayIntersects = function (t, e, i, r, n) {
      return null;
    }, t.prototype.cullFace = function (t) {
      return undefined !== t && (this._cullFace = t), this._cullFace;
    }, t.MODE_GL_LINES = 1, t;
  }();
!function (t) {
  t[t.INSIDE = 0] = "INSIDE", t[t.LEFT = 1] = "LEFT", t[t.RIGHT = 2] = "RIGHT", t[t.BOTTOM = 4] = "BOTTOM", t[t.TOP = 8] = "TOP";
}(Ut || (Ut = {}));
var ee,
  ie = function (t, e, i, r, n, o) {
    var a = Ut.INSIDE;
    return t < i ? a |= Ut.LEFT : t > r && (a |= Ut.RIGHT), e < n ? a |= Ut.BOTTOM : e > o && (a |= Ut.TOP), a;
  },
  re = function (t) {
    var e = t[0],
      i = t[1],
      r = e * e + i * i;
    return r > 0 && (r = 1 / Math.sqrt(r), t[0] = e * r, t[1] = i * r), t;
  },
  ne = function (t, e, i, r, n, o, a, s, l) {
    if (void 0 === l && (l = 1), "round" == t) !1 === r ? a.push(e, i, e, i, e, i) : a.push(e, i, r, e, i, r, e, i, r), n *= Math.SQRT2 * l, o *= Math.SQRT2 * l, s.push(n << 1 | 0, o << 1 | 1, n << 1 | 0, o << 1 | 1, n << 1 | 1, o << 1 | 0, n << 1 | 1, o << 1 | 0, o << 1 | 1, n << 1 | 1, o << 1 | 1, n << 1 | 1);else if ("square" == t) {
      !1 === r ? a.push(e, i, e, i, e, i, e, i, e, i, e, i) : a.push(e, i, r, e, i, r, e, i, r, e, i, r, e, i, r, e, i, r);
      var u = o - n,
        h = n + o;
      s.push(n << 1 | 0, o << 1 | 1, 0, 0, h << 1 | 1, u << 1 | 0, 0, 0, n << 1 | 1, o << 1 | 0, 0, 0, u << 1 | 1, h << 1 | 1, n << 1 | 1, o << 1 | 1, h << 1 | 1, u << 1 | 0, n << 1 | 1, o << 1 | 1, n << 1 | 0, o << 1 | 1, 0, 0);
    }
  },
  oe = function (t, e, i, r, n, o, a, s, l, u, h, f, c, p, d, v, y) {
    void 0 === v && (v = 0), void 0 === y && (y = 0), f *= .5;
    var g = !!a;
    !0 === a && 2 == o && (a = 0);
    var m = s + 16,
      x = -16,
      _ = r[n / o - 1],
      w = v * _,
      b = y * _;
    if ((v || y) && (p = !1), w && b && y < v) {
      var T = w;
      w = b, b = T;
    }
    d && (u = "butt", "none" != h && (h = "miter")), a && (u = "butt", h = "none"), c && (u = "butt", d || (h = "none"));
    for (var L, S, A = ie(i[0], i[1], x, m, x, m), M = null, z = null, I = 0, P = o; P < n; I = P, P += o) {
      var E = i[I],
        C = i[I + 1];
      !0 === a && i[I + 2];
      var k = i[P],
        D = i[P + 1];
      for (!0 === a && i[P + 2], L = S = ie(k, D, x, m, x, m);;) {
        if (!(A | L)) {
          null == M && (M = I), L !== S && (z = P);
          break;
        }
        if (A & L) break;
        var O = A || L,
          F = void 0,
          R = void 0;
        O & Ut.TOP ? (F = E + (k - E) * ((m - C) / (D - C)), R = m) : O & Ut.BOTTOM ? (F = E + (k - E) * ((x - C) / (D - C)), R = x) : O & Ut.RIGHT ? (R = C + (D - C) * ((m - E) / (k - E)), F = m) : O & Ut.LEFT && (R = C + (D - C) * ((x - E) / (k - E)), F = x), O = ie(F, R, x, m, x, m), A ? (A = O, E = F, C = R) : (L = O, k = F, D = R);
      }
      null == M || null == z && P != n - o || (z || (z = n - o), p && (M -= o), ae(t, o, e, i, g, a, r, n, M, z + o, s, u, u, h, f, c, w, b, d, p), M = null, z = null), A = S;
    }
    return t.length;
  },
  ae = function (t, e, i, r, n, o, a, s, l, u, h, f, c, p, d, v, y, g, m, x, _, w) {
    var b,
      T = l;
    l < 0 && (T = s - e + l);
    var L = r[T],
      S = r[T + 1],
      A = !0 === o ? r[T + 2] : o;
    _ && (L = _[0], S = _[1], A = _[2]);
    var M,
      z,
      I,
      P,
      E,
      C,
      k,
      D,
      O,
      F,
      R,
      N,
      B,
      U,
      W,
      G,
      Z,
      X,
      Y,
      H,
      j,
      V,
      q,
      K = a[T / e],
      Q = u,
      $ = null,
      J = null,
      tt = null,
      et = null,
      it = null,
      rt = null;
    if (g && g < K) return K;
    for (var nt = x, ot = l + e; ot < Q; ot += e) {
      var at = !x && ot == Q - e,
        st = null,
        lt = !1,
        ut = void 0,
        ht = void 0;
      at && w ? (P = w[0], E = w[1], C = w[2]) : (P = r[ot], E = r[ot + 1], C = !0 === o ? r[ot + 2] : o), I = p, O = (q = re([k = L - P, D = S - E]))[1], F = q[0], tt = null == tt;
      var ft = K,
        ct = (K = a[ot / e]) - ft;
      if (length = ct, g && g < K && g > ft) {
        var pt = (g - ft) / ct;
        P = L - k * pt, E = S - D * pt, C = A, length *= pt, at = !0, Q = 0;
      }
      if (y) {
        if (!(y < K)) {
          L = P, S = E, A = C;
          continue;
        }
        if (y > ft) {
          var dt = (y - ft) / ct;
          L -= k * dt, S -= D * dt, length *= 1 - dt, tt = !0;
        }
      }
      if (tt && at && (p = "none"), !at) {
        var vt = ot % (s - e) + e,
          yt = r[vt];
        ut = k * (J = E - r[vt + 1]) - D * ($ = P - yt) < 0;
        var gt = [R = (st = re([$, J]))[1] + O, N = -st[0] - F];
        (ht = 1 / (gt[0] * O - gt[1] * F)) == 1 / 0 ? (lt = !0, R = 2, N = 2) : (lt = ht > 3, "miter" == p && lt && (I = "bevel"), ht > 2 ? (R = (b = re(gt))[0], N = b[1], R *= 2, N *= 2) : (R = gt[0] * ht, N = gt[1] * ht)), R *= -8191, N *= -8191;
      }
      if (Y = X = [1 ^ (W = [-(O *= 8191) << 1 | 1, (F *= 8191) << 1 | 1])[0], 1 ^ W[1]], H = X, G = W, Z = W, "none" != p) {
        if (!at && "miter" == I && Q > 2 * e && (H = [R << 1 | 0, N << 1 | 0], Z = [R << 1 | 1, N << 1 | 1]), tt || j || (V ? (G = [B << 1 | 1, U << 1 | 1], "miter" == p && (Y = [B << 1 | 0, U << 1 | 0])) : (Y = [B << 1 | 0, U << 1 | 0], "miter" == p && (G = [B << 1 | 1, U << 1 | 1]))), !lt && !at && "miter" != p) {
          var mt = d * R / -8191,
            xt = d * N / -8191;
          ut && (mt *= -1, xt *= -1);
          var _t = q[0] * mt + q[1] * xt;
          length < _t ? lt = !0 : ut ? Z = [R << 1 | 1, N << 1 | 1] : H = [R << 1 | 0, N << 1 | 0];
        }
        if ((!tt || at) && K) if ("round" == p && (V ? i.push(z[0], z[1], z[0], z[1], Y[0], Y[1], Y[0], Y[1], B << 1 | 0, U << 1 | 0, B << 1 | 0, U << 1 | 0) : i.push(B << 1 | 1, U << 1 | 1, B << 1 | 1, U << 1 | 1, G[0], G[1], G[0], G[1], M[0], M[1], M[0], M[1]), n ? t.push(et, it, rt, et, it, rt, et, it, rt) : t.push(et, it, et, it, et, it)), !tt) if (j) {
          if (!m) {
            var wt,
              bt = 0,
              Tt = 0;
            if ("round" != p) bt = 8191 * (wt = re([R, N]))[0], Tt = 8191 * wt[1];
            bt = bt << 1 | 1, Tt = Tt << 1 | 1, V ? i.push(0, 0, 0, 0, X[0], X[1], bt, Tt, z[0], z[1], bt, Tt) : i.push(0, 0, 0, 0, M[0], M[1], bt, Tt, W[0], W[1], bt, Tt), n ? t.push(et, it, rt, et, it, rt, et, it, rt) : t.push(et, it, et, it, et, it);
          }
        } else if ("miter" != p) (wt = re([B, U]))[0] *= 8191, wt[1] *= 8191, V ? "bevel" == p ? i.push(B << 1 | 1, U << 1 | 1, wt[0] << 1 | 1, wt[1] << 1 | 1, Y[0], Y[1], wt[0] << 1 | 0, wt[1] << 1 | 0, z[0], z[1], wt[0] << 1 | 0, wt[1] << 1 | 0) : i.push(B << 1 | 1, U << 1 | 1, wt[0] << 1 | 1, wt[1] << 1 | 1, Y[0], Y[1], Y[0], Y[1], z[0], z[1], z[0], z[1]) : "bevel" == p ? i.push(G[0], G[1], wt[0] << 1 | 1, wt[1] << 1 | 1, B << 1 | 0, U << 1 | 0, wt[0] << 1 | 0, wt[1] << 1 | 0, M[0], M[1], wt[0] << 1 | 1, wt[1] << 1 | 1) : i.push(G[0], G[1], G[0], G[1], B << 1 | 0, U << 1 | 0, wt[0] << 1 | 0, wt[1] << 1 | 0, M[0], M[1], M[0], M[1]), n ? t.push(et, it, rt, et, it, rt, et, it, rt) : t.push(et, it, et, it, et, it);
      }
      if (!nt && (i.push(G[0], G[1], W[0], W[1], H[0], H[1], X[0], X[1], Y[0], Y[1], X[0], X[1], G[0], G[1], W[0], W[1], Z[0], Z[1], W[0], W[1], H[0], H[1], X[0], X[1]), n ? t.push(L, S, A, P, E, C, L, S, A, L, S, A, P, E, C, P, E, C) : t.push(L, S, P, E, L, S, L, S, P, E, P, E), tt && ne(f, L, S, n && A, O, F, t, i), at && ne(c, P, E, n && C, -O, -F, t, i), v)) {
        var Lt = K - length;
        v.push(Lt, K, Lt, Lt, K, K);
      }
      nt = !1, M = W, z = X, B = R, U = N, et = P, it = E, rt = C, L = P, S = E, A = C, V = ut, j = lt;
    }
  },
  se = function (t, e, i) {
    for (var r; ++e < t.length;) {
      var n = t.charAt(e),
        o = null === (r = i.glyphInfos[n]) || void 0 === r ? void 0 : r.glyph;
      if (o) {
        var a = o.direction;
        if (a) return a;
      }
    }
  },
  le = function (t, e, i, r, n, o, a) {
    var s = a.offset,
      l = a.x,
      u = e.spaceWidth,
      h = e.glyphInfos[t],
      f = 0,
      c = n.data,
      p = null != r,
      d = n.length,
      v = o.data,
      y = o.length,
      g = i >> 5,
      m = 31 & i;
    if (h) {
      var x = h.glyph,
        _ = h.u1 << 5 | m,
        w = h.u2 << 5 | m,
        b = h.v1 << 5 | g,
        T = h.v2 << 5 | g,
        L = x.advanceX,
        S = x.data,
        A = S.width,
        M = S.height,
        z = 32 * l;
      M *= 32, f = z + 32 * A, c[d++] = z, c[d++] = 0, p && (c[d++] = r), c[d++] = f, c[d++] = M, p && (c[d++] = r), c[d++] = z, c[d++] = M, p && (c[d++] = r), c[d++] = f, c[d++] = 0, p && (c[d++] = r), c[d++] = f, c[d++] = M, p && (c[d++] = r), c[d++] = z, c[d++] = 0, p && (c[d++] = r), v[y++] = _, v[y++] = b, v[y++] = w, v[y++] = T, v[y++] = _, v[y++] = T, v[y++] = w, v[y++] = b, v[y++] = w, v[y++] = T, v[y++] = _, v[y++] = b, l += L, s += 12;
    } else " " == t && (l += u);
    n.length = d, o.length = y, a.x = l, a.offset = s, a.x2 = f;
  },
  ue = function (t, e, i, r, n, o, a, s, l, u) {
    for (var h = e, f = i, c = void 0, p = void 0; h < f; h++) {
      if (c = r ? e + (f - 1 - h) : h, p = t.charAt(c), r && V(t.charCodeAt(c))) {
        for (var d = c, v = 0; --d >= 0;) if (!V(t.charCodeAt(d))) {
          for (; ++d <= c;) le(t.charAt(d), n, o, a, s, l, u), v++;
          break;
        }
        if (v) {
          h += v - 1;
          continue;
        }
      }
      le(p, n, o, a, s, l, u);
    }
  },
  he = function (t, e, i, r, n, o) {
    var a;
    void 0 === n && (n = 0);
    var s = t.length;
    i.reserve(18 * s), r.reserve(12 * s), o && (o = 32767 * o / (2 * Math.PI) ^ 0);
    var l,
      u,
      h,
      f = {
        x: 0,
        x2: 0,
        offset: 0
      },
      c = 0;
    n = Math.round(n);
    for (var p = 0; p < s; p++) {
      var d = t.charAt(p),
        v = e.glyphInfos[d],
        y = p == s - 1,
        g = (null === (a = null == v ? void 0 : v.glyph) || void 0 === a ? void 0 : a.direction) || 0;
      if (!l) {
        if (" " == d) continue;
        l = g = g || 1;
      }
      if (void 0 !== u) {
        var m = !0;
        if (!g) {
          var x = se(t, p, e);
          m = x && x != u;
        }
        if (m && g != u) {
          var _ = p - 1;
          " " == h && 1 == g && _--, _++, ue(t, c, _, -1 == u, e, n, o, i, r, f), c = _;
        }
      }
      if (y && c <= p) {
        _ = p + Number(" " != d);
        ue(t, c, _, g ? -1 == g : u != l, e, n, o, i, r, f);
      }
      g && (u = g), h = d;
    }
    var w = f.x2;
    return {
      count: f.offset / 2,
      position: i.data,
      texcoord: r.data,
      width: w / 32 / e.scale
    };
  },
  fe = q.getInstance(),
  ce = function () {
    function t(t, e, i, r) {
      this.x = 0, this.y = 0, this.glyphInfos = {}, this.avgCharWidth = 0, this.glyphs = 0;
      var n = fe.initFont(t, e);
      if (this.style = t, this.letterHeight = n.letterHeight, this.lineHeight = n.letterHeight * e, this.baselineOffset = n.baselineOffset, this.rowHeight = n.rowHeight, this.spaceWidth = n.spaceWidth, this.fontScale = n.fontScale, !i) for (i = 1; i < n.rowHeight;) i *= 2;
      i *= e, this.width = i, this.height = i, this.maxWidth = i, this.maxHeight = i, this.style = t, this.scale = e, this.font = n, r && this.addChars(r);
    }
    return t.prototype.getTextWidth = function (t) {
      return fe.getTextWidth(t, this.font);
    }, t.prototype.placeGlyph = function (t) {
      var e = this.rowHeight;
      if (this.x + t > this.width) {
        var i = this.y + 2 * e;
        i > this.maxHeight ? i > this.height ? (this.height *= 2, this.width *= 2, 0 == this.x ? this.maxWidth = this.maxWidth = this.width : (this.x = this.maxWidth, this.y = 0)) : (this.x = 0, this.y += e, this.maxHeight = this.height, this.maxWidth = this.width) : (this.y += e, this.maxHeight < this.height ? this.x = this.maxWidth : this.x = 0);
      }
    }, t.prototype.addChars = function (t) {
      for (var e = this.glyphInfos, i = this.rowHeight, r = !1, n = 0, o = t; n < o.length; n++) {
        var a = o[n];
        if (" " != a && !e[a]) {
          var s = fe.getGlyph(a, this.font),
            l = a.charCodeAt(0),
            u = s.data.width,
            h = s.width;
          if (l) {
            this.avgCharWidth = (this.avgCharWidth * this.glyphs + h) / ++this.glyphs, r = !0, this.placeGlyph(u);
            var f = this.x,
              c = this.y;
            e[a] = {
              u1: f,
              v1: c,
              u2: f + u,
              v2: c + i,
              glyph: s
            }, this.x += u;
          }
        }
      }
      return r;
    }, t;
  }(),
  pe = function (t) {
    function e(e, i, r) {
      var n = t.call(this, e) || this;
      n.dirty = !1;
      var o = e.dpr;
      return n.atlas = new ce(i, o, r), n.format = e.LUMINANCE_ALPHA, n;
    }
    return y(e, t), e.prototype.addChars = function (t) {
      this.dirty = this.atlas.addChars(t) || this.dirty;
    }, e.prototype.bufferLength = function (t, e) {
      void 0 === e && (e = 2);
      for (var i = 0, r = 0, n = t; r < n.length; r++) {
        " " != n[r] && i++;
      }
      return 6 * i * e;
    }, e.prototype.getAtlas = function () {
      return this.atlas;
    }, e.prototype.sync = function () {
      if (this.dirty) {
        var t = this.atlas;
        this.gl;
        var e = t.glyphInfos;
        for (var i in this.set({
          width: t.width,
          height: t.height
        }), e) {
          var r = e[i];
          this.set(r.glyph.data, r.u1, r.v1);
        }
      }
    }, e.prototype.destroy = function () {
      this.atlas = null, t.prototype.destroy.call(this);
    }, e;
  }(Et),
  de = function () {
    function t(t, e) {
      void 0 === e && (e = !1), this.i32 = !1, this._flat = !0, this._flat = t, this.scissor = e, t || (this.idOffsets = []), this.cullFace = 1028;
    }
    return t.prototype.count = function () {
      var t = this.flexAttributes.a_position;
      return t.data.length / t.size - this.first;
    }, t.prototype.index = function () {
      return this._index = this._index || [];
    }, t.prototype.hasIndex = function () {
      return !!this._index;
    }, t.prototype.isEmpty = function () {
      return 0 == this.count();
    }, t.prototype.trimAttribute = function (t) {
      var e = t;
      return e.data = e.data.trim(), e;
    }, t.prototype.isFlat = function () {
      return this._flat;
    }, t.prototype.finalize = function (t) {
      var e,
        i = this,
        r = i.flexAttributes;
      if (i.hasIndex()) {
        var n = i.index();
        if (!n.length) return null;
        e = new te(n, t, i.i32);
      } else e = new te({
        first: i.first,
        count: i.count()
      }, t);
      for (var o in r) {
        var a = r[o];
        a.data.length && e.addAttribute(o, i.trimAttribute(a));
      }
      return e.idOffsets = i.idOffsets, e;
    }, t.prototype.setIdOffset = function (t) {
      var e;
      null === (e = this.idOffsets) || void 0 === e || e.push(t);
    }, t.prototype.rayIntersects = function (t, e, i, r, n) {
      return null;
    }, t;
  }(),
  ve = function () {
    function t(t, e) {
      void 0 === e && (e = 128), this.length = 0, this.data = new t(this.size = e);
    }
    return t.prototype.get = function (t) {
      return this.data[t];
    }, t.prototype.push = function (t) {
      var e = arguments.length;
      this.reserve(e);
      for (var i = 0; i < e; i++) this.data[this.length++] = arguments[i];
      return this.length;
    }, t.prototype.reserve = function (t) {
      var e = this.data,
        i = t - (this.size - this.length);
      i > 0 && (this.size += Math.max(i, this.size), this.data = new e.constructor(this.size), this.length && this.data.set(e));
    }, t.prototype.trim = function () {
      return this.data = this.data.slice(0, this.length);
    }, t;
  }(),
  ye = "undefined" != typeof Float32Array ? Float32Array : Array;
function ge(t, e, i) {
  return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t;
}
function me(t, e) {
  var i = e[0],
    r = e[1],
    n = e[2],
    o = i * i + r * r + n * n;
  return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o, t;
}
function xe(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
}
function _e(t, e, i) {
  var r = e[0],
    n = e[1],
    o = e[2],
    a = i[0],
    s = i[1],
    l = i[2];
  return t[0] = n * l - o * s, t[1] = o * a - r * l, t[2] = r * s - n * a, t;
}
function we(t, e, i) {
  var r = e[0],
    n = e[1],
    o = e[2],
    a = i[3] * r + i[7] * n + i[11] * o + i[15];
  return a = a || 1, t[0] = (i[0] * r + i[4] * n + i[8] * o + i[12]) / a, t[1] = (i[1] * r + i[5] * n + i[9] * o + i[13]) / a, t[2] = (i[2] * r + i[6] * n + i[10] * o + i[14]) / a, t;
}
Math.hypot || (Math.hypot = function () {
  for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];
  return Math.sqrt(t);
}), ee = new ye(3), ye != Float32Array && (ee[0] = 0, ee[1] = 0, ee[2] = 0);
var be,
  Te = function () {
    function t(t, e) {
      this.sMat = t, this.iSMat = e, this.origin = [0, 0, 0], this.direction = [0, 0, 0], this.sOrigin = [0, 0, 0], this.sDirection = [0, 0, 0], this.pIntersection = [0, 0, 0], this.intersectRayLength = 0;
    }
    return t.rayIntersectsTriangle = function (t, e, i, r, n, o) {
      var a = 1e-7,
        s = ge([0, 0, 0], r, i),
        l = ge([0, 0, 0], n, i),
        u = _e([0, 0, 0], e, l),
        h = xe(s, u);
      if (h > -1e-7 && h < a) return null;
      var f = 1 / h,
        c = ge([0, 0, 0], t, i),
        p = f * xe(c, u);
      if (p < 0 || p > 1) return null;
      var d = _e([0, 0, 0], c, s),
        v = f * xe(e, d);
      if (v < 0 || p + v > 1) return null;
      var y = f * xe(l, d);
      return y > a ? (o && function (t, e, i) {
        t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2];
      }(o, t, function (t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t;
      }(o, e, y)), y) : null;
    }, t.prototype.getInverseScale = function (t) {
      return t ? this.invMapScale : this.invVpScale;
    }, t.prototype.intersectAABBox = function (t, e, i, r, n, o) {
      var a = this.direction[0],
        s = this.direction[1],
        l = this.direction[2],
        u = this.origin[0],
        h = this.origin[1],
        f = this.origin[2],
        c = 1 / a,
        p = 1 / s,
        d = 1 / l,
        v = (t - u) * c,
        y = (r - u) * c,
        g = (e - h) * p,
        m = (n - h) * p,
        x = (i - f) * d,
        _ = (o - f) * d,
        w = Math.min(Math.min(Math.max(v, y), Math.max(g, m)), Math.max(x, _));
      if (w < 0) return null;
      var b = Math.max(Math.max(Math.min(v, y), Math.min(g, m)), Math.min(x, _));
      return b > w ? null : b;
    }, t.prototype.intersectSphere = function (t, e) {
      var i = ge([], t, this.origin),
        r = xe(i, this.direction),
        n = xe(i, i) - r * r,
        o = e * e;
      if (n > o) return null;
      var a = Math.sqrt(o - n),
        s = r - a,
        l = r + a;
      return s < 0 && l < 0 ? null : s < 0 ? l : s;
    }, t.prototype.intersectEllipsoid = function (t, e) {
      var i = ge([], this.origin, t),
        r = this.direction,
        n = e[0] * e[0],
        o = e[1] * e[1],
        a = e[2] * e[2],
        s = r[0] * r[0] / n + r[1] * r[1] / o + r[2] * r[2] / a,
        l = 2 * i[0] * r[0] / n + 2 * i[1] * r[1] / o + 2 * i[2] * r[2] / a,
        u = l * l - 4 * s * (i[0] * i[0] / n + i[1] * i[1] / o + i[2] * i[2] / a - 1);
      if (u < 0) return null;
      var h = (-l + (u = Math.sqrt(u))) / (2 * s),
        f = (-l - u) / (2 * s);
      return h < f ? h : f;
    }, t.prototype.init = function (t, e, i, r, n, o) {
      var a = this,
        s = a.sMat,
        l = a.iSMat,
        u = a.origin,
        h = a.direction,
        f = a.sOrigin,
        c = a.sDirection;
      this.w = i, this.h = r, this.scale = n, this.invMapScale = [1 / n, 1 / n, 1 / n / o], this.invVpScale = [2 / i, 2 / r], this.scaleZ = o, u[0] = t, u[1] = e, u[2] = -1, h[0] = t, h[1] = e, h[2] = 0, we(u, u, l), we(h, h, l), we(c, h, s), we(f, u, s), ge(c, c, f), me(c, c), ge(h, h, u), me(h, h), this.result = {
        id: null,
        z: 1 / 0,
        layerIndex: null
      };
    }, t.prototype.rayLengthScreenToWorld = function (t) {
      var e = this.iSMat,
        i = this.origin[2],
        r = this.direction[2],
        n = t[0],
        o = t[1],
        a = t[2],
        s = e[3] * n + e[7] * o + e[11] * a + e[15];
      return ((a = (e[2] * n + e[6] * o + e[10] * a + e[14]) / (s || 1)) - i) / r;
    }, t.prototype.getIntersectionTop = function () {
      return this.result;
    }, t.prototype.intersect = function (t, e, i, r) {
      if ("Image" != i.type && !1 !== i.pointerEvents) {
        var n = this.result,
          o = i.rayIntersects(i, n, t, e, this);
        null != o && (n.id = o, n.layerIndex = r);
      }
    }, t;
  }(),
  Le = function (t) {
    function e(e) {
      void 0 === e && (e = !0);
      var i = t.call(this, e, !0) || this;
      return e || (i.cullFace = null), i.flexAttributes = {
        a_position: {
          data: new ve(Float32Array),
          size: e ? 2 : 3
        },
        a_normal: {
          data: new ve(Int16Array),
          size: 4
        },
        a_lengthSoFar: {
          data: new ve(Uint16Array),
          size: 1
        }
      }, i.first = 0, i;
    }
    return y(e, t), e.prototype.setIdOffset = function (t) {
      var e;
      null === (e = this.idOffsets) || void 0 === e || e.push(this.flexAttributes.a_position.data.length, t);
    }, e.prototype.rayIntersects = function (t, e, i, r, n) {
      for (var o, a = t.attributes, s = a.a_position.data, l = a.a_normal.data, u = a.a_position.size, h = [0, 0, 0], f = [0, 0, 0], c = [0, 0, 0], p = n.origin, d = n.direction, v = t.getUniform("u_strokeWidth")[0], y = 1 / 8192, g = 0, m = 0; g < s.length; g += u, m += 12) {
        var x = l[m],
          _ = l[m + 1];
        x = (2 * (1 & x) - 1) * (x >> 1) * y, _ = (2 * (1 & _) - 1) * (_ >> 1) * y;
        var w = s[g],
          b = s[g + 1],
          T = 3 == u ? -s[g + 2] : 0;
        g += u;
        var L = l[m + 4],
          S = l[m + 5];
        L = (2 * (1 & L) - 1) * (L >> 1) * y, S = (2 * (1 & S) - 1) * (S >> 1) * y;
        var A = s[g],
          M = s[g + 1],
          z = 3 == u ? -s[g + 2] : 0;
        g += u;
        var I = l[m + 8],
          P = l[m + 9];
        I = (2 * (1 & I) - 1) * (I >> 1) * y, P = (2 * (1 & P) - 1) * (P >> 1) * y;
        var E = s[g],
          C = s[g + 1],
          k = 3 == u ? -s[g + 2] : 0;
        h[0] = i + w + x * v, h[1] = r + b + _ * v, h[2] = T, f[0] = i + A + L * v, f[1] = r + M + S * v, f[2] = z, c[0] = i + E + I * v, c[1] = r + C + P * v, c[2] = k;
        var D = Te.rayIntersectsTriangle(p, d, h, f, c);
        null != D && D <= e.z && (e.z = D, o = g);
      }
      if (null != o) for (var O = 0, F = t.idOffsets, R = F.length; O < R; O += 2) if (o < F[O]) return e.id = F[O + 1];
    }, e;
  }(de);
function Se(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
}
function Ae(t, e) {
  var i = e[0],
    r = e[1],
    n = e[2],
    o = e[3],
    a = e[4],
    s = e[5],
    l = e[6],
    u = e[7],
    h = e[8],
    f = e[9],
    c = e[10],
    p = e[11],
    d = e[12],
    v = e[13],
    y = e[14],
    g = e[15],
    m = i * s - r * a,
    x = i * l - n * a,
    _ = i * u - o * a,
    w = r * l - n * s,
    b = r * u - o * s,
    T = n * u - o * l,
    L = h * v - f * d,
    S = h * y - c * d,
    A = h * g - p * d,
    M = f * y - c * v,
    z = f * g - p * v,
    I = c * g - p * y,
    P = m * I - x * z + _ * M + w * A - b * S + T * L;
  return P ? (P = 1 / P, t[0] = (s * I - l * z + u * M) * P, t[1] = (n * z - r * I - o * M) * P, t[2] = (v * T - y * b + g * w) * P, t[3] = (c * b - f * T - p * w) * P, t[4] = (l * A - a * I - u * S) * P, t[5] = (i * I - n * A + o * S) * P, t[6] = (y * _ - d * T - g * x) * P, t[7] = (h * T - c * _ + p * x) * P, t[8] = (a * z - s * A + u * L) * P, t[9] = (r * A - i * z - o * L) * P, t[10] = (d * b - v * _ + g * m) * P, t[11] = (f * _ - h * b - p * m) * P, t[12] = (s * S - a * M - l * L) * P, t[13] = (i * M - r * S + n * L) * P, t[14] = (v * x - d * w - y * m) * P, t[15] = (h * w - f * x + c * m) * P, t) : null;
}
var Me = function (t, e, i, r, n) {
  var o,
    a = 1 / Math.tan(e / 2);
  return t[0] = a / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != n && n !== 1 / 0 ? (o = 1 / (r - n), t[10] = (n + r) * o, t[14] = 2 * n * r * o) : (t[10] = -1, t[14] = -2 * r), t;
};
var ze = {
    create: function () {
      var t = new ye(16);
      return ye != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
    },
    lookAt: function (t, e, i, r) {
      var n,
        o,
        a,
        s,
        l,
        u,
        h,
        f,
        c,
        p,
        d = e[0],
        v = e[1],
        y = e[2],
        g = r[0],
        m = r[1],
        x = r[2],
        _ = i[0],
        w = i[1],
        b = i[2];
      return Math.abs(d - _) < 1e-6 && Math.abs(v - w) < 1e-6 && Math.abs(y - b) < 1e-6 ? Se(t) : (h = d - _, f = v - w, c = y - b, n = m * (c *= p = 1 / Math.hypot(h, f, c)) - x * (f *= p), o = x * (h *= p) - g * c, a = g * f - m * h, (p = Math.hypot(n, o, a)) ? (n *= p = 1 / p, o *= p, a *= p) : (n = 0, o = 0, a = 0), s = f * a - c * o, l = c * n - h * a, u = h * o - f * n, (p = Math.hypot(s, l, u)) ? (s *= p = 1 / p, l *= p, u *= p) : (s = 0, l = 0, u = 0), t[0] = n, t[1] = s, t[2] = h, t[3] = 0, t[4] = o, t[5] = l, t[6] = f, t[7] = 0, t[8] = a, t[9] = u, t[10] = c, t[11] = 0, t[12] = -(n * d + o * v + a * y), t[13] = -(s * d + l * v + u * y), t[14] = -(h * d + f * v + c * y), t[15] = 1, t);
    },
    multiply: function (t, e, i) {
      var r = e[0],
        n = e[1],
        o = e[2],
        a = e[3],
        s = e[4],
        l = e[5],
        u = e[6],
        h = e[7],
        f = e[8],
        c = e[9],
        p = e[10],
        d = e[11],
        v = e[12],
        y = e[13],
        g = e[14],
        m = e[15],
        x = i[0],
        _ = i[1],
        w = i[2],
        b = i[3];
      return t[0] = x * r + _ * s + w * f + b * v, t[1] = x * n + _ * l + w * c + b * y, t[2] = x * o + _ * u + w * p + b * g, t[3] = x * a + _ * h + w * d + b * m, x = i[4], _ = i[5], w = i[6], b = i[7], t[4] = x * r + _ * s + w * f + b * v, t[5] = x * n + _ * l + w * c + b * y, t[6] = x * o + _ * u + w * p + b * g, t[7] = x * a + _ * h + w * d + b * m, x = i[8], _ = i[9], w = i[10], b = i[11], t[8] = x * r + _ * s + w * f + b * v, t[9] = x * n + _ * l + w * c + b * y, t[10] = x * o + _ * u + w * p + b * g, t[11] = x * a + _ * h + w * d + b * m, x = i[12], _ = i[13], w = i[14], b = i[15], t[12] = x * r + _ * s + w * f + b * v, t[13] = x * n + _ * l + w * c + b * y, t[14] = x * o + _ * u + w * p + b * g, t[15] = x * a + _ * h + w * d + b * m, t;
    },
    perspective: Me,
    rotateX: function (t, e, i) {
      var r = Math.sin(i),
        n = Math.cos(i),
        o = e[4],
        a = e[5],
        s = e[6],
        l = e[7],
        u = e[8],
        h = e[9],
        f = e[10],
        c = e[11];
      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = o * n + u * r, t[5] = a * n + h * r, t[6] = s * n + f * r, t[7] = l * n + c * r, t[8] = u * n - o * r, t[9] = h * n - a * r, t[10] = f * n - s * r, t[11] = c * n - l * r, t;
    },
    rotateZ: function (t, e, i) {
      var r = Math.sin(i),
        n = Math.cos(i),
        o = e[0],
        a = e[1],
        s = e[2],
        l = e[3],
        u = e[4],
        h = e[5],
        f = e[6],
        c = e[7];
      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * n + u * r, t[1] = a * n + h * r, t[2] = s * n + f * r, t[3] = l * n + c * r, t[4] = u * n - o * r, t[5] = h * n - a * r, t[6] = f * n - s * r, t[7] = c * n - l * r, t;
    },
    translate: function (t, e, i) {
      var r,
        n,
        o,
        a,
        s,
        l,
        u,
        h,
        f,
        c,
        p,
        d,
        v = i[0],
        y = i[1],
        g = i[2];
      return e === t ? (t[12] = e[0] * v + e[4] * y + e[8] * g + e[12], t[13] = e[1] * v + e[5] * y + e[9] * g + e[13], t[14] = e[2] * v + e[6] * y + e[10] * g + e[14], t[15] = e[3] * v + e[7] * y + e[11] * g + e[15]) : (r = e[0], n = e[1], o = e[2], a = e[3], s = e[4], l = e[5], u = e[6], h = e[7], f = e[8], c = e[9], p = e[10], d = e[11], t[0] = r, t[1] = n, t[2] = o, t[3] = a, t[4] = s, t[5] = l, t[6] = u, t[7] = h, t[8] = f, t[9] = c, t[10] = p, t[11] = d, t[12] = r * v + s * y + f * g + e[12], t[13] = n * v + l * y + c * g + e[13], t[14] = o * v + u * y + p * g + e[14], t[15] = a * v + h * y + d * g + e[15]), t;
    },
    scale: function (t, e, i) {
      var r = i[0],
        n = i[1],
        o = i[2];
      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * o, t[9] = e[9] * o, t[10] = e[10] * o, t[11] = e[11] * o, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
    },
    clone: function (t) {
      var e = new ye(16);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
    },
    copy: function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
    },
    invert: Ae,
    identity: Se
  },
  Ie = 2 * Math.PI,
  Pe = 2 * Math.atan(1 / 3),
  Ee = function (t, e) {
    return Math.round((t + 1) / 2 * e);
  },
  Ce = {
    font: "bold 14px Arial",
    stroke: "red",
    fill: "white",
    strokeWidth: 3
  },
  ke = function () {
    function t(t) {
      this.gridTextBuf = new WeakMap(), this.tileGrid = !1, this.dbgTile = function (t, e) {
        void 0 === t && (t = [1, 0, 0, 1]), void 0 === e && (e = 2);
        var i = new Le(),
          r = i.flexAttributes;
        oe(r.a_position.data, r.a_normal.data, new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 0, 0]), new Float32Array([0, 1, 2, 3, 4]), 10, 2, 0, 1, 0, "butt", "none", e);
        var n = i.finalize("Line");
        return n.addUniform("u_zIndex", 0), n.addUniform("u_fill", t), n.addUniform("u_strokeWidth", [e, 0]), n.addUniform("u_offset", [0, 0]), n.scissor = !1, n.depth = !1, n;
      }(), this.buffers = new WeakMap(), this.ctxAttr = g({
        alpha: !0,
        antialias: !1,
        depth: !0,
        stencil: !0,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !1
      }, t), this.vPMat = ze.create(), this.vMat = ze.create(), this.invVPMat = ze.create(), this.screenMat = ze.create(), this.invScreenMat = ze.create(), this.worldMatrix = new Float64Array(16), this.tilePreviewTransform = {
        m: ze.create(),
        tx: 0,
        ty: 0,
        s: 0
      };
      var e,
        i,
        r,
        n = (e = 1, i = new te([0, 1, 3, 3, 1, 2], "Polygon"), r = e > 256 ? Int16Array : Int8Array, i.addAttribute("a_position", {
          data: new r([0, 0, e, 0, e, e, 0, e]),
          size: 2
        }), i.addUniform("u_offsetZ", [0, 0]), i.addUniform("u_zIndex", 0), i.addUniform("u_fill", [1, 0, 1, 1]), i.scissor = !0, i.depth = !1, i.alpha = 0, i);
      n.alpha = It.ALPHA, n.blend = !0, this.stencilTile = n;
    }
    return t.prototype.getContext = function () {
      return this.gl;
    }, t.prototype.setPass = function (t) {
      var e = this.gl;
      this.pass = t, this.depthFnc = t != It.OPAQUE ? e.LEQUAL : e.LESS, t == It.POST_ALPHA && e.clear(e.STENCIL_BUFFER_BIT);
    }, t.prototype.convertColor = function (t) {
      return G(t);
    }, t.prototype.setBackgroundColor = function (t) {
      this.gl && this.gl.clearColor(t[0], t[1], t[2], 1);
    }, t.prototype.setScale = function (t, e, i) {}, t.prototype.setRotation = function (t, e) {}, t.prototype.clear = function (t) {
      var e = this.gl;
      t && this.setBackgroundColor(t), e.colorMask(!0, !0, !0, !0), e.disable(e.SCISSOR_TEST), e.depthMask(!0), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT), e.colorMask(!0, !0, !0, !1);
    }, t.prototype.init = function (t, e) {
      this.dpr = e;
      var i = t.getContext("webgl", this.ctxAttr);
      i.dpr = e, i.getExtension("OES_element_index_uint"), this.gl = i, this.initContext(), this.depthBufferSize = 1 << i.getParameter(i.DEPTH_BITS);
      var r = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      for (var n in this.icons = new Ot(i, r - 2), this.programs = {
        Rect: new Gt(i, e),
        Line: new Yt(i, e),
        DashedLine: new Ht(i, e),
        Text: new qt(i, e),
        Image: new Vt(i, e),
        Circle: new Zt(i, e),
        Polygon: new jt(i, e),
        Extrude: new Qt(i, e),
        Icon: new Kt(i, e),
        Box: new $t(i, e),
        Sphere: new Jt(i, e)
      }, this.programs) this.programs[n].setBufferCache(this.buffers);
    }, t.prototype.initContext = function () {
      var t = this.gl;
      t.enable(t.CULL_FACE), t.cullFace(t.FRONT), t.enable(t.DEPTH_TEST), t.enable(t.SCISSOR_TEST), t.clearStencil(0), t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA);
    }, t.prototype.grid = function (t) {
      this.tileGrid = t;
    }, t.prototype.applyTransform = function () {}, t.prototype.initView = function (t, e, i, r, n, o, a, s, l) {
      var u = this.vPMat,
        h = this.vMat,
        f = .5 * Pe,
        c = .5 * t,
        p = .5 * e,
        d = p / Math.tan(f),
        v = Math.cos(f),
        y = Math.sin(f) * d,
        g = Math.max(.01, .5 * Math.PI - f + r),
        m = .1 * d,
        x = v * (v * d + y / Math.tan(g));
      x *= 1.005, this.tilePreviewTransform.tx = null, this.tilePreviewTransform.ty = null, this.tilePreviewTransform.s = null, this.w = t, this.h = e, this.rz = (n + Ie) % Ie, this.rx = r, this.scale = i, this.zMeterToPixel = 1 / o, this.gl.viewport(0, 0, t * this.dpr, e * this.dpr), ze.perspective(u, Pe, t / e, m, x);
      var _ = ze.copy(this.worldMatrix, u);
      ze.scale(_, _, [1, -1, 1]), ze.translate(_, _, [0, 0, -d]), ze.rotateX(_, _, -r), ze.rotateZ(_, _, n), ze.scale(_, _, [l, l, l]), ze.translate(_, _, [-a, -s, 0]), ze.lookAt(h, [c, p, -d], [c, p, 0], [0, -1, 0]), ze.translate(h, h, [c, p, 0]), ze.rotateX(h, h, r), ze.rotateZ(h, h, n), ze.scale(h, h, [i, i, i / o]), ze.translate(h, h, [-c, -p, 0]), ze.multiply(u, u, h), Ae(this.invVPMat, this.vPMat);
      var w = ze.identity(this.screenMat);
      ze.scale(w, w, [c, -p, 1]), ze.translate(w, w, [1, -1, 0]), ze.multiply(w, w, this.vPMat), Ae(this.invScreenMat, w);
    }, t.prototype.initBuffers = function (t) {
      var e = this.gl;
      for (var i in t) {
        var r = t[i],
          n = this.buffers.get(r);
        n || (n = e.createBuffer(), this.buffers.set(r, n)), r.dirty && (r.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, n), e.bufferData(e.ARRAY_BUFFER, r.data, e.STATIC_DRAW));
      }
    }, t.prototype.useProgram = function (t) {
      var e = this.prog;
      if (e != t) {
        var i = this.gl;
        if (e) {
          var r = e.attributes;
          for (var n in r) i.disableVertexAttribArray(r[n]);
        }
        return i.useProgram(t.prog), this.prog = t, !0;
      }
      return !1;
    }, t.prototype.drawGrid = function (t, e, i, r) {
      var n = this.pass;
      this.pass = It.ALPHA, this.drawBuffer(this.dbgTile, t, e, null, null, r);
      var o = this.gridTextBuf.get(i);
      o || (o = function (t, e, i) {
        be || ((be = new pe(e, i)).addChars("L0123456789"), be.sync());
        var r = t + " L" + t.length,
          n = r.length,
          o = new ve(Int16Array, 18 * n),
          a = new ve(Uint16Array, 12 * n),
          s = he(r, be.atlas, o, a),
          l = s.position,
          u = s.count,
          h = s.texcoord,
          f = new te({
            first: 0,
            count: u
          }, "Text");
        return f.addAttribute("a_position", {
          data: new Int8Array(l.length).fill(1),
          size: 2,
          stride: 0
        }), f.addAttribute("a_point", {
          data: l,
          size: 2,
          stride: 0
        }), f.addAttribute("a_texcoord", {
          data: h,
          size: 2,
          stride: 0
        }), f.depth = !1, f.scissor = !1, f.texture = be, f.addUniform("u_texture", 0), f.addUniform("u_atlasScale", 1 / be.width), f.addUniform("u_opacity", 1), f.addUniform("u_alignMap", !0), f.addUniform("u_fillColor", G(i.fill)), f.addUniform("u_strokeColor", G(i.stroke)), f;
      }(i.quadkey, this.gl, Ce), this.gridTextBuf.set(i, o)), this.drawBuffer(o, t + 4, e + 4), this.pass = n;
    }, t.prototype.deleteBuffer = function (t) {
      var e = this.buffers,
        i = this.gl,
        r = t.attributes,
        n = t.texture;
      for (var o in n && n.destroy(), r) {
        var a = r[o],
          s = e.get(a);
        i.deleteBuffer(s);
      }
      for (var l = 0, u = t.groups; l < u.length; l++) {
        var h = u[l].index;
        h && i.deleteBuffer(e.get(h));
      }
    }, t.prototype.initGroundDepth = function (t, e, i) {
      var r = this.gl,
        n = this.stencilTile,
        o = this.programs[n.type];
      o.pass(this.pass);
      var a = n.getAttributes();
      this.initBuffers(a), this.useProgram(o), r.depthRange(0, 1), r.depthMask(!0), r.disable(r.STENCIL_TEST), r.disable(r.SCISSOR_TEST), r.enable(r.DEPTH_TEST), o.initAttributes(a), o.initUniforms(n.uniforms);
      var s = o.uniforms;
      r.uniform2f(s.u_topLeft, t, e), r.uniform1f(s.u_tileScale, i || 1), r.uniformMatrix4fv(s.u_matrix, !1, this.vPMat), r.clear(r.DEPTH_BUFFER_BIT), r.depthFunc(r.ALWAYS), r.colorMask(!1, !1, !1, !1), o.draw(n), r.colorMask(!0, !0, !0, !1), r.depthFunc(this.depthFnc);
    }, t.prototype.drawBuffer = function (t, e, i, r, n, o) {
      var a,
        s,
        l,
        u = this.gl,
        h = this.pass;
      if (s = this.programs[t.type]) {
        var f = s.pass(h);
        n = n || 1;
        var c = this.zIndex,
          p = t.flat && c > this.min3dZIndex,
          d = t.alpha == It.POST_ALPHA && h == It.POST_ALPHA;
        if ((t.alpha || p) && (f = h == It.ALPHA || d), f) {
          if (this.stencilVal && t.alpha) {
            var v = this.stencilVal;
            this.stencilVal = null, this.drawStencil(v);
          }
          a = t.getAttributes(), this.initBuffers(a), this.useProgram(s), u.depthFunc(this.depthFnc);
          var y = (65535 - c) / 65536;
          u.depthRange(t.flat ? y : 0, y), s.init(t, h, Boolean(this.rx || this.rz), c), p && u.disable(this.gl.DEPTH_TEST), s.initAttributes(a), s.initUniforms(t.uniforms), l = s.uniforms, u.uniform1i(l.u_fixedView, this.fixedView), u.uniform1f(l.u_rotate, this.rz), u.uniform2f(l.u_resolution, this.w, this.h), u.uniform1f(l.u_scale, this.scale * n), u.uniform2f(l.u_topLeft, e, i), u.uniform1f(l.u_tileScale, o || 1), u.uniformMatrix4fv(l.u_matrix, !1, r || this.vPMat), u.uniformMatrix4fv(l.u_inverseMatrix, !1, this.invVPMat), u.uniform1f(l.u_zMeterToPixel, this.zMeterToPixel / n), s.draw(t);
        }
      }
    }, t.prototype.initStencil = function (t, e, i, r) {
      this.stencilVal = t, this.stencilSize = r, this.stencilX = e, this.stencilY = i;
    }, t.prototype.drawStencil = function (t) {
      if (this.rx || this.rz) {
        var e = this.gl,
          i = this.stencilTile,
          r = this.stencilX,
          n = this.stencilY;
        e.stencilFunc(e.ALWAYS, t, 255), e.stencilOp(e.REPLACE, e.REPLACE, e.REPLACE), e.colorMask(!1, !1, !1, !1), this.drawBuffer(i, r, n, null, null, this.stencilSize), e.stencilFunc(e.EQUAL, t, 255), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.colorMask(!0, !0, !0, !1);
      }
    }, t.prototype.initScissor = function (t, e, i, r, n) {
      if (t.scissor) {
        var o = this.gl,
          a = o.canvas.width,
          s = o.canvas.height;
        if (this.scale > 4) return o.scissor(0, 0, a, s), this.scissorX = null, !0;
        if (this.scissorX != e || this.scissorY != i || this.scissorSize != r) {
          this.scissorX = e, this.scissorY = i, this.scissorSize = r;
          for (var l = e + r, u = i + n, h = 1 / 0, f = -h, c = h, p = f, d = 0, v = [[e, u, 0], [l, u, 0], [e, i, 0], [l, i, 0]]; d < v.length; d++) {
            var y = v[d];
            y = we([], y, this.vPMat);
            var g = Ee(y[0], a),
              m = Ee(y[1], s);
            g < h && (h = g), g > f && (f = g), m < c && (c = m), m > p && (p = m);
          }
          o.scissor(h, c, f - h, p - c);
        }
        return !0;
      }
    }, t.prototype.draw = function (t, e) {
      var i,
        r,
        n,
        o,
        a,
        s,
        l,
        u,
        h,
        f,
        c,
        p = !1,
        d = !1,
        v = t.data.tile,
        y = v.tile,
        g = v.size,
        m = v.x,
        x = v.y,
        _ = t.b,
        w = t.data.preview;
      if (this.zIndex = t.z, this.min3dZIndex = e, w) {
        var b = t.data.previewTile;
        i = w[0], r = w[1], n = w[2], o = w[3], a = w[5], s = w[6], u = (l = w[7]) / o, h = Math.pow(2, y.quadkey.length - i.length), f = a / u - r, c = s / u - n, this.initScissor(_, m + a, x + s, l, l), h < 1 ? this.initStencil(b.i, m + a, x + s, g * h) : d || (d = !0, this.initStencil(y.i, m, x, g));
        var T = this.initPreviewMatrix(m, x, u);
        this.drawBuffer(_, f, c, T, h);
      } else p || (p = this.initScissor(_, m, x, g, g)), d || (this.initStencil(y.i, m, x, g), d = !0), this.drawBuffer(_, m, x);
    }, t.prototype.initPreviewMatrix = function (t, e, i) {
      var r = this.tilePreviewTransform,
        n = this.vPMat,
        o = r.m;
      return r.tx == t && r.ty == e && r.s == i || (ze.copy(o, n), ze.translate(o, o, [t, e, 0]), ze.scale(o, o, [i, i, 1]), r.tx = t, r.ty = e, r.s = i), o;
    }, t.prototype.destroy = function () {
      this.icons.destroy();
    }, t.prototype.prepare = function (t, e, i, r, n, o) {}, t.prototype.drawCustom = function (t, e) {
      var i,
        r = this,
        n = r.gl;
      r.prog = null;
      var o = (65535 - e) / 65536,
        a = "3d" == t.renderOptions.mode ? 0 : o;
      n.depthRange(a, o), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), t.render(n, r.worldMatrix), null === (i = n.getExtension("OES_vertex_array_object")) || void 0 === i || i.bindVertexArrayOES(null), n.bindFramebuffer(n.FRAMEBUFFER, null), this.initContext();
    }, t;
  }(),
  De = function () {
    function t() {
      this.r = [], this.p = [];
    }
    return t.prototype.init = function (t, e) {
      this.luTs = null, this.quadkey = t, this.layers = e, this.tasks = {}, this.r.length = 0, this.p.length = 0;
    }, t.prototype.busy = function (t) {
      var e = t.id;
      for (var i in this.tasks) if (e == this.tasks[i]._lid) return !0;
    }, t.prototype.addTask = function (t, e) {
      t._lid = e.id, this.tasks[t.id] = t;
    }, t.prototype.cancelTasks = function (t) {
      var e,
        i = this.tasks;
      for (var r in i) e = i[r], t && t.id != e._lid || (e.cancel(), delete i[r]);
    }, t.prototype.removeTask = function (t, e) {
      delete this.tasks[t.id];
    }, t.prototype.index = function (t) {
      return this.layers.indexOf(t);
    }, t.prototype.ready = function (t, e) {
      return 2 == arguments.length && (this.r[t] = e, e && (this.luTs = Date.now())), this.r[t];
    }, t.prototype.addLayer = function (t) {
      this.r.splice(t, 0, !1), this.p.splice(t, 0, undefined);
    }, t.prototype.removeLayer = function (t) {
      this.r.splice(t, 1), this.p.splice(t, 1);
    }, t.prototype.preview = function (t, e) {
      return 2 == arguments.length && (this.p[t] = e), this.p[t];
    }, t;
  }(),
  Oe = function (t) {
    function e(e, i, r) {
      var n = t.call(this) || this;
      return n.data = [], n.onDrop = r, n.init(e, i), n;
    }
    return y(e, t), e.prototype.clear = function (t) {
      this.setData(t, undefined), this.ready(t, !1), this.preview(t, !1);
    }, e.prototype.init = function (e, i) {
      t.prototype.init.call(this, e, i), this.data.length = 0;
    }, e.prototype.setData = function (t, e) {
      var i = "number" == typeof t ? t : this.layers.indexOf(t),
        r = this.data[i];
      return r && r.length && this.onDrop && this.onDrop(r, i), this.data[i] = e, i;
    }, e.prototype.getData = function (t) {
      return this.data[t];
    }, e.prototype.addLayer = function (e) {
      t.prototype.addLayer.call(this, e), this.data.splice(e, 0, undefined);
    }, e.prototype.removeLayer = function (e) {
      t.prototype.removeLayer.call(this, e), this.setData(e, undefined), this.preview(e, undefined), this.data.splice(e, 1);
    }, e;
  }(De),
  Fe = function () {
    function t(t) {
      this.tiles = new _xyzMapsCommon.LRU(t);
    }
    return t.prototype.setSize = function (t) {
      this.tiles.setSize(t);
    }, t.prototype.get = function (t, e) {
      if (e) {
        var i = this.tiles._[t];
        return i && i.data;
      }
      return this.tiles.get(t);
    }, t.prototype.forEach = function (t) {
      return this.tiles.forEach(t);
    }, t;
  }(),
  Re = function (t) {
    function e(e) {
      return t.call(this, e) || this;
    }
    return y(e, t), e.prototype.create = function (t, e) {
      var i,
        r,
        n = this.tiles,
        o = this.onDrop,
        a = n.get(t);
      if (!a && (a = new Oe(t, e, o), (i = n.set(t, a)) && (r = i.data))) {
        for (var s = 0; s < r.length; s++) i.setData(s, null), i.preview(s, null);
        i.data = null;
      }
      return a;
    }, e;
  }(Fe),
  Ne = _xyzMapsCommon.geometry.centroid,
  Be = _xyzMapsCommon.TaskManager.getInstance(),
  Ue = Math.PI / 180,
  We = new Float32Array([-1, -1, -1, -1]),
  Ge = function (t, e, i, r, n, o, a) {
    void 0 === a && (a = 0);
    for (var s = t.z, l = !0, u = 0, h = r; u < h.length; u++) {
      var f = h[u],
        c = f.type,
        p = rt("type", f, e, s);
      if ("Polygon" == p || "Line" == p) {
        if (rt("stroke", f, e, s)) {
          f.type = "Line";
          for (var d = 0, v = i; d < v.length; d++) {
            var y = v[d];
            l = l && t.create(e, "LineString", y, [f], n, o.clipped);
          }
          f.type = c;
        }
      } else if (0 == a) {
        var g = o.bounds,
          m = e.bbox,
          x = void 0;
        if ("Centroid" == rt("anchor", f, e, s)) {
          var _ = e.geometry;
          x = _._c = _._c || Ne("Polygon" == _.type ? _.coordinates : _.coordinates[0]);
        } else x = [m[0] + (m[2] - m[0]) / 2, m[1] + (m[3] - m[1]) / 2];
        var w = x[0],
          b = x[1];
        w >= g[0] && b >= g[1] && w < g[2] && b < g[3] && (l = l && t.create(e, "Point", x, [f], n));
      }
    }
    return l;
  },
  Ze = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1],
  Xe = function (t, e, i, r) {
    var n = r.length,
      o = t = 32 * t << 2 | 1,
      a = e = 32 * e << 2 | 1,
      s = 2 | t,
      l = a,
      u = o,
      h = 2 | e,
      f = s,
      c = h;
    return "number" == typeof i ? (i = Math.round(i / 9e3 * 65535), r.push(o, a, i, u, h, i, f, c, i, o, a, i, f, c, i, s, l, i), n += 18) : (r.push(o, a, u, h, f, c, o, a, f, c, s, l), n += 12), n;
  },
  Ye = function (t, e, i, r, n) {
    for (var o = "number" == typeof n, a = t.length, s = [], l = 0, u = 0; u < e.length; u++) {
      for (var h = 0, f = void 0, c = void 0; h < e[u].length; h++) f = i.lon2x(e[u][h][0], r), c = i.lat2y(e[u][h][1], r), o ? t.push(f, c, n) : t.push(f, c);
      u > 0 && (l += e[u - 1].length, s[s.length] = l);
    }
    return {
      dimensions: o ? 3 : 2,
      vertices: t,
      holes: s,
      start: a,
      stop: t.length
    };
  },
  He = function (t, e, i, r, n) {
    var o;
    if ("number" != typeof e[0][0][0]) {
      o = [];
      for (var a = 0, s = e; a < s.length; a++) {
        var l = s[a];
        o.push(Ye(t, l, i, r, n));
      }
    } else o = [Ye(t, e, i, r, n)];
    return o;
  },
  je = function (t, e, i) {
    for (var r = 0, n = e, o = i - 1; n < o; n += 3) {
      var a = t[n],
        s = t[n + 1];
      r += (t[n + 3] - a) * (s + t[n + 4]);
    }
    return r;
  },
  Ve = function (t, e, i, r, n, o, a, s) {
    var l = t.holes,
      u = t.vertices,
      h = t.stop - 3,
      f = t.start,
      c = 0,
      p = f + 3 * l[c] - 6,
      d = je(e.data, f, p ? p + 3 : h) >= 0;
    for (a = a || 0; f < h;) {
      var v = void 0,
        y = void 0,
        g = void 0,
        m = void 0;
      if (d) {
        var x = t.start + h - f;
        v = u.get(x), g = u.get(x + 1), y = u.get(x - 3), m = u.get(x - 2);
      } else v = u.get(f), g = u.get(f + 1), y = u.get(f + 3), m = u.get(f + 4);
      var _ = Math.round(v) - Math.round(y),
        w = Math.round(g) - Math.round(m);
      if ((_ || w) && (Y(v, g, 0, 0, n, n) || Y(y, m, 0, 0, n, n))) {
        var b = e.length / 3;
        r[r.length] = b + 2, r[r.length] = b, r[r.length] = b + 1, r[r.length] = b + 3, r[r.length] = b + 2, r[r.length] = b + 1, null == s || s.push(b, b + 1, b + 2, b + 3, b, b + 2, b + 1, b + 3), e.push(v, g, o, v, g, a, y, m, o, y, m, a);
        var T = _ * _ + w * w,
          L = w,
          S = -_;
        L *= T = 127 / Math.sqrt(T), S *= T, i.push(L, S, L, S, L, S, L, S);
      }
      f == p ? (f += 6, p = t.start + 3 * l[++c] - 6, d = je(e.data, f, p ? p + 3 : h) < 0) : f += 3;
    }
  },
  qe = function (t, e, i, r, n, o, a, s, l) {
    for (var u = t.length, h = He(t, r, n, o, a); u < t.length;) e.push(0, 0), u += 3;
    if (a) for (var f = 0, c = h; f < c.length; f++) {
      var p = c[f];
      Ve(p, t, e, i, o, a, s, l);
    }
    return h;
  },
  Ke = {
    exports: {}
  };
function Qe(t, e, i) {
  i = i || 2;
  var r,
    n,
    o,
    a,
    s,
    l,
    u,
    h = e && e.length,
    f = h ? e[0] * i : t.length,
    c = $e(t, 0, f, i, !0),
    p = [];
  if (!c || c.next === c.prev) return p;
  if (h && (c = function (t, e, i, r) {
    var n,
      o,
      a,
      s = [];
    for (n = 0, o = e.length; n < o; n++) (a = $e(t, e[n] * r, n < o - 1 ? e[n + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0), s.push(ui(a));
    for (s.sort(oi), n = 0; n < s.length; n++) i = ai(s[n], i);
    return i;
  }(t, e, c, i)), t.length > 80 * i) {
    r = o = t[0], n = a = t[1];
    for (var d = i; d < f; d += i) (s = t[d]) < r && (r = s), (l = t[d + 1]) < n && (n = l), s > o && (o = s), l > a && (a = l);
    u = 0 !== (u = Math.max(o - r, a - n)) ? 32767 / u : 0;
  }
  return ti(c, p, i, r, n, u, 0), p;
}
function $e(t, e, i, r, n) {
  var o, a;
  if (n === bi(t, e, i, r) > 0) for (o = e; o < i; o += r) a = xi(o, t[o], t[o + 1], a);else for (o = i - r; o >= e; o -= r) a = xi(o, t[o], t[o + 1], a);
  return a && pi(a, a.next) && (_i(a), a = a.next), a;
}
function Je(t, e) {
  if (!t) return t;
  e || (e = t);
  var i,
    r = t;
  do {
    if (i = !1, r.steiner || !pi(r, r.next) && 0 !== ci(r.prev, r, r.next)) r = r.next;else {
      if (_i(r), (r = e = r.prev) === r.next) break;
      i = !0;
    }
  } while (i || r !== e);
  return e;
}
function ti(t, e, i, r, n, o, a) {
  if (t) {
    !a && o && function (t, e, i, r) {
      var n = t;
      do {
        0 === n.z && (n.z = li(n.x, n.y, e, i, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
      } while (n !== t);
      n.prevZ.nextZ = null, n.prevZ = null, function (t) {
        var e,
          i,
          r,
          n,
          o,
          a,
          s,
          l,
          u = 1;
        do {
          for (i = t, t = null, o = null, a = 0; i;) {
            for (a++, r = i, s = 0, e = 0; e < u && (s++, r = r.nextZ); e++);
            for (l = u; s > 0 || l > 0 && r;) 0 !== s && (0 === l || !r || i.z <= r.z) ? (n = i, i = i.nextZ, s--) : (n = r, r = r.nextZ, l--), o ? o.nextZ = n : t = n, n.prevZ = o, o = n;
            i = r;
          }
          o.nextZ = null, u *= 2;
        } while (a > 1);
      }(n);
    }(t, r, n, o);
    for (var s, l, u = t; t.prev !== t.next;) if (s = t.prev, l = t.next, o ? ii(t, r, n, o) : ei(t)) e.push(s.i / i | 0), e.push(t.i / i | 0), e.push(l.i / i | 0), _i(t), t = l.next, u = l.next;else if ((t = l) === u) {
      a ? 1 === a ? ti(t = ri(Je(t), e, i), e, i, r, n, o, 2) : 2 === a && ni(t, e, i, r, n, o) : ti(Je(t), e, i, r, n, o, 1);
      break;
    }
  }
}
function ei(t) {
  var e = t.prev,
    i = t,
    r = t.next;
  if (ci(e, i, r) >= 0) return !1;
  for (var n = e.x, o = i.x, a = r.x, s = e.y, l = i.y, u = r.y, h = n < o ? n < a ? n : a : o < a ? o : a, f = s < l ? s < u ? s : u : l < u ? l : u, c = n > o ? n > a ? n : a : o > a ? o : a, p = s > l ? s > u ? s : u : l > u ? l : u, d = r.next; d !== e;) {
    if (d.x >= h && d.x <= c && d.y >= f && d.y <= p && hi(n, s, o, l, a, u, d.x, d.y) && ci(d.prev, d, d.next) >= 0) return !1;
    d = d.next;
  }
  return !0;
}
function ii(t, e, i, r) {
  var n = t.prev,
    o = t,
    a = t.next;
  if (ci(n, o, a) >= 0) return !1;
  for (var s = n.x, l = o.x, u = a.x, h = n.y, f = o.y, c = a.y, p = s < l ? s < u ? s : u : l < u ? l : u, d = h < f ? h < c ? h : c : f < c ? f : c, v = s > l ? s > u ? s : u : l > u ? l : u, y = h > f ? h > c ? h : c : f > c ? f : c, g = li(p, d, e, i, r), m = li(v, y, e, i, r), x = t.prevZ, _ = t.nextZ; x && x.z >= g && _ && _.z <= m;) {
    if (x.x >= p && x.x <= v && x.y >= d && x.y <= y && x !== n && x !== a && hi(s, h, l, f, u, c, x.x, x.y) && ci(x.prev, x, x.next) >= 0) return !1;
    if (x = x.prevZ, _.x >= p && _.x <= v && _.y >= d && _.y <= y && _ !== n && _ !== a && hi(s, h, l, f, u, c, _.x, _.y) && ci(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  for (; x && x.z >= g;) {
    if (x.x >= p && x.x <= v && x.y >= d && x.y <= y && x !== n && x !== a && hi(s, h, l, f, u, c, x.x, x.y) && ci(x.prev, x, x.next) >= 0) return !1;
    x = x.prevZ;
  }
  for (; _ && _.z <= m;) {
    if (_.x >= p && _.x <= v && _.y >= d && _.y <= y && _ !== n && _ !== a && hi(s, h, l, f, u, c, _.x, _.y) && ci(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  return !0;
}
function ri(t, e, i) {
  var r = t;
  do {
    var n = r.prev,
      o = r.next.next;
    !pi(n, o) && di(n, r, r.next, o) && gi(n, o) && gi(o, n) && (e.push(n.i / i | 0), e.push(r.i / i | 0), e.push(o.i / i | 0), _i(r), _i(r.next), r = t = o), r = r.next;
  } while (r !== t);
  return Je(r);
}
function ni(t, e, i, r, n, o) {
  var a = t;
  do {
    for (var s = a.next.next; s !== a.prev;) {
      if (a.i !== s.i && fi(a, s)) {
        var l = mi(a, s);
        return a = Je(a, a.next), l = Je(l, l.next), ti(a, e, i, r, n, o, 0), void ti(l, e, i, r, n, o, 0);
      }
      s = s.next;
    }
    a = a.next;
  } while (a !== t);
}
function oi(t, e) {
  return t.x - e.x;
}
function ai(t, e) {
  var i = function (t, e) {
    var i,
      r = e,
      n = t.x,
      o = t.y,
      a = -1 / 0;
    do {
      if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
        var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
        if (s <= n && s > a && (a = s, i = r.x < r.next.x ? r : r.next, s === n)) return i;
      }
      r = r.next;
    } while (r !== e);
    if (!i) return null;
    var l,
      u = i,
      h = i.x,
      f = i.y,
      c = 1 / 0;
    r = i;
    do {
      n >= r.x && r.x >= h && n !== r.x && hi(o < f ? n : a, o, h, f, o < f ? a : n, o, r.x, r.y) && (l = Math.abs(o - r.y) / (n - r.x), gi(r, t) && (l < c || l === c && (r.x > i.x || r.x === i.x && si(i, r))) && (i = r, c = l)), r = r.next;
    } while (r !== u);
    return i;
  }(t, e);
  if (!i) return e;
  var r = mi(i, t);
  return Je(r, r.next), Je(i, i.next);
}
function si(t, e) {
  return ci(t.prev, t, e.prev) < 0 && ci(e.next, t, t.next) < 0;
}
function li(t, e, i, r, n) {
  return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * n | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
}
function ui(t) {
  var e = t,
    i = t;
  do {
    (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
  } while (e !== t);
  return i;
}
function hi(t, e, i, r, n, o, a, s) {
  return (n - a) * (e - s) >= (t - a) * (o - s) && (t - a) * (r - s) >= (i - a) * (e - s) && (i - a) * (o - s) >= (n - a) * (r - s);
}
function fi(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
    var i = t;
    do {
      if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && di(i, i.next, t, e)) return !0;
      i = i.next;
    } while (i !== t);
    return !1;
  }(t, e) && (gi(t, e) && gi(e, t) && function (t, e) {
    var i = t,
      r = !1,
      n = (t.x + e.x) / 2,
      o = (t.y + e.y) / 2;
    do {
      i.y > o != i.next.y > o && i.next.y !== i.y && n < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (r = !r), i = i.next;
    } while (i !== t);
    return r;
  }(t, e) && (ci(t.prev, t, e.prev) || ci(t, e.prev, e)) || pi(t, e) && ci(t.prev, t, t.next) > 0 && ci(e.prev, e, e.next) > 0);
}
function ci(t, e, i) {
  return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
}
function pi(t, e) {
  return t.x === e.x && t.y === e.y;
}
function di(t, e, i, r) {
  var n = yi(ci(t, e, i)),
    o = yi(ci(t, e, r)),
    a = yi(ci(i, r, t)),
    s = yi(ci(i, r, e));
  return n !== o && a !== s || !(0 !== n || !vi(t, i, e)) || !(0 !== o || !vi(t, r, e)) || !(0 !== a || !vi(i, t, r)) || !(0 !== s || !vi(i, e, r));
}
function vi(t, e, i) {
  return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y);
}
function yi(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function gi(t, e) {
  return ci(t.prev, t, t.next) < 0 ? ci(t, e, t.next) >= 0 && ci(t, t.prev, e) >= 0 : ci(t, e, t.prev) < 0 || ci(t, t.next, e) < 0;
}
function mi(t, e) {
  var i = new wi(t.i, t.x, t.y),
    r = new wi(e.i, e.x, e.y),
    n = t.next,
    o = e.prev;
  return t.next = e, e.prev = t, i.next = n, n.prev = i, r.next = i, i.prev = r, o.next = r, r.prev = o, r;
}
function xi(t, e, i, r) {
  var n = new wi(t, e, i);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function _i(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function wi(t, e, i) {
  this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function bi(t, e, i, r) {
  for (var n = 0, o = e, a = i - r; o < i; o += r) n += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
  return n;
}
Ke.exports = Qe, Ke.exports.default = Qe, Qe.deviation = function (t, e, i, r) {
  var n = e && e.length,
    o = n ? e[0] * i : t.length,
    a = Math.abs(bi(t, 0, o, i));
  if (n) for (var s = 0, l = e.length; s < l; s++) {
    var u = e[s] * i,
      h = s < l - 1 ? e[s + 1] * i : t.length;
    a -= Math.abs(bi(t, u, h, i));
  }
  var f = 0;
  for (s = 0; s < r.length; s += 3) {
    var c = r[s] * i,
      p = r[s + 1] * i,
      d = r[s + 2] * i;
    f += Math.abs((t[c] - t[d]) * (t[p + 1] - t[c + 1]) - (t[c] - t[p]) * (t[d + 1] - t[c + 1]));
  }
  return 0 === a && 0 === f ? 0 : Math.abs((f - a) / a);
}, Qe.flatten = function (t) {
  for (var e = t[0][0].length, i = {
      vertices: [],
      holes: [],
      dimensions: e
    }, r = 0, n = 0; n < t.length; n++) {
    for (var o = 0; o < t[n].length; o++) for (var a = 0; a < e; a++) i.vertices.push(t[n][o][a]);
    n > 0 && (r += t[n - 1].length, i.holes.push(r));
  }
  return i;
};
var Ti,
  Li = function () {
    function t(t) {
      this.data = {}, this.gl = t;
    }
    return t.prototype.create = function (t) {
      var e = t.reduce(function (t, e) {
        return t + e;
      }) * (t.length % 2 + 1);
      e *= Math.ceil(512 / e);
      for (var i = new Uint8Array(e), r = !0, n = 0; n < e;) for (var o = 0, a = t; o < a.length; o++) {
        var s = a[o];
        r && i.fill(255, n, n + s), n += s, r = !r;
      }
      return new Ct(this.gl, {
        width: i.length,
        height: 1,
        pixels: i
      }, this.gl.LUMINANCE);
    }, t.prototype.get = function (t) {
      var e = String(t),
        i = this.data[e];
      return i || (i = this.data[e] = this.create(t)), i;
    }, t;
  }(),
  Si = function () {
    function t(t) {
      void 0 === t && (t = 256), this.length = 0, this.points = [], this.sqDistance = this.setMinDistance(t);
    }
    return t.prototype.setMinDistance = function (t) {
      return this.sqDistance = t * t;
    }, t.prototype.add = function (t, e) {
      var i = this.points;
      i[this.length++] = t, i[this.length++] = e;
    }, t.prototype.clear = function () {
      this.length = 0, this.points.length = 0;
    }, t.prototype.hasSpace = function (t, e) {
      var i = this,
        r = i.length,
        n = i.points,
        o = i.sqDistance,
        a = 0;
      if (o) for (; a < r;) {
        var s = t - n[a++],
          l = e - n[a++];
        if (s * s + l * l < o) return !1;
      }
      return !0;
    }, t;
  }(),
  Ai = 180 / Math.PI,
  Mi = function () {
    function t(t) {
      this.length = 0, this.dashes = new Li(t), this.gl = t, this.pixels = new Float32Array(262144), this.alpha = new Float32Array(131072), this.lineLength = new Float32Array(131072), this.repeat = {};
    }
    return t.prototype.getDistanceGrp = function () {
      return this.repeat[this.dId];
    }, t.prototype.projectLine = function (t, e, i) {
      var r = this.pixels,
        n = this.decimals;
      if (!this.length) {
        for (var o = 0, a = "number" == typeof t[0][2] ? 3 : 2, s = 3 === a, l = 0, u = t.length, h = void 0, f = void 0, c = void 0, p = void 0, d = void 0, v = void 0; l < u; l++) {
          var y = t[l];
          if (h = e.lon2x(y[0], i), f = e.lat2y(y[1], i), c = y[2] || 0, (!l || Math.round(p * n) - Math.round(h * n) || Math.round(d * n) - Math.round(f * n) || s && c != v) && (r[o++] = h, r[o++] = f, s && (r[o++] = c), o > a)) {
            var g = p - h,
              m = d - f;
            this.lineLength[l] = this.lineLength[l - 1] + Math.sqrt(g * g + m * m);
          }
          p = h, d = f, v = c;
        }
        this.length = o, this.dimensions = a;
      }
      return this.length;
    }, t.prototype.placeCached = function (t, e, i, r) {
      for (var n = this.collisions, o = 0, a = void 0; o < n.length; o++) {
        var s = (a = n[o]).cx,
          l = a.cy,
          u = a.cz;
        256 == i && (s -= e.x % 2 * i, l -= e.y % 2 * i), t(s, l, u, r ? this.alpha[o] : 0, 0, a);
      }
    }, t.prototype.initTile = function () {
      var t = this.repeat;
      for (var e in t) t[e].clear();
    }, t.prototype.initFeature = function (t, e, i) {
      this.decimals = t >= 20 - Number(512 == e) ? 100 : 1, this.length = 0, this.collisions = null;
      var r = this.repeat;
      this.dId = i, i && !r[i] && (r[i] = new Si());
    }, t.prototype.createLine = function (t, e, i, r, n, o, a, s, l, u, h, f, c) {
      o && (e.texture = this.dashes.get(o)), e.buffer || (e.buffer = new Le(!u));
      var p = e.buffer;
      this.projectLine(t, i, r);
      var d = this,
        v = d.pixels,
        y = d.length,
        g = d.dimensions,
        m = y - g,
        x = v[0] == v[m] && v[1] == v[m + 1];
      return oe(p.flexAttributes.a_position.data, p.flexAttributes.a_normal.data, v, this.lineLength, y, g, u, r, 0, a, s, l, o && p.flexAttributes.a_lengthSoFar.data, x, h, f, c);
    }, t.prototype.placeAtSegments = function (t, e, i, r, n, o, a, s, l, u, h, f, c, p) {
      var d;
      this.projectLine(t, i, r), null === (d = this.getDistanceGrp()) || void 0 === d || d.setMinDistance(null == a ? 256 : a), this.placeAlongLine(i, r, n, o, s, l, u, h, f, c, e, p);
    }, t.prototype.getAbsOffset = function (t) {
      if ("string" == typeof t && t.endsWith("px")) return parseFloat(t);
      var e = this,
        i = e.length,
        r = e.dimensions;
      return t * e.lineLength[i / r - 1];
    }, t.prototype.placeAtPoints = function (t, e, i, r, n, o, a, s, l, u, h, f, c) {
      void 0 === h && (h = 0), void 0 === f && (f = 1), this.projectLine(t, i, r);
      var p = this,
        d = p.length,
        v = p.dimensions,
        y = p.lineLength,
        g = y[d / v - 1],
        m = h * g,
        x = f * g;
      if (this.collisions) return this.placeCached(c, i, r);
      for (var _, w = n && [], b = "number" == typeof e ? e : null, T = 0, L = 0, S = this.pixels; L < d; L += v) {
        var A = S[L],
          M = S[L + 1],
          z = !0 === e ? S[L + 2] : b,
          I = L / v;
        if (_ = T, T = y[I + 1], m) {
          if (!(m < T)) continue;
          var P = (m - _) / (T - _),
            E = L + v,
            C = S[E],
            k = S[E + 1],
            D = !0 === e ? S[E + 2] : b;
          A += (C - A) * P, M += (k - M) * P, null != z && (z += (D - z) * P), m == x && (d = null, x = null), m = null;
        }
        if (x && x && _ > x) {
          var O = (x - _) / (_ - y[I - 1]),
            F = L - v,
            R = S[F],
            N = S[F + 1],
            B = !0 === e ? S[F + 2] : b;
          A -= (R - A) * O, M -= (N - M) * O, null != z && (z -= (B - z) * O), d = null;
        }
        var U = void 0;
        if (A >= 0 && M >= 0 && A < r && M < r) {
          var W = void 0;
          w && ((W = this.getDistanceGrp()) && !W.hasSpace(A, M) || (U = n.insert(A, M, z, l, u, a, s, i, r, o)) && w.push(U)), w && !U || (c(A, M, z, 0, 0, U), null == W || W.add(A, M));
        }
      }
      (null == w ? void 0 : w.length) && (this.collisions = w);
    }, t.prototype.placeAlongLine = function (t, e, i, r, n, o, a, s, l, u, h, f) {
      if (this.collisions) return this.placeCached(f, t, e, l);
      var c,
        p,
        d,
        v,
        y,
        g,
        m,
        x,
        _,
        w = this.dimensions,
        b = i && [],
        T = this.length / w,
        L = this.pixels,
        S = Math.pow(2 * n + a, 2),
        A = Math.floor(T / 2) - 1,
        M = 1,
        z = L[A * w],
        I = L[A * w + 1],
        P = 1 == h,
        E = 0;
      P ? _ = L[A * w + 2] : x = "number" == typeof h ? h : null;
      for (var C = z, k = I, D = 1; D < T; D++) {
        var O = A + M * D;
        if (O >= T && (M = -1, O = A - 1, A = T - 1, z = C, I = k), c = L[O * w], p = L[O * w + 1], d = L[O * w + 2], m = .5 * (y = p - I) + I, (g = .5 * (v = c - z) + z) >= 0 && m >= 0 && g < e && m < e) {
          var F = u ? v * v + y * y : 1 / 0;
          if (F > S) {
            if (P) {
              var R = d - _;
              x = _ + .5 * (d - _), E = Math.asin(R / Math.sqrt(v * v + y * y + R * R));
            }
            var N = Math.atan2(y, v);
            -1 == M && (N += Math.PI);
            var B = void 0,
              U = void 0;
            if (b && (!(U = this.getDistanceGrp()) || U.hasSpace(g, m))) {
              var W = n,
                G = o;
              if (l && N && (W || G)) {
                var Z = Math.sin(N),
                  X = Math.cos(N);
                W = X * n - Z * o, G = Z * n + X * o;
              }
              var Y = Math.sqrt(S / F),
                H = [v * Y, y * Y];
              (B = i.insert(g, m, x, W, G, a / 2, s / 2, t, e, r, H)) && (this.alpha[b.length] = N * Ai, b.push(B));
            }
            b && !B || (f(g, m, x, l ? N * Ai : 0, E, B), null == U || U.add(g, m));
          }
        }
        z = c, I = p, _ = d;
      }
      (null == b ? void 0 : b.length) && (this.collisions = b);
    }, t;
  }(),
  zi = function (t) {
    function e(e, i) {
      void 0 === e && (e = !0);
      var r = t.call(this, e) || this;
      return r.flexAttributes = {
        a_position: {
          data: new ve(Uint16Array),
          size: e ? 2 : 3
        },
        a_point: {
          data: new ve(Int16Array),
          size: i ? 3 : 2
        },
        a_texcoord: {
          data: new ve(Uint16Array),
          size: 2
        }
      }, r.first = 0, r;
    }
    return y(e, t), e;
  }(de),
  Ii = function (t) {
    return 9e3 * t / 65535;
  },
  Pi = function (t, e, i) {
    return e > 0 ? t * e * i : t;
  },
  Ei = function (t, e, i) {
    var r = t.getUniform("u_offset"),
      n = Pi(r[0], r[1], e),
      o = Pi(r[2], r[3], e),
      a = t.getUniform("u_offsetZ");
    return [n, o, Pi(a[0], a[1], e)];
  },
  Ci = function (t) {
    function e(e) {
      void 0 === e && (e = !0);
      var i = t.call(this, e) || this;
      return i.flexAttributes = {
        a_position: {
          data: new ve(Uint16Array),
          size: e ? 2 : 3
        }
      }, i.first = 0, i;
    }
    return y(e, t), e.prototype.rayIntersects = function (t, e, i, r, n) {
      var o,
        a,
        s,
        l = t.type,
        u = t.attributes,
        h = t.getUniform("u_alignMap"),
        f = n.scale,
        c = n.scaleZ,
        p = h ? 1 / n.scale : 1,
        d = Ei(t, f),
        v = d[0],
        y = d[1],
        g = d[2];
      if (g = -g / c / f, "Rect" === l) {
        var m = t.getUniform("u_size"),
          x = t.getUniform("u_strokeWidth") || 0;
        a = .5 * (m[0] + x), s = .5 * (m[2] + x);
      } else "Circle" == l && (a = s = t.getUniform("u_radius")[0]);
      a *= p, s *= p;
      var _,
        w,
        b,
        T = u.a_position.data,
        L = u.a_position.size,
        S = [0, 0, 0],
        A = [0, 0, 0],
        M = [0, 0, 0],
        z = null;
      h ? (_ = n.origin, w = n.direction, v /= f, y /= f) : b = [0, 0, 0];
      for (var I = 0, P = 0; I < T.length; I += L, P += 6) {
        var E = (2 & T[I]) - 1,
          C = i + (T[I] >> 2) / 32,
          k = (2 & T[I + 1]) - 1,
          D = r + (T[I + 1] >> 2) / 32,
          O = 3 == L ? -Ii(T[I + 2]) : 0,
          F = (2 & T[I += L]) - 1,
          R = i + (T[I] >> 2) / 32,
          N = (2 & T[I + 1]) - 1,
          B = r + (T[I + 1] >> 2) / 32,
          U = 3 == L ? -Ii(T[I + 2]) : 0,
          W = (2 & T[I += L]) - 1,
          G = i + (T[I] >> 2) / 32,
          Z = (2 & T[I + 1]) - 1,
          X = r + (T[I + 1] >> 2) / 32,
          Y = 3 == L ? -Ii(T[I + 2]) : 0;
        if ("Icon" === l) {
          var H = null === (o = u.a_size) || void 0 === o ? void 0 : o.data;
          a = .5 * H[P] * p, s = .5 * H[P + 1] * p;
        }
        h ? (S[0] = C + E * a + v, S[1] = D - k * s + y, S[2] = O + g, A[0] = R + F * a + v, A[1] = B - N * s + y, A[2] = U + g, M[0] = G + W * a + v, M[1] = X - Z * s + y, M[2] = Y + g) : (S[0] = C, S[1] = D, S[2] = O + g, we(S, S, n.sMat), S[0] += v, S[1] += y, A[0] = S[0] + F * a, A[1] = S[1] - N * s, A[2] = S[2], M[0] = S[0] + W * a, M[1] = S[1] - Z * s, M[2] = S[2], S[0] += E * a, S[1] -= k * s, _ = n.sOrigin, w = n.sDirection);
        var j = Te.rayIntersectsTriangle(_, w, S, A, M, b);
        j && (h || (j = n.rayLengthScreenToWorld(b)), j < e.z && (e.z = j, z = I));
      }
      if (null != z) return t.idOffsets[Math.floor(z / 18)];
    }, e;
  }(de),
  ki = function (t) {
    function e(e) {
      void 0 === e && (e = !0);
      var i = t.call(this, e) || this;
      return i.flexAttributes = {
        a_position: {
          data: new ve(Uint16Array),
          size: e ? 2 : 3
        },
        a_size: {
          data: new ve(Uint8Array),
          size: 2
        },
        a_texcoord: {
          data: new ve(Uint16Array),
          size: 2
        }
      }, i.first = 0, i;
    }
    return y(e, t), e;
  }(Ci),
  Di = function (t) {
    function e(e) {
      void 0 === e && (e = !0);
      var i = t.call(this, e, !0) || this;
      return i.flexAttributes = {
        a_position: {
          data: new ve(Float32Array),
          size: e ? 2 : 3
        }
      }, i.first = 0, i;
    }
    return y(e, t), e.prototype.setIdOffset = function (t) {
      var e;
      null === (e = this.idOffsets) || void 0 === e || e.push(this.flexAttributes.a_position.data.length, t);
    }, e.prototype.rayIntersects = function (t, e, i, r, n) {
      for (var o, a = t.attributes, s = a.a_position.data, l = a.a_position.size, u = n.origin, h = n.direction, f = [0, 0, 0], c = [0, 0, 0], p = [0, 0, 0], d = null, v = 0, y = t.groups; v < y.length; v++) {
        var g = y[v],
          m = null === (o = g.index) || void 0 === o ? void 0 : o.data,
          x = null;
        if (g.mode != te.MODE_GL_LINES) {
          for (var _ = 0; _ < m.length; _ += 3) {
            var w = m[_] * l,
              b = m[_ + 1] * l,
              T = m[_ + 2] * l;
            f[0] = i + s[w], f[1] = r + s[w + 1], f[2] = 3 == l ? -s[w + 2] : 0, c[0] = i + s[b], c[1] = r + s[b + 1], c[2] = 3 == l ? -s[b + 2] : 0, p[0] = i + s[T], p[1] = r + s[T + 1], p[2] = 3 == l ? -s[T + 2] : 0;
            var L = Te.rayIntersectsTriangle(u, h, f, c, p);
            L && L < e.z && (x = w, e.z = L);
          }
          if (null != x) {
            _ = 0;
            for (var S = t.idOffsets, A = S.length; _ < A; _ += 2) if (x < S[_]) {
              d = S[_ + 1];
              break;
            }
          }
        }
      }
      return d;
    }, e;
  }(de),
  Oi = function (t) {
    function e() {
      var e = t.call(this, !1) || this;
      return e.flexAttributes.a_normal = {
        data: new ve(Int8Array),
        size: 2,
        normalized: !0
      }, e;
    }
    return y(e, t), e;
  }(Di),
  Fi = new Map();
[[Ti, Ti, Ti], [Ti, Ti, 65154], [Ti, Ti, 65156], [Ti, Ti, 65158], [Ti, Ti, 65160], [65163, 65164, 65162], [Ti, Ti, 65166], [65169, 65170, 65168], [Ti, Ti, 65172], [65175, 65176, 65174], [65179, 65180, 65178], [65183, 65184, 65182], [65187, 65188, 65186], [65191, 65192, 65190], [Ti, Ti, 65194], [Ti, Ti, 65196], [Ti, Ti, 65198], [Ti, Ti, 65200], [65203, 65204, 65202], [65207, 65208, 65206], [65211, 65212, 65210], [65215, 65216, 65214], [65219, 65220, 65218], [65223, 65224, 65222], [65227, 65228, 65226], [65231, 65232, 65230], Ti, Ti, Ti, Ti, Ti, [1600, 1600, 1600], [65235, 65236, 65234], [65239, 65240, 65238], [65243, 65244, 65242], [65247, 65248, 65246], [65251, 65252, 65250], [65255, 65256, 65254], [65259, 65260, 65258], [Ti, Ti, 65262], [Ti, Ti, 65264], [65267, 65268, 65266]].forEach(function (t, e) {
  Fi.set(1569 + e, t && {
    initial: t[0],
    medial: t[1],
    final: t[2]
  });
}), Fi.set(1662, {
  initial: 64344,
  medial: 64345,
  final: 64343
}), Fi.set(1740, {
  initial: 64510,
  medial: 64511,
  final: 64509
}), Fi.set(1670, {
  initial: 64380,
  medial: 64381,
  final: 64379
}), Fi.set(1705, {
  initial: 64400,
  medial: 64401,
  final: 64399
}), Fi.set(1711, {
  initial: 64404,
  medial: 64405,
  final: 64403
}), Fi.set(1688, {
  final: 64395
});
var Ri,
  Ni = new Set([1552, 1554, 1555, 1556, 1557, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1648, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1759, 1760, 1761, 1762, 1763, 1764, 1767, 1768, 1770, 1771, 1772, 1773]),
  Bi = {
    1570: {
      isolated: 65269,
      final: 65270
    },
    1571: {
      isolated: 65271,
      final: 65272
    },
    1573: {
      isolated: 65273,
      final: 65274
    },
    1575: {
      isolated: 65275,
      final: 65276
    }
  },
  Ui = function (t, e, i) {
    for (var r = i > 0 ? t.length - e : e + 1, n = 1, o = void 0; n < r; n++) if (o = t.charCodeAt(e + i * n), !Ni.has(o)) return {
      cp: o,
      map: Fi.get(o)
    };
  },
  Wi = function (t) {
    var e;
    if (!function (t) {
      return /[\u0600-\u06FF]/.test(t);
    }(t)) return t;
    for (var i = "", r = 0; r < t.length; ++r) {
      var n = t.charCodeAt(r);
      if (Fi.has(n)) {
        var o = null === (e = Ui(t, r, -1)) || void 0 === e ? void 0 : e.map;
        !o || o.initial || o.medial || (o = Ti);
        var a = Ui(t, r, 1),
          s = null == a ? void 0 : a.map;
        !s || s.medial || s.final || (s = Ti);
        var l;
        if (l = 1604 == n && Bi[null == a ? void 0 : a.cp]) n = o ? l.final : l.isolated, r++;else {
          var u = Fi.get(n);
          o && s && u.medial ? n = u.medial : o && u.final ? n = u.final : s && u.initial && (n = u.initial);
        }
      }
      i += String.fromCharCode(n);
    }
    return i;
  },
  Gi = function (t, e, i, r) {
    if (r) {
      t.buffer || (t.buffer = new Di(!1), t.isVerticalLine = !0);
      var n = t.buffer.flexAttributes.a_position.data;
      return n.push(e, i, 0, e, i, r), n.length;
    }
  },
  Zi = function (t) {
    function e(e) {
      var i = t.call(this, !1) || this;
      return i.flexAttributes.a_point = {
        data: new ve(Uint8Array),
        size: 3
      }, i.flexAttributes.a_normal = {
        data: new ve(Int8Array),
        normalized: !0,
        size: 3
      }, i;
    }
    return y(e, t), e.prototype.rayIntersects = function (t, e, i, r, n) {
      var o = t.attributes,
        a = o.a_position.data,
        s = o.a_position.size,
        l = o.a_point.data,
        u = n.getInverseScale(!0),
        h = u[0],
        f = u[1],
        c = u[2],
        p = null,
        d = 6 * s * 6,
        v = Ei(t, n.scale),
        y = v[0],
        g = v[1],
        m = v[2];
      y *= h, g *= f, m *= c;
      for (var x = 0, _ = a.length; x < _; x += d) {
        var w = i + .03125 * a[x] + y,
          b = r + .03125 * a[x + 1] + g,
          T = (3 == s ? -Ii(a[x + 2]) : 0) - m,
          L = (l[x] >> 1) * h,
          S = (l[x + 1] >> 1) * f,
          A = (l[x + 2] >> 1) * c,
          M = n.intersectAABBox(w - L, b - S, T - A, w + L, b + S, T + A);
        null != M && M < e.z && (e.z = M, p = x);
      }
      if (null != p) return t.idOffsets[Math.floor(p / d)];
    }, e;
  }(Ci),
  Xi = function (t, e, i) {
    var r = e[0] - t[0],
      n = e[1] - t[1],
      o = e[2] - t[2],
      a = i[0] - t[0],
      s = i[1] - t[1],
      l = i[2] - t[2];
    return [Math.floor(127 * (n * l - o * s)), Math.floor(127 * (o * a - r * l)), Math.floor(127 * (r * s - n * a))];
  },
  Yi = function (t, e, i, r, n, o, a) {
    Ri = Ri || function (t, e, i, r, n, o, a) {
      void 0 === t && (t = 8), void 0 === e && (e = 6), void 0 === i && (i = 0), void 0 === r && (r = 2 * Math.PI), void 0 === n && (n = 0), void 0 === o && (o = Math.PI), void 0 === a && (a = 1);
      for (var s = Math.min(n + o, Math.PI), l = [], u = [], h = [], f = 0, c = 0; c <= e; c++) {
        for (var p = [], d = c / e, v = 0; v <= t; v++) {
          var y = v / t,
            g = Math.sin(n + d * o);
          h.push(-Math.cos(i + y * r) * g * a, Math.cos(n + d * o) * a, -Math.sin(i + y * r) * g * a), p.push(f++);
        }
        l.push(p);
      }
      var m = [];
      for (c = 0; c < e; c++) for (v = 0; v < t; v++) {
        var x = l[c][v + 1],
          _ = l[c][v],
          w = l[c + 1][v],
          b = l[c + 1][v + 1];
        if (0 !== c || n > 0) {
          u.push(x, _, b);
          var T = h.slice(3 * x, 3 * x + 3),
            L = h.slice(3 * _, 3 * _ + 3),
            S = h.slice(3 * b, 3 * b + 3),
            A = Xi(T, L, S);
          m.push.apply(m, A), m.push.apply(m, A), m.push.apply(m, A);
        }
        if (c !== e - 1 || s < Math.PI) {
          u.push(_, w, b), L = h.slice(3 * _, 3 * _ + 3);
          var M = h.slice(3 * w, 3 * w + 3);
          S = h.slice(3 * b, 3 * b + 3), A = Xi(L, M, S), m.push.apply(m, A), m.push.apply(m, A), m.push.apply(m, A);
        }
      }
      for (var z = [], I = 0, P = u; I < P.length; I++) {
        var E = P[I];
        z.push(127 + Math.floor(127 * h[3 * E]), 127 + Math.floor(127 * h[3 * E + 1]), 127 + Math.floor(127 * h[3 * E + 2]));
      }
      return {
        normals: z,
        surfaceNormals: m
      };
    }(16, 12), t *= 32, e *= 32, i = Math.round(i / 9e3 * 65535);
    for (var s = Ri.normals, l = Ri.surfaceNormals, u = 0; u < s.length; u += 3) n.push(t, e, i), o.push(s[u], s[u + 1], s[u + 2]), null == a || a.push(l[u], l[u + 1], l[u + 2]);
  },
  Hi = function (t) {
    function e(e) {
      var i = t.call(this, !1) || this;
      return i.cullFace = 1029, i.flexAttributes.a_point = {
        normalized: !0,
        data: new ve(Uint8Array),
        size: 3
      }, i;
    }
    return y(e, t), e.prototype.rayIntersects = function (t, e, i, r, n) {
      var o = t.attributes,
        a = o.a_position.data,
        s = o.a_position.size,
        l = n.getInverseScale(!0),
        u = l[0],
        h = l[1],
        f = l[2],
        c = t.uniforms.u_radius[0],
        p = [c * u, c * h, c * f],
        d = Ei(t, n.scale),
        v = d[0],
        y = d[1],
        g = d[2];
      v *= u, y *= h, g *= f;
      for (var m = null, x = 1056 * s, _ = [0, 0, 0], w = 0, b = a.length; w < b; w += x) {
        _[0] = i + .03125 * a[w] + v, _[1] = r + .03125 * a[w + 1] + y, _[2] = (3 == s ? -Ii(a[w + 2]) : 0) - g;
        var T = n.intersectEllipsoid(_, p);
        null != T && T < e.z && (e.z = T, m = w);
      }
      if (null != m) return t.idOffsets[Math.floor(m / x)];
    }, e;
  }(Zi),
  ji = function () {
    function t(t, e, i, r) {
      this.pendingCollisions = [], this.gl = t, this.icons = e, this.dpr = r, this.dashes = new Li(t), this.collisions = i, this.lineFactory = new Mi(t);
    }
    return t.prototype.init = function (t, e, i, r) {
      this.tile = t, this.groups = e, this.tileSize = i, this.z = r, this.lineFactory.initTile(), this.pendingCollisions.length = 0;
    }, t.prototype.createPoint = function (t, e, i, r, n, o, a, s, l, u, h, f) {
      void 0 === l && (l = 0);
      var c,
        p,
        d,
        v = null === n,
        y = this.z;
      if (l = (l + 360) % 360, "Text" == t) {
        e.texture || (e.texture = new pe(this.gl, e.shared), e.buffer = new zi(v, null != u));
        var g = e.texture,
          m = e.buffer.flexAttributes;
        g.addChars(h);
        var x = g.getAtlas(),
          _ = rt("lineWrap", o, a, y);
        null == _ && (_ = f);
        var w = N(h, _);
        d = (p = (c = m.a_position).data.length) + g.bufferLength(h, v ? 2 : 3), function (t, e, i, r, n, o, a, s, l, u) {
          void 0 === l && (l = 0);
          var h = r.length,
            f = s.lineHeight,
            c = 32 * (s.baselineOffset + (h - 1) * f * .5);
          t = 64 * t << 1 | 1, e = 64 * e << 1 | 1, l = Math.round(1024 * l / 360);
          var p = null !== i,
            d = 2,
            v = null == u ? 2 : 3;
          p && (i = Math.round(i / 9e3 * 65535), d = 3);
          for (var y = o.length / d, g = 0, m = r; g < m.length; g++) {
            var x = m[g],
              _ = he(x, s, n, a, l, u),
              w = _.width * s.scale / 2 * 32,
              b = _.count * d;
            o.reserve(b);
            for (var T = n.data, L = o.data, S = y + b / d; y < S; y++) T[y * v] -= w, T[y * v + 1] -= c, L[y * d] = t, L[y * d + 1] = e, p && (L[y * d + 2] = i);
            o.length += b, c -= 32 * f;
          }
        }(i, r, n, w, m.a_point.data, m.a_position.data, m.a_texcoord.data, x, l, u);
      } else {
        if ("Icon" == t) {
          e.buffer || (e.buffer = new ki(v));
          m = e.buffer.flexAttributes;
          var b = rt("src", o, a, y),
            T = rt("width", o, a, y),
            L = rt("height", o, a, y) || T,
            S = this.icons.get(b, T, L);
          if (!S) return void (this.iconsLoaded = !1);
          c = m.a_position, function (t, e, i, r, n, o, a, s, l, u) {
            void 0 === u && (u = 0);
            var h = r.u1,
              f = r.u2,
              c = r.v1,
              p = r.v2;
            Xe(t, e, i, s);
            var d = (u = Math.round(1024 * u / 360)) >> 5,
              v = 31 & u;
            h = h << 5 | v, f = f << 5 | v, c = c << 5 | d, p = p << 5 | d, a.push(n, o, n, o, n, o, n, o, n, o, n, o), l.push(h, p, h, c, f, c, h, p, f, c, f, p);
          }(i, r, n, S, T, L, m.a_size.data, c.data, m.a_texcoord.data, l), e.texture = this.icons.getTexture();
        } else if ("Circle" == t || "Rect" == t) e.buffer || (e.buffer = new Ci(v)), c = e.buffer.flexAttributes.a_position, Xe(i, r, n, c.data);else if ("Sphere" == t) {
          T = 2 * rt("radius", o, a, y);
          e.buffer || (e.buffer = new Hi(v)), c = e.buffer.flexAttributes.a_position, Yi(i, r, n, 0, c.data, e.buffer.flexAttributes.a_point.data, e.buffer.flexAttributes.a_normal.data);
        } else {
          if ("Box" != t) return void (n > 0 && "VerticalLine" == t && Gi(e, i, r, n));
          T = rt("width", o, a, y), L = rt("height", o, a, y) || T;
          var A = rt("depth", o, a, y) || T;
          e.buffer || (e.buffer = new Zi(v)), function (t, e, i, r, n, o, a, s, l) {
            t *= 32, e *= 32, "number" == typeof i ? (i = Math.round(i / 9e3 * 65535), a.push(t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i, t, e, i)) : a.push(t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e, t, e), s.push(0 | r, 1 | n, 1 | o, 1 | r, 1 | n, 1 | o, 0 | r, 1 | n, 0 | o, 0 | r, 1 | n, 0 | o, 1 | r, 1 | n, 1 | o, 1 | r, 1 | n, 0 | o, 0 | r, 0 | n, 0 | o, 1 | r, 0 | n, 1 | o, 0 | r, 0 | n, 1 | o, 1 | r, 0 | n, 0 | o, 1 | r, 0 | n, 1 | o, 0 | r, 0 | n, 0 | o, 0 | r, 1 | n, 0 | o, 0 | r, 0 | n, 0 | o, 0 | r, 1 | n, 1 | o, 0 | r, 0 | n, 0 | o, 0 | r, 0 | n, 1 | o, 0 | r, 1 | n, 1 | o, 1 | r, 1 | n, 0 | o, 1 | r, 1 | n, 1 | o, 1 | r, 0 | n, 0 | o, 1 | r, 0 | n, 0 | o, 1 | r, 1 | n, 1 | o, 1 | r, 0 | n, 1 | o, 0 | r, 0 | n, 1 | o, 1 | r, 1 | n, 1 | o, 0 | r, 1 | n, 1 | o, 0 | r, 0 | n, 1 | o, 1 | r, 0 | n, 1 | o, 1 | r, 1 | n, 1 | o, 0 | r, 0 | n, 0 | o, 1 | r, 1 | n, 0 | o, 0 | r, 1 | n, 0 | o, 0 | r, 0 | n, 0 | o, 1 | r, 0 | n, 0 | o, 1 | r, 1 | n, 0 | o), l && l.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1);
          }(i, r, n, T, L, A, (c = e.buffer.flexAttributes.a_position).data, e.buffer.flexAttributes.a_point.data, e.buffer.flexAttributes.a_normal.data);
        }
        p = (d = c.data.length) - 12;
      }
      e.buffer.setIdOffset(a.id), s && c && s.attrs.push({
        buffer: c,
        start: p,
        stop: d
      });
    }, t.prototype.create = function (t, e, i, r, n, o, a, s) {
      var l,
        u,
        h,
        f,
        c,
        p,
        d,
        v,
        y,
        g,
        m,
        x,
        _,
        w,
        b,
        T,
        L,
        S,
        A,
        M,
        z,
        I,
        P,
        E,
        C,
        D,
        O,
        F,
        R,
        N,
        B,
        U,
        W,
        Z,
        X,
        Y,
        H,
        j,
        V,
        q,
        K,
        Q,
        $,
        J = this,
        tt = this,
        et = tt.tile,
        ot = tt.groups,
        at = tt.tileSize,
        st = this.z,
        lt = Number.MAX_SAFE_INTEGER,
        ht = -Number.MAX_SAFE_INTEGER,
        ft = "";
      if (this.iconsLoaded = !0, this.lineFactory.initFeature(st, at, null == s ? void 0 : s.id), undefined === a && "Point" === e && !et.isInside(i)) return this.iconsLoaded;
      for (var ct = 0, pt = r.length; ct < pt; ct++) if (m = r[ct], (_ = rt("type", m, t, st)) && 0 !== (w = rt("opacity", m, t, st))) {
        var dt = "Polygon" == e || rt("collide", m, t, st);
        if (null != a || ("Text" != _ || dt) && !1 !== dt) {
          (null == w || w >= .98) && (w = 1), "Image" == _ && (_ = "Icon"), b = undefined, T = undefined, A = undefined, L = undefined, M = undefined, z = undefined, I = undefined, P = undefined, E = undefined, O = undefined, F = undefined, W = 0, Z = 0, Y = undefined, j = undefined, H = n, V = "px", q = undefined;
          var vt = !0,
            yt = !1;
          S = 0 ^ rt("rotation", m, t, st);
          var gt = rt("altitude", m, t, st);
          if ("Icon" == _) N = (gt ? "AI" : "I") + ((j = rt("alignment", m, t, st) || "viewport") || ""), yt = !0;else {
            if (A = rt("stroke", m, t, st), z = rt("strokeWidth", m, t, st), "VerticalLine" == _) N = "VL" + A + (X = rt("offsetZ", m, t, st) || 0), null == gt && (gt = !0);else if ("Line" == _) {
              if (!A || !z) continue;
              var mt = nt(z);
              z = mt[0], V = mt[1], P = rt("strokeLinecap", m, t, st) || "round", E = rt("strokeLinejoin", m, t, st) || "round", (I = rt("strokeDasharray", m, t, st)) instanceof Array && I.length && I[0] || (I = undefined);
              var xt = rt("offset", m, t, st);
              N = (gt ? "AL" : "L") + V + (W = (l = nt(xt))[0]) + (q = l[1]) + P + E + (I || "*");
            } else if (T = rt("fill", m, t, st), "Polygon" == _) {
              if (!T || "Polygon" != e) continue;
              C = rt("extrude", m, t, st), D = rt("extrudeBase", m, t, st), "number" == typeof C || D ? (N = "E", _ = "Extrude") : N = "P";
            } else {
              if ("Polygon" == e) continue;
              if (j = rt("alignment", m, t, st), "Text" == _) {
                if (!(Y = it(m, t, st))) continue;
                Y = Wi(Y), null == j && (j = "Point" == e ? "viewport" : "map"), N = "T" + ((b = rt("font", m, t, st) || k) || "*");
              } else if ("Circle" == _) O = F = rt("radius", m, t, st), O = (u = nt(O))[0], N = (gt ? "AC" : "C") + (V = u[1]) + O || "*";else if ("Rect" == _) O = rt("width", m, t, st), O = (h = nt(O))[0], V = h[1], F = (F = rt("height", m, t, st)) ? nt(F)[0] : O, N = (gt ? "AR" : "R") + S + V + O + F;else if ("Box" == _) vt = rt("pointerEvents", m, t, st), N = "B" + S + vt;else {
                if ("Sphere" != _) continue;
                O = F = rt("radius", m, t, st), O = (f = nt(O))[0], V = f[1], N = "S" + O + (vt = rt("pointerEvents", m, t, st));
              }
              yt = !0, N += j || "";
            }
            T && ((L = G(T)) ? L[3] *= w : T = null), A && ((M = G(A)) ? M[3] *= w : A = null, "Text" == _ && (H = 1), ("number" != typeof z || (z *= H) < 0) && (z = 1)), N += (A || "*") + (z || "*") + (T || "*");
          }
          yt && (W = rt("offsetX", m, t, st), Z = rt("offsetY", m, t, st), X = rt("offsetZ", m, t, st), q = new Array(3), W = (c = nt(W))[0], q[0] = c[1], Z = (p = nt(Z))[0], q[1] = p[1], X = (d = nt(X))[0], q[2] = d[1], N += W + (Z << 8) + (X << 16) + q[0] + q[1] + q[2]), N += 100 * w ^ 0, x = rt("zIndex", m, t, st);
          var _t = rt("zLayer", m, t, st);
          null != _t && (N = _t + ":" + N);
          var wt = void 0;
          if (gt && ((wt = rt("depthTest", m, t, st)) || (N = "ND" + N)), null == (U = (R = ot[x] = ot[x] || {
            index: {},
            groups: []
          }).index[N]) ? (U = R.index[N] = R.groups.length, B = R.groups[U] = {
            type: _,
            zLayer: _t,
            depthTest: wt,
            pointerEvents: vt,
            shared: {
              unit: V,
              font: b,
              fill: L,
              opacity: w,
              stroke: M,
              strokeWidth: z,
              strokeLinecap: P,
              strokeLinejoin: E,
              strokeDasharray: I,
              width: O,
              height: F,
              depth: void 0,
              rotation: S,
              offsetX: W,
              offsetY: Z,
              offsetZ: X,
              offsetUnit: q,
              alignment: j
            }
          }) : B = R.groups[U], "Point" == e) {
            if ("VerticalLine" == _) {
              if ("number" == typeof gt || i[2] > 0) if ((Lt = "number" == typeof gt ? gt : i[2]) > 0) {
                var bt = et.lon2x(i[0], at),
                  Tt = et.lat2y(i[1], at);
                Gi(B, bt, Tt, Lt);
              }
            } else {
              bt = et.lon2x(i[0], at), Tt = et.lat2y(i[1], at);
              var Lt = "number" == typeof gt ? gt : gt ? i[2] || 0 : null;
              if (s) {
                if (!($ = this.collisions.insert(bt, Tt, Lt, s.offsetX, s.offsetY, s.width, s.height, et, at, s.priority))) return this.iconsLoaded;
                s = null;
              }
              this.createPoint(_, B, bt, Tt, Lt, m, t, $, S, void 0, Y);
            }
          } else if ("LineString" == e) {
            if ("Line" == _) this.lineFactory.createLine(i, B, et, at, o, I, P, E, z, gt, W, rt("from", m, t, st), rt("to", m, t, st)), B.buffer.setIdOffset(t.id);else {
              var St = rt("anchor", m, t, st);
              null == St && (St = "Text" == _ ? "Line" : "Coordinate");
              var At = "Text" == _ ? !dt : !1 === dt,
                Mt = void 0,
                zt = void 0;
              if ("Line" == St) {
                var It = "map" == j;
                if (s) Mt = 2 * s.width, zt = 2 * s.height;else if ("Icon" == _) Mt = rt("width", m, t, st), zt = rt("height", m, t, st) || O;else if ("Text" == _) {
                  var Pt = B.texture;
                  Pt || (Pt = B.texture = new pe(this.gl, m), B.buffer = new zi(!0, !0));
                  var Et = Pt.getAtlas();
                  Mt = Et.getTextWidth(Y), zt = Et.letterHeight;
                } else Mt = O, zt = F, "Circle" == _ && (Mt *= 2, zt *= 2);
                var Ct = rt("checkLineSpace", m, t, st);
                null == Ct && (Ct = !0), this.lineFactory.placeAtSegments(i, gt, et, at, At && this.collisions, a, rt("repeat", m, t, st), W, Z, Mt, zt, It, Ct, function (e, i, r, n, o, a) {
                  J.createPoint(_, B, e, i, r, m, t, a, n + S, o, Y, !1);
                });
              } else s ? (Mt = s.width, zt = s.height) : (Mt = O / 2, zt = F / 2), this.lineFactory.placeAtPoints(i, gt, et, at, At && this.collisions, a, Mt, zt, W, Z, rt("from", m, t, st), rt("to", m, t, st), function (e, i, r, n, o, a) {
                J.createPoint(_, B, e, i, r, m, t, a, n + S, undefined, Y);
              });
            }
          } else if ("Polygon" == _ || "Extrude" == _) {
            B.buffer || (B.buffer = "Polygon" == _ ? new Di() : new Oi());
            var kt = B.buffer,
              Dt = kt.index(),
              Ot = kt.flexAttributes,
              Ft = Ot.a_position.data;
            if (v = Ft.length, "Extrude" == _) {
              var Rt = void 0;
              A && (Rt = B.extrudeStrokeIndex = B.extrudeStrokeIndex || []), y = qe(Ft, Ot.a_normal.data, Dt, i, et, at, C, D, Rt);
            } else "Polygon" == _ && (y = He(Ft, i, et, at));
            if (B.buffer.setIdOffset(t.id), !g) {
              var Nt = t.geometry;
              if (Nt._xyz) g = Nt._xyz;else {
                g = [];
                for (var Bt = 0, Ut = y; Bt < Ut.length; Bt++) for (var Wt = Ut[Bt], Gt = Wt.dimensions, Zt = Ft.data.subarray(Wt.start, Wt.stop), Xt = Ke.exports(Zt, Wt.holes, Gt), Yt = (Wt.start - v) / Gt, Ht = 0, jt = Xt; Ht < jt.length; Ht++) {
                  var Vt = jt[Ht];
                  g.push(Yt + Vt);
                }
                et.clipped || (Nt._xyz = g);
              }
            }
            Vt = 0;
            for (var qt, Kt = v / y[0].dimensions; Vt < g.length; Vt++) qt = Kt + g[Vt], kt.i32 = kt.i32 || qt > 65535, Dt.push(qt);
          }
        } else {
          var Qt = ut(m, t, st, this.dpr, Q);
          if (Qt) {
            Q = Qt || Q, (K = K || []).push(m);
            var $t = rt("priority", m, t, st);
            $t < lt && (lt = $t);
            var Jt = rt("repeat", m, t, st);
            Jt > ht && (ht = Jt), ft += _ + ($t || "?") + (Jt || "?");
          }
        }
      }
      if (K) {
        var te = {
            id: ft,
            priority: lt,
            repeat: ht,
            styleGrp: K,
            feature: t,
            geomType: e,
            coordinates: i
          },
          ee = Q[0],
          ie = Q[1],
          re = .5 * (Q[2] - ee),
          ne = .5 * (Q[3] - ie);
        te.offsetX = ee + re, te.offsetY = ie + ne, te.width = re, te.height = ne, this.pendingCollisions.push(te);
      }
      return this.iconsLoaded;
    }, t;
  }(),
  Vi = function () {
    function t(t) {
      this.timer = null, this.tiles = new Map(), this.display = t, this.debug(false);
    }
    return t.prototype.debug = function (t) {
      var e = this;
      t ? this.dbgLayers || (this.dbgLayers = [new _xyzMapsCore.TileLayer({
        pointerEvents: !1,
        min: 2,
        max: 28,
        provider: new _xyzMapsCore.LocalProvider({})
      }), new _xyzMapsCore.TileLayer({
        pointerEvents: !1,
        min: 2,
        max: 28,
        provider: new _xyzMapsCore.LocalProvider({})
      })], setTimeout(function () {
        return e.dbgLayers.forEach(function (t) {
          return wn.getInstances().pop().addLayer(t);
        });
      }, 0)) : this.dbgLayers && this.dbgLayers.forEach(function (t) {
        return t.getProvider().clear();
      }), this.dbg = t;
    }, t.prototype.dbgBBoxes = function (t, e, i) {
      for (var r = wn.getInstances().pop(), n = 2, o = 1, a = 0, s = t.boxes; a < s.length; a++) {
        var u = s[a],
          h = .5 * (u.maxX - u.minX),
          f = .5 * (u.maxY - u.minY),
          c = void 0,
          p = void 0;
        if ("number" == typeof e) {
          var d = _xyzMapsCore.webMercator.mapSizePixel(512, e);
          c = _xyzMapsCore.webMercator.x2lon(u.maxX - h, d), p = _xyzMapsCore.webMercator.y2lat(u.maxY - f, d), n = 3, o = 0;
        } else {
          var v = r.pixelToGeo(u.minX + h, u.minY + f);
          c = v.longitude, p = v.latitude, i = e ? "orange" : "green";
        }
        this.dbgLayers[Number("number" != typeof e)].addFeature({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [c, p]
          }
        }, [{
          zLayer: 1e5,
          zIndex: o,
          type: "Rect",
          stroke: i,
          strokeWidth: n,
          width: 2 * h,
          height: 2 * f,
          collide: !0
        }]);
      }
    }, t.prototype.getTileCacheKey = function (t, e) {
      return 256 == e.tileSize ? t.slice(0, -1) : t;
    }, t.prototype.getDataKey = function (t, e) {
      return "".concat(e.id, "-").concat(t);
    }, t.prototype.intersects = function (t, e) {
      for (var i = t.boxes, r = 0, n = e; r < n.length; r++) for (var o = 0, a = n[r].boxes; o < a.length; o++) for (var s = a[o], l = 0, u = i; l < u.length; l++) {
        var h = u[l];
        if (h.minX <= s.maxX && s.minX <= h.maxX && h.minY <= s.maxY && s.minY <= h.maxY) return !0;
      }
    }, t.prototype.updateBBoxes = function (t, e, i, r, n, o, a) {
      for (var s = 0; s <= o; s++) {
        var l = .75 * (s / o - .5),
          u = i[0] * l + t,
          h = i[1] * l + e;
        a[s] = {
          minX: u - r,
          maxX: u + r,
          minY: h - n,
          maxY: h + n
        };
      }
    }, t.prototype.initTile = function (t, e) {
      var i = [],
        r = t.quadkey,
        n = t.x,
        o = t.y,
        a = t.z;
      this.clearTile(r, e), 256 == e.tileSize && (a--, o = .5 * o ^ 0, n = .5 * n ^ 0);
      for (var l = -1; l < 2; l++) for (var u = -1; u < 2; u++) if (0 != u || 0 != l) {
        var h = _xyzMapsCore.tileUtils.tileXYToQuadKey(a, o + l, n + u),
          f = this.tiles.get(h);
        if (f) for (var c in f) for (var p = 0, d = f[c]; p < d.length; p++) {
          var v = d[p];
          i[i.length] = v;
        }
      }
      var y = this.getTileCacheKey(r, e);
      this.curLayerTileCollision = {
        tileKey: y,
        data: [],
        dataKey: this.getDataKey(r, e),
        existing: g({
          neighbours: i
        }, this.tiles.get(y) || {})
      }, this.updated = !1;
    }, t.prototype.insert = function (t, e, i, r, n, o, a, s, l, u, h) {
      void 0 === u && (u = Number.MAX_SAFE_INTEGER);
      var f,
        c = s.x,
        p = s.y,
        d = s.z;
      256 == l && (t += c % 2 * l, e += p % 2 * l, l *= 2, c = .5 * c ^ 0, p = .5 * p ^ 0, d--), c = c * l + r, p = p * l + n;
      o += 4, a += 4;
      var v = Math.min(o, a),
        y = Math.max(o, a),
        g = Math.floor(y / v);
      h && g > 1.5 ? (o = v, a = v, g = Math.floor(.7 * g), f = new Array(g), this.updateBBoxes(t + c, e + p, h, v, v, g, f)) : f = [{
        minX: c + t - o,
        maxX: c + t + o,
        minY: p + e - a,
        maxY: p + e + a
      }];
      var m = {
          cx: t,
          cy: e,
          cz: i,
          halfWidth: o,
          halfHeight: a,
          offsetX: r,
          offsetY: n,
          boxes: f,
          slope: h,
          priority: u,
          attrs: []
        },
        x = this.curLayerTileCollision,
        _ = x.data,
        w = x.existing,
        b = this.dbg;
      if (this.intersects(m, _)) return !1;
      for (var T in w) if (this.intersects(m, w[T])) return b && this.dbgBBoxes(m, d, "darkred"), !1;
      return this.updated = !0, _.push(m), m;
    }, t.prototype.completeTile = function (t) {
      var e = this.curLayerTileCollision,
        i = e.tileKey,
        r = e.dataKey,
        n = e.data,
        o = this.tiles.get(i) || {};
      return o[r] = n, this.tiles.set(i, o), this.curLayerTileCollision = null, this.updated && t && this.updateTileSync(this.display.getScreenTile(i, 512)), this.updated;
    }, t.prototype.clearTile = function (t, e) {
      var i,
        r = this.getTileCacheKey(t, e),
        n = this.getDataKey(t, e);
      if ((null === (i = this.curLayerTileCollision) || void 0 === i ? void 0 : i.dataKey) != n) {
        var o = this.tiles.get(r);
        if (o) {
          for (var a in delete o[n], o) return;
          this.tiles.delete(r);
        }
      }
    }, t.prototype.updateTileSync = function (t) {
      return this.updateTiles([t], this.display.s);
    }, t.prototype.update = function (t, e) {
      var i = this;
      null == this.timer && (this.timer = setTimeout(function () {
        var t = i.display.grid.tiles[512],
          r = i.display.s;
        i.updateTiles(t, r), i.timer = null, e && e();
      }, 150));
    }, t.prototype.updateTiles = function (t, e) {
      var i = this.display,
        r = this.dbg,
        n = [];
      r && this.dbgLayers[1].getProvider().clear();
      for (var o = 0, a = t; o < a.length; o++) {
        var s = a[o],
          l = s.quadkey,
          u = this.tiles.get(l);
        if (u) for (var h in u) for (var f = 0, c = u[h]; f < c.length; f++) {
          var p = c[f],
            d = p.attrs,
            v = p.offsetX / e,
            y = p.offsetY / e,
            g = p.boxes.length,
            m = p.slope,
            x = p.halfWidth,
            _ = p.halfHeight,
            w = s.x + p.cx,
            b = s.y + p.cy,
            T = void 0;
          if (g > 1) {
            T = new Array(g), w += v, b += y;
            var L = i.project(w, b, 0, 0, 0),
              S = L[0],
              A = L[1],
              M = i.project(w + m[0], b + m[1], 0, 0, 0);
            m = [(M[0] - S) / e, (M[1] - A) / e], this.updateBBoxes(S, A, m, x, _, T.length - 1, T);
          } else {
            var z = i.project(w, b, 0, 0, 0);
            T = [{
              minX: (S = z[0]) - x + v,
              maxX: S + x + v,
              minY: (A = z[1]) - _ + y,
              maxY: A + _ + y
            }];
          }
          n.push({
            boxes: T,
            attrs: d,
            slope: m,
            priority: p.priority
          });
        }
      }
      n.sort(function (t, e) {
        return t.priority - e.priority;
      });
      for (var I = [], P = [], E = 0, C = n; E < C.length; E++) {
        var k = C[E],
          D = void 0,
          O = this.intersects(k, P);
        k.slope ? D = I : (O || (O = this.intersects(k, I)), D = P), O || (D[D.length] = k);
        for (var F = 0, R = k.attrs; F < R.length; F++) {
          var N = R[F],
            B = N.buffer,
            U = N.start,
            W = N.stop,
            G = B.data,
            Z = B.size,
            X = 1 == (1 & G[U]);
          if (O && X || !O && !X) {
            for (; U < W;) G[U] ^= 1, U += Z;
            B.dirty = !0;
          }
        }
        r && this.dbgBBoxes(k, O);
      }
    }, t.prototype.removeTiles = function (t) {
      var e = t.id;
      this.tiles.forEach(function (t) {
        for (var i in t) Number(i.split("-")[0]) == e && delete t[i];
      });
    }, t;
  }(),
  qi = [3, 9],
  Ki = function (t) {
    function e(e, i, r, n) {
      var o = t.call(this, e, i, r || "auto", new Re(512), new ke(n), qi) || this;
      o.name = "gl-test", o.worldCenter = [0, 0], o.dpr < 2 && o.buckets.setSize(1024);
      var a = o;
      o.collision = new Vi(a), o.buckets.onDrop = function (t, e) {
        var i = this.quadkey,
          r = this.layers;
        a.collision.clearTile(i, r[e]), a.releaseBuffers(t);
      };
      var s = a.render;
      return s.init(o.canvas, o.dpr), o.rayCaster = new Te(s.screenMat, s.invScreenMat), o.factory = new ji(s.gl, s.icons, o.collision, o.dpr), o.tilesNotReady = [], o.render.icons.onLoad = function (t) {
        for (var e = 0, i = o.tilesNotReady; e < i.length; e++) {
          var r = i[e],
            n = r.quadkey,
            a = r.layerId,
            s = o.layers.get(a);
          if (s) {
            var l = o.buckets.get(n, !0);
            if (l) {
              var u = s.layer,
                h = s.index;
              l.preview(h, !1), l.ready(h, !1), l.cancelTasks(u);
              var f = u.getCachedTile(l.quadkey);
              f && o.getScreenTile(n, s.tileSize) && o.handleTile(f, u, l, h);
            }
          }
        }
        o.tilesNotReady = [];
      }, o;
    }
    return y(e, t), e.prototype.releaseBuffers = function (t) {
      var e = this.render;
      if (t) for (var i = 0, r = t; i < r.length; i++) {
        var n = r[i];
        e.deleteBuffer(n);
      }
    }, e.prototype.removeLayer = function (e) {
      return this.collision.removeTiles(this.layers.get(e)), t.prototype.removeLayer.call(this, e);
    }, e.prototype.unproject = function (t, e, i) {
      var r = this.render.invScreenMat;
      if ("number" == typeof i) {
        var n = [t, e, i];
        return we(n, n, r), n[2] *= -1, n;
      }
      var o = [t, e, 0],
        a = [t, e, 1];
      we(o, o, r), we(a, a, r);
      var s = o[2],
        l = a[2],
        u = s === l ? 0 : (0 - s) / (l - s);
      return [o[0] * (1 - u) + a[0] * u, o[1] * (1 - u) + a[1] * u];
    }, e.prototype.project = function (t, e, i, r, n) {
      void 0 === i && (i = 0), void 0 === r && (r = this.sx), void 0 === n && (n = this.sy);
      var o = [t - r, e - n, -i];
      return we(o, o, this.render.screenMat);
    }, e.prototype.setSize = function (e, i) {
      t.prototype.setSize.call(this, e, i), this.initRenderer();
    }, e.prototype.setTransform = function (t, e, i) {
      var r = 2 * Math.PI;
      e = (e + r) % r, this.s = t, this.rz = e, this.rx = i;
    }, e.prototype.setView = function (e, i, r, n, o, a) {
      void 0 === o && (o = this.groundResolution), void 0 === a && (a = this.worldSize), t.prototype.setView.call(this, e, i, r, n, o, a), this.groundResolution = o, this.worldCenter[0] = e[0], this.worldCenter[1] = e[1], this.worldSize = a, this.initRenderer();
    }, e.prototype.initRenderer = function () {
      this.render.gl && this.render.initView(this.w, this.h, this.s, this.rx, this.rz, this.groundResolution, this.worldCenter[0], this.worldCenter[1], this.worldSize);
    }, e.prototype.prepareTile = function (t, e, i, r, n) {
      var o = this,
        a = this,
        s = a.render.gl,
        u = i.tileSize,
        h = this.layers.get(i.id);
      if ("image" == t.type && e instanceof Image) {
        var f = function (t, e, i, r) {
          var n = new te({
              first: 0,
              count: 6
            }, "Image"),
            o = new Int16Array(12);
          return o[0] = 0, o[1] = 0, o[2] = i, o[3] = 0, o[4] = i, o[5] = i, o[6] = 0, o[7] = 0, o[8] = i, o[9] = i, o[10] = 0, o[11] = i, n.addAttribute("a_position", {
            data: o,
            size: 2,
            stride: 0
          }), n.addAttribute("a_textureCoord", {
            data: new Int8Array(Ze),
            size: 2,
            stride: 0
          }), n.texture = new Et(e, t), n.addUniform("u_sampler", 0), n.zIndex = 0, n.scissor = !0, n.blend = r, n.alpha = r ? It.ALPHA : It.OPAQUE, n;
        }(e, s, u, h.index > 0);
        h.addZ(f.zIndex), r.preview(r.setData(i, [f]), null), n(r, i);
      } else if (e.length) {
        var c = function (t, e, i, r, n, o, a) {
          var s = e.layer,
            u = {},
            h = !0,
            f = Be.create({
              time: 4,
              priority: 4,
              init: function () {
                var e = r.z + s.levelOffset,
                  a = s.getStyle(),
                  l = 1;
                if (a) {
                  var h = a.strokeWidthZoomScale || a.LineStringZoomScale;
                  h && (l = h(e));
                }
                return o && o(), n.init(r, u, i, e), [r, t, l, 0, 16, s, e, !1];
              },
              name: "createBuffer",
              onDone: function (t) {
                var i,
                  n,
                  o,
                  f = t[6],
                  c = 1 / _xyzMapsCore.webMercator.getGroundResolution(f),
                  p = [];
                for (o in u) {
                  var d = u[o];
                  if (d) for (var v = 0, y = d.groups; v < y.length; v++) {
                    var g = y[v],
                      m = g.type,
                      x = g.shared,
                      _ = x.stroke,
                      w = x.strokeWidth,
                      b = m;
                    if (n = g.buffer, ("Text" != b || g.texture) && n && !n.isEmpty() && null != (i = te.fromTemplateBuffer(m, n))) {
                      if (i.pointerEvents = g.pointerEvents, "VerticalLine" == b && (i.groups[0].mode = te.MODE_GL_LINES, i.type = "Polygon", i.addUniform("u_fill", x.stroke), i.addUniform("u_offsetZ", [x.offsetZ, 0])), p.push(i), "Line" == m) x.strokeDasharray && (i.type = "DashedLine", i.texture = g.texture, i.addUniform("u_texWidth", g.texture.width), i.addUniform("u_pattern", 0)), i.addUniform("u_fill", _), i.addUniform("u_strokeWidth", [.5 * w, "m" == x.unit ? c : 0]), i.addUniform("u_offset", [x.offsetX, "m" == x.offsetUnit ? c : 0]), i.alpha = 1;else if ("Polygon" == m || "Extrude" == m) i.addUniform("u_fill", x.fill), "Extrude" == m && (i.addUniform("u_strokePass", 0), i.scissor = !1, x.stroke && (i.addGroup(g.extrudeStrokeIndex, n.i32, 1).uniforms = {
                        u_strokePass: 1,
                        u_stroke: x.stroke
                      }));else {
                        if ("Text" == m || "Icon" == m) i.scissor = n.scissor, i.texture = g.texture, "Text" == m ? (i.texture.sync(), i.addUniform("u_fillColor", x.fill || We), i.addUniform("u_strokeColor", x.stroke || We)) : i.addUniform("u_opacity", x.opacity), i.addUniform("u_texture", 0), i.addUniform("u_atlasScale", 1 / i.texture.width), i.addUniform("u_alignMap", "map" == x.alignment);else if ("Rect" == m || "Circle" == m || "Box" == m || "Sphere" == m) {
                          i.scissor = n.scissor;
                          var T = x.fill || We;
                          i.addUniform("u_fill", T), _ && (i.addUniform("u_stroke", _), null == w && (w = 1)), i.addUniform("u_strokeWidth", 0 ^ w);
                          var L = "m" == x.unit ? c : 0;
                          "Circle" == m || "Sphere" == m ? i.addUniform("u_radius", [x.width, L]) : (T == We && (i.alpha = 1, i.blend = !0), i.addUniform("u_size", [x.width, L, x.height, L]), i.addUniform("u_rotation", x.rotation * Ue)), i.addUniform("u_alignMap", "map" == x.alignment);
                        }
                        x.offsetUnit && (i.addUniform("u_offset", [x.offsetX, "m" == x.offsetUnit[0] ? c : 0, x.offsetY, "m" == x.offsetUnit[1] ? c : 0]), i.addUniform("u_offsetZ", [x.offsetZ, "m" == x.offsetUnit[2] ? c : 0]));
                      }
                      i.flat = n.isFlat();
                      var S = x.fill && x.fill[3],
                        A = x.stroke && x.stroke[3],
                        M = S < 1,
                        z = M || A < 1;
                      z && (i.alpha = M && "Extrude" == m || !i.flat && "Line" == m ? 2 : 1, i.blend = !0, i.depth = !0);
                      var I = g.zLayer;
                      "top" == o && (I = 1 / 0, o = 0), o = Number(o), i.flat || (i.scissor = !1, null != g.depthTest && (i.depth = g.depthTest, i.alpha || (i.alpha = 1))), e.addZ(o, !i.flat), i.zIndex = o, i.zLayer = "number" == typeof I ? Math.ceil(I) : null, null == i.scissor && (i.scissor = !r.clipped || s.getMargin() > 0 || z);
                    }
                  }
                }
                a(p.reverse(), h);
              },
              exec: function (t) {
                var e,
                  i,
                  r,
                  o = t[0],
                  a = t[1],
                  s = t[2],
                  l = t[5],
                  u = a.length,
                  f = t[6],
                  c = !1;
                if (!t[7]) {
                  for (; t[4]-- && (i = a[t[3]++]);) if (e = l.getStyleGroup(i, f)) {
                    r = i.geometry.type, e.length || (e = [e]), mt(e);
                    var p = i.getProvider().decCoord(i),
                      d = !0;
                    if ("MultiLineString" == r || "MultiPoint" == r) for (var v = "MultiPoint" == r ? "Point" : "LineString", y = 0, g = p; y < g.length; y++) {
                      var m = g[y];
                      d = d && n.create(i, v, m, e, s);
                    } else if ("MultiPolygon" == r) {
                      d = n.create(i, "Polygon", p, e, s);
                      for (var x = 0; x < p.length; x++) {
                        var _ = p[x];
                        d = d && Ge(n, i, _, e, s, o, x);
                      }
                    } else d = n.create(i, r, p, e, s), "Polygon" == r && (d = d && Ge(n, i, p, e, s, o));
                    h = h && d;
                  }
                  c = t[3] < u;
                }
                if (!c && n.pendingCollisions.length) {
                  t[7] || (t[7] = n.pendingCollisions.sort(function (t, e) {
                    return t.priority - e.priority;
                  }), t[3] = 0);
                  var w = t[7],
                    b = void 0;
                  if (t[4] >= 0) for (; t[4]-- && (b = w[t[3]++]);) {
                    p = b.coordinates;
                    var T = b.priority,
                      L = b.geomType;
                    if ("Point" == L || "LineString" == L) {
                      var S = n.create(b.feature, L, p, b.styleGrp, s, !1, T, b);
                      h = h && S;
                    }
                  }
                  c = t[3] < w.length;
                }
                return t[4] = 16, c;
              }
            });
          return Be.start(f), f;
        }(e, h, u, t, this.factory, function () {
          a.collision.initTile(t, h);
        }, function (t, e) {
          r.removeTask(c, i), r.preview(r.setData(i, t), null), e || a.tilesNotReady.push({
            quadkey: r.quadkey,
            layerId: i.id
          }), a.collision.completeTile(!0) && (o.dirty = !0), n(r, i);
        });
        r.addTask(c, i);
      } else r.preview(r.setData(i, []), null), n(r, i);
    }, e.prototype.orderBuffers = function (t, e, i, r, n, o) {
      for (var a = 0, s = e; a < s.length; a++) {
        var l = s[a],
          u = l.zLayer,
          h = l.zIndex;
        null == u && (u = i.index + 1);
        var f = 1e6 * u + h;
        r[f] = 0, t[t.length] = {
          b: l,
          z: f,
          data: n,
          tiled: o
        };
      }
    }, e.prototype.viewport = function (t) {
      var e,
        i,
        r = this,
        n = r.buckets,
        o = r.layers,
        a = r.render,
        s = o.length;
      r.dirty && (r.dirty = !1, r.collision.update(r.grid.tiles[512], function () {
        return r.update();
      })), a.clear(s && o[0].bgColor || r.globalBgc), a.fixedView = Number(!this.viewChange);
      for (var l = [], u = {}, h = 0, f = o; h < f.length; h++) {
        var c = f[h],
          p = c.tiles;
        if (c.cnt = 0, c.layer.tiled) {
          if (p) for (var d = c.index, v = p.length, y = 0; y < v;) {
            var g = (W = p[y++]).tile,
              m = null === (e = g.data) || void 0 === e ? void 0 : e[c.index];
            if (!c.ready && g.ready(d) && ++c.cnt == v && (c.ready = !0), m) m.length && this.orderBuffers(l, m, c, u, {
              tile: W
            }, !0);else {
              var x;
              if ((x = g.preview(d)) && x.length) for (var _ = 0, w = x; _ < w.length; _++) {
                var b,
                  T = w[_],
                  L = T[0],
                  S = n.get(L, !0);
                (null == (b = null == S ? void 0 : S.getData(d)) ? void 0 : b.length) && this.orderBuffers(l, b, c, u, {
                  tile: W,
                  preview: T,
                  previewTile: S
                }, !0);
              }
            }
          }
        } else {
          c.ready = !0;
          var A = c.layer,
            M = A.renderOptions;
          this.orderBuffers(l, [{
            zLayer: M.zLayer,
            zIndex: M.zIndex,
            alpha: M.alpha || 1,
            flat: A.flat
          }], c, u, c.layer, !1);
        }
      }
      for (var z = 0, I = 0, P = Object.keys(u).sort(function (t, e) {
          return Number(t) - Number(e);
        }); I < P.length; I++) {
        u[C = P[I]] = z++;
      }
      for (var E = 1 / 0, C = (y = 0, void 0), k = void 0; y < l.length; y++) C = (k = l[y]).z = u[k.z], !k.b.flat && C < E && (E = C);
      a.setPass(It.OPAQUE), a.zIndexLength = z;
      for (var D = l.length; D--;) {
        (null == (R = l[D]) ? void 0 : R.tiled) && a.draw(R, E);
      }
      a.setPass(It.ALPHA), l = l.sort(function (t, e) {
        return 10 * (t.z - e.z) + t.b.alpha - e.b.alpha;
      });
      var O = 0;
      do {
        var F = !1;
        for (D = 0, i = l.length; D < i; D++) {
          var R;
          2 == (R = l[D]).b.alpha && (F = !0), (null == R ? void 0 : R.z) == O && (R.tiled ? a.draw(R, E) : a.drawCustom(R.data, R.z));
        }
        a.pass == It.POST_ALPHA ? a.setPass(It.ALPHA) : F && (a.setPass(It.POST_ALPHA), O--);
      } while (++O < z);
      if (a.tileGrid) for (var N in r.tiles) {
        if ((p = r.tiles[N]).length) {
          for (var B = 0, U = p; B < U.length; B++) {
            var W = U[B];
            a.drawGrid(W.x, W.y, W.tile, Number(N));
          }
          break;
        }
      }
    }, e.prototype.destroy = function () {
      t.prototype.destroy.call(this);
    }, e.prototype.getRenderedFeatureAt = function (t, e, i) {
      var r = this.tiles;
      for (var n in this.rayCaster.init(t, e, this.w, this.h, this.s, 1 / this.groundResolution), r) for (var o = 0, a = r[n]; o < a.length; o++) for (var s = a[o], l = s.x, u = s.y, h = s.tile, f = h.data, c = 0; c < f.length; c++) {
        var p = h.layers[c].layer,
          d = f[c],
          v = i.indexOf(p);
        if (d && -1 != v) for (var y = 0, g = d; y < g.length; y++) {
          var m = g[y];
          m.isFlat() || this.rayCaster.intersect(l, u, m, v);
        }
      }
      var x = this.rayCaster.getIntersectionTop();
      return this.viewport(!0), x;
    }, e.prototype.viewChangeDone = function () {
      this.viewChange = !1, this.update();
    }, e.zoomBehavior = "float", e;
  }(St),
  Qi = new Pt(),
  $i = 2 * Math.PI,
  Ji = Math.PI / 180,
  tr = Math.log(2048) / Math.log(2),
  er = tr + 9,
  ir = function (t, e, i, r, n, o, a, s, l, u, h, f) {
    var c = a.z;
    e += 0 ^ rt("offsetX", r, n, c), i += 0 ^ rt("offsetY", r, n, c);
    var p,
      d,
      v,
      y,
      g,
      m,
      x = rt("rotation", r, n, c),
      _ = e + 512 << tr | i + 512 ^ 0 | (x + 360) % 360 << er;
    h[_] || (h[_] = 1, x && (x *= Ji, l.translate(e, i), l.rotate(x), g = e, m = i, e = 0, i = 0), "Text" == t ? (r.stroke && 0 != r.strokeWidth && l.strokeText(o, e, i), r.fill && l.fillText(o, e, i)) : "Circle" == t ? (d = rt("radius", r, n, c), l.moveTo(e + d, i), l.arc(e, i, d, 0, $i, !1)) : (e -= (v = rt("width", r, n, c)) / 2, i -= (y = rt("height", r, n, c) || v) / 2, "Image" == t ? (p = rt("src", r, n, c), Qi.isReady(p) ? l.drawImage(Qi.get(p), e, i, v, y) : Qi.get(p, function () {
      return f.updateTile(a, s, u);
    }, a.quadkey)) : "Rect" == t && l.rect(e, i, v, y)), x && (l.rotate(-x), l.translate(-g, -m)));
  },
  rr = Math,
  nr = function () {
    function t() {
      this.o = .5;
    }
    return t.prototype.init = function (t) {
      return this.o = t, !0;
    }, t.prototype.createSymbol = function (t, e) {
      return t - ("Circle" == e.type ? e.radius : e.width) > 0;
    }, t.prototype.drawSymbol = function (t, e, i, r, n, o, a, s, l, u, h) {
      ir(n.type, e, i, n, a, !1, o, s, r, l, u, h);
    }, t.prototype.angle = function (t, e) {
      return Math.atan2(t, e);
    }, t.prototype.place = function (t, e, i, r, n, o, a, s, l, u) {
      for (var h, f, c, p, d, v, y, g, m, x, _ = this.o, w = 0; w < t.length; w++) c = Math.round(e.lon2x(t[w][0])), p = Math.round(e.lat2y(t[w][1])), w && (m = c - h, x = p - f, d = rr.sqrt(rr.pow(m, 2) + rr.pow(x, 2)) - 16, (v = this.createSymbol(d, n)) && (y = (m * _ + h) * u, g = (x * _ + f) * u, i.setTransform(u, 0, 0, u, y, g), i.rotate(this.angle(x, m)), i.translate(-y, -g), this.drawSymbol(v, y, g, i, n, e, r, o, a, s, l), i.setTransform(u, 0, 0, u, 0, 0))), h = c, f = p;
    }, t;
  }(),
  or = function (t) {
    function e(e) {
      var i = t.call(this) || this;
      return t.prototype.init.call(i, .5), i.setCharWidth(e), i;
    }
    return y(e, t), e.prototype.setCharWidth = function (t) {
      this.cw = t;
    }, e.prototype.init = function (t) {
      return "string" != typeof t && (t = String(t)), this.lw = t.length * this.cw, this.label = t, !0;
    }, e.prototype.angle = function (t, e) {
      return Math.atan(t / e);
    }, e.prototype.createSymbol = function (t) {
      var e,
        i,
        r = this.label,
        n = this.cw,
        o = this.lw,
        a = Math.floor(t / o);
      return a > 0 && (e = r, a > 1 && (a = 1 + Math.floor((a - 1) / 8), i = new Array(Math.floor(1.5 * (t - o) / n / a)).join(" "), e = r + new Array(a).join(i + r))), e;
    }, e.prototype.drawSymbol = function (t, e, i, r, n) {
      n.stroke && r.strokeText(t, e, i), n.fill && r.fillText(t, e, i);
    }, e;
  }(nr),
  ar = function (t, e, i) {
    var r,
      n,
      o,
      a,
      s = t.length - 1;
    for (e.moveTo(o = Math.round(i.lon2x(t[s][0])), a = Math.round(i.lat2y(t[s][1]))); s--;) r = Math.round(i.lon2x(t[s][0])), n = Math.round(i.lat2y(t[s][1])), (o - r || a - n) && e.lineTo(o = r, a = n);
  },
  sr = [],
  lr = new or(R({
    font: k
  }).width),
  ur = new nr(),
  hr = function (t, e, i) {
    t.globalAlpha = null == e.opacity ? 1 : e.opacity;
    var r,
      n,
      o = e.font,
      a = e.stroke;
    if (a && (t.strokeStyle = a, o && (i = 1), (r = e.strokeWidth) && "number" == typeof r || (r = 1), t.lineWidth = r * i), e.fill && (t.fillStyle = e.fill), o) {
      var s = e.font || k;
      lr.setCharWidth(R(e).width), t.font = s, t.textAlign = e.textAlign || "center", t.textBaseline = e.textBaseline || "middle";
    } else t.lineCap = e.strokeLinecap || "round", t.lineJoin = e.strokeLinejoin || "round", (n = e.strokeDasharray) instanceof Array ? t.setLineDash(n) : t.setLineDash(sr), (e.fill || e.stroke) && t.beginPath();
    return !0;
  },
  fr = function (t, e, i, r, n, o, a, s, l, u) {
    var h = i.getProvider().decCoord(i),
      f = i.geometry.type,
      c = t.z,
      p = rt("type", n, i, c);
    if ("LineString" == f) {
      if ("Circle" == p || "Rect" == p || "Image" == p) {
        var d = rt("offset", n, i, c);
        if (null != d) return ur.init(d), void ur.place(h, t, e, i, n, o, a, s, l, u);
        f = "MultiPoint";
      }
    } else if (("Polygon" == f || "MultiPolygon" == f) && "Polygon" != p && "Line" != p) {
      var v = i.bbox;
      return ir(p, Math.round(t.lon2x(v[0] + (v[2] - v[0]) / 2)), Math.round(t.lat2y(v[1] + (v[3] - v[1]) / 2)), n, i, r, t, o, e, a, s, l);
    }
    if ("Point" == f) ir(p, Math.round(t.lon2x(h[0])), Math.round(t.lat2y(h[1])), n, i, r, t, o, e, a, s, l);else if ("Text" == p) {
      if (!lr.init(r)) return;
      if ("MultiLineString" == f) for (var y = 0; y < h.length; y++) lr.place(h[y], t, e, i, n, o, a, s, l, u);else "LineString" == f && lr.place(h, t, e, i, n, o, a, s, l, u);
    } else if ("LineString" == f) ar(h, e, t);else if ("Polygon" == f || "MultiLineString" == f) for (var g = 0; g < h.length; g++) ar(h[g], e, t);else if ("MultiPolygon" == f) for (y = 0; y < h.length; y++) for (g = 0; g < h[y].length; g++) ar(h[y][g], e, t);else if ("MultiPoint" == f) for (var m = h.length; m--;) ir(p, Math.round(t.lon2x(h[m][0])), Math.round(t.lat2y(h[m][1])), n, i, r, t, o, e, a, s, l);
  },
  cr = function () {
    function t(t, e, i) {
      this.tm = t, this.exclusiveTimeMS = i, this.dpr = e;
    }
    return t.prototype.spawn = function (t, e, i, r, n, o, a, s, l) {
      var u = this.createTask(t, e, i, r, n, i.bounds, o, a, s, l);
      return this.tm.start(u), u;
    }, t.prototype.createTask = function (t, e, i, r, n, o, a, s, l, u) {
      var h = this.dpr,
        f = n.index(r),
        c = n.getContext(f),
        p = this.tm.create({
          priority: t,
          delay: u,
          time: this.exclusiveTimeMS,
          init: function () {
            if (!l) {
              c.setTransform(h, 0, 0, h, 0, 0);
              var t = r.getStyle().backgroundColor;
              t ? (c.fillStyle = t, c.globalAlpha = 1, c.fillRect(0, 0, 256, 256)) : c.clearRect(0, 0, 256, 256);
            }
            return {
              tile: i,
              ctx: c,
              data: a,
              lI: 0,
              gI: 0,
              fI: 0,
              style: undefined,
              dTile: n,
              layer: r,
              bI: 100
            };
          },
          onDone: function () {
            n.dirty(f), s(c, this);
          },
          exec: function (t) {
            var i,
              r = t.tile,
              n = t.data,
              o = n.length;
            if (o) {
              for (; !(i = n[t.lI]) && t.lI < o;) ++t.lI;
              if (i) {
                var a = i[t.gI];
                if (a) {
                  var s = t.ctx,
                    l = a.shared,
                    u = null != l.font;
                  if (t.style != l) {
                    t.style = l;
                    var f = hr(s, l, n.swzs);
                    if (t.pmap = {}, !f) return t.fI = 0, t.gI++, t.bI = 100, this.CONTINUE;
                  }
                  for (; t.bI--;) {
                    var c = t.fI++,
                      p = a.data,
                      d = p.features[c];
                    if (!d) {
                      u ? s.setTransform(h, 0, 0, h, 0, 0) : (l.fill && s.fill(), l.stroke && (l.strokeWidth || null == l.strokeWidth) && s.stroke()), t.fI = 0, t.gI++;
                      break;
                    }
                    var v = p.styles[c],
                      y = void 0;
                    u && !(y = it(v, d, r.z)) || fr(r, s, d, y, v, t.dTile, t.layer, t.pmap, e, h);
                  }
                } else t.fI = 0, t.gI = 0, t.lI++;
                return t.bI = 100, this.CONTINUE;
              }
            }
          }
        });
      return p;
    }, t;
  }(),
  pr = function () {
    function t(t, i) {
      this.dpr = 1, this.debug = !1, this.rz = 0, this.sx = 0, this.sy = 0, this.s = 1;
      var r = _xyzMapsCommon.TaskManager.getInstance(),
        n = this;
      n.ts = t, n.dpr = i, n.painter = new cr(r, i, 4);
    }
    return t.prototype.drawGrid = function (t, e, i) {
      var r = i + "  L" + i.length,
        n = this.ctx;
      n.strokeRect(t, e, 256, 256), n.strokeText(r, t + 8, e + 16), n.fillText(r, t + 8, e + 16);
    }, t.prototype.applyTransform = function () {
      var t = this,
        e = t.s,
        i = t.rz;
      if (t._s != e || t._rz != i) {
        t._s = e, t._rz = i;
        var r = t.ctx,
          n = t.canvas,
          o = n.width,
          a = n.height,
          s = o / 2 - t.sx,
          l = a / 2 - t.sy,
          u = t.dpr;
        r.setTransform(1, 0, 0, 1, o / 2, a / 2), r.rotate(i), r.translate(-o / 2 + s, -a / 2 + l), r.scale(e, e), r.translate(-s, -l), r.scale(u, u);
      }
    }, t.prototype.init = function (t) {
      var e = t.getContext("2d", {
        alpha: !1
      });
      e.font = "bold 14px Arial", e.lineWidth = 3, e.strokeStyle = "red", e.fillStyle = "white", e.textAlign = "start", e.textBaseline = "alphabetic", this.ctx = e, this.canvas = t;
    }, t.prototype.setBuckets = function (t) {
      this.buckets = t;
    }, t.prototype.clear = function () {}, t.prototype.convertColor = function (t) {
      return t;
    }, t.prototype.setBackgroundColor = function (t) {
      this.buckets.bgColor(t);
    }, t.prototype.grid = function (t) {
      this.debug = t;
    }, t.prototype.setScale = function (t, e, i) {
      var r = this;
      r.s = t, r.sx = e, r.sy = i;
    }, t.prototype.setRotation = function (t, e) {
      this.rz = t;
    }, t.prototype.prepare = function (t, e, i, r, n, o) {
      return this.painter.spawn(3, r, e, i, n, t, o);
    }, t.prototype.tile = function (t, e, i) {
      var r = this;
      e = Math.round(e), i = Math.round(i), r.ctx.drawImage(t.combine(), e, i, 256, 256), r.debug && r.drawGrid(e, i, t.quadkey);
    }, t.prototype.preview = function (t, e, i, r) {
      var n = t.getContext(r);
      n.clearRect(0, 0, t.size, t.size);
      for (var o = 0, a = e.length; o < a; o++) {
        var s = e[o],
          l = this.buckets.get(s[0], !0),
          u = void 0;
        l && (u = l.getData(r)) && (n.setTransform(1, 0, 0, 1, 0, 0), n.drawImage(u, s[1], s[2], s[3], s[4], 0 + s[5], 0 + s[6], s[7], s[8]), t.dirty(r));
      }
    }, t.prototype.destroy = function () {}, t.prototype.getContext = function () {
      return this.ctx;
    }, t;
  }(),
  dr = function (t) {
    function e(e, i, r, n, o) {
      var a = t.call(this) || this,
        s = r.length;
      return a.c = new Array(s), a.init(i, r), a.size = n, a.bPool = e, a.ctx = e.claimCtx(n), a.canvas = a.ctx.canvas, a.ctx.fillStyle = o, a;
    }
    return y(e, t), e.prototype.destroy = function (t) {
      if (null != t) (e = this.c[t]) && (e.canvas && this.bPool.releaseCtx(e), this.c[t] = undefined);else for (var e, i = this.c.length; i--;) (e = this.c[i]) && e.canvas && (this.bPool.releaseCtx(e), this.c[i] = undefined);
    }, e.prototype.init = function (e, i) {
      t.prototype.init.call(this, e, i);
      var r = i.length;
      for (this.c.length = r; r--;) this.c[r] = undefined;
      this._c = !1, this._ready = !1;
    }, e.prototype.dirty = function (t, e) {
      var i = this.c[t],
        r = e != i;
      e && i && r && this.destroy(t), e || (r = !0, e = this.c[t]), r && (this.c[t] = e, this._c = !1);
    }, e.prototype.clear = function (t) {
      var e;
      (e = this.c[t]) && (e.setTransform && this.bPool.releaseCtx(e), this.c[t] = undefined, this.preview(t, undefined), this.ready(t, !1), this._c = !1, this.combine());
    }, e.prototype.getContext = function (t) {
      return this.c[t] || (this.c[t] = this.bPool.claimCtx(this.size)), this.c[t];
    }, e.prototype.getData = function (t) {
      return this.c[t] && (this.c[t].canvas || this.c[t]);
    }, e.prototype.combine = function () {
      var t,
        e = this,
        i = e.size;
      if (!e._c) {
        e._c = !0, e.ctx.fillRect(0, 0, i, i);
        for (var r = 0; r < e.c.length; r++) (t = this.getData(r)) && e.ctx.drawImage(t, 0, 0, i, i);
      }
      return e.canvas;
    }, e.prototype.addLayer = function (e) {
      t.prototype.addLayer.call(this, e);
      var i = this;
      i.c.splice(e, 0, undefined), i._c = !1, i._ready = !1;
    }, e.prototype.removeLayer = function (e) {
      t.prototype.removeLayer.call(this, e);
      this.destroy(e), this.c.splice(e, 1), this._c = !1;
    }, e;
  }(De),
  vr = [],
  yr = {
    length: 0,
    max: 128,
    clear: function () {
      this.length = 0;
    },
    create: function (t) {
      var e = document.createElement("canvas");
      return e.width = e.height = t, this.length++, e.getContext("2d");
    },
    get: function (t) {
      return vr.length ? (this.length++, vr.shift()) : this.create(t);
    },
    release: function (t) {
      t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, t.canvas.width, t.canvas.height), t.lineWidth = 1, t.globalAlpha = 1, vr.push(t), this.length--;
    }
  },
  gr = function (t) {
    function e(e, i) {
      var r = t.call(this, e || 256) || this;
      return r.ctxCache = yr, r._bgc = null, r.tSize = i, r;
    }
    return y(e, t), e.prototype.bgColor = function (t) {
      this._bgc = t, this.forEach(function (e) {
        e.ctx.fillStyle = t;
      });
    }, e.prototype.clear = function () {
      this.tiles.clear(), yr.clear();
    }, e.prototype.setSize = function (t) {
      this.tiles.setSize(t);
    }, e.prototype.releaseCtx = function (t) {
      return yr.release(t);
    }, e.prototype.claimCtx = function (t) {
      if (yr.length < yr.max) return yr.get(t);
      var e = this.tiles.tail.data;
      return e.destroy(), yr.release(e.ctx), e.ctx = null, e.canvas = null, this.tiles.remove(e.quadkey), e.cancelTasks(), this.claimCtx(t);
    }, e.prototype.create = function (t, e) {
      var i = this.tiles.get(t);
      return i || (this.tiles.length >= this.tiles.max ? ((i = this.tiles.tail.data).destroy(), i.init(t, e), i.size = this.tSize) : i = new dr(this, t, e, this.tSize, this._bgc), this.tiles.set(t, i)), i;
    }, e;
  }(Fe),
  mr = {
    1: [512, 3, 512],
    2: [128, 2, 128],
    3: [64, 1, 128]
  },
  xr = function (t, e, i, r, n) {
    var o = Math.sin(n),
      a = Math.cos(n),
      s = t - i,
      l = e - r;
    return [a * s - o * l + i, o * s + a * l + r];
  },
  _r = function () {
    function t() {
      this.features = [], this.styles = [];
    }
    return t.prototype.add = function (t, e) {
      this.features.push(t), this.styles.push(e);
    }, t;
  }(),
  wr = function (t) {
    function e(e, i, r, n) {
      var o;
      i = i || 256, r = 0 ^ St.getPixelRatio(r);
      var a = mr[r][1],
        s = new pr(i * r, r),
        l = mr[r][0],
        u = new gr(l, i * r);
      return s.setBuckets(u), o = t.call(this, e, i, r, u, s, a) || this, s.init(o.canvas), o;
    }
    return y(e, t), e.prototype.preview = function (e, i, r) {
      var n = t.prototype.preview.call(this, e, i, r);
      return n && this.render.preview(e, n, i, r), n;
    }, e.prototype.prepareTile = function (t, e, i, r, n) {
      var o = this,
        a = o.render;
      if ("image" == t.type) {
        var s = r.index(i);
        r.dirty(s, e), n(r, i);
      } else if (e.length) r.addTask(o.cluster.spawn(4, i, t, e, {}, _r, function (e, s) {
        r.removeTask(s, i), null == r && (r = undefined), r.addTask(a.prepare(e, t, i, o, r, function (t, e) {
          r.removeTask(e, i), n(r, i);
        }), i);
      }), i);else {
        s = r.index(i);
        r.destroy(s), r.dirty(s), n(r, i);
      }
    }, e.prototype.viewport = function (t) {
      var e,
        i,
        r = this,
        n = r.tiles,
        o = r.render,
        a = r.layers,
        s = a.length;
      for (var l in this.buckets, (this.dirty || t) && (this.render.clear(), this.dirty = !1), n) if ("512" != l) for (var u = n[l], h = u.length, f = 0, c = u; f < c.length; f++) {
        var p = c[f];
        if (i = (e = p.tile).luTs, p.lrTs != i || t) {
          p.lrTs = i, o.tile(e, p.x, p.y);
          for (var d, v = 0; v < s; v++) !(d = a[v]).ready && e.ready(v) && ++d.cnt == h && (d.ready = !0);
        }
      }
    }, e.prototype.addLayer = function (e, i, r) {
      e.tileSize = 256;
      var n = t.prototype.addLayer.call(this, e, i, r);
      return n && this.setupTilePool(), n;
    }, e.prototype.removeLayer = function (e) {
      var i = t.prototype.removeLayer.call(this, e);
      return -1 !== i && this.setupTilePool(), i;
    }, e.prototype.setSize = function (e, i) {
      var r = this;
      t.prototype.setSize.call(this, e, i), r.setupTilePool(), r.render._s = undefined, r.setTransform(r.s, r.rz, r.rx);
    }, e.prototype.destroy = function () {
      t.prototype.destroy.call(this), this.buckets.clear();
    }, e.prototype.setupTilePool = function () {
      var t = this,
        e = (Math.ceil(t.w / 256) + 1) * (Math.ceil(t.h / 256) + 1),
        i = e,
        r = mr[t.dpr],
        n = e * t.getLayers().length;
      i < r[0] && (i = r[0]), t.buckets.setSize(i), n < r[2] && (n = r[2]), t.buckets.ctxCache.max = n;
    }, e.prototype.update = function (e) {
      t.prototype.update.call(this);
    }, e.prototype.project = function (t, e) {
      var i = this,
        r = i.s;
      return xr(t *= r, e *= r, i.w / 2, i.h / 2, i.rz);
    }, e.prototype.unproject = function (t, e) {
      var i = this,
        r = i.s,
        n = i.w / 2,
        o = i.h / 2,
        a = xr(t, e, n, o, -i.rz);
      return a[0] = (a[0] - n) / r + n, a[1] = (a[1] - o) / r + o, a;
    }, e.zoomBehavior = "fixed", e;
  }(St),
  br = 0 === navigator.platform.indexOf("Win") ? .0025 : .0015,
  Tr = function () {
    function e(t, e, i, r) {
      var n = this;
      this.passive = !1;
      try {
        var o = Object.defineProperty({}, "passive", {
          get: function () {
            n.passive = !0;
          }
        });
        window.addEventListener("testPassive", null, o), window.removeEventListener("testPassive", null, o);
      } catch (t) {}
      this.el = t, this.settings = i, this.map = e, this.ams = 0 ^ r, this.onSpin = this.onSpin.bind(this);
    }
    return e.prototype.onSpin = function (e) {
      var i = this,
        r = i.settings,
        n = i.el,
        o = i.map,
        a = r.zoom;
      if (a) {
        var s = -(e = e || _xyzMapsCommon.global.event).deltaY;
        if (e.deltaMode === e.DOM_DELTA_LINE && (s *= 32.001953125), s) {
          var l = o.getZoomlevel(),
            u = void 0,
            h = void 0;
          "fixed" == a ? e.shiftKey ? u = l + (s > 0 ? .1 : -.1) : (u = Math.round(l + (s < 0 ? -1 : 1)), h = !0) : u = l + s * br;
          var f = n.getBoundingClientRect();
          this.zoom(u, e.pageX - f.left, e.pageY - f.top, h);
        }
      }
      e.preventDefault && e.preventDefault(), e.returnValue = !1;
    }, e.prototype.enable = function () {
      _(this.el, ["wheel", "DOMMouseScroll"], this.onSpin);
    }, e.prototype.disable = function () {
      w(this.el, ["wheel", "DOMMouseScroll"], this.onSpin);
    }, e.prototype.zoom = function (t, e, i, r) {
      var n = this.map,
        o = this.ams;
      n.setZoomlevel(t, e, i, r && o);
    }, e;
  }(),
  Lr = function (t) {
    return t;
  },
  Sr = function (t) {
    return Math.sin(Math.PI * t * .5);
  },
  Ar = Object.freeze({
    __proto__: null,
    linear: Lr,
    easeOut: function (t) {
      return 1 - Math.pow(1 - t, 1.5);
    },
    easeOutSine: Sr,
    easeOutCubic: function (t) {
      return 1 - (t = 1 - t) * t * t;
    }
  }),
  Mr = function () {
    function t(t, e, i, r, n) {
      this.ts = 0, this.af = null, this.from = "number" == typeof t ? [t] : t, this.to = "number" == typeof e ? [e] : e, this.duration = i, "function" == typeof r && (n = r, r = "linear"), this.easing = Ar[r] || Lr, this.animator = n, this.animate = this.animate.bind(this);
    }
    return t.prototype.animate = function () {
      var t = this,
        e = this.duration,
        i = Math.min(Date.now() - this.ts, e),
        r = this.from.map(function (r, n) {
          var o = t.to[n];
          return r + t.easing(i / e) * (o - r);
        });
      this.animator(1 == r.length ? r[0] : r), i < e ? this.af = requestAnimationFrame(this.animate) : (this.af = null, this.done());
    }, t.prototype.start = function () {
      return m(this, void 0, void 0, function () {
        var t = this;
        return x(this, function (e) {
          return [2, new Promise(function (e) {
            t.done = e, t.ts ? e() : (t.ts = Date.now(), t.animate());
          })];
        });
      });
    }, t.prototype.stop = function () {
      null != this.af && (cancelAnimationFrame(this.af), this.af = null);
    }, t;
  }(),
  zr = function (t, e) {
    var i,
      r,
      n = t.targetTouches;
    if (n) {
      var o = n.length,
        a = n[o - 1],
        s = void 0;
      if (o) {
        var l = e.getBoundingClientRect(),
          u = a.pageX - l.left,
          h = a.pageY - l.top;
        o > 1 ? (i = (u + (s = n[o - 2]).pageX - l.left) / 2, r = (h + s.pageY - l.top) / 2) : (i = u, r = h);
      }
    } else i = t.clientX, r = t.clientY;
    return [0 ^ i, 0 ^ r];
  },
  Ir = function (t) {
    var e = t.targetTouches,
      i = e.length,
      r = e[i - 2];
    if (r) {
      var n = e[i - 1],
        o = r.clientX - n.clientX,
        a = r.clientY - n.clientY;
      return 180 * Math.atan2(a, o) / Math.PI;
    }
  },
  Pr = function (e, i, r, n, o) {
    var a = this;
    this.scrollHandler = new Tr(e, i, n, o.zoomAnimationMs);
    var s,
      l,
      u,
      h,
      f,
      c,
      p,
      d,
      v,
      y,
      g,
      m,
      x,
      b,
      T,
      L = this,
      S = null,
      A = Date.now(),
      M = [],
      z = [],
      I = function (t, e, i) {
        var r = o[t];
        return Math.abs(e - s) > r || Math.abs(i - l) > r;
      },
      P = function () {
        p = 0, M.length = 0, z.length = 0;
      };
    function E(t) {
      var e = 1;
      if (null != t.scale) return t.scale;
      var i = t.targetTouches,
        r = i.length,
        n = i[r - 1],
        o = i[r - 2];
      if (o) {
        var a = H(n.clientX, n.clientY, o.clientX, o.clientY);
        null == S && (S = a), e = a / S;
      }
      return e;
    }
    function C(t, e) {
      if (!f) {
        if (!I("minPanMapThreshold", t, e)) return !0;
        r.cancel();
      }
      if (c = Date.now(), n.drag && !i.lockViewport().pan) {
        var o = t - u,
          a = e - h;
        p < 8 ? (M[p] = o, z[p] = a, p++) : p = 0, i.pan(o, a), f = !0;
      }
      u = t, h = e;
    }
    function k(t) {
      if (f) {
        var e = Date.now();
        e - c < 25 && r.pan(e, 3 * M.reduce(function (t, e) {
          return t + e;
        }, 0), 3 * z.reduce(function (t, e) {
          return t + e;
        }, 0));
      }
    }
    var D,
      O = null;
    function F(t) {
      P();
      var r = t.targetTouches,
        n = r.length,
        o = zr(t, e);
      if (u = o[0], h = o[1], s = u, l = h, E(t), f = !1, 2 == n) {
        D = 0;
        var a = r[n - 1],
          c = r[n - 2];
        m = a.clientX, x = a.clientY, b = c.clientX, T = c.clientY, S = H(m, x, b, T), g = i.getZoomlevel(), d = i.rotate(), v = i.pitch(), y = Ir(t);
      }
    }
    function R(t) {
      var r = t.targetTouches,
        o = r.length,
        a = zr(t, e),
        s = E(t);
      if (o > 1) {
        if (n.pitch) {
          if (++D < 5) return void t.preventDefault();
          var l = r[o - 1],
            f = r[o - 2],
            c = x - l.clientY,
            p = T - f.clientY;
          if (O || 0 != O && Math.abs(f.clientY - l.clientY) < 110 && Math.sign(c) == Math.sign(p)) return O = !0, i.pitch(v + .2 * c), void t.preventDefault();
          O = !1;
        }
        n.zoom && L.scrollHandler.zoom(g + Math.log2(s), a[0], a[1], !1), n.rotate && i.rotate(d + Ir(t) - y);
      }
      C(a[0], a[1]), u = a[0], h = a[1], t.preventDefault();
    }
    function N(t) {
      var i = zr(t, e),
        r = t.targetTouches.length;
      O = null, i && (u = i[0], h = i[1], s = u, l = h), r < 2 && (S = null);
      var n = Date.now(),
        o = n - A;
      r && (A = n), E(t), 0 == r && 1 == t.changedTouches.length && o > 350 && k();
    }
    var B = null;
    function U(t) {
      B = t.button, P(), f = !1, _(e, "mousemove", W), d = i.rotate(), v = i.pitch(), u = t.clientX, h = t.clientY, s = u, l = h;
    }
    function W(t) {
      var e;
      null === (e = L.resetAnimation) || void 0 === e || e.stop();
      var r = t.clientX,
        o = t.clientY;
      0 == B ? C(r, o) : 2 == B && (n.rotate && I("minRotateMapThreshold", r, o) && i.rotate(d + .25 * (u - r)), n.pitch && I("minPanMapThreshold", r, o) && i.pitch(v + .1 * (h - o)));
    }
    function G(t) {
      if (B = null, w(e, "mousemove", W), f) k();else if (n.rotate) {
        var r = i.rotate();
        d != r && Math.abs(r) <= 5 && (L.resetAnimation = new Mr(r, 0, 500, "easeOutSine", function (t) {
          return i.rotate(t);
        }), L.resetAnimation.start());
      }
    }
    L.scroll = function (t) {
      var e = a.scrollHandler;
      t ? e.enable() : e.disable();
    }, L.drag = function (i) {
      var r = i ? _ : w;
      setTimeout(function () {
        r(e, "touchstart", F), r(_xyzMapsCommon.global, "touchend", N), r(e, "touchmove", R), r(e, "mousedown", U), r(_xyzMapsCommon.global, "mouseup", G);
      }, 0);
    }, L.getOptions = function () {
      return n;
    };
  },
  Er = function () {
    function t(t, e, i, r, n) {
      this.type = t, this.timeStamp = Date.now(), null != e && (this.data = this.detail = e), i && (this.mapX = r, this.mapY = n, this.nativeEvent = i, this.button = i.button);
    }
    return t.prototype.stopPropagation = function () {
      var t = this.nativeEvent;
      if ("mousemove" == t.type || "touchmove" == t.type) return t.stopImmediatePropagation(), t.preventDefault();
    }, t.prototype.toString = function () {
      return "MapEvent " + this.type;
    }, t;
  }(),
  Cr = ["pointerup", "pointerenter", "pointerleave", "pointerdown", "pointermove", "pressmove", "tap", "dbltap"];
exports.MapEvent = Er;
function kr(t) {
  return -1 !== Cr.indexOf(t);
}
function Dr(t, e) {
  var i = e.type;
  "touchstart" != i && "touchmove" != i && "touchend" != i || (e = e.changedTouches[e.changedTouches.length - 1]);
  var r = t.getBoundingClientRect();
  return [e.pageX - r.left, e.pageY - r.top];
}
var Or,
  Fr = function () {
    function t(t, i, r, o) {
      this.disabled = {}, this.hActive = !1, this.cnt = 0, this.el = t, this.cbs = new _xyzMapsCommon.Listener(["click"]);
      var a,
        s,
        l,
        u,
        h,
        f,
        c = this.disabled,
        p = !1,
        d = !1,
        v = 0,
        y = !1,
        g = this.cbs;
      g.sync(!0), Cr.forEach(function (t) {
        g.addEvent(t), c[t] = !1;
      });
      var m = _xyzMapsCommon.TaskManager.getInstance().create({
        delay: 40,
        priority: 5,
        exec: function () {
          !function (e) {
            var i = Dr(t, e),
              r = w(i);
            _("pointermove", e, i, r), r ? h ? h.feature.id !== r.feature.id && (_("pointerleave", e, i, h), _("pointerenter", e, i, r)) : _("pointerenter", e, i, r) : h && _("pointerleave", e, i, h);
            h = r;
          }(f), y = !1;
        }
      });
      function x(t, e, r, n, o) {
        var a = new Er(t, o, e, r, n);
        return o && (a.target = o.feature, a.detail.display = i), a;
      }
      function _(t, e, i, r) {
        g.trigger(t, [x(t, e, i[0], i[1], r)], !1);
      }
      function w(t) {
        return i.getFeatureAt({
          x: t[0],
          y: t[1]
        }, {
          layers: i._layers.filter(function (t) {
            return t.pointerEvents();
          })
        });
      }
      var b = !1;
      this.onPointerDown = function (e) {
        var r = "touchstart" == e.type;
        r || !b ? (l = i.getCenter(), d = !0, p = !1, a = Dr(t, e), s = w(a), _("pointerdown", e, a, s), r && e.target.parentNode == t && (b = !0)) : b = !1;
      }, this.onPointerMove = function (e) {
        var i = "mousemove" == e.type;
        if (!i || !b) {
          var r, n, l;
          if (d) {
            var u = o.minPanMapThreshold;
            if (!p && (n = (r = Dr(t, e))[0] - a[0], l = r[1] - a[1], Math.abs(n) < u && Math.abs(l) < u)) return;
          }
          p = !0, d ? s && g.isListened("pressmove") && (n = (r = Dr(t, e))[0] - a[0], l = r[1] - a[1], g.trigger("pressmove", [x("pressmove", e, r[0], r[1], s), n, l], !1)) : i && (g.isListened("pointerenter") || g.isListened("pointerleave") || g.isListened("pointermove")) && (f = e, c.pointerenter || c.pointerleave || y || (y = !0, m.start()));
        }
      }, this.onPointerUp = function (e) {
        if (d) {
          var r = i.getCenter();
          if (!(l.longitude != r.longitude || l.latitude != r.latitude) && e.target.parentNode == t && (s || !p)) {
            var n = Dr(t, e);
            _("tap", e, n, s), _("pointerup", e, n, s), function (t) {
              var e = Date.now(),
                i = s && s.feature;
              e - v < 250 && !p && u == i && _("dbltap", t, a, s), u = i, v = e;
            }(e);
          }
          d = p = !1;
        }
      };
    }
    return t.prototype.getGlobalHandlers = function () {
      var t = this,
        e = t.onPointerDown,
        i = t.onPointerMove,
        r = t.onPointerUp;
      return {
        touchstart: e,
        touchmove: i,
        touchend: r,
        mousedown: e,
        mouseup: r,
        mousemove: i
      };
    }, t.prototype.enable = function (t) {
      kr(t) && delete this.disabled[t];
    }, t.prototype.disable = function (t) {
      kr(t) && (this.disabled[t] = !0);
    }, t.prototype.destroy = function () {
      var t = this.getGlobalHandlers();
      if (this.hActive) {
        for (var e in t) w(this.el, e, t[e]);
        this.hActive = !1;
      }
    }, t.prototype.addEventListener = function (t, e, i) {
      if (kr(t) && this.cbs.add(t, e, i)) {
        this.cnt++;
        var r = this.getGlobalHandlers(),
          n = void 0;
        if (!this.hActive) for (var o in r) {
          n = r[o];
          var a = this.el;
          if ("mouseup" == o) for (; a.parentNode;) a = a.parentNode;
          _(a, o, n), this.hActive = !0;
        }
      }
    }, t.prototype.removeEventListener = function (t, e, i) {
      var r = this.cbs,
        n = this.el;
      if (kr(t) && r.remove(t, e, i) && ! --this.cnt && this.hActive) {
        var o = this.getGlobalHandlers();
        for (var a in o) r.isListened(a) || w(n, a, o[a]);
        this.hActive = !1;
      }
    }, t;
  }(),
  Rr = function (t, e, i) {
    for (var r = !1, n = 0, o = i.length - 1; n < i.length; o = n++) {
      var a = i[n][0],
        s = i[n][1],
        l = i[o][0],
        u = i[o][1];
      s > e != u > e && t < (l - a) * (e - s) / (u - s) + a && (r = !r);
    }
    return r;
  },
  Nr = function () {
    function t(t, e) {
      this.map = t, this.dpr = e;
    }
    return t.prototype.pointToLineDistanceSq = function (t, e, i, r, n, o) {
      var a,
        s,
        l,
        u,
        h = n - i,
        f = o - r,
        c = h * h + f * f,
        p = -1;
      0 != c && (p = ((a = t - i) * h + (s = e - r) * f) / c);
      p < 0 ? (l = i, u = r) : p > 1 ? (l = n, u = o) : (l = i + p * h, u = r + p * f);
      var d = t - l,
        v = e - u;
      return this.sideOfLine = h * s - a * f < 0 ? -1 : 1, d * d + v * v;
    }, t.prototype.pointInPolygon = function (t, e, i) {
      for (var r = 0; r < i.length; r++) if (Rr(t, e, i[r]) != !r) return !1;
      return !0;
    }, t.prototype.pointInBox = function (t, e, i, r, n) {
      for (var o = 0, a = t; o < a.length; o++) {
        var s = a[o],
          l = s[0],
          u = s[1];
        if (l >= e && l <= i && u >= r && u <= n) return !0;
      }
    }, t.prototype.linesIntersectBox = function (t, e, i, r, n) {
      for (var o = [[e, n], [i, n], [i, r], [e, r], [e, n]], a = 0, s = t.length - 1; a < s; a++) for (var l = 0; l < o.length - 1; l++) if (j(t[a], t[a + 1], o[l], o[l + 1], !1)) return !0;
    }, t.prototype.getOffsetLineData = function (t, e, i) {
      for (var r = [], n = function (e) {
          var n = rt("offset", e, t, i) || 0;
          if (n && r.find(function (t) {
            return t.offset == n;
          })) return "continue";
          r.push({
            offset: n,
            width: .5 * ot("strokeWidth", e, t, i, !0)
          });
        }, o = 0, a = e; o < a.length; o++) {
        n(a[o]);
      }
      return r.length, r;
    }, t.prototype.geometry = function (t, e, i, r, n, o, a, s, l, u) {
      var h,
        f,
        c,
        p,
        d,
        v,
        y,
        g = !1,
        m = this.dpr,
        x = this.map,
        _ = !t && !e,
        w = this.screenX,
        b = this.screenY,
        T = 1;
      if ("Point" == r) {
        if (l = l || ht(n, a, s, m, o, u)) {
          var L = i[0],
            S = i[1],
            A = rt("alignment", n[0], a, s);
          if (A && "viewport" != A) L = (h = x._g2w(L, S))[0], S = h[1], w = this.worldX, b = this.worldY, T = 1 / x._s;else {
            var M = x.geoToPixel(L, S);
            L = M.x, S = M.y;
          }
          var z = L + l[0] * T,
            I = S + l[1] * T,
            P = L + l[2] * T,
            E = S + l[3] * T;
          f = w + t, c = b, p = b + e, d = z, v = I, y = E, g = w <= P && d <= f && c <= y && v <= p;
        }
      } else if ("LineString" == r) {
        l = l || lt(n, a, s, o, u);
        var C = i.length;
        if (l[0]) if (_) {
          var k = x.geoToPixel(i[0][0], i[0][1]),
            D = this.getOffsetLineData(a, n, s),
            O = void 0,
            F = void 0,
            R = void 0;
          D.length || (O = Math.pow(.5 * l[0], 2));
          for (var N = 1; N < C; N++) {
            if (F = x.geoToPixel(i[N][0], i[N][1]), R = this.pointToLineDistanceSq(w, b, k.x, k.y, F.x, F.y), D.length) {
              for (var B = 0, U = D; B < U.length; B++) {
                var W = U[B],
                  G = W.offset,
                  Z = W.width,
                  X = Math.pow(G - this.sideOfLine * Z, 2);
                if (G) {
                  if (R > X) {
                    if (g = R - Math.pow(G + this.sideOfLine * Z, 2) <= Z * Z) break;
                  }
                } else if (g = R <= Z * Z) break;
              }
              if (g) break;
            } else if (g = R <= O) break;
            k = F;
          }
        } else {
          var Y = .5 * l[0],
            H = x.pixelToGeo(w - Y, b - Y),
            j = x.pixelToGeo(w + Y, b + Y),
            V = H.longitude,
            q = j.longitude,
            K = j.latitude,
            Q = H.latitude;
          if (!(g = this.pointInBox(i, V, q, K, Q) || this.linesIntersectBox(i, V, q, K, Q))) return !1;
        }
      } else if ("Polygon" == r) {
        var $ = !1;
        if (!n.find(function (t) {
          var e = rt("type", t, a, s);
          return $ = $ || "Line" == e, "Polygon" == e;
        })) return $ && this.geometry(t, e, i, "MultiLineString", n, o, a, s, null, u);
        if (_) {
          var J = x.pixelToGeo(w, b),
            tt = J.longitude,
            et = J.latitude;
          if (!(g = this.pointInPolygon(tt, et, i))) return !1;
        } else {
          H = x.pixelToGeo(w - t, b - t), j = x.pixelToGeo(w + t, b + t), V = H.longitude, q = j.longitude, K = j.latitude, Q = H.latitude;
          for (var it = 0; it < i.length && !(g = this.pointInBox(i[it], V, q, K, Q)); it++);
          if (!g) {
            var nt = x.pixelToGeo(w, b);
            tt = nt.longitude, et = nt.latitude;
            if (!(g = this.pointInPolygon(tt, et, i) || this.linesIntersectBox(i[0], V, q, K, Q))) return !1;
          }
        }
        l = l || [st(n, a, s, o)];
      } else {
        var ot = void 0;
        if ("MultiPolygon" == r ? (ot = "Polygon", l = l || [st(n, a, s, o)]) : "MultiPoint" == r ? (ot = "Point", l = l || ht(n, a, s, m, o)) : "MultiLineString" == r && (ot = "LineString", l = l || lt(n, a, s, o)), ot) {
          it = 0;
          for (var at = i.length; it < at; it++) if (this.geometry(t, e, i[it], ot, n, o, a, s, l, u)) {
            g = !0;
            break;
          }
        }
      }
      return g && l;
    }, t.prototype.init = function (t, e) {
      var i;
      this.screenX = t, this.screenY = e, i = this.map._unprj(t, e), this.worldX = i[0], this.worldY = i[1];
    }, t.prototype.feature = function (t, e, i, r, n, o, a) {
      return this.geometry(t, e, i.geometry.coordinates, i.geometry.type, r, n, i, o, null, a);
    }, t;
  }(),
  Br = Array.from({
    length: 33
  }, function (t, e) {
    return 32 * Math.pow(2, Math.max(0, e - 20 + 3));
  }),
  Ur = function (t) {
    return "number" == typeof t;
  },
  Wr = function () {
    function t(t, e) {
      this.map = t, this.hit = new Nr(t, e);
    }
    return t.prototype.getFeaturesInRect = function (t, e, i, r, n, o) {
      var a,
        s,
        l,
        u = this.map,
        h = this.hit,
        f = u.getZoomlevel(),
        c = Br[Math.ceil(f)],
        p = 0 ^ Math.min(20, f),
        d = {},
        v = (i - t) / 2,
        y = (r - e) / 2,
        g = t + v,
        m = e + y,
        x = 180,
        _ = -180,
        w = 180,
        b = -180;
      t = (a = u._unprj(t, e))[0], e = a[1], i = (s = u._unprj(i, r))[0], r = s[1];
      for (var T, L, S, A, M, z, I, P, E = [u._w2g(t - c, e - c), u._w2g(i + c, r + c), u._w2g(t - c, r + c), u._w2g(i + c, e - c)], C = 4, k = []; C--;) {
        var D = E[C][0],
          O = E[C][1];
        D < x && (x = D), D > _ && (_ = D), O < w && (w = O), O > b && (b = O);
      }
      T = [x, w, _, b], n && !Array.isArray(n) && (n = []), h.init(g, m);
      for (var F = n.length; F--;) if (L = null === (l = (S = n[F]).getProvider) || void 0 === l ? void 0 : l.call(S, f), f <= S.max && f >= S.min && (null == L ? void 0 : L.search)) for (z = (M = L.search(T)).length; z--;) if (A = M[z], (I = S.getStyleGroup(A, p)) && (P = h.feature(v, y, A, I, F, f, o))) {
        var R = P[P.length - 1],
          N = d[R] = d[R] || [];
        (N[F] = N[F] || []).push(A);
      }
      for (var B = {
          layer: null,
          features: null
        }, U = 0, W = Object.keys(d).sort(function (t, e) {
          return Number(t) - Number(e);
        }); U < W.length; U++) for (var G = d[W[U]], Z = 0, X = void 0; Z < G.length; Z++) if (X = G[Z]) {
        var Y = n[Z];
        B.layer == Y ? B.features = B.features.concat(X) : k.push({
          layer: Y,
          features: X
        });
      }
      return k;
    }, t.prototype.search = function (t, e, i, r, n, o) {
      var a = this.map._layers;
      if (n = n ? n.slice().sort(function (t, e) {
        return Number(a.indexOf(t) > a.indexOf(e));
      }) : a, Ur(t) && Ur(e) && Ur(i) && Ur(r)) return this.getFeaturesInRect(t, e, i, r, n, o);
    }, t;
  }(),
  Gr = _xyzMapsCommon.global.setTimeout,
  Zr = _xyzMapsCommon.global.setInterval,
  Xr = 100,
  Yr = function (t, e, i) {
    var r;
    return "function" == typeof Event ? r = new Event(t) : (r = document.createEvent("Event")).initEvent(t, !0, !0), r.detail = r.data = {
      map: e,
      layer: i
    }, r;
  },
  Hr = function () {
    function e(e, i, r) {
      this.watchTimer = null, this.map = e, this.trigger = i, this.renderInfo = r, Xr = _xyzMapsCommon.global.__XYZTST_MVCEDelayMs || Xr, this.changeWatcher = this.changeWatcher.bind(this), this.readyWatcher = this.readyWatcher.bind(this);
    }
    return e.prototype.centerChanged = function (t) {
      return this.center.longitude != t.longitude || this.center.latitude != t.latitude;
    }, e.prototype.vpChanged = function (t, e, i) {
      var r = this,
        n = r.viewport,
        o = r.rz,
        a = r.rx;
      return !(n.minLon != t.minLon || n.maxLon != t.maxLon || n.minLat != t.minLat || n.maxLat != t.maxLat || o != e || a != i);
    }, e.prototype.changeWatcher = function () {
      var t = this,
        e = t.map,
        i = t.readyTimer,
        r = t.watchTimer,
        n = t.viewport;
      t.center;
      var o = e.getViewBounds(),
        a = e.getCenter(),
        s = e.rotate(),
        l = e.pitch(),
        u = "mapviewchange",
        h = {
          changed: {
            center: !0
          }
        };
      if (n) {
        if (h.changed.center = this.centerChanged(a), this.vpChanged(o, s, l)) return clearInterval(r), this.watchTimer = this.viewport = this.rz = this.rx = null, i && clearTimeout(i), this.readyTimer = Gr(this.readyWatcher, Xr);
        this.viewport = o, this.rz = s, this.rx = l, this.center = a;
      } else this.triggeredLayers = {}, u = "mapviewchangestart", this.viewport = o, this.rz = s, this.center = a, this.endTriggered = !0;
      this.trigger(u, h, true);
    }, e.prototype.readyWatcher = function () {
      var t,
        e,
        i,
        r = this.map,
        n = this.triggeredLayers,
        o = this.renderInfo.getLayers(),
        a = !0;
      if (this.endTriggered) {
        this.endTriggered = !1;
        var s = r.getCenter();
        this.trigger("mapviewchangeend", {
          changed: {
            center: this.centerChanged(s)
          }
        }, true);
      }
      for (var l = 0; l < o.length; l++) if (i = (t = (e = o[l]).layer).id, e.ready) {
        if (!n[i] && (n[i] = !0, !e.error)) {
          var u = Yr("viewportReady", r, t);
          t._l.trigger("viewportReady", u, !0);
        }
      } else a = !1;
      a || (this.readyTimer = Gr(this.readyWatcher, Xr));
    }, e.prototype.watch = function (t) {
      var e = this.readyTimer,
        i = this.watchTimer;
      e && (clearTimeout(e), this.readyTimer = null), t ? i || (this.watchTimer = Zr(this.changeWatcher, 33.333333333333336)) : i && (clearInterval(i), this.watchTimer = null);
    }, e;
  }(),
  jr = function () {
    function t(t, e, i, r) {
      this._v = !0;
      var n = this;
      n.map = i, n.cPrefix = t.className + "-ui-", n.parent = t, n.opt = e, e.visible && (n.create(t, e), n.enable());
    }
    return t.prototype.show = function () {
      var t = this;
      t.html || t.create(t.parent, t.opt), t.html.style.display = "inline";
    }, t.prototype.hide = function () {
      var t = this.html;
      t && (t.style.display = "none");
    }, t.prototype.enable = function () {
      this.active = !0, this.toggleListeners(!0);
    }, t.prototype.disable = function () {
      this.active = !1, this.toggleListeners(!1);
    }, t.prototype.destroy = function () {
      var t = this;
      t.disable(), t.parent.removeChild(t.html);
    }, t.prototype.toggleListeners = function (t) {
      var e = this,
        i = e.listeners,
        r = function (r) {
          var n = e.querySelectorAll(r),
            o = function (o) {
              n.forEach(function (n) {
                var a = i[r][o];
                t ? n.addEventListener(o, i[r][o]._ = a.bind(e)) : n.removeEventListener(o, a._);
              });
            };
          for (var a in i[r]) o(a);
        };
      for (var n in i) r(n);
    }, t.prototype.insertRule = function (t, e) {
      var i,
        r = (Or = Or || (i = document.createElement("style"), document.head.appendChild(i), i)).sheet;
      r.insertRule ? r.insertRule(t + " {" + e + "}", r.cssRules.length) : r.addRule && r.addRule(t, e);
    }, t.prototype.create = function (t, e) {
      var i = this.templ.replace(/class\=\"/g, 'class="' + this.cPrefix);
      i = i.replace(/\>[\s]+\</g, "><");
      var r,
        n = (r = i, new DOMParser().parseFromString(r, "text/html").body.childNodes[0]),
        o = n.style,
        a = e.position,
        s = "." + t.className + " ";
      for (var l in a) o[l] = a[l];
      if (this.style) for (var u in this.style) this.insertRule(s + this.prefixClass(u), this.style[u]);
      this.html = t.appendChild(n);
    }, t.prototype.prefixClass = function (t) {
      return t = t.replace(/\./g, "." + this.cPrefix);
    }, t.prototype.querySelector = function (t) {
      return this.html.querySelector(this.prefixClass(t));
    }, t.prototype.querySelectorAll = function (t) {
      return this.html.querySelectorAll(this.prefixClass(t));
    }, t;
  }(),
  Vr = function (t) {
    function e(e, i, r, n) {
      var o = t.call(this, e, i, r) || this;
      return o.maxPitch = n.maxPitch, o;
    }
    return y(e, t), e.prototype.enable = function () {
      t.prototype.enable.call(this);
      var e = this.querySelector(".needle"),
        i = this.map;
      i.addEventListener("mapviewchange", this._rl = function (t) {
        e.style.transform = "rotate(".concat(i.rotate(), "deg) rotateX(").concat(i.pitch(), "deg) scale(0.7,1.1)");
      }), this._rl();
    }, e.prototype.disable = function () {
      t.prototype.disable.call(this), this.map.removeEventListener("mapviewchange", this._rl), this.a && (this.a.stop(), this.a = null);
    }, e;
  }(jr);
Vr.prototype.listeners = {
  ".needle": {
    click: function (t) {
      return m(this, void 0, void 0, function () {
        var t, e, i, r;
        return x(this, function (n) {
          switch (n.label) {
            case 0:
              return this.aip ? [3, 2] : (t = this.map, e = t.rotate(), i = t.pitch(), r = [0, 0], e || i || (r = [0, this.maxPitch]), this.a = new Mr([e, i], r, 500, "easeOutCubic", function (e) {
                t.rotate(e[0]), t.pitch(e[1]);
              }), [4, this.a.start()]);
            case 1:
              n.sent(), this.a = null, n.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }
  }
}, Vr.prototype.style = {
  ".compass": "        position: absolute;        right:  10px;        bottom: 96px;        text-align: center;        font-family: sans-serif;        color: white;        height: 28px;        background-color: #0f1621;        user-select: none;        border-radius: 4px;        font-size: 12px;        width: 28px;        margin: 2px;        overflow: hidden;",
  ".compass .needle": "        padding: 4px 0px;        line-height: 10px;",
  ".compass:hover": "        background-color: #383c45;        cursor: pointer;"
}, Vr.prototype.templ = '<div class="compass">        <div class="needle">&#9650;<br>&#9661;</div>    </div>';
var qr = function (t) {
  function e(e, i, r, n) {
    var o = t.call(this, e, i, r) || this;
    o.ams = 250;
    var a = o;
    return n && n.zoomAnimationMs && (a.ams = n.zoomAnimationMs), o;
  }
  return y(e, t), e.prototype.enable = function () {
    t.prototype.enable.call(this);
    var e = this.querySelector(".info"),
      i = this.map;
    e.innerText = i.getZoomlevel(), i.addEventListener("mapviewchangeend", this._zll = function (t) {
      e.innerText = Math.round(10 * i.getZoomlevel()) / 10;
    });
  }, e.prototype.disable = function () {
    t.prototype.disable.call(this), this.map.removeEventListener("mapviewchangeend", this._zll);
  }, e;
}(jr);
qr.prototype.listeners = {
  ".zoomBtn": {
    click: function (t) {
      var e = 0 ^ t.srcElement.getAttribute("dir");
      this.map.setZoomlevel(this.map.getZoomlevel() + e, this.ams);
    }
  }
}, qr.prototype.style = {
  ".zoomctrl": "        position: absolute;        right:  10px;        bottom: 20px;        text-align: center;        font-family: sans-serif;        color: white;        user-select: none;",
  ".zoomctrl div": "        background-color: #0f1621;        border-radius: 4px;        font-size: 12px;        width: 28px;        margin: 2px;",
  ".zoomctrl .zoomBtn": "        height: 28px;        font-size: 32px;        /* border: 1px solid white; */        line-height: 22px;        font-weight: 200;",
  ".zoomctrl .zoomBtn:hover": "        background-color: #383c45;        cursor: pointer;"
}, qr.prototype.templ = '<div class="zoomctrl">         <div class="zoomBtn" dir="1">+</div>         <div class="info">L</div>        <div class="zoomBtn" dir="-1">-</div>     </div>';
var Kr = function (t) {
  function e(e, i, r) {
    return t.call(this, e, i, r) || this;
  }
  return y(e, t), e.prototype.add = function (t) {
    var e, i, r, n, o;
    e = "div", i = this.prefixClass(".src").substr(1), r = "Â© " + t.label, n = this.html, o = document.createElement(e), i && (o.className = i), r && (o.innerText = r), n && n.appendChild(o);
  }, e.prototype.setData = function (t) {
    var e = this;
    if (e.data = t, e.html) {
      e.html.innerText = "";
      for (var i = 0, r = t; i < r.length; i++) {
        var n = r[i];
        e.add(n);
      }
    }
  }, e;
}(jr);
Kr.prototype.style = {
  ".copyright-popup": "        user-select: none;        background-color: rgba(0,0,0,0.1);        position: absolute;        bottom: 15px;        padding: 2px;        right: 120px;        z-index: 1;        width:  auto;        color: #fff;        font-family: arial;        font-size: 11px;        opacity: 0.8;        height: auto;",
  ".src": "        opacity: 0.8;        margin: 4px;    "
}, Kr.prototype.templ = '<div class="copyright-popup"></div>';
var Qr = _xyzMapsCommon.global.document,
  $r = function (t, e) {
    var i,
      r,
      n,
      o = t.scopes,
      a = o.length;
    if (!a) return true;
    for (; i = o[--a];) {
      var s = i.layer.getProvider(e),
        l = s && s.level || e;
      if (r = i.minLevel || -1 / 0, n = i.maxLevel || 1 / 0, l >= r && l <= n) return true;
    }
    return false;
  },
  Jr = function (t, e) {
    t.style.display = e ? "inline" : "none";
  },
  tn = {
    defaultOwner: "XYZ",
    termsAndConditions: {
      label: "Terms and Conditions",
      url: !1
    }
  },
  en = function (t) {
    function e(e, i, r) {
      var n = t.call(this, e, _xyzMapsCommon.JSUtils.extend(!0, _xyzMapsCommon.JSUtils.clone(tn), i), r) || this;
      n.sources = new _xyzMapsCommon.Map(), n.sLen = 0, n.srcWidth = 0;
      var s = n,
        l = s.opt,
        u = l.termsAndConditions,
        h = l.defaultOwner;
      return s.$src = s.querySelector(".sources"), s.$cDefault = s.querySelector(".cDefault"), s.$btn = s.querySelector(".btn"), n.details = new Kr(e, {
        visible: !1
      }, r), n.setDefaultOwner(h), n.setTermsAndConditions(u), n;
    }
    return y(e, t), e.prototype.setTermsAndConditions = function (t) {
      var e = t.url,
        i = t.label,
        r = this.querySelector(".terms");
      e ? (r.lastChild.href = e, i && (r.lastChild.innerText = i)) : Jr(r, false);
    }, e.prototype.setDefaultOwner = function (t) {
      "string" == typeof t && this.setOwnerLabel(this.$cDefault, t);
    }, e.prototype.enable = function () {
      var e = this;
      t.prototype.enable.call(this), e.map.addObserver("zoomlevel", e.onZoomChange = function (t, i, r) {
        Math.abs((0 ^ i) - (0 ^ r)) && (e.sources.forEach(function (t) {
          Jr(t.el, $r(t, i));
        }), e.showDetails(!1), e.handleOverflow());
      }), e.map.addEventListener("addLayer removeLayer", e.onLayerChange = function (t) {
        var i = t.detail.layer;
        i.getCopyright(function (r) {
          e.active && ("addLayer" == t.type ? r.forEach(function (t) {
            return e.addSource(t, i);
          }) : r.forEach(function (t) {
            return e.removeSource(t, i);
          }));
        });
      }), e.map.addEventListener("resize", e.onResize = function () {
        return e.handleOverflow();
      });
    }, e.prototype.disable = function () {
      var e = this;
      t.prototype.disable.call(this), e.map.removeObserver("zoomlevel", e.onZoomChange), e.map.removeEventListener("addLayer removeLayer", e.onLayerChange), e.map.removeEventListener("resize", e.onResize);
    }, e.prototype.getSourceLabelsString = function () {
      for (var t = 0 ^ this.map.getZoomlevel(), e = "", i = 0, r = this.sources.values(); i < r.length; i++) {
        var n = r[i];
        $r(n, t) && (e += "Â© ".concat(n.label, " "));
      }
      return e;
    }, e.prototype.getColors = function () {
      return {
        color: window.getComputedStyle(this.$cDefault).getPropertyValue("color"),
        backgroundColor: window.getComputedStyle(this.html).getPropertyValue("background-color")
      };
    }, e.prototype.calcWidth = function () {
      var t = 0 ^ this.map.getZoomlevel(),
        e = this.sources,
        i = 0;
      return e.forEach(function (e) {
        i += $r(e, t) && e.width;
      }), i;
    }, e.prototype.handleOverflow = function () {
      var t = this,
        e = t.$btn,
        i = t.map.getWidth(),
        r = t.calcWidth(),
        n = i - 132 ^ 0;
      t.$src.style.width = (n < r ? n - 10 : r) + "px", r > Math.min(n, 384) ? Jr(e, true) : (Jr(e, false), t.showDetails(!1));
    }, e.prototype.showDetails = function (t) {
      var e = this,
        i = e.details,
        r = e.map.getZoomlevel();
      e.$btn.innerText = t ? "-" : "+", t ? (i.show(), i.setData(e.sources.values().filter(function (t) {
        return $r(t, r);
      }))) : i.hide();
    }, e.prototype.setOwnerLabel = function (t, e) {
      t.innerText = "Â© " + e;
    }, e.prototype.addSource = function (t, e) {
      var i,
        r = this,
        n = r.sources,
        o = t.label,
        a = t.scopes,
        s = 0 ^ r.map.getZoomlevel(),
        l = n.get(o);
      l ? (i = l.el, l.cnt++) : ((i = Qr.createElement("span")).className = this.prefixClass(".source").substr(1), r.setOwnerLabel(i, o), r.$src.appendChild(i), l = {
        label: o,
        scopes: [],
        el: i,
        cnt: 1,
        width: i.getBoundingClientRect().width
      }, n.set(o, l), r.sLen++, r.srcWidth += l.width), null != a && a.forEach(function (t) {
        return l.scopes.push({
          minLevel: t.minLevel,
          maxLevel: t.maxLevel,
          layer: e
        });
      }), Jr(r.$cDefault, false), Jr(i, $r(l, s)), r.handleOverflow();
    }, e.prototype.removeSource = function (t, e) {
      var i,
        r,
        n = this,
        o = t.label,
        a = n.sources.get(o);
      if (a) {
        if (r = a.scopes, i = t.scopes) for (var s = 0, l = void 0; s < i.length; s++) {
          l = i[s];
          for (var u = 0, h = void 0; s < r.length; u++) if ((h = r[u]).layer == e && h.minLevel == l.minLevel && h.maxLevel == l.maxLevel) {
            r.splice(u, 1);
            break;
          }
        }
        --a.cnt || (n.$src.removeChild(a.el), n.sources.delete(o), n.handleOverflow(), --n.sLen || Jr(n.$cDefault, true));
      }
    }, e;
  }(jr);
en.prototype.listeners = {
  ".btn": {
    click: function (t) {
      var e = "+" == this.$btn.innerText;
      this.showDetails(e);
    }
  }
}, en.prototype.style = {
  ".copyright *": "        color: rgba(255,255,255,.8);        font-family: arial;        text-decoration: none;",
  ".copyright": "        right: 0px;        bottom: 0px;        padding: 1px 4px;        margin: 0px;        background-color: rgba(0,0,0,.1);        position: absolute;        font-size: 11px;        line-height: 13px;        overflow: hidden;        white-space: nowrap;        user-select: none;",
  ".sources": "        width:auto;        max-width: 384px;        float: left;        white-space: nowrap;        overflow: hidden;        text-overflow: ellipsis;        border-right: 2px;",
  ".btn": "        display: none;        font-family: sans-serif;        font-weight: bold;        text-align: center;        height: 12px;        width: 12px;        float: left;        padding: 0px;        line-height: 9px;        margin: 1px 2px 0px;        background-color: inherit;        box-sizing: border-box;        border-radius: 3px;        border: 1px solid;",
  ".terms, .cDefault, .source": "        white-space: nowrap;        padding-right: 4px;"
}, en.prototype.templ = '<div class="copyright">        <span style="float: left; white-space: nowrap;">            <span class="sources"></span>            <span class="cDefault"></span>         </span>        <span class="tac" style="float: right; white-space: nowrap;">            <span class="btn">+</span>            <span class="terms" style="white-space: nowrap;">|            <a target="_blank" style="white-space: nowrap;" href="">Terms and Conditions</a></span>        </span>    </div>';
var rn = function (t) {
  function e(e, i, r) {
    var n = t.call(this, e, i, r) || this,
      o = i.url;
    return o && n.setSrc(o), n;
  }
  return y(e, t), e.prototype.setSrc = function (t) {
    this.html.style.backgroundImage = "url(".concat(t, ")");
  }, e.prototype.getImage = function () {
    var t = window.getComputedStyle(this.html),
      e = Math.round(parseFloat(t.getPropertyValue("width"))),
      i = Math.round(parseFloat(t.getPropertyValue("height")));
    return new Promise(function (r) {
      var n = new Image();
      n.onload = function () {
        return r({
          img: n,
          width: e,
          height: i
        });
      }, n.src = t.getPropertyValue("background-image").slice(5, -2);
    });
  }, e;
}(jr);
rn.prototype.style = {
  ".logo": "        position: absolute;        bottom: 6px;        left: 6px;        z-index: 1;        margin:  0px;        background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjdweCIgaGVpZ2h0PSIzMnB4IiB2aWV3Qm94PSIwIDAgMjcgMzIiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjYgKDY3NDkxKSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5Hcm91cCAzPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Ikdyb3VwLTMiPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aCIgZmlsbD0iIzA0QjZDOCIgcG9pbnRzPSItNy44NjQyMTYxOWUtMTQgOSAxMyAxNS45Njg4NjgxIDEzIDMyIDAgMjQuNDc4MDIyNiI+PC9wb2x5Z29uPgogICAgICAgICAgICA8cG9seWdvbiBpZD0iUGF0aCIgZmlsbD0iIzBBNTdENCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAuNTAwMDAwLCAyMC41MDAwMDApIHNjYWxlKC0xLCAxKSB0cmFuc2xhdGUoLTIwLjUwMDAwMCwgLTIwLjUwMDAwMCkgIiBwb2ludHM9IjE0IDkgMjcgMTUuOTY4ODY4MSAyNyAzMiAxNCAyNC40NzgwMjI2Ij48L3BvbHlnb24+CiAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJQYXRoLTIiIGZpbGw9IiMwQTk0REUiIHBvaW50cz0iMCA3Ljc5MTIyNDMxIDEzLjU1MDIxNTEgMCAyNyA3Ljc5MTIyNDMxIDEzLjU1MDIxNTEgMTUiPjwvcG9seWdvbj4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==);        background-repeat: no-repeat;        background-size: contain;        width: 32px;        height: 32px;        cursor: pointer;"
}, rn.prototype.templ = '<div class="logo"></div>';
var nn,
  on = {
    Compass: Vr,
    ZoomControl: qr,
    Copyright: en,
    Logo: rn
  },
  an = function () {
    function t(t, e, i) {
      var r = g({}, e.UI || e.ui || {}),
        n = this.components = {};
      for (var o in this.el = t, null != r.HERE && (r.Logo = r.HERE), on) {
        var a = r[o];
        !1 !== a && ("object" != typeof a && (a = {}), null == a.visible && (a.visible = !0), a.visible && (n[o] = new on[o](t, a, i, e)));
      }
    }
    return t.initComponentOptions = function () {}, t.prototype.get = function (t) {
      return this.components[t];
    }, t.prototype.destroy = function () {
      var t = this.components;
      for (var e in t) t[e].destroy(), delete t[e];
    }, t;
  }(),
  sn = _xyzMapsCommon.JSUtils.isFunction,
  ln = function () {
    function t(t) {
      void 0 === t && (t = {}), this.animation = null;
      this.easing = t.easing, sn(t.onStart) && (this.onStart = t.onStart), sn(t.onStop) && (this.onStop = t.onStop);
    }
    return t.prototype.onStart = function () {}, t.prototype.onStop = function () {}, t.prototype.animate = function (t, e, i, r) {
      return m(this, void 0, void 0, function () {
        var n;
        return x(this, function (o) {
          switch (o.label) {
            case 0:
              return (n = this).active ? [3, 2] : (n.active = !0, n.onStart(), n.animation = new Mr(t, e, i, this.easing, r), [4, n.animation.start()]);
            case 1:
              o.sent(), n.onStop(), n.active = !1, n.animation = null, o.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, t.prototype.stop = function () {
      var t;
      null === (t = this.animation) || void 0 === t || t.stop();
    }, t;
  }(),
  un = function (t) {
    function e(e, i) {
      void 0 === i && (i = {});
      var r = this;
      return i.easing = i.easing || "easeOutCubic", (r = t.call(this, i) || this).map = e, r;
    }
    return y(e, t), e.prototype.start = function (t, e, i, r) {
      var n = this.map;
      this.animate(n.getZoomlevel(), t, r, function (t) {
        n.setZoomlevel(t, e, i);
      });
    }, e;
  }(ln),
  hn = _xyzMapsCommon.JSUtils.isFunction,
  fn = function () {
    function t(t, e) {
      e = e || {};
      var i = this;
      i.map = t, i.duration = e.duration || 500, hn(e.onStart) && (i.onStart = e.onStart), hn(e.onStop) && (i.onStop = e.onStop), i.raf = function () {
        i._pan() && (i.rafId = requestAnimationFrame(i.raf));
      };
    }
    return t.prototype._pan = function () {
      var t = this,
        e = t.deltaX,
        i = t.deltaY,
        r = t.duration,
        n = t.startTs,
        o = Math.min(Date.now() - n, r) / r,
        a = Sr(o) * e,
        s = Sr(o) * i;
      if (t.map.pan(a - t.lastDx || 0, s - t.lastDy || 0), a != e || s != i) return t.lastDx = a, t.lastDy = s, !0;
      t.onStop();
    }, t.prototype.pan = function (t, e, i) {
      this.startTs = t, this.deltaX = e, this.deltaY = i, this.onStart(), this.raf();
    }, t.prototype.cancel = function () {
      var t = this.rafId;
      t && (cancelAnimationFrame(t), this.rafId = null), this.onStop(), this.startTs = 0, this.lastDx = 0, this.lastDy = 0;
    }, t.prototype.onStart = function () {}, t.prototype.onStop = function () {}, t;
  }(),
  cn = {
    ui: {},
    behavior: {
      drag: !0,
      pitch: !1,
      rotate: !1
    },
    rotate: 0,
    pitch: 0,
    zoomlevel: 18,
    center: {
      longitude: 8.534,
      latitude: 50.162
    },
    layers: null,
    maxLevel: 20,
    minLevel: 2,
    debug: !1,
    minPanMapThreshold: 4,
    minRotateMapThreshold: 4,
    minPitchMapThreshold: 4,
    zoomAnimationMs: 100,
    maxPitch: 50
  },
  pn = function (t) {
    function e(e, i) {
      void 0 === i && (i = {});
      var r = this;
      return i.easing = i.easing || "easeOut", (r = t.call(this, i) || this).map = e, r;
    }
    return y(e, t), e.prototype.start = function (t, e, i) {
      var r = this.map,
        n = r.getZoomlevel(),
        o = r._worldSizeFixed,
        a = r.getCenter(),
        s = _xyzMapsCore.webMercator.lon2x(a.longitude, o),
        u = _xyzMapsCore.webMercator.lat2y(a.latitude, o),
        h = _xyzMapsCore.webMercator.lon2x(t.longitude, o),
        c = _xyzMapsCore.webMercator.lat2y(t.latitude, o),
        p = Math.max(r.getWidth(), r.getHeight()),
        d = p / Math.pow(2, e - n),
        v = H(h, c, s, u) || 1,
        y = 1.42,
        g = 2.0164,
        m = function (t) {
          return (Math.exp(t) - Math.exp(-t)) / 2;
        },
        x = function (t) {
          return (Math.exp(t) + Math.exp(-t)) / 2;
        },
        _ = function (t) {
          var e = (d * d - p * p + (t ? -1 : 1) * g * g * v * v) / (2 * (t ? d : p) * g * v);
          return Math.log(Math.sqrt(e * e + 1) - e);
        },
        w = _(0),
        b = function (t) {
          return p * (x(w) * (m(e = w + y * t) / x(e)) - m(w)) / g;
          var e;
        },
        T = (_(1) - w) / y,
        L = p * Math.pow(2, n);
      i = i || 1e3 * T * .77, this.animate(0, T, i, function (i) {
        var a,
          d,
          g = b(i) / v,
          m = s + (h - s) * g,
          _ = u + (c - u) * g;
        i >= T ? (a = t, d = e) : (a = new _xyzMapsCore.GeoPoint(_xyzMapsCore.webMercator.x2lon(m, o), _xyzMapsCore.webMercator.y2lat(_, o)), d = Math.log(L / function (t) {
          return p * (x(w) / x(w + y * t));
        }(i)) / Math.LN2, d = isNaN(d) ? n : d), r.setZoomlevel(d), r.setCenter(a);
      });
    }, e;
  }(ln),
  dn = _xyzMapsCore.webMercator,
  vn = _xyzMapsCore.webMercator.earthCircumference,
  yn = "fixed",
  gn = "longitude",
  mn = "latitude",
  xn = [];
function _n(t, e, i, r, n, o) {
  for (var a, s, l, u = 256 * Math.pow(2, 20), h = 20; h >= 0; --h) if (l = 20 - h, a = (dn.lon2x(i, u) >> l) - (dn.lon2x(t, u) >> l), s = (dn.lat2y(e, u) >> l) - (dn.lat2y(r, u) >> l), a <= n && s <= o) return h;
  return 0;
}
var wn = function () {
    function t(t, e) {
      this._s = 1, this._rz = 0, this._rx = 0, this._cWorldFixed = new _xyzMapsCore.PixelPoint(0, 0), this._cWorld = new _xyzMapsCore.PixelPoint(0, 0), this._c = new _xyzMapsCore.GeoPoint(0, 0), this._pc = new _xyzMapsCore.GeoPoint(0, 0), this._ox = 0, this._oy = 0, this._cfg = e = _xyzMapsCommon.JSUtils.extend(!0, _xyzMapsCommon.JSUtils.extend(!0, {}, cn), e || {});
      var i = this;
      this._w = b(t, "width"), this._h = b(t, "height"), this._cx = this._w / 2, this._cy = this._h / 2;
      var r = e.zoomLevel || e.zoomlevel;
      e.maxLevel = Math.min(28, e.maxLevel), e.maxPitch = Math.min(85, e.maxPitch), this._z = 0 ^ Math.min(20, r), this._worldSizeFixed = 256 * Math.pow(2, this._z), this._worldSize = 256 * Math.pow(2, r), this._l = new _xyzMapsCommon.Listener(["center", "rotation", "zoomlevel", "mapviewchangestart", "mapviewchange", "mapviewchangeend", "resize", "addLayer", "removeLayer"]);
      var a = this._l,
        s = [],
        l = t;
      i._layers = s, i.id = 1e6 * Math.random() ^ 0, (t = document.createElement("div")).className = "_" + _xyzMapsCommon.JSUtils.String.random(11), t.style["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", t.style.position = "relative", t.style.width = this._w + "px", t.style.height = this._h + "px", l.appendChild(t), this._el = t;
      var u = "canvas" == e.renderer ? wr : Ki;
      "string" == typeof u.zoomBehavior && (yn = u.zoomBehavior);
      var h = new u(t, 256, e.devicePixelRatio, e.renderOptions || {});
      i._mvcRecognizer = new Hr(i, function (t, e, i) {
        a.trigger(t, [new Er(t, e)], i);
      }, h), i._display = h, this._search = new Wr(i, h.dpr);
      var c = this._evDispatcher = new Fr(t, i, s, e);
      a.add("mapviewchangestart", function (t) {
        return c.disable("pointerenter");
      }), a.add("mapviewchangeend", function (t) {
        return c.enable("pointerenter");
      }), a.add("mapviewchangeend", function (t) {
        return h.viewChangeDone();
      }), this._zoomAnimator = new un(i), this._flightAnimator = new pn(i);
      var d = g(g({}, e.behavior), e.behaviour);
      d.zoom == nn && (d.zoom = yn);
      var v = this._b = new Pr(t, i, new fn(i), d, e);
      v.drag(!0), v.scroll(!0), this._vplock = {
        pan: !1,
        minLevel: e.minLevel,
        maxLevel: e.maxLevel
      };
      var y = e.UI || e.ui || {};
      y.Compass == nn && (y.Compass = d.rotate || d.pitch), this.ui = new an(t, e, i), i.setCenter(e.center), i.pitch(e.pitch), i.rotate(e.rotate), i.setZoomlevel(r), i._layerClearListener = i._layerClearListener.bind(i);
      for (var m = 0, x = e.layers || []; m < x.length; m++) {
        var _ = x[m];
        i.addLayer(_);
      }
      xn.push(this), e.debug && this.debug(e.debug);
    }
    return t.getInstances = function () {
      return xn.slice();
    }, t.prototype._layerClearListener = function (t) {
      this.refresh(t.detail.layer);
    }, t.prototype.initViewPort = function () {
      var t = this._s,
        e = this._worldSizeFixed,
        i = this._cWorldFixed.x,
        r = this._cWorldFixed.y,
        n = this._w / 2,
        o = this._h / 2,
        a = i - n / t,
        s = r - o / t;
      this._tlwx = a, this._tlwy = s, this._ox = i - n - a, this._oy = r - o - s;
      var l = dn.x2lon(a, e),
        u = dn.y2lat(s, e),
        h = i + n / t,
        f = r + o / t,
        p = dn.x2lon(h, e),
        d = dn.y2lat(f, e);
      return this._vp = new _xyzMapsCore.GeoRect(l, d, p, u), [i / e, r / e];
    }, t.prototype.updateGrid = function () {
      var t = this._display,
        e = this._c,
        i = this._pc;
      this._mvcRecognizer.watch(!0), this._groundResolution = vn(e.latitude) / this._worldSizeFixed, t.setView(this.initViewPort(), this._s, this._rz, this._rx, this._groundResolution, this._worldSize), t.updateGrid(this._z, this._ox, this._oy), i[gn] == e[gn] && i[mn] == e[mn] || (this._l.trigger("center", ["center", e, i], !0), this._pc = e);
    }, t.prototype._clipLatitude = function (t) {
      return Math.min(85.05112878, Math.max(-85.05112878, t));
    }, t.prototype._setCenter = function (t, e) {
      var i = this._worldSizeFixed;
      return 2 != arguments.length && (t instanceof Array ? (e = t[1], t = t[0]) : (e = (t = t || this._c)[mn], t = t[gn])), !isNaN(t) && !isNaN(e) && "number" == typeof t && "number" == typeof e && (t > 180 ? t -= 360 : t < -180 && (t += 360), e = this._clipLatitude(e), this._c = new _xyzMapsCore.GeoPoint(t, e), this._cWorldFixed = new _xyzMapsCore.PixelPoint(dn.lon2x(t, i), dn.lat2y(e, i)), this._cWorld = new _xyzMapsCore.PixelPoint(dn.lon2x(t, this._worldSize), dn.lat2y(e, this._worldSize)), !0);
    }, t.prototype.repaint = function () {
      this.updateGrid();
    }, t.prototype.debug = function (t) {
      this._display.showGrid(t), this.updateGrid();
    }, t.prototype.pitch = function (t) {
      if (t !== nn) {
        var e = this._cfg.maxPitch,
          i = Math.max(0, Math.min(e, Math.round(t % 360 * 10) / 10));
        this._rx = -i * Math.PI / 180, this.updateGrid();
      }
      return 180 * -this._rx / Math.PI;
    }, t.prototype.rotate = function (t) {
      if (t !== nn) {
        var e = Math.round(10 * t || 0) * Math.PI / 1800,
          i = this._rz;
        if (e !== i) {
          var r = this._cx,
            n = this._cy,
            o = this._display.unproject(r, n),
            a = this._cWorldFixed;
          a.x += o[0] - r, a.y += o[1] - n, this._rz = e, this.updateGrid(), this._l.trigger("rotation", ["rotation", this._rz, i], !0);
        }
      }
      return this._rz / Math.PI * 180;
    }, t.prototype.setBackgroundColor = function (t) {
      this._display.setBGColor(t), this.refresh();
    }, t.prototype.addEventListener = function (t, e) {
      var i = this,
        r = this._l;
      t.split(" ").forEach(function (t) {
        if (r.isDefined(t)) return r.add(t, e);
        i._evDispatcher.addEventListener(t, e);
      });
    }, t.prototype.removeEventListener = function (t, e) {
      var i = this,
        r = this._l;
      t.split(" ").forEach(function (t) {
        if (r.isDefined(t)) return r.remove(t, e);
        i._evDispatcher.removeEventListener(t, e);
      });
    }, t.prototype.getViewBounds = function () {
      var t = this._vp,
        e = t.minLon,
        i = t.maxLon,
        r = t.minLat,
        n = t.maxLat;
      return r <= -85.05112878 && (r = -90), n >= 85.05112878 && (n = 90), e < -180 && (e = -180), i > 180 && (i = 180), new _xyzMapsCore.GeoRect(e, r, i, n);
    }, t.prototype.setViewBounds = function (t, e) {
      var i,
        r,
        n,
        o,
        a = arguments;
      if ("number" == typeof t ? t = [a[0], a[1], a[2], a[3]] : "FeatureCollection" == t.type ? t = t.features : "Feature" == t.type && (t = [t]), Array.isArray(t)) {
        if ("object" == typeof t[0]) {
          for (var s = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = 0, u = t; l < u.length; l++) {
            var h = u[l];
            _xyzMapsCore.utils.calcBBox(h, s);
          }
          t = s;
        }
        i = t[0], r = t[1], n = t[2], o = t[3];
      } else {
        var c = t;
        i = c.minLon, r = c.minLat, n = c.maxLon, o = c.maxLat;
      }
      var p = _n(i, r, n, o, this.getWidth(), this.getHeight()),
        v = new _xyzMapsCore.GeoPoint(i + (n - i) / 2, r + (o - r) / 2);
      e ? this.flyTo(v, p, !0 === e ? {} : e) : (this.setZoomlevel(p), this.setCenter(v));
    }, t.prototype.getFeatureAt = function (t, e) {
      e = e || {};
      var i = this.getFeaturesAt(t, e);
      if (i.length) {
        var r = i[i.length - 1];
        return r.feature = r.features[0], r;
      }
    }, t.prototype.getFeaturesAt = function (t, e) {
      var i,
        r,
        n,
        o,
        a = !1,
        s = (e = e || {}).layers;
      if (s && !Array.isArray(s) && (s = [s]), t.x != nn && t.y != nn) {
        var l = t.x,
          u = t.y,
          h = 0 ^ e.width,
          f = e.height || h;
        if (!h && !f) {
          a = !0;
          var c = this._display.getRenderedFeatureAt(l, u, s || this._layers);
          if (null != c.id) {
            var p = s[c.layerIndex],
              d = p.getProvider(0 ^ this.getZoomlevel()),
              v = (null == d ? void 0 : d.search) && d.search(c.id);
            if (v) return [{
              layer: p,
              features: [v]
            }];
          }
        }
        i = l - h / 2, r = l + h / 2, n = u - f / 2, o = u + f / 2;
      } else t.minX != nn && t.maxX != nn && (i = t.minX, n = t.minY, r = t.maxX, o = t.maxY);
      return i != nn && this._search.search(i, n, r, o, s, a);
    }, t.prototype.snapshot = function (t, e, i, r, n) {
      var o = this;
      if (t) {
        e || (e = 0), i || (i = 0), r || (r = this._w), n || (n = this._h), r + e > this._w && (r = this._w - e), n + i > this._h && (n = this._h - i);
        var a = this._display,
          s = a.dpr,
          l = a.copyCanvas2d(e, i, r, n),
          u = Math.ceil(11 / 3),
          h = this.ui.get("Copyright"),
          f = h.getSourceLabelsString(),
          c = h.getColors(),
          p = h.calcWidth();
        m(o, void 0, void 0, function () {
          var e, i;
          return x(this, function (o) {
            switch (o.label) {
              case 0:
                return [4, this.ui.get("Logo").getImage()];
              case 1:
                return e = o.sent(), (i = l.getContext("2d")).scale(s, s), i.font = "".concat(11, "px sans-serif"), i.textBaseline = "hanging", i.fillStyle = c.backgroundColor, i.fillRect(r - p - 2 * u, n - 11 - u, r + 2 * u, 11 + u), i.fillStyle = c.color, i.fillText(f, r - p - u, n - 11), i.drawImage(e.img, 2 * u, n - e.height - 2 * u), l.style.width = "".concat(r, "px"), l.style.height = "".concat(n, "px"), t(l), [2];
            }
          });
        });
      }
    }, t.prototype.getBehavior = function () {
      var t = {},
        e = this._b.getOptions();
      for (var i in e) t[i] = !!e[i];
      return t;
    }, t.prototype.setBehavior = function (t, e) {
      var i = typeof t,
        r = "object" == i ? t : {},
        n = this._b.getOptions();
      "string" == i && (r[t] = e);
      var o = r.zoom;
      o != nn && (n.zoom = "fixed" == o || "float" == o ? o : !!o && yn);
      for (var a = 0, s = ["drag", "pitch", "rotate"]; a < s.length; a++) {
        var l = s[a],
          u = r[l];
        u != nn && (n[l] = !!u);
      }
    }, t.prototype.getZoomlevel = function () {
      return this._z + Math.log(this._s) / Math.LN2;
    }, t.prototype.setZoomlevel = function (t, e, i, r) {
      var n = this._vplock,
        o = this._z,
        a = this._s;
      if (t = Math.round(1e3 * t) / 1e3, t = Math.max(Math.min(t, n.maxLevel), n.minLevel), 2 == arguments.length && (r = e, e = nn), e != nn && i != nn || (e = this._cx, i = this._cy), o != t || 1 != a) if (this._worldSize = 256 * Math.pow(2, t), r) this._zoomAnimator.start(t, e, i, "number" == typeof r ? r : 250);else {
        var s = this.getZoomlevel(),
          l = this._display.unproject(e, i),
          u = 0 ^ Math.min(20, t),
          h = o - u,
          f = this._worldSizeFixed,
          c = Math.pow(2, t - u);
        h && (this._z = 0 ^ Math.min(20, t), this._worldSizeFixed = 256 * Math.pow(2, this._z)), this._display.setView(this.initViewPort(), c * Math.pow(.5, h), this._rz, this._rx, this._groundResolution, this._worldSize);
        var p = this._display.unproject(e, i);
        this._setCenter(dn.x2lon(this._cWorldFixed.x + l[0] - p[0], f), dn.y2lat(this._cWorldFixed.y + l[1] - p[1], f)), this._s = c, this.updateGrid(), this._l.trigger("zoomlevel", ["zoomlevel", this.getZoomlevel(), s], !0);
      }
    }, t.prototype.setCenter = function (t, e) {
      this._setCenter.apply(this, arguments) && this.updateGrid();
    }, t.prototype.getCenter = function () {
      return new _xyzMapsCore.GeoPoint(this._c.longitude, this._c.latitude);
    }, t.prototype.flyTo = function (t, e, i) {
      e && "object" != typeof e || (i = e, e = this.getZoomlevel()), this._flightAnimator.stop(), this._flightAnimator.start(t, e, null == i ? void 0 : i.duration);
    }, t.prototype.lockViewport = function (t) {
      var e = this._vplock;
      if (t) {
        var i = t.pan,
          r = t.minLevel,
          n = t.maxLevel;
        r = !1 === r ? this._cfg.minLevel : r, n = !1 === n ? this._cfg.maxLevel : n, i != nn && (e.pan = i), "number" == typeof r && (e.minLevel = r), "number" == typeof n && (e.maxLevel = n);
      }
      return e;
    }, t.prototype.pan = function (t, e) {
      if (0 != t || 0 != e) {
        var i = this._worldSizeFixed,
          r = this._cx,
          n = this._cy,
          o = this._cWorldFixed,
          a = this._display.unproject(r + t, n + e),
          s = o.x - a[0] + r,
          l = o.y - a[1] + n;
        this.setCenter(dn.x2lon(s, i), dn.y2lat(l, i));
      }
    }, t.prototype.getLayers = function (t) {
      var e = this._layers;
      return t != nn ? e[t] : e.slice();
    }, t.prototype.addLayer = function (t, e) {
      var i = this._layers;
      if (-1 == i.indexOf(t)) {
        e == nn && (e = i.length), this._display.addLayer(t, t.getStyle(), e), t.addEventListener("clear", this._layerClearListener);
        var r = {
          index: e,
          layer: t,
          map: this,
          context: this._display.getContext(),
          canvas: this._display.canvas
        };
        t.dispatchEvent("layerAdd", r), this._l.trigger("addLayer", [new Er("addLayer", r)]), i.splice(e, 0, t), this.updateGrid();
      }
    }, t.prototype.removeLayer = function (t) {
      var e = this._layers,
        i = e.indexOf(t);
      i >= 0 && (this._display.removeLayer(t), t.removeEventListener("clear", this._layerClearListener), e.splice(i, 1), this.updateGrid(), this._l.trigger("removeLayer", [new Er("removeLayer", {
        index: i,
        layer: t
      })]));
    }, t.prototype.refresh = function (t) {
      t instanceof Array || (t = [t]);
      for (var e = 0, i = t; e < i.length; e++) {
        var r = i[e];
        r instanceof _xyzMapsCore.TileLayer && this._display.clearLayer(r);
      }
      this.updateGrid();
    }, t.prototype.pixelToGeo = function (t, e) {
      1 == arguments.length && (e = t.y, t = t.x);
      var i = this._unprj(t, e),
        r = this._w2g(i),
        n = r[0],
        o = r[1];
      return new _xyzMapsCore.GeoPoint(n, o);
    }, t.prototype._unprj = function (t, e, i) {
      var r;
      Array.isArray(t) && (t = (r = t)[0], e = r[1], i = r[2]);
      var n = this._ox,
        o = this._oy,
        a = this._display.unproject(t, e, i);
      return a[0] += n, a[1] += o, a;
    }, t.prototype._w2g = function (t, e, i) {
      var r;
      Array.isArray(t) && (t = (r = t)[0], e = r[1], i = r[2]);
      var n = this._worldSizeFixed,
        o = t + this._tlwx,
        a = e + this._tlwy;
      return o %= n, (a %= n) < 0 && (a += n), [dn.x2lon(o, n), dn.y2lat(a, n), i];
    }, t.prototype.geoToPixel = function (t, e) {
      var i;
      e == nn && (e = t.latitude, t = t.longitude);
      var r = this._g2w(t, e),
        n = r[0],
        o = r[1];
      return n = (i = this._prj([n, o]))[0], o = i[1], new _xyzMapsCore.PixelPoint(n, o);
    }, t.prototype._g2w = function (t, e, i) {
      var r;
      Array.isArray(t) && (t = (r = t)[0], e = r[1], i = r[2]), e = this._clipLatitude(e);
      var n = this._worldSizeFixed,
        o = this._tlwx,
        a = this._tlwy;
      return [dn.lon2x(t, n) - o, dn.lat2y(e, n) - a, i || 0];
    }, t.prototype._prj = function (t) {
      return this._display.project(t[0], t[1], t[2]);
    }, t.prototype.getCamera = function () {
      var t = this,
        e = t._w2g(t._unprj(t._cx, t._cy, -1));
      return {
        position: {
          longitude: e[0],
          latitude: e[1],
          altitude: e[2]
        }
      };
    }, t.prototype._translateGeoCoord = function (t, e, i, r) {
      var n,
        o = this,
        a = o._groundResolution / o._s,
        s = t[0],
        l = t[1],
        u = t[2];
      if (u += r * a, e || i) {
        var h = o._g2w(s, l, u),
          f = h[0],
          c = h[1],
          p = h[2];
        s = (n = o._w2g([f + e, c + i, p]))[0], l = n[1], u = n[2];
      }
      return [s, l, u];
    }, t.prototype.destroy = function () {
      var t = this,
        e = this._el;
      this.ui.destroy(), this._layers.forEach(function (e) {
        return t.removeLayer(e);
      }), this._display.destroy(), e.parentNode.removeChild(e), this._mvcRecognizer.watch(!1), this._evDispatcher.destroy(), this._b.drag(!1), this._b.scroll(!1);
      var i = this;
      i.__proto__ = null, Object.keys(i).forEach(function (t) {
        return delete i[t];
      }), xn.splice(xn.indexOf(i), 1);
    }, t.prototype.resize = function (t, e) {
      var i = this._el;
      t != nn && e != nn || (t = b(i.parentNode, "width"), e = b(i.parentNode, "height"));
      var r = this._w,
        n = this._h;
      r === t && n === e || (i.style.width = t + "px", i.style.height = e + "px", this._display.setSize(t, e), this._w = t, this._h = e, this._cx = t / 2, this._cy = e / 2, this.updateGrid(), this._l.trigger("resize", [new Er("resize", {
        width: t,
        height: e
      })]));
    }, t.prototype.getWidth = function () {
      return this._w;
    }, t.prototype.getHeight = function () {
      return this._h;
    }, t.prototype.addObserver = function (t, e) {
      return "zoomLevel" == t && (t = "zoomlevel"), this._l.add(t, e);
    }, t.prototype.removeObserver = function (t, e) {
      return "zoomLevel" == t && (t = "zoomlevel"), this._l.remove(t, e);
    }, t.prototype.getContainer = function () {
      return this._el.parentNode;
    }, t;
  }(),
  bn = _xyzMapsCommon.global.here.xyz.maps;
exports.default = exports.Map = wn;
bn.Map = wn, bn.styleTools = xt;
},{"@here/xyz-maps-common":"node_modules/@here/xyz-maps-common/dist/xyz-maps-common.esm.min.js","@here/xyz-maps-core":"node_modules/@here/xyz-maps-core/dist/xyz-maps-core.min.js"}],"src/index.js":[function(require,module,exports) {
"use strict";

var L = _interopRequireWildcard(require("leaflet"));
var _deck = require("deck.gl-leaflet");
var _core = require("@deck.gl/core");
var _layers = require("@deck.gl/layers");
var _xyzMapsDisplay = require("@here/xyz-maps-display");
var _xyzMapsCore = require("@here/xyz-maps-core");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/* eslint-disable */

// source: Natural Earth http://www.naturalearthdata.com/ via geojson.xyz
var AIR_PORTS = "https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson";
var coords = {
  longitude: -74.30603020869314,
  latitude: 40.69074847550857,
  zoom: 7
};
var map = L.map(document.getElementById("map"), {
  center: [coords.latitude, coords.longitude],
  zoom: coords.zoom
});
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);
var deckLayer = new _deck.LeafletLayer({
  debug: true,
  views: [new _core.MapView({
    repeat: true
  })],
  layers: []
});
map.addLayer(deckLayer);
var featureGroup = L.featureGroup();
featureGroup.addLayer(L.marker([51.4709959, -0.4531566]));
map.addLayer(featureGroup);
var YOUR_ACCESS_TOKEN = "AGB705k1T0Oyizl4K04zMwA";

// Step1 - Set underlying MVT tiles layer
var MVT = new _xyzMapsCore.MVTLayer({
  name: "background layer",
  // the minimum zoom level the layer is displayed
  min: 1,
  // the maximum zoom level the layer is displayed
  max: 20,
  remote: {
    url: "https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt?access_token=" + YOUR_ACCESS_TOKEN
  }
});

// Step 1.1 - setup the Map Display
var display = new _xyzMapsDisplay.Map(document.getElementById("xyzmap"), {
  zoomlevel: coords.zoom,
  center: {
    longitude: coords.longitude,
    latitude: coords.latitude
  },
  // add layers to the map
  layers: [MVT]
});

// display.addLayer(myLayer);

window.deckLayer = deckLayer;
window.xyzMap = display;

// Update lat long of XYZ map upon move
map.on("moveend", function () {
  console.log("Leaflet", map.getZoom());
  console.log("XYZ Map: ", display.getCenter());
  display.setCenter({
    longitude: map.getBounds().getCenter().lng,
    latitude: map.getBounds().getCenter().lat
  });
  display.setZoomlevel(map.getZoom());
});
},{"leaflet":"node_modules/leaflet/dist/leaflet-src.js","deck.gl-leaflet":"node_modules/deck.gl-leaflet/dist/deck.gl-leaflet.min.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@deck.gl/layers":"node_modules/@deck.gl/layers/dist/esm/index.js","@here/xyz-maps-display":"node_modules/@here/xyz-maps-display/dist/xyz-maps-display.esm.min.js","@here/xyz-maps-core":"node_modules/@here/xyz-maps-core/dist/xyz-maps-core.min.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "36335" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] âœ¨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] ðŸš¨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ðŸš¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.js"], null)
//# sourceMappingURL=/src.a2b27638.js.map