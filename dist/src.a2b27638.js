// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/@babel/runtime/helpers/esm/typeof.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _typeof;
function _typeof(obj) {
  "@babel/helpers - typeof";

  return exports.default = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
},{}],"node_modules/@babel/runtime/helpers/esm/toPrimitive.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toPrimitive;
var _typeof2 = _interopRequireDefault(require("./typeof.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toPrimitive(input, hint) {
  if ((0, _typeof2.default)(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if ((0, _typeof2.default)(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
},{"./typeof.js":"node_modules/@babel/runtime/helpers/esm/typeof.js"}],"node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toPropertyKey;
var _typeof2 = _interopRequireDefault(require("./typeof.js"));
var _toPrimitive = _interopRequireDefault(require("./toPrimitive.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toPropertyKey(arg) {
  var key = (0, _toPrimitive.default)(arg, "string");
  return (0, _typeof2.default)(key) === "symbol" ? key : String(key);
}
},{"./typeof.js":"node_modules/@babel/runtime/helpers/esm/typeof.js","./toPrimitive.js":"node_modules/@babel/runtime/helpers/esm/toPrimitive.js"}],"node_modules/@babel/runtime/helpers/esm/defineProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _defineProperty;
var _toPropertyKey = _interopRequireDefault(require("./toPropertyKey.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) {
  key = (0, _toPropertyKey.default)(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
},{"./toPropertyKey.js":"node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.nodeVersion = exports.isWorker = exports.isBrowser = exports.global = exports.document = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
const window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
const global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
const document_ = globals.document || {};
exports.document = document_;
const isBrowser = Boolean(typeof process !== 'object' || String(process) !== '[object process]' || true);
exports.isBrowser = isBrowser;
const isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/option-utils/merge-loader-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLoaderOptions = mergeLoaderOptions;
function mergeLoaderOptions(baseOptions, newOptions) {
  const options = {
    ...baseOptions
  };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === 'object') {
      options[key] = options[key] || {};
      Object.assign(options[key], newOptions[key]);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const DEFAULT_VERSION = 'latest';
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : DEFAULT_VERSION;
exports.VERSION = VERSION;
if (typeof "3.4.6" === 'undefined') {
  console.error('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.nodeVersion = exports.isWorker = exports.isMobile = exports.isBrowser = exports.global = exports.document = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
const window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
const global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
const document_ = globals.document || {};
exports.document = document_;
const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || true;
exports.isBrowser = isBrowser;
const isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
exports.isMobile = isMobile;
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _assert = require("../env-utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WorkerJob {
  constructor(jobName, workerThread) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "workerThread", void 0);
    (0, _defineProperty2.default)(this, "isRunning", true);
    (0, _defineProperty2.default)(this, "result", void 0);
    (0, _defineProperty2.default)(this, "_resolve", () => {});
    (0, _defineProperty2.default)(this, "_reject", () => {});
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: 'loaders.gl',
      type,
      payload
    });
  }
  done(value) {
    (0, _assert.assert)(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error) {
    (0, _assert.assert)(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
}
exports.default = WorkerJob;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parentPort = exports.Worker = exports.NodeWorkerType = exports.NodeWorker = void 0;
class Worker {
  terminate() {}
}
exports.NodeWorkerType = exports.NodeWorker = exports.Worker = Worker;
const parentPort = null;
exports.parentPort = parentPort;
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadableWorkerURL = getLoadableWorkerURL;
var _assert = require("../env-utils/assert");
const workerURLCache = new Map();
function getLoadableWorkerURL(props) {
  (0, _assert.assert)(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  (0, _assert.assert)(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransferList = getTransferList;
exports.getTransferListForWriter = getTransferListForWriter;
function getTransferList(object) {
  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let transfers = arguments.length > 2 ? arguments[2] : undefined;
  const transfersSet = transfers || new Set();
  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === 'object') {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === undefined ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
function getTransferListForWriter(object) {
  if (object === null) {
    return {};
  }
  const clone = Object.assign({}, object);
  Object.keys(clone).forEach(key => {
    if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {
      clone[key] = getTransferListForWriter(object[key]);
    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {
      clone[key] = {};
    } else {
      clone[key] = object[key];
    }
  });
  return clone;
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _worker_threads = require("../node/worker_threads");
var _globals = require("../env-utils/globals");
var _assert = require("../env-utils/assert");
var _getLoadableWorkerUrl = require("../worker-utils/get-loadable-worker-url");
var _getTransferList = require("../worker-utils/get-transfer-list");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NOOP = () => {};
class WorkerThread {
  static isSupported() {
    return typeof Worker !== 'undefined' && _globals.isBrowser || typeof _worker_threads.NodeWorker !== 'undefined' && !_globals.isBrowser;
  }
  constructor(props) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "terminated", false);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "onMessage", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadableURL", '');
    const {
      name,
      source,
      url
    } = props;
    (0, _assert.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = error => console.log(error);
    this.worker = _globals.isBrowser ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data, transferList) {
    transferList = transferList || (0, _getTransferList.getTransferList)(data);
    this.worker.postMessage(data, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = 'Failed to load ';
    message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
    if (event.message) {
      message += "".concat(event.message, " in ");
    }
    if (event.lineno) {
      message += ":".concat(event.lineno, ":").concat(event.colno);
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = (0, _getLoadableWorkerUrl.getLoadableWorkerURL)({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });
    worker.onmessage = event => {
      if (!event.data) {
        this.onError(new Error('No data received'));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = error => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = event => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(':/') || this.url.startsWith('/');
      const url = absolute ? this.url : "./".concat(this.url);
      worker = new _worker_threads.NodeWorker(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new _worker_threads.NodeWorker(this.source, {
        eval: true
      });
    } else {
      throw new Error('no worker');
    }
    worker.on('message', data => {
      this.onMessage(data);
    });
    worker.on('error', error => {
      this.onError(error);
    });
    worker.on('exit', code => {});
    return worker;
  }
}
exports.default = WorkerThread;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node/worker_threads":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js","../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../worker-utils/get-loadable-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js","../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _globals = require("../env-utils/globals");
var _workerThread = _interopRequireDefault(require("./worker-thread"));
var _workerJob = _interopRequireDefault(require("./worker-job"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WorkerPool {
  static isSupported() {
    return _workerThread.default.isSupported();
  }
  constructor(props) {
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", () => {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    if (props.name !== undefined) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name) {
    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);
    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);
    const startPromise = new Promise(onStart => {
      this.jobQueue.push({
        name,
        onMessage,
        onError,
        onStart
      });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: 'Starting job',
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new _workerJob.default(queuedJob.name, workerThread);
      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = error => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new _workerThread.default({
        name,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
exports.default = WorkerPool;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","./worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","./worker-job":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _workerPool = _interopRequireDefault(require("./worker-pool"));
var _workerThread = _interopRequireDefault(require("./worker-thread"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {}
};
class WorkerFarm {
  static isSupported() {
    return _workerThread.default.isSupported();
  }
  static getWorkerFarm() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  constructor(props) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "workerPools", new Map());
    this.props = {
      ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = new Map();
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = new Map();
  }
  setProps(props) {
    this.props = {
      ...this.props,
      ...props
    };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new _workerPool.default({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
exports.default = WorkerFarm;
(0, _defineProperty2.default)(WorkerFarm, "_workerFarm", void 0);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./worker-pool":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","./worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getTransferList = require("../worker-utils/get-transfer-list");
function getParentPort() {
  let parentPort;
  try {
    eval('globalThis.parentPort = require(\'worker_threads\').parentPort');
    parentPort = globalThis.parentPort;
  } catch {}
  return parentPort;
}
const onMessageWrapperMap = new Map();
class WorkerBody {
  static inWorkerThread() {
    return typeof self !== 'undefined' || Boolean(getParentPort());
  }
  static set onmessage(onMessage) {
    function handleMessage(message) {
      const parentPort = getParentPort();
      const {
        type,
        payload
      } = parentPort ? message : message.data;
      onMessage(type, payload);
    }
    const parentPort = getParentPort();
    if (parentPort) {
      parentPort.on('message', handleMessage);
      parentPort.on('exit', () => console.debug('Node worker closing'));
    } else {
      globalThis.onmessage = handleMessage;
    }
  }
  static addEventListener(onMessage) {
    let onMessageWrapper = onMessageWrapperMap.get(onMessage);
    if (!onMessageWrapper) {
      onMessageWrapper = message => {
        if (!isKnownMessage(message)) {
          return;
        }
        const parentPort = getParentPort();
        const {
          type,
          payload
        } = parentPort ? message : message.data;
        onMessage(type, payload);
      };
    }
    const parentPort = getParentPort();
    if (parentPort) {
      console.error('not implemented');
    } else {
      globalThis.addEventListener('message', onMessageWrapper);
    }
  }
  static removeEventListener(onMessage) {
    const onMessageWrapper = onMessageWrapperMap.get(onMessage);
    onMessageWrapperMap.delete(onMessage);
    const parentPort = getParentPort();
    if (parentPort) {
      console.error('not implemented');
    } else {
      globalThis.removeEventListener('message', onMessageWrapper);
    }
  }
  static postMessage(type, payload) {
    const data = {
      source: 'loaders.gl',
      type,
      payload
    };
    const transferList = (0, _getTransferList.getTransferList)(payload);
    const parentPort = getParentPort();
    if (parentPort) {
      parentPort.postMessage(data, transferList);
    } else {
      globalThis.postMessage(data, transferList);
    }
  }
}
exports.default = WorkerBody;
function isKnownMessage(message) {
  const {
    type,
    data
  } = message;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}
},{"../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorkerName = getWorkerName;
exports.getWorkerURL = getWorkerURL;
var _assert = require("../env-utils/assert");
var _version = require("../env-utils/version");
const NPM_TAG = 'latest';
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : NPM_TAG;
function getWorkerName(worker) {
  const warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}
function getWorkerURL(worker) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;
  if (!url && worker.id === 'compression') {
    url = options.workerUrl;
  }
  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }
  if (!url) {
    let version = worker.version;
    if (version === 'latest') {
      version = NPM_TAG;
    }
    const versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }
  (0, _assert.assert)(url);
  return url;
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canProcessOnWorker = canProcessOnWorker;
exports.processOnWorker = processOnWorker;
var _workerFarm = _interopRequireDefault(require("../worker-farm/worker-farm"));
var _getWorkerUrl = require("./get-worker-url");
var _getTransferList = require("../worker-utils/get-transfer-list");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function canProcessOnWorker(worker, options) {
  if (!_workerFarm.default.isSupported()) {
    return false;
  }
  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function processOnWorker(worker, data) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const name = (0, _getWorkerUrl.getWorkerName)(worker);
  const workerFarm = _workerFarm.default.getWorkerFarm(options);
  const {
    source
  } = options;
  const workerPoolProps = {
    name,
    source
  };
  if (!source) {
    workerPoolProps.url = (0, _getWorkerUrl.getWorkerURL)(worker, options);
  }
  const workerPool = workerFarm.getWorkerPool(workerPoolProps);
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(jobName, onMessage.bind(null, context));
  const transferableOptions = (0, _getTransferList.getTransferListForWriter)(options);
  job.postMessage('process', {
    input: data,
    options: transferableOptions
  });
  const result = await job.result;
  return result.result;
}
async function onMessage(context, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;
    case 'error':
      job.error(new Error(payload.error));
      break;
    case 'process':
      const {
        id,
        input,
        options
      } = payload;
      try {
        if (!context.process) {
          job.postMessage('error', {
            id,
            error: 'Worker not set up to process on main thread'
          });
          return;
        }
        const result = await context.process(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("process-on-worker: unknown message ".concat(type));
  }
}
},{"../worker-farm/worker-farm":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","./get-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js","../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let _Symbol$asyncIterator;
_Symbol$asyncIterator = Symbol.asyncIterator;
class AsyncQueue {
  constructor() {
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }
  [_Symbol$asyncIterator]() {
    return this;
  }
  push(value) {
    return this.enqueue(value);
  }
  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }
    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }
      const settler = this._settlers.shift();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.push(value);
    }
  }
  close() {
    while (this._settlers.length > 0) {
      const settler = this._settlers.shift();
      settler.resolve({
        done: true
      });
    }
    this._closed = true;
  }
  next() {
    if (this._values.length > 0) {
      const value = this._values.shift();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({
        done: false,
        value
      });
    }
    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }
      return Promise.resolve({
        done: true,
        value: undefined
      });
    }
    return new Promise((resolve, reject) => {
      this._settlers.push({
        resolve,
        reject
      });
    });
  }
}
exports.default = AsyncQueue;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;
var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));
var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let requestId = 0;
let inputBatches;
let options;
function createWorker(process, processInBatches) {
  if (!_workerBody.default.inWorkerThread()) {
    return;
  }
  const context = {
    process: processOnMainThread
  };
  _workerBody.default.onmessage = async (type, payload) => {
    try {
      switch (type) {
        case 'process':
          if (!process) {
            throw new Error('Worker does not support atomic processing');
          }
          const result = await process(payload.input, payload.options || {}, context);
          _workerBody.default.postMessage('done', {
            result
          });
          break;
        case 'process-in-batches':
          if (!processInBatches) {
            throw new Error('Worker does not support batched processing');
          }
          inputBatches = new _asyncQueue.default();
          options = payload.options || {};
          const resultIterator = processInBatches(inputBatches, options, context);
          for await (const batch of resultIterator) {
            _workerBody.default.postMessage('output-batch', {
              result: batch
            });
          }
          _workerBody.default.postMessage('done', {});
          break;
        case 'input-batch':
          inputBatches.push(payload.input);
          break;
        case 'input-done':
          inputBatches.close();
          break;
        default:
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : '';
      _workerBody.default.postMessage('error', {
        error: message
      });
    }
  };
}
function processOnMainThread(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise((resolve, reject) => {
    const id = requestId++;
    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }
      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);
          resolve(payload.result);
          break;
        case 'error':
          _workerBody.default.removeEventListener(onMessage);
          reject(payload.error);
          break;
        default:
      }
    };
    _workerBody.default.addEventListener(onMessage);
    const payload = {
      id,
      input: arrayBuffer,
      options
    };
    _workerBody.default.postMessage('process', payload);
  });
}
},{"../async-queue/async-queue":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js","../worker-farm/worker-body":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateWorkerVersion = validateWorkerVersion;
var _assert = require("../env-utils/assert");
var _version = require("../env-utils/version");
function validateWorkerVersion(worker) {
  let coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _version.VERSION;
  (0, _assert.assert)(worker, 'no worker provided');
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLibraryUrl = getLibraryUrl;
exports.loadLibrary = loadLibrary;
var _globals = require("../env-utils/globals");
var node = _interopRequireWildcard(require("../node/require-utils.node"));
var _assert = require("../env-utils/assert");
var _version = require("../env-utils/version");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const LATEST = 'latest';
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : LATEST;
const loadLibraryPromises = {};
async function loadLibrary(libraryUrl) {
  let moduleName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }
  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }
  if (!_globals.isBrowser) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }
  if (options.CDN) {
    (0, _assert.assert)(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }
  if (_globals.isWorker) {
    return "../src/libs/".concat(library);
  }
  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }
  if (!_globals.isBrowser) {
    try {
      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));
    } catch {
      return null;
    }
  }
  if (_globals.isWorker) {
    return importScripts(libraryUrl);
  }
  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!_globals.isBrowser) {
    return node.requireFromString && node.requireFromString(scriptSource, id);
  }
  if (_globals.isWorker) {
    eval.call(_globals.global, scriptSource);
    return null;
  }
  const script = document.createElement('script');
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}
},{"../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../node/require-utils.node":"node_modules/parcel-bundler/src/builtins/_empty.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function () {
    return _asyncQueue.default;
  }
});
Object.defineProperty(exports, "ChildProcessProxy", {
  enumerable: true,
  get: function () {
    return _childProcessProxy.default;
  }
});
exports.NullWorker = void 0;
Object.defineProperty(exports, "WorkerBody", {
  enumerable: true,
  get: function () {
    return _workerBody.default;
  }
});
Object.defineProperty(exports, "WorkerFarm", {
  enumerable: true,
  get: function () {
    return _workerFarm.default;
  }
});
Object.defineProperty(exports, "WorkerJob", {
  enumerable: true,
  get: function () {
    return _workerJob.default;
  }
});
Object.defineProperty(exports, "WorkerPool", {
  enumerable: true,
  get: function () {
    return _workerPool.default;
  }
});
Object.defineProperty(exports, "WorkerThread", {
  enumerable: true,
  get: function () {
    return _workerThread.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "canProcessOnWorker", {
  enumerable: true,
  get: function () {
    return _processOnWorker.canProcessOnWorker;
  }
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function () {
    return _createWorker.createWorker;
  }
});
Object.defineProperty(exports, "getLibraryUrl", {
  enumerable: true,
  get: function () {
    return _libraryUtils.getLibraryUrl;
  }
});
Object.defineProperty(exports, "getTransferList", {
  enumerable: true,
  get: function () {
    return _getTransferList.getTransferList;
  }
});
Object.defineProperty(exports, "getTransferListForWriter", {
  enumerable: true,
  get: function () {
    return _getTransferList.getTransferListForWriter;
  }
});
Object.defineProperty(exports, "getWorkerURL", {
  enumerable: true,
  get: function () {
    return _getWorkerUrl.getWorkerURL;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "loadLibrary", {
  enumerable: true,
  get: function () {
    return _libraryUtils.loadLibrary;
  }
});
Object.defineProperty(exports, "processOnWorker", {
  enumerable: true,
  get: function () {
    return _processOnWorker.processOnWorker;
  }
});
Object.defineProperty(exports, "validateWorkerVersion", {
  enumerable: true,
  get: function () {
    return _validateWorkerVersion.validateWorkerVersion;
  }
});
var _version = require("./lib/env-utils/version");
var _assert = require("./lib/env-utils/assert");
var _globals = require("./lib/env-utils/globals");
var _workerJob = _interopRequireDefault(require("./lib/worker-farm/worker-job"));
var _workerThread = _interopRequireDefault(require("./lib/worker-farm/worker-thread"));
var _workerFarm = _interopRequireDefault(require("./lib/worker-farm/worker-farm"));
var _workerPool = _interopRequireDefault(require("./lib/worker-farm/worker-pool"));
var _workerBody = _interopRequireDefault(require("./lib/worker-farm/worker-body"));
var _processOnWorker = require("./lib/worker-api/process-on-worker");
var _createWorker = require("./lib/worker-api/create-worker");
var _getWorkerUrl = require("./lib/worker-api/get-worker-url");
var _validateWorkerVersion = require("./lib/worker-api/validate-worker-version");
var _getTransferList = require("./lib/worker-utils/get-transfer-list");
var _libraryUtils = require("./lib/library-utils/library-utils");
var _asyncQueue = _interopRequireDefault(require("./lib/async-queue/async-queue"));
var _childProcessProxy = _interopRequireDefault(require("./lib/process-utils/child-process-proxy"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _version.VERSION,
  options: {
    null: {}
  }
};
exports.NullWorker = NullWorker;
},{"./lib/env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js","./lib/env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","./lib/env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","./lib/worker-farm/worker-job":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js","./lib/worker-farm/worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","./lib/worker-farm/worker-farm":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","./lib/worker-farm/worker-pool":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","./lib/worker-farm/worker-body":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js","./lib/worker-api/process-on-worker":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js","./lib/worker-api/create-worker":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js","./lib/worker-api/get-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js","./lib/worker-api/validate-worker-version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js","./lib/worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js","./lib/library-utils/library-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js","./lib/async-queue/async-queue":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js","./lib/process-utils/child-process-proxy":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoaderWorker = createLoaderWorker;
var _workerUtils = require("@loaders.gl/worker-utils");
let requestId = 0;
function createLoaderWorker(loader) {
  if (!_workerUtils.WorkerBody.inWorkerThread()) {
    return;
  }
  _workerUtils.WorkerBody.onmessage = async (type, payload) => {
    switch (type) {
      case 'process':
        try {
          const {
            input,
            options = {},
            context = {}
          } = payload;
          const result = await parseData({
            loader,
            arrayBuffer: input,
            options,
            context: {
              ...context,
              parse: parseOnMainThread
            }
          });
          _workerUtils.WorkerBody.postMessage('done', {
            result
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : '';
          _workerUtils.WorkerBody.postMessage('error', {
            error: message
          });
        }
        break;
      default:
    }
  };
}
function parseOnMainThread(arrayBuffer, options) {
  return new Promise((resolve, reject) => {
    const id = requestId++;
    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }
      switch (type) {
        case 'done':
          _workerUtils.WorkerBody.removeEventListener(onMessage);
          resolve(payload.result);
          break;
        case 'error':
          _workerUtils.WorkerBody.removeEventListener(onMessage);
          reject(payload.error);
          break;
        default:
      }
    };
    _workerUtils.WorkerBody.addEventListener(onMessage);
    const payload = {
      id,
      input: arrayBuffer,
      options
    };
    _workerUtils.WorkerBody.postMessage('process', payload);
  });
}
async function parseData(_ref) {
  let {
    loader,
    arrayBuffer,
    options,
    context
  } = _ref;
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arrayBuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arrayBuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error("Could not load data with ".concat(loader.name, " loader"));
  }
  options = {
    ...options,
    modules: loader && loader.options && loader.options.modules || {},
    worker: false
  };
  return await parser(data, {
    ...options
  }, context, loader);
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canParseWithWorker = canParseWithWorker;
exports.parseWithWorker = parseWithWorker;
var _workerUtils = require("@loaders.gl/worker-utils");
function canParseWithWorker(loader, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }
  if (!_workerUtils.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = (0, _workerUtils.getWorkerURL)(loader, options);
  const workerFarm = _workerUtils.WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));
  job.postMessage('process', {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;
    case 'error':
      job.error(new Error(payload.error));
      break;
    case 'process':
      const {
        id,
        input,
        options
      } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canEncodeWithWorker = canEncodeWithWorker;
var _workerUtils = require("@loaders.gl/worker-utils");
var _globals = require("../env-utils/globals");
function canEncodeWithWorker(writer, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }
  if (!_globals.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }
  return writer.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","../env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstCharacters = getFirstCharacters;
exports.getMagicString = getMagicString;
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseJSON = parseJSON;
var _getFirstCharacters = require("../binary-utils/get-first-characters");
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat((0, _getFirstCharacters.getFirstCharacters)(string), "\""));
  }
}
},{"../binary-utils/get-first-characters":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareArrayBuffers = compareArrayBuffers;
exports.concatenateArrayBuffers = concatenateArrayBuffers;
exports.concatenateTypedArrays = concatenateTypedArrays;
exports.sliceArrayBuffer = sliceArrayBuffer;
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }
  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;
exports.padToNBytes = padToNBytes;
var _assert = require("../env-utils/assert");
function padToNBytes(byteLength, padding) {
  (0, _assert.assert)(byteLength >= 0);
  (0, _assert.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  let byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
},{"../env-utils/assert":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyBinaryToDataView = copyBinaryToDataView;
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;
exports.copyStringToDataView = copyStringToDataView;
exports.padStringToByteAlignment = padStringToByteAlignment;
var _memoryCopyUtils = require("./memory-copy-utils");
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}
function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}
function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }
  return byteOffset + byteLength;
}
function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = (0, _memoryCopyUtils.padToNBytes)(sourceBuffer.byteLength, padding);
  const padLength = paddedLength - sourceBuffer.byteLength;
  if (dataView) {
    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);
    for (let i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}
function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  const stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}
},{"./memory-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeLineIterator = makeLineIterator;
exports.makeNumberedLineIterator = makeNumberedLineIterator;
exports.makeTextDecoderIterator = makeTextDecoderIterator;
exports.makeTextEncoderIterator = makeTextEncoderIterator;
function makeTextDecoderIterator(arrayBufferIterator) {
  try {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return async function* () {
      const textDecoder = new TextDecoder(undefined, options);
      for await (const arrayBuffer of arrayBufferIterator) {
        yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
          stream: true
        });
      }
    }();
  } catch (e) {
    return Promise.reject(e);
  }
}
async function* makeTextEncoderIterator(textIterator) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}
async function* makeLineIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }
  if (previous.length > 0) {
    yield previous;
  }
}
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {
      counter,
      line
    };
    counter++;
  }
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatenateArrayBuffersAsync = concatenateArrayBuffersAsync;
exports.concatenateStringsAsync = concatenateStringsAsync;
exports.forEach = forEach;
var _arrayBufferUtils = require("../binary-utils/array-buffer-utils");
async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return (0, _arrayBufferUtils.concatenateArrayBuffers)(...arrayBuffers);
}
async function concatenateStringsAsync(asyncIterator) {
  const strings = [];
  for await (const chunk of asyncIterator) {
    strings.push(chunk);
  }
  return strings.join('');
}
},{"../binary-utils/array-buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stat {
  constructor(name, type) {
    this.name = void 0;
    this.type = void 0;
    this.sampleSize = 1;
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    this.name = name;
    this.type = type;
    this.reset();
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  incrementCount() {
    this.addCount(1);
    return this;
  }
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  timeStart() {
    this._startTime = (0, _hiResTimestamp.default)();
    this._timerPending = true;
    return this;
  }
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime((0, _hiResTimestamp.default)() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1000) : 0;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
}
exports.default = Stat;
},{"../utils/hi-res-timestamp.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _stat = _interopRequireDefault(require("./stat.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stats {
  constructor(options) {
    this.id = void 0;
    this.stats = {};
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  get(name) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
    return this._getOrCreate({
      name,
      type
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const stat of Object.values(this.stats)) {
      stat.reset();
    }
    return this;
  }
  forEach(fn) {
    for (const stat of Object.values(this.stats)) {
      fn(stat);
    }
  }
  getTable() {
    const table = {};
    this.forEach(stat => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    stats.forEach(stat => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    const {
      name,
      type
    } = stat;
    let result = this.stats[name];
    if (!result) {
      if (stat instanceof _stat.default) {
        result = stat;
      } else {
        result = new _stat.default(name, type);
      }
      this.stats[name] = result;
    }
    return result;
  }
}
exports.default = Stats;
},{"./stat.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js"}],"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _stat.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.default;
  }
});
var _stats = _interopRequireDefault(require("./lib/stats.js"));
var _stat = _interopRequireDefault(require("./lib/stat.js"));
var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/stats.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stats.js","./lib/stat.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/lib/stat.js","./utils/hi-res-timestamp.js":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _stats = require("@probe.gl/stats");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
const DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};
class RequestScheduler {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "activeRequestCount", 0);
    (0, _defineProperty2.default)(this, "requestQueue", []);
    (0, _defineProperty2.default)(this, "requestMap", new Map());
    (0, _defineProperty2.default)(this, "deferredUpdate", null);
    this.props = {
      ...DEFAULT_PROPS,
      ...props
    };
    this.stats = new _stats.Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }
  scheduleRequest(handle) {
    let getPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => 0;
    if (!this.props.throttleRequests) {
      return Promise.resolve({
        done: () => {}
      });
    }
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }
    const request = {
      handle,
      priority: 0,
      getPriority
    };
    const promise = new Promise(resolve => {
      request.resolve = resolve;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }
  _issueRequest(request) {
    const {
      handle,
      resolve
    } = request;
    let isDone = false;
    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        this._issueNewRequests();
      }
    };
    this.activeRequestCount++;
    return resolve ? resolve({
      done
    }) : Promise.resolve({
      done
    });
  }
  _issueNewRequests() {
    if (!this.deferredUpdate) {
      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }
  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (freeSlots === 0) {
      return;
    }
    this._updateAllRequests();
    for (let i = 0; i < freeSlots; ++i) {
      const request = this.requestQueue.shift();
      if (request) {
        this._issueRequest(request);
      }
    }
  }
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }
    requestQueue.sort((a, b) => a.priority - b.priority);
  }
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
}
exports.default = RequestScheduler;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/stats":"node_modules/@loaders.gl/loader-utils/node_modules/@probe.gl/stats/dist/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAliases = addAliases;
exports.getPathPrefix = getPathPrefix;
exports.resolvePath = resolvePath;
exports.setPathPrefix = setPathPrefix;
let pathPrefix = '';
const fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }
  return filename;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckJSONLoader = exports.JSONLoader = void 0;
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : 'latest';
const JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync,
  parse: async arrayBuffer => parseTextSync(new TextDecoder().decode(arrayBuffer)),
  options: {}
};
exports.JSONLoader = JSONLoader;
function parseTextSync(text) {
  return JSON.parse(text);
}
const _typecheckJSONLoader = JSONLoader;
exports._typecheckJSONLoader = _typecheckJSONLoader;
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;
exports.toBuffer = toBuffer;
function toArrayBuffer(buffer) {
  return buffer;
}
function toBuffer(binaryData) {
  throw new Error('Buffer not supported in browser');
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBuffer = isBuffer;
exports.toArrayBuffer = toArrayBuffer;
exports.toBuffer = toBuffer;
var node = _interopRequireWildcard(require("../node/buffer"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function isBuffer(value) {
  return value && typeof value === 'object' && value.isBuffer;
}
function toBuffer(data) {
  return node.toBuffer ? node.toBuffer(data) : data;
}
function toArrayBuffer(data) {
  if (isBuffer(data)) {
    return node.toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error('toArrayBuffer');
}
},{"../node/buffer":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify1 = promisify1;
exports.promisify2 = promisify2;
exports.promisify3 = promisify3;
function promisify1(fn) {
  return args => new Promise((resolve, reject) => fn(args, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
}
function promisify2(fn) {
  return (arg1, arg2) => new Promise((resolve, reject) => fn(arg1, arg2, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
}
function promisify3(fn) {
  return (arg1, arg2, arg3) => new Promise((resolve, reject) => fn(arg1, arg2, arg3, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCWD = getCWD;
function getCWD() {
  var _window$location;
  if (typeof process !== 'undefined' && typeof process.cwd !== 'undefined') {
    return process.cwd();
  }
  const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
  return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf('/') + 1)) || '';
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
exports.filename = filename;
exports.join = join;
exports.resolve = resolve;
var _getCwd = require("./get-cwd");
function filename(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf('/') : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}
function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  const separator = '/';
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }
    return part;
  });
  return parts.join(separator);
}
function resolve() {
  const paths = [];
  for (let _i = 0; _i < arguments.length; _i++) {
    paths[_i] = _i < 0 || arguments.length <= _i ? undefined : arguments[_i];
  }
  let resolvedPath = '';
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === undefined) {
        cwd = (0, _getCwd.getCWD)();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = "".concat(path, "/").concat(resolvedPath);
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return "/".concat(resolvedPath);
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return '.';
}
const SLASH = 47;
const DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = '';
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (; j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? '' : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += '/..';
          } else {
            res = '..';
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += "/".concat(slice);
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
},{"./get-cwd":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js"}],"node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"node_modules/base64-js/index.js","ieee754":"node_modules/ieee754/index.js","isarray":"node_modules/isarray/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._readToArrayBuffer = _readToArrayBuffer;
exports.writeFileSync = exports.writeFile = exports.stat = exports.readdir = exports.readFileSync = exports.readFile = exports.read = exports.open = exports.isSupported = exports.fstat = exports.createWriteStream = exports.close = void 0;
var _fs = _interopRequireDefault(require("fs"));
var _buffer = require("./buffer");
var _promisify = require("./promisify");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let readdir;
exports.readdir = readdir;
let stat;
exports.stat = stat;
let readFile;
exports.readFile = readFile;
let readFileSync;
exports.readFileSync = readFileSync;
let writeFile;
exports.writeFile = writeFile;
let writeFileSync;
exports.writeFileSync = writeFileSync;
let open;
exports.open = open;
let close;
exports.close = close;
let read;
exports.read = read;
let fstat;
exports.fstat = fstat;
let createWriteStream;
exports.createWriteStream = createWriteStream;
let isSupported = Boolean(_fs.default);
exports.isSupported = isSupported;
try {
  exports.readdir = readdir = (0, _promisify.promisify2)(_fs.default.readdir);
  exports.stat = stat = (0, _promisify.promisify2)(_fs.default.stat);
  exports.readFile = readFile = _fs.default.readFile;
  exports.readFileSync = readFileSync = _fs.default.readFileSync;
  exports.writeFile = writeFile = (0, _promisify.promisify3)(_fs.default.writeFile);
  exports.writeFileSync = writeFileSync = _fs.default.writeFileSync;
  exports.open = open = _fs.default.open;
  exports.close = close = fd => new Promise((resolve, reject) => _fs.default.close(fd, err => err ? reject(err) : resolve()));
  exports.read = read = _fs.default.read;
  exports.fstat = fstat = _fs.default.fstat;
  exports.createWriteStream = createWriteStream = _fs.default.createWriteStream;
  exports.isSupported = isSupported = Boolean(_fs.default);
} catch {}
async function _readToArrayBuffer(fd, start, length) {
  const buffer = Buffer.alloc(length);
  const {
    bytesRead
  } = await read(fd, buffer, 0, length, start);
  if (bytesRead !== length) {
    throw new Error('fs.read failed');
  }
  return (0, _buffer.toArrayBuffer)(buffer);
}
},{"fs":"node_modules/parcel-bundler/src/builtins/_empty.js","./buffer":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js","./promisify":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = exports.Transform = void 0;
var _stream = _interopRequireDefault(require("stream"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let Transform;
exports.Transform = Transform;
const isSupported = Boolean(_stream.default);
exports.isSupported = isSupported;
try {
  exports.Transform = Transform = _stream.default.Transform;
} catch {}
},{"stream":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/readable-file.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeReadableFile = makeReadableFile;
function makeReadableFile(data) {
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    return {
      read: async (start, length) => Buffer.from(data, start, length),
      close: async () => {},
      size: arrayBuffer.byteLength
    };
  }
  const blob = data;
  return {
    read: async (start, length) => {
      const arrayBuffer = await blob.slice(start, start + length).arrayBuffer();
      return Buffer.from(arrayBuffer);
    },
    close: async () => {},
    size: blob.size
  };
}
},{"buffer":"node_modules/buffer/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeWritableFile = makeWritableFile;
var _globals = require("../env-utils/globals");
var fs = _interopRequireWildcard(require("../node/fs"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function makeWritableFile(pathOrStream, options) {
  if (_globals.isBrowser) {
    return {
      write: async () => {},
      close: async () => {}
    };
  }
  const outputStream = typeof pathOrStream === 'string' ? fs.createWriteStream(pathOrStream, options) : pathOrStream;
  return {
    write: async buffer => new Promise((resolve, reject) => {
      outputStream.write(buffer, err => err ? reject(err) : resolve());
    }),
    close: () => new Promise((resolve, reject) => {
      outputStream.close(err => err ? reject(err) : resolve());
    })
  };
}
},{"../env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js","../node/fs":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var fs = _interopRequireWildcard(require("../node/fs"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class NodeFileSystem {
  constructor(options) {
    this.fetch = options._fetch;
  }
  async readdir() {
    let dirname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
    let options = arguments.length > 1 ? arguments[1] : undefined;
    return await fs.readdir(dirname, options);
  }
  async stat(path, options) {
    const info = await fs.stat(path, options);
    return {
      size: Number(info.size),
      isDirectory: () => false,
      info
    };
  }
  async fetch(path, options) {
    const fallbackFetch = options.fetch || this.fetch;
    return fallbackFetch(path, options);
  }
  async open(path, flags, mode) {
    return await fs.open(path, flags);
  }
  async close(fd) {
    return await fs.close(fd);
  }
  async fstat(fd) {
    const info = await fs.fstat(fd);
    return info;
  }
  async read(fd, _ref) {
    let {
      buffer = null,
      offset = 0,
      length = buffer.byteLength,
      position = null
    } = _ref;
    let totalBytesRead = 0;
    while (totalBytesRead < length) {
      const {
        bytesRead
      } = await fs.read(fd, buffer, offset + totalBytesRead, length - totalBytesRead, position + totalBytesRead);
      totalBytesRead += bytesRead;
    }
    return {
      bytesRead: totalBytesRead,
      buffer
    };
  }
}
exports.default = NodeFileSystem;
},{"../node/fs":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function () {
    return _jsonLoader.JSONLoader;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function () {
    return _requestScheduler.default;
  }
});
Object.defineProperty(exports, "_NodeFileSystem", {
  enumerable: true,
  get: function () {
    return _nodeFilesystem.default;
  }
});
Object.defineProperty(exports, "_addAliases", {
  enumerable: true,
  get: function () {
    return _fileAliases.addAliases;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "canEncodeWithWorker", {
  enumerable: true,
  get: function () {
    return _encodeWithWorker.canEncodeWithWorker;
  }
});
Object.defineProperty(exports, "canParseWithWorker", {
  enumerable: true,
  get: function () {
    return _parseWithWorker.canParseWithWorker;
  }
});
Object.defineProperty(exports, "compareArrayBuffers", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.compareArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffers", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.concatenateArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function () {
    return _asyncIteration.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "concatenateTypedArrays", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.concatenateTypedArrays;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "createLoaderWorker", {
  enumerable: true,
  get: function () {
    return _createLoaderWorker.createLoaderWorker;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function () {
    return _asyncIteration.forEach;
  }
});
exports.fs = void 0;
Object.defineProperty(exports, "getFirstCharacters", {
  enumerable: true,
  get: function () {
    return _getFirstCharacters.getFirstCharacters;
  }
});
Object.defineProperty(exports, "getMagicString", {
  enumerable: true,
  get: function () {
    return _getFirstCharacters.getMagicString;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function () {
    return _fileAliases.getPathPrefix;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isBuffer", {
  enumerable: true,
  get: function () {
    return _memoryConversionUtils.isBuffer;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeReadableFile", {
  enumerable: true,
  get: function () {
    return _readableFile.makeReadableFile;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeWritableFile", {
  enumerable: true,
  get: function () {
    return _writableFile.makeWritableFile;
  }
});
Object.defineProperty(exports, "mergeLoaderOptions", {
  enumerable: true,
  get: function () {
    return _mergeLoaderOptions.mergeLoaderOptions;
  }
});
Object.defineProperty(exports, "nodeVersion", {
  enumerable: true,
  get: function () {
    return _globals.nodeVersion;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function () {
    return _dataviewCopyUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "padToNBytes", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.padToNBytes;
  }
});
Object.defineProperty(exports, "parseJSON", {
  enumerable: true,
  get: function () {
    return _parseJson.parseJSON;
  }
});
Object.defineProperty(exports, "parseWithWorker", {
  enumerable: true,
  get: function () {
    return _parseWithWorker.parseWithWorker;
  }
});
exports.path = void 0;
Object.defineProperty(exports, "promisify1", {
  enumerable: true,
  get: function () {
    return _promisify.promisify1;
  }
});
Object.defineProperty(exports, "promisify2", {
  enumerable: true,
  get: function () {
    return _promisify.promisify2;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function () {
    return _fileAliases.resolvePath;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _fileAliases.setPathPrefix;
  }
});
Object.defineProperty(exports, "sliceArrayBuffer", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.sliceArrayBuffer;
  }
});
exports.stream = void 0;
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function () {
    return _memoryConversionUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "toBuffer", {
  enumerable: true,
  get: function () {
    return _memoryConversionUtils.toBuffer;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
var _assert = require("./lib/env-utils/assert");
var _globals = require("./lib/env-utils/globals");
var _mergeLoaderOptions = require("./lib/option-utils/merge-loader-options");
var _createLoaderWorker = require("./lib/worker-loader-utils/create-loader-worker");
var _parseWithWorker = require("./lib/worker-loader-utils/parse-with-worker");
var _encodeWithWorker = require("./lib/worker-loader-utils/encode-with-worker");
var _parseJson = require("./lib/parser-utils/parse-json");
var _arrayBufferUtils = require("./lib/binary-utils/array-buffer-utils");
var _memoryCopyUtils = require("./lib/binary-utils/memory-copy-utils");
var _dataviewCopyUtils = require("./lib/binary-utils/dataview-copy-utils");
var _getFirstCharacters = require("./lib/binary-utils/get-first-characters");
var _textIterators = require("./lib/iterators/text-iterators");
var _asyncIteration = require("./lib/iterators/async-iteration");
var _requestScheduler = _interopRequireDefault(require("./lib/request-utils/request-scheduler"));
var _fileAliases = require("./lib/path-utils/file-aliases");
var _jsonLoader = require("./json-loader");
var _memoryConversionUtils = require("./lib/binary-utils/memory-conversion-utils");
var _promisify = require("./lib/node/promisify");
var path = _interopRequireWildcard(require("./lib/path-utils/path"));
exports.path = path;
var fs = _interopRequireWildcard(require("./lib/node/fs"));
exports.fs = fs;
var stream = _interopRequireWildcard(require("./lib/node/stream"));
exports.stream = stream;
var _readableFile = require("./lib/filesystems/readable-file");
var _writableFile = require("./lib/filesystems/writable-file");
var _nodeFilesystem = _interopRequireDefault(require("./lib/filesystems/node-filesystem"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/env-utils/assert":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js","./lib/env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js","./lib/option-utils/merge-loader-options":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/option-utils/merge-loader-options.js","./lib/worker-loader-utils/create-loader-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js","./lib/worker-loader-utils/parse-with-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js","./lib/worker-loader-utils/encode-with-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js","./lib/parser-utils/parse-json":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js","./lib/binary-utils/array-buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js","./lib/binary-utils/memory-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js","./lib/binary-utils/dataview-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/dataview-copy-utils.js","./lib/binary-utils/get-first-characters":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js","./lib/iterators/text-iterators":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js","./lib/iterators/async-iteration":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js","./lib/request-utils/request-scheduler":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js","./lib/path-utils/file-aliases":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js","./json-loader":"node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js","./lib/binary-utils/memory-conversion-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js","./lib/node/promisify":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/promisify.js","./lib/path-utils/path":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js","./lib/node/fs":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/fs.js","./lib/node/stream":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/stream.js","./lib/filesystems/readable-file":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/readable-file.js","./lib/filesystems/writable-file":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/writable-file.js","./lib/filesystems/node-filesystem":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js"}],"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isWritableNodeStream = exports.isWritableDOMStream = exports.isResponse = exports.isReadableStream = exports.isReadableNodeStream = exports.isReadableDOMStream = exports.isPureObject = exports.isPromise = exports.isObject = exports.isIterator = exports.isIterable = exports.isFile = exports.isBuffer = exports.isBlob = exports.isAsyncIterable = void 0;
const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';
exports.isObject = isObject;
const isPureObject = x => isObject(x) && x.constructor === {}.constructor;
exports.isPureObject = isPureObject;
const isPromise = x => isObject(x) && isFunction(x.then);
exports.isPromise = isPromise;
const isIterable = x => x && typeof x[Symbol.iterator] === 'function';
exports.isIterable = isIterable;
const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';
exports.isAsyncIterable = isAsyncIterable;
const isIterator = x => x && isFunction(x.next);
exports.isIterator = isIterator;
const isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
exports.isResponse = isResponse;
const isFile = x => typeof File !== 'undefined' && x instanceof File;
exports.isFile = isFile;
const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;
exports.isBlob = isBlob;
const isBuffer = x => x && typeof x === 'object' && x.isBuffer;
exports.isBuffer = isBuffer;
const isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
exports.isWritableDOMStream = isWritableDOMStream;
const isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
exports.isReadableDOMStream = isReadableDOMStream;
const isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
exports.isWritableNodeStream = isWritableNodeStream;
const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
exports.isReadableNodeStream = isReadableNodeStream;
const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);
exports.isReadableStream = isReadableStream;
const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);
exports.isWritableStream = isWritableStream;
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIMEType = parseMIMEType;
exports.parseMIMETypeFromURL = parseMIMETypeFromURL;
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function parseMIMEType(mimeString) {
  const matches = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches) {
    return matches[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches = DATA_URL_PATTERN.exec(url);
  if (matches) {
    return matches[1];
  }
  return '';
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractQueryString = extractQueryString;
exports.stripQueryString = stripQueryString;
const QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches = url.match(QUERY_STRING_PATTERN);
  return matches && matches[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourceContentLength = getResourceContentLength;
exports.getResourceMIMEType = getResourceMIMEType;
exports.getResourceUrl = getResourceUrl;
var _isType = require("../../javascript-utils/is-type");
var _mimeTypeUtils = require("./mime-type-utils");
var _urlUtils = require("./url-utils");
function getResourceUrl(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const response = resource;
    return response.url;
  }
  if ((0, _isType.isBlob)(resource)) {
    const blob = resource;
    return blob.name || '';
  }
  if (typeof resource === 'string') {
    return resource;
  }
  return '';
}
function getResourceMIMEType(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get('content-type') || '';
    const noQueryUrl = (0, _urlUtils.stripQueryString)(response.url);
    return (0, _mimeTypeUtils.parseMIMEType)(contentTypeHeader) || (0, _mimeTypeUtils.parseMIMETypeFromURL)(noQueryUrl);
  }
  if ((0, _isType.isBlob)(resource)) {
    const blob = resource;
    return blob.type || '';
  }
  if (typeof resource === 'string') {
    return (0, _mimeTypeUtils.parseMIMETypeFromURL)(resource);
  }
  return '';
}
function getResourceContentLength(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const response = resource;
    return response.headers['content-length'] || -1;
  }
  if ((0, _isType.isBlob)(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === 'string') {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./mime-type-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js","./url-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkResponse = checkResponse;
exports.checkResponseSync = checkResponseSync;
exports.makeResponse = makeResponse;
var _isType = require("../../javascript-utils/is-type");
var _resourceUtils = require("./resource-utils");
async function makeResponse(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = (0, _resourceUtils.getResourceContentLength)(resource);
  if (contentLength >= 0) {
    headers['content-length'] = String(contentLength);
  }
  const url = (0, _resourceUtils.getResourceUrl)(resource);
  const type = (0, _resourceUtils.getResourceMIMEType)(resource);
  if (type) {
    headers['content-type'] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers['x-first-bytes'] = initialDataUrl;
  }
  if (typeof resource === 'string') {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, 'url', {
    value: url
  });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}
function checkResponseSync(response) {
  if (!response.ok) {
    let message = "".concat(response.status, " ").concat(response.statusText);
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    throw new Error(message);
  }
}
async function getResponseError(response) {
  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
  try {
    const contentType = response.headers.get('Content-Type');
    let text = response.statusText;
    if (contentType.includes('application/json')) {
      text += " ".concat(await response.text());
    }
    message += text;
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
  } catch (error) {}
  return message;
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === 'string') {
    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = event => {
        var _event$target;
        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return "data:base64,".concat(base64);
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _responseUtils = require("../utils/response-utils");
async function fetchFile(url, options) {
  if (typeof url === 'string') {
    url = (0, _loaderUtils.resolvePath)(url);
    let fetchOptions = options;
    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {
      fetchOptions = options.fetch;
    }
    return await fetch(url, fetchOptions);
  }
  return await (0, _responseUtils.makeResponse)(url);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../utils/response-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readArrayBuffer = readArrayBuffer;
exports.readBlob = readBlob;
var _loaderUtils = require("@loaders.gl/loader-utils");
async function readArrayBuffer(file, start, length) {
  if (typeof file === 'number') {
    return await _loaderUtils.fs._readToArrayBuffer(file, start, length);
  }
  if (!(file instanceof Blob)) {
    file = new Blob([file]);
  }
  const slice = file.slice(start, start + length);
  return await readBlob(slice);
}
async function readBlob(blob) {
  return await new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.onload = event => {
      var _event$target;
      return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
    };
    fileReader.onerror = error => reject(error);
    fileReader.readAsArrayBuffer(blob);
  });
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
function readFileSync(url) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = (0, _loaderUtils.resolvePath)(url);
  if (!_loaderUtils.isBrowser) {
    const buffer = _loaderUtils.fs.readFileSync(url, options);
    return typeof buffer !== 'string' ? (0, _loaderUtils.toArrayBuffer)(buffer) : buffer;
  }
  if (!options.nothrow) {
    (0, _loaderUtils.assert)(false);
  }
  return null;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
async function writeFile(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);
  if (!_loaderUtils.isBrowser) {
    await _loaderUtils.fs.writeFile(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }
  (0, _loaderUtils.assert)(false);
}
function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);
  if (!_loaderUtils.isBrowser) {
    _loaderUtils.fs.writeFileSync(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }
  (0, _loaderUtils.assert)(false);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;
function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }
  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions['electron'])) {
    return true;
  }
  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }
  return false;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;
var _isElectron = _interopRequireDefault(require("./is-electron.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !true;
  return !isNode || (0, _isElectron.default)();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
},{"./is-electron.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js","process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.process = exports.navigator = exports.global = exports.document = exports.console = void 0;
const global_ = globalThis;
exports.global = global_;
const self_ = globalThis.self || globalThis.window || globalThis.global;
exports.self = self_;
const window_ = globalThis.window || globalThis.self || globalThis.global;
exports.window = window_;
const document_ = globalThis.document || {};
exports.document = document_;
const process_ = globalThis.process || {};
exports.process = process_;
const console_ = globalThis.console;
exports.console = console_;
const navigator_ = globalThis.navigator || {};
exports.navigator = navigator_;
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
exports.isBrowser = void 0;
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
var _isBrowser = _interopRequireDefault(require("../lib/is-browser.js"));
var _globals = require("../lib/globals.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
const isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;
},{"../lib/is-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js","../lib/globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js","process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/get-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBrowser;
exports.isMobile = isMobile;
var _isBrowser = _interopRequireDefault(require("./is-browser.js"));
var _isElectron = _interopRequireDefault(require("./is-electron.js"));
var _globals = require("./globals.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = globalThis;
function isMobile() {
  return typeof window.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }
  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }
  const userAgent = mockUserAgent || _globals.navigator.userAgent || '';
  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  if (isMSIE || isTrident) {
    return 'IE';
  }
  if (window.chrome) {
    return 'Chrome';
  }
  if (window.safari) {
    return 'Safari';
  }
  if (window.mozInnerScreenX) {
    return 'Firefox';
  }
  return 'Unknown';
}
},{"./is-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js","./is-electron.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js","./globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals2.window;
  }
});
var _globals = require("./utils/globals.js");
var _globals2 = require("./lib/globals.js");
var _isBrowser = _interopRequireWildcard(require("./lib/is-browser.js"));
var _getBrowser = _interopRequireWildcard(require("./lib/get-browser.js"));
var _isElectron = _interopRequireDefault(require("./lib/is-electron.js"));
var _assert = _interopRequireDefault(require("./utils/assert.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./utils/globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js","./lib/globals.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js","./lib/is-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js","./lib/get-browser.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/get-browser.js","./lib/is-electron.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js","./utils/assert.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/assert.js","process":"node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorage = void 0;
function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
class LocalStorage {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    this.storage = void 0;
    this.id = void 0;
    this.config = void 0;
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
}
exports.LocalStorage = LocalStorage;
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatImage = formatImage;
exports.formatTime = formatTime;
exports.formatValue = formatValue;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = options;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, options);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
function formatArrayValue(v, options) {
  const {
    maxElts = 16,
    size = 1
  } = options;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], options);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}
function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');
  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }
  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;
exports.addColor = addColor;
var _env = require("@probe.gl/env");
let COLOR;
exports.COLOR = COLOR;
(function (COLOR) {
  COLOR[COLOR["BLACK"] = 30] = "BLACK";
  COLOR[COLOR["RED"] = 31] = "RED";
  COLOR[COLOR["GREEN"] = 32] = "GREEN";
  COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
  COLOR[COLOR["BLUE"] = 34] = "BLUE";
  COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
  COLOR[COLOR["CYAN"] = 36] = "CYAN";
  COLOR[COLOR["WHITE"] = 37] = "WHITE";
  COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (exports.COLOR = COLOR = {}));
const BACKGROUND_INCREMENT = 10;
function getColor(color) {
  if (typeof color !== 'string') {
    return color;
  }
  color = color.toUpperCase();
  return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
  if (!_env.isBrowser && typeof string === 'string') {
    if (color) {
      const colorCode = getColor(color);
      string = "\x1B[".concat(colorCode, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      const colorCode = getColor(background);
      string = "\x1B[".concat(colorCode + BACKGROUND_INCREMENT, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}
},{"@probe.gl/env":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === 'function') {
      if (!predefined.find(name => key === name)) {
        object[key] = value.bind(obj);
      }
    }
  }
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiResTimestamp = getHiResTimestamp;
var _env = require("@probe.gl/env");
function getHiResTimestamp() {
  let timestamp;
  if ((0, _env.isBrowser)() && _env.window.performance) {
    var _window$performance, _window$performance$n;
    timestamp = _env.window === null || _env.window === void 0 ? void 0 : (_window$performance = _env.window.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ('hrtime' in _env.process) {
    var _process$hrtime;
    const timeParts = _env.process === null || _env.process === void 0 ? void 0 : (_process$hrtime = _env.process.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(_env.process);
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"@probe.gl/env":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Log = void 0;
exports.normalizeArguments = normalizeArguments;
var _env = require("@probe.gl/env");
var _localStorage = require("./utils/local-storage.js");
var _formatters = require("./utils/formatters.js");
var _color = require("./utils/color.js");
var _autobind = require("./utils/autobind.js");
var _assert = _interopRequireDefault(require("./utils/assert.js"));
var _hiResTimestamp = require("./utils/hi-res-timestamp.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const originalConsole = {
  debug: (0, _env.isBrowser)() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop() {}
const cache = {};
const ONCE = {
  once: true
};
class Log {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    };
    this.id = void 0;
    this.VERSION = _env.VERSION;
    this._startTs = (0, _hiResTimestamp.getHiResTimestamp)();
    this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
    this._storage = void 0;
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new _localStorage.LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_LOG_CONFIGURATION);
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    (0, _assert.default)(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = '',
      scale = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }
    return (0, _env.isBrowser)() ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      (0, _assert.default)(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache[tag]) {
          cache[tag] = (0, _hiResTimestamp.getHiResTimestamp)();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
}
exports.Log = Log;
Log.VERSION = _env.VERSION;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;
    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  (0, _assert.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {}
  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case 'object':
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  (0, _assert.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref2;
  console.warn('removed');
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref3;
  if (typeof image === 'string') {
    const img = new Image();
    img.onload = () => {
      const args = (0, _formatters.formatImage)(img, message, scale);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || '';
  if (element.toLowerCase() === 'img') {
    console.log(...(0, _formatters.formatImage)(image, message, scale));
    return noop;
  }
  if (element.toLowerCase() === 'canvas') {
    const img = new Image();
    img.onload = () => console.log(...(0, _formatters.formatImage)(img, message, scale));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }
  return 'empty';
}
},{"@probe.gl/env":"node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/index.js","./utils/local-storage.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js","./utils/formatters.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js","./utils/color.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js","./utils/autobind.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js","./utils/assert.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js","./utils/hi-res-timestamp.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/init.js":[function(require,module,exports) {
globalThis.probe = {};

},{}],"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _localStorage.LocalStorage;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.Log;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _autobind.autobind;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.getHiResTimestamp;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _formatters.rightPad;
  }
});
var _log = require("./log.js");
var _color = require("./utils/color.js");
var _formatters = require("./utils/formatters.js");
var _autobind = require("./utils/autobind.js");
var _localStorage = require("./utils/local-storage.js");
var _hiResTimestamp = require("./utils/hi-res-timestamp.js");
require("./init.js");
var _default = new _log.Log({
  id: '@probe.gl/log'
});
exports.default = _default;
},{"./log.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js","./utils/color.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js","./utils/formatters.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js","./utils/autobind.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js","./utils/local-storage.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js","./utils/hi-res-timestamp.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js","./init.js":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/init.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.probeLog = exports.NullLog = exports.ConsoleLog = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _log = require("@probe.gl/log");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const probeLog = new _log.Log({
  id: 'loaders.gl'
});
exports.probeLog = probeLog;
class NullLog {
  log() {
    return () => {};
  }
  info() {
    return () => {};
  }
  warn() {
    return () => {};
  }
  error() {
    return () => {};
  }
}
exports.NullLog = NullLog;
class ConsoleLog {
  constructor() {
    (0, _defineProperty2.default)(this, "console", void 0);
    this.console = console;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.console.log.bind(this.console, ...args);
  }
  info() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.console.info.bind(this.console, ...args);
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.console.warn.bind(this.console, ...args);
  }
  error() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.console.error.bind(this.console, ...args);
  }
}
exports.ConsoleLog = ConsoleLog;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/log":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVED_LOADER_OPTIONS = exports.DEFAULT_LOADER_OPTIONS = void 0;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _loggers = require("./loggers");
const DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers.ConsoleLog(),
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: _loaderUtils.isBrowser,
  _nodeWorkers: false,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
exports.DEFAULT_LOADER_OPTIONS = DEFAULT_LOADER_OPTIONS;
const REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
exports.REMOVED_LOADER_OPTIONS = REMOVED_LOADER_OPTIONS;
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./loggers":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlobalLoaderOptions = void 0;
exports.getGlobalLoaderState = getGlobalLoaderState;
exports.normalizeOptions = normalizeOptions;
exports.setGlobalOptions = setGlobalOptions;
var _isType = require("../../javascript-utils/is-type");
var _loggers = require("./loggers");
var _optionDefaults = require("./option-defaults");
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}
const getGlobalLoaderOptions = () => {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || {
    ..._optionDefaults.DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
};
exports.getGlobalLoaderOptions = getGlobalLoaderOptions;
function setGlobalOptions(options) {
  const state = getGlobalLoaderState();
  const globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _optionDefaults.DEFAULT_LOADER_OPTIONS, _optionDefaults.REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || 'Top level';
  const prefix = id ? "".concat(id, ".") : '';
  for (const key in options) {
    const isSubOptions = !id && (0, _isType.isObject)(options[key]);
    const isBaseUriOption = key === 'baseUri' && !id;
    const isWorkerUrlOption = key === 'workerUrl' && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = '';
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = {
    ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers.NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if ((0, _isType.isPureObject)(value) && (0, _isType.isPureObject)(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./loggers":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js","./option-defaults":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getLoaderOptions", {
  enumerable: true,
  get: function () {
    return _optionUtils.getGlobalLoaderOptions;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function () {
    return _optionUtils.setGlobalOptions;
  }
});
var _optionUtils = require("../loader-utils/option-utils");
},{"../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;
var _loaderUtils = require("@loaders.gl/loader-utils");
function isLoaderObject(loader) {
  var _loader;
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  var _loader2, _loader3;
  (0, _loaderUtils.assert)(loader, 'null loader');
  (0, _loaderUtils.assert)(isLoaderObject(loader), 'invalid loader');
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: {
        ...loader.options,
        ...options
      }
    };
  }
  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._unregisterLoaders = _unregisterLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;
exports.registerLoaders = registerLoaders;
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _optionUtils = require("../loader-utils/option-utils");
const getGlobalLoaderRegistry = () => {
  const state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    const normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);
    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
  const state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = [];
}
},{"../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = void 0;
var _log = require("@probe.gl/log");
const log = new _log.Log({
  id: 'loaders.gl'
});
exports.log = log;
},{"@probe.gl/log":"node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectLoader = selectLoader;
exports.selectLoaderSync = selectLoaderSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _log = require("../utils/log");
var _resourceUtils = require("../utils/resource-utils");
var _registerLoaders = require("./register-loaders");
var _isType = require("../../javascript-utils/is-type");
var _urlUtils = require("../utils/url-utils");
const EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, {
    ...options,
    nothrow: true
  }, context);
  if (loader) {
    return loader;
  }
  if ((0, _isType.isBlob)(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data) {
  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : undefined;
  let context = arguments.length > 3 ? arguments[3] : undefined;
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return (0, _normalizeLoader.normalizeLoader)(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...(0, _registerLoaders.getRegisteredLoaders)());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const type = (0, _resourceUtils.getResourceMIMEType)(data);
  const testUrl = (0, _urlUtils.stripQueryString)(url) || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = '';
  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? "matched url ".concat(testUrl) : '');
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? "matched MIME type ".concat(type) : '');
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data)) : '');
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  reason = reason || (loader ? "matched fallback MIME type ".concat(type) : '');
  if (reason) {
    var _loader;
    _log.log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const type = (0, _resourceUtils.getResourceMIMEType)(data);
  let message = 'No valid loader found (';
  message += url ? "".concat(_loaderUtils.path.filename(url), ", ") : 'no url provided, ';
  message += "MIME type: ".concat(type ? "\"".concat(type, "\"") : 'not provided', ", ");
  const firstCharacters = data ? getFirstCharacters(data) : '';
  message += firstCharacters ? " first bytes: \"".concat(firstCharacters, "\"") : 'first bytes: not available';
  message += ')';
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    (0, _normalizeLoader.normalizeLoader)(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }
    if (mimeType === "application/x.".concat(loader.id)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0, _loaderUtils.compareArrayBuffers)(test, data, test.byteLength);
  }
  switch (typeof test) {
    case 'function':
      return test(data, loader);
    case 'string':
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters(data) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../utils/log":"node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./register-loaders":"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../utils/url-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStringIterator = makeStringIterator;
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeArrayBufferIterator = makeArrayBufferIterator;
const DEFAULT_CHUNK_SIZE = 256 * 1024;
function makeArrayBufferIterator(arrayBuffer) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function* () {
    const {
      chunkSize = DEFAULT_CHUNK_SIZE
    } = options;
    let byteOffset = 0;
    while (byteOffset < arrayBuffer.byteLength) {
      const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
      const chunk = new ArrayBuffer(chunkByteLength);
      const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
      const chunkArray = new Uint8Array(chunk);
      chunkArray.set(sourceArray);
      byteOffset += chunkByteLength;
      yield chunk;
    }
  }();
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBlobIterator = makeBlobIterator;
const DEFAULT_CHUNK_SIZE = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStreamIterator = makeStreamIterator;
var _loaderUtils = require("@loaders.gl/loader-utils");
function makeStreamIterator(stream, options) {
  return _loaderUtils.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const {
        done,
        value
      } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield (0, _loaderUtils.toArrayBuffer)(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield (0, _loaderUtils.toArrayBuffer)(chunk);
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeIterator = makeIterator;
var _makeStringIterator = require("./make-string-iterator");
var _makeArrayBufferIterator = require("./make-array-buffer-iterator");
var _makeBlobIterator = require("./make-blob-iterator");
var _makeStreamIterator = require("./make-stream-iterator");
var _isType = require("../../javascript-utils/is-type");
function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0, _makeStringIterator.makeStringIterator)(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return (0, _makeArrayBufferIterator.makeArrayBufferIterator)(data, options);
  }
  if ((0, _isType.isBlob)(data)) {
    return (0, _makeBlobIterator.makeBlobIterator)(data, options);
  }
  if ((0, _isType.isReadableStream)(data)) {
    return (0, _makeStreamIterator.makeStreamIterator)(data, options);
  }
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    return (0, _makeStreamIterator.makeStreamIterator)(response.body, options);
  }
  throw new Error('makeIterator');
}
},{"./make-string-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js","./make-array-buffer-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js","./make-blob-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js","./make-stream-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getAsyncIterableFromData = getAsyncIterableFromData;
exports.getReadableStream = getReadableStream;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _isType = require("../../javascript-utils/is-type");
var _makeIterator = require("../../iterators/make-iterator/make-iterator");
var _responseUtils = require("../utils/response-utils");
const ERR_DATA = 'Cannot convert supplied data type';
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }
  if ((0, _isType.isBuffer)(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if ((0, _isType.isBlob)(data)) {
    data = await (0, _responseUtils.makeResponse)(data);
  }
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    await (0, _responseUtils.checkResponse)(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if ((0, _isType.isReadableStream)(data)) {
    data = (0, _makeIterator.makeIterator)(data, options);
  }
  if ((0, _isType.isIterable)(data) || (0, _isType.isAsyncIterable)(data)) {
    return (0, _loaderUtils.concatenateArrayBuffersAsync)(data);
  }
  throw new Error(ERR_DATA);
}
async function getAsyncIterableFromData(data, options) {
  if ((0, _isType.isIterator)(data)) {
    return data;
  }
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    await (0, _responseUtils.checkResponse)(response);
    const body = await response.body;
    return (0, _makeIterator.makeIterator)(body, options);
  }
  if ((0, _isType.isBlob)(data) || (0, _isType.isReadableStream)(data)) {
    return (0, _makeIterator.makeIterator)(data, options);
  }
  if ((0, _isType.isAsyncIterable)(data)) {
    return data[Symbol.asyncIterator]();
  }
  return getIterableFromData(data);
}
async function getReadableStream(data) {
  if ((0, _isType.isReadableStream)(data)) {
    return data;
  }
  if ((0, _isType.isResponse)(data)) {
    return data.body;
  }
  const response = await (0, _responseUtils.makeResponse)(data);
  return response.body;
}
function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return function* oneChunk() {
      yield data.buffer;
    }();
  }
  if (data instanceof ArrayBuffer) {
    return function* oneChunk() {
      yield data;
    }();
  }
  if ((0, _isType.isIterator)(data)) {
    return data;
  }
  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }
  throw new Error(ERR_DATA);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../../iterators/make-iterator/make-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","../utils/response-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFetchFunction = getFetchFunction;
var _isType = require("../../javascript-utils/is-type");
var _fetchFile = require("../fetch/fetch-file");
var _optionUtils = require("./option-utils");
function getFetchFunction(options, context) {
  const globalOptions = (0, _optionUtils.getGlobalLoaderOptions)();
  const fetchOptions = options || globalOptions;
  if (typeof fetchOptions.fetch === 'function') {
    return fetchOptions.fetch;
  }
  if ((0, _isType.isObject)(fetchOptions.fetch)) {
    return url => (0, _fetchFile.fetchFile)(url, fetchOptions);
  }
  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }
  return _fetchFile.fetchFile;
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoaderContext = getLoaderContext;
exports.getLoadersFromContext = getLoadersFromContext;
var _getFetchFunction = require("./get-fetch-function");
var _urlUtils = require("../utils/url-utils");
var _loaderUtils = require("@loaders.gl/loader-utils");
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: (0, _getFetchFunction.getFetchFunction)(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = (0, _urlUtils.stripQueryString)(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = (0, _urlUtils.extractQueryString)(newContext.url);
    newContext.filename = _loaderUtils.path.filename(baseUrl);
    newContext.baseUrl = _loaderUtils.path.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}
},{"./get-fetch-function":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js","../utils/url-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
var _workerUtils = require("@loaders.gl/worker-utils");
var _loaderUtils = require("@loaders.gl/loader-utils");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _isType = require("../../javascript-utils/is-type");
var _optionUtils = require("../loader-utils/option-utils");
var _getData = require("../loader-utils/get-data");
var _loaderContext = require("../loader-utils/loader-context");
var _resourceUtils = require("../utils/resource-utils");
var _selectLoader = require("./select-loader");
async function parse(data, loaders, options, context) {
  (0, _workerUtils.assert)(!context || typeof context === 'object');
  if (loaders && !Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const typedLoaders = loaders;
  const candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  const loader = await (0, _selectLoader.selectLoader)(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders, url);
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parse,
    loaders: candidateLoaders
  }, options, context || null);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  (0, _workerUtils.validateWorkerVersion)(loader);
  if ((0, _isType.isResponse)(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }
  data = await (0, _getData.getArrayBufferOrStringFromData)(data, loader, options);
  if (loader.parseTextSync && typeof data === 'string') {
    options.dataType = 'text';
    return loader.parseTextSync(data, options, context, loader);
  }
  if ((0, _loaderUtils.canParseWithWorker)(loader, options)) {
    return await (0, _loaderUtils.parseWithWorker)(loader, data, options, context, parse);
  }
  if (loader.parseText && typeof data === 'string') {
    return await loader.parseText(data, options, context, loader);
  }
  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }
  (0, _workerUtils.assert)(!loader.parseSync);
  throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _selectLoader = require("./select-loader");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _optionUtils = require("../loader-utils/option-utils");
var _getData = require("../loader-utils/get-data");
var _loaderContext = require("../loader-utils/loader-context");
var _resourceUtils = require("../utils/resource-utils");
function parseSync(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || typeof context === 'object');
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  options = options || {};
  const typedLoaders = loaders;
  const candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  const loader = (0, _selectLoader.selectLoaderSync)(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders);
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const parse = () => {
    throw new Error('parseSync called parse (which is async');
  };
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parseSync,
    parse,
    loaders: loaders
  }, options, context || null);
  return parseWithLoaderSync(loader, data, options, context);
}
function parseWithLoaderSync(loader, data, options, context) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader, options);
  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options);
  }
  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }
  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ''));
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInBatches = parseInBatches;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _optionUtils = require("../loader-utils/option-utils");
var _loaderContext = require("../loader-utils/loader-context");
var _getData = require("../loader-utils/get-data");
var _resourceUtils = require("../utils/resource-utils");
var _selectLoader = require("./select-loader");
var _parse = require("./parse");
async function parseInBatches(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || typeof context === 'object');
  const loaderArray = Array.isArray(loaders) ? loaders : undefined;
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = (0, _resourceUtils.getResourceUrl)(data);
  const loader = await (0, _selectLoader.selectLoader)(data, loaders, options);
  if (!loader) {
    return null;
  }
  options = (0, _optionUtils.normalizeOptions)(options, loader, loaderArray, url);
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parseInBatches,
    parse: _parse.parse,
    loaders: loaderArray
  }, options, context || null);
  return await parseWithLoaderInBatches(loader, data, options, context);
}
async function parseWithLoaderInBatches(loader, data, options, context) {
  const outputIterator = await parseToOutputIterator(loader, data, options, context);
  if (!options.metadata) {
    return outputIterator;
  }
  const metadataBatch = {
    batchType: 'metadata',
    metadata: {
      _loader: loader,
      _context: context
    },
    data: [],
    bytesUsed: 0
  };
  async function* makeMetadataBatchIterator(iterator) {
    yield metadataBatch;
    yield* iterator;
  }
  return makeMetadataBatchIterator(outputIterator);
}
async function parseToOutputIterator(loader, data, options, context) {
  const inputIterator = await (0, _getData.getAsyncIterableFromData)(data, options);
  const transformedIterator = await applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);
  if (loader.parseInBatches) {
    return loader.parseInBatches(transformedIterator, options, context);
  }
  async function* parseChunkInBatches() {
    const arrayBuffer = await (0, _loaderUtils.concatenateArrayBuffersAsync)(transformedIterator);
    const parsedData = await (0, _parse.parse)(arrayBuffer, loader, {
      ...options,
      mimeType: loader.mimeTypes[0]
    }, context);
    const batch = {
      mimeType: loader.mimeTypes[0],
      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',
      batchType: 'data',
      data: parsedData,
      length: Array.isArray(parsedData) ? parsedData.length : 1
    };
    yield batch;
  }
  return parseChunkInBatches();
}
async function applyInputTransforms(inputIterator) {
  let transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let iteratorChain = inputIterator;
  for await (const transformBatches of transforms) {
    iteratorChain = transformBatches(iteratorChain);
  }
  return iteratorChain;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","./parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;
var _isType = require("../../javascript-utils/is-type");
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _getFetchFunction = require("../loader-utils/get-fetch-function");
var _parse = require("./parse");
async function load(url, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  const fetch = (0, _getFetchFunction.getFetchFunction)(options);
  let data = url;
  if (typeof url === 'string') {
    data = await fetch(url);
  }
  if ((0, _isType.isBlob)(url)) {
    data = await fetch(url);
  }
  return await (0, _parse.parse)(data, loaders, options);
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/get-fetch-function":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js","./parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;
var _normalizeLoader = require("../loader-utils/normalize-loader");
var _getFetchFunction = require("../loader-utils/get-fetch-function");
var _parseInBatches = require("./parse-in-batches");
function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = null;
  }
  const fetch = (0, _getFetchFunction.getFetchFunction)(options || {});
  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch);
  }
  const promises = files.map(file => loadOneFileInBatches(file, loaders, options, fetch));
  return promises;
}
async function loadOneFileInBatches(file, loaders, options, fetch) {
  if (typeof file === 'string') {
    const url = file;
    const response = await fetch(url);
    return await (0, _parseInBatches.parseInBatches)(response, loaders, options);
  }
  return await (0, _parseInBatches.parseInBatches)(file, loaders, options);
}
},{"../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/get-fetch-function":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js","./parse-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeInBatches = encodeInBatches;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeURLtoURL = encodeURLtoURL;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _workerUtils = require("@loaders.gl/worker-utils");
var _writeFile = require("../fetch/write-file");
var _fetchFile = require("../fetch/fetch-file");
var _loaderOptions = require("./loader-options");
async function encode(data, writer, options) {
  const globalOptions = (0, _loaderOptions.getLoaderOptions)();
  options = {
    ...globalOptions,
    ...options
  };
  if ((0, _loaderUtils.canEncodeWithWorker)(writer, options)) {
    return await (0, _workerUtils.processOnWorker)(writer, data, options);
  }
  if (writer.encode) {
    return await writer.encode(data, options);
  }
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  if (writer.encodeText) {
    return new TextEncoder().encode(await writer.encodeText(data, options));
  }
  if (writer.encodeInBatches) {
    const batches = encodeInBatches(data, writer, options);
    const chunks = [];
    for await (const batch of batches) {
      chunks.push(batch);
    }
    return (0, _loaderUtils.concatenateArrayBuffers)(...chunks);
  }
  if (!_loaderUtils.isBrowser && writer.encodeURLtoURL) {
    const tmpInputFilename = getTemporaryFilename('input');
    await (0, _writeFile.writeFile)(tmpInputFilename, data);
    const tmpOutputFilename = getTemporaryFilename('output');
    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);
    const response = await (0, _fetchFile.fetchFile)(outputFilename);
    return response.arrayBuffer();
  }
  throw new Error('Writer could not encode data');
}
function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error('Writer could not synchronously encode data');
}
async function encodeText(data, writer, options) {
  if (writer.text && writer.encodeText) {
    return await writer.encodeText(data, options);
  }
  if (writer.text && (writer.encode || writer.encodeInBatches)) {
    const arrayBuffer = await encode(data, writer, options);
    return new TextDecoder().decode(arrayBuffer);
  }
  throw new Error('Writer could not encode data as text');
}
function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    const dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }
  throw new Error('Writer could not encode data in batches');
}
async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {
  inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
  outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);
  if (_loaderUtils.isBrowser || !writer.encodeURLtoURL) {
    throw new Error();
  }
  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);
  return outputFilename;
}
function getIterator(data) {
  const dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}
function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","../fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","../fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./loader-options":"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/save.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;
var _encode = require("./encode");
var _writeFile = require("../fetch/write-file");
async function save(data, url, writer, options) {
  const encodedData = await (0, _encode.encode)(data, writer, options);
  return await (0, _writeFile.writeFile)(url, encodedData);
}
function saveSync(data, url, writer, options) {
  const encodedData = (0, _encode.encodeSync)(data, writer, options);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}
},{"./encode":"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","../fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStream = makeStream;
function makeStream(source, options) {
  const iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream({
    type: 'bytes',
    async pull(controller) {
      try {
        const {
          done,
          value
        } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(new Uint8Array(value));
        }
      } catch (error) {
        controller.error(error);
      }
    },
    async cancel() {
      var _iterator$return;
      await (iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));
    }
  }, {
    highWaterMark: 2 ** 24,
    ...options
  });
}
},{}],"node_modules/@loaders.gl/core/dist/esm/null-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullWorkerLoader = exports.NullLoader = void 0;
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : 'latest';
const NullWorkerLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  worker: true,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  tests: [() => false],
  options: {
    null: {}
  }
};
exports.NullWorkerLoader = NullWorkerLoader;
function parseSync(arrayBuffer, options, context) {
  if (!options.null.echoParameters) return null;
  context = context && JSON.parse(JSON.stringify(context));
  return {
    arrayBuffer,
    options,
    context
  };
}
const NullLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  parse: async (arrayBuffer, options, context) => parseSync(arrayBuffer, options, context),
  parseSync,
  parseInBatches: async function* generator(asyncIterator, options, context) {
    for await (const batch of asyncIterator) {
      yield parseSync(batch, options, context);
    }
  },
  tests: [() => false],
  options: {
    null: {
      echoParameters: false
    }
  }
};
exports.NullLoader = NullLoader;
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchProgress;
async function fetchProgress(response, onProgress) {
  let onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
  let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};
  response = await response;
  if (!response.ok) {
    return response;
  }
  const body = response.body;
  if (!body) {
    return response;
  }
  const contentLength = response.headers.get('content-length') || 0;
  const totalBytes = contentLength ? parseInt(contentLength) : 0;
  if (!(totalBytes > 0)) {
    return response;
  }
  if (typeof ReadableStream === 'undefined' || !body.getReader) {
    return response;
  }
  const progressStream = new ReadableStream({
    async start(controller) {
      const reader = body.getReader();
      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
    }
  });
  return new Response(progressStream);
}
async function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
  try {
    const {
      done,
      value
    } = await reader.read();
    if (done) {
      onDone();
      controller.close();
      return;
    }
    loadedBytes += value.byteLength;
    const percent = Math.round(loadedBytes / totalBytes * 100);
    onProgress(percent, {
      loadedBytes,
      totalBytes
    });
    controller.enqueue(value);
    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
  } catch (error) {
    controller.error(error);
    onError(error);
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class BrowserFileSystem {
  constructor(files, options) {
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "files", {});
    (0, _defineProperty2.default)(this, "lowerCaseFiles", {});
    (0, _defineProperty2.default)(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;
    for (let i = 0; i < files.length; ++i) {
      const file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }
    this.fetch = this.fetch.bind(this);
  }
  async fetch(path, options) {
    if (path.includes('://')) {
      return this._fetch(path, options);
    }
    const file = this.files[path];
    if (!file) {
      return new Response(path, {
        status: 400,
        statusText: 'NOT FOUND'
      });
    }
    const headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
    const range = headers.get('Range');
    const bytes = range && /bytes=($1)-($2)/.exec(range);
    if (bytes) {
      const start = parseInt(bytes[1]);
      const end = parseInt(bytes[2]);
      const data = await file.slice(start, end).arrayBuffer();
      const response = new Response(data);
      Object.defineProperty(response, 'url', {
        value: path
      });
      return response;
    }
    const response = new Response(file);
    Object.defineProperty(response, 'url', {
      value: path
    });
    return response;
  }
  async readdir(dirname) {
    const files = [];
    for (const path in this.files) {
      files.push(path);
    }
    return files;
  }
  async stat(path, options) {
    const file = this.files[path];
    if (!file) {
      throw new Error(path);
    }
    return {
      size: file.size
    };
  }
  async unlink(path) {
    delete this.files[path];
    delete this.lowerCaseFiles[path];
    this.usedFiles[path] = true;
  }
  async open(pathname, flags, mode) {
    return this.files[pathname];
  }
  async read(fd, buffer) {
    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : buffer.byteLength;
    let position = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    const file = fd;
    const startPosition = 0;
    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();
    return {
      bytesRead: length,
      buffer: arrayBuffer
    };
  }
  async close(fd) {}
  _getFile(path, used) {
    const file = this.files[path] || this.lowerCaseFiles[path];
    if (file && used) {
      this.usedFiles[path] = true;
    }
    return file;
  }
}
exports.default = BrowserFileSystem;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@loaders.gl/core/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function () {
    return _loaderUtils.JSONLoader;
  }
});
Object.defineProperty(exports, "NullLoader", {
  enumerable: true,
  get: function () {
    return _nullLoader.NullLoader;
  }
});
Object.defineProperty(exports, "NullWorkerLoader", {
  enumerable: true,
  get: function () {
    return _nullLoader.NullWorkerLoader;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function () {
    return _loaderUtils.RequestScheduler;
  }
});
Object.defineProperty(exports, "_BrowserFileSystem", {
  enumerable: true,
  get: function () {
    return _browserFilesystem.default;
  }
});
Object.defineProperty(exports, "_fetchProgress", {
  enumerable: true,
  get: function () {
    return _fetchProgress.default;
  }
});
Object.defineProperty(exports, "_unregisterLoaders", {
  enumerable: true,
  get: function () {
    return _registerLoaders._unregisterLoaders;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _loaderUtils.assert;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function () {
    return _loaderUtils.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _loaderUtils.document;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function () {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function () {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function () {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeText", {
  enumerable: true,
  get: function () {
    return _encode.encodeText;
  }
});
Object.defineProperty(exports, "encodeURLtoURL", {
  enumerable: true,
  get: function () {
    return _encode.encodeURLtoURL;
  }
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function () {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function () {
    return _loaderUtils.forEach;
  }
});
Object.defineProperty(exports, "getLoaderOptions", {
  enumerable: true,
  get: function () {
    return _loaderOptions.getLoaderOptions;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function () {
    return _loaderUtils.getPathPrefix;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _loaderUtils.global;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function () {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _loaderUtils.isBrowser;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function () {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function () {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function () {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isPureObject", {
  enumerable: true,
  get: function () {
    return _isType.isPureObject;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function () {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isResponse", {
  enumerable: true,
  get: function () {
    return _isType.isResponse;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _loaderUtils.isWorker;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function () {
    return _isType.isWritableStream;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function () {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function () {
    return _loadInBatches.loadInBatches;
  }
});
Object.defineProperty(exports, "makeIterator", {
  enumerable: true,
  get: function () {
    return _makeIterator.makeIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeStream", {
  enumerable: true,
  get: function () {
    return _makeNodeStream.makeStream;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function () {
    return _parseInBatches.parseInBatches;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function () {
    return _parseSync.parseSync;
  }
});
Object.defineProperty(exports, "readArrayBuffer", {
  enumerable: true,
  get: function () {
    return _readArrayBuffer.readArrayBuffer;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function () {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function () {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function () {
    return _loaderUtils.resolvePath;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function () {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function () {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "selectLoader", {
  enumerable: true,
  get: function () {
    return _selectLoader.selectLoader;
  }
});
Object.defineProperty(exports, "selectLoaderSync", {
  enumerable: true,
  get: function () {
    return _selectLoader.selectLoaderSync;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _loaderUtils.self;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function () {
    return _loaderOptions.setLoaderOptions;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loaderUtils.setPathPrefix;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _loaderUtils.window;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function () {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function () {
    return _writeFile.writeFileSync;
  }
});
var _fetchFile = require("./lib/fetch/fetch-file");
var _readArrayBuffer = require("./lib/fetch/read-array-buffer");
var _readFile = require("./lib/fetch/read-file");
var _writeFile = require("./lib/fetch/write-file");
var _loaderOptions = require("./lib/api/loader-options");
var _registerLoaders = require("./lib/api/register-loaders");
var _selectLoader = require("./lib/api/select-loader");
var _parse = require("./lib/api/parse");
var _parseSync = require("./lib/api/parse-sync");
var _parseInBatches = require("./lib/api/parse-in-batches");
var _load = require("./lib/api/load");
var _loadInBatches = require("./lib/api/load-in-batches");
var _encode = require("./lib/api/encode");
var _save = require("./lib/api/save");
var _loaderUtils = require("@loaders.gl/loader-utils");
var _makeIterator = require("./iterators/make-iterator/make-iterator");
var _makeNodeStream = require("./iterators/make-stream/make-node-stream");
var _nullLoader = require("./null-loader");
var _fetchProgress = _interopRequireDefault(require("./lib/progress/fetch-progress"));
var _browserFilesystem = _interopRequireDefault(require("./lib/filesystems/browser-filesystem"));
var _isType = require("./javascript-utils/is-type");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./lib/fetch/read-array-buffer":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js","./lib/fetch/read-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js","./lib/fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","./lib/api/loader-options":"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js","./lib/api/register-loaders":"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","./lib/api/select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","./lib/api/parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js","./lib/api/parse-sync":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js","./lib/api/parse-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js","./lib/api/load":"node_modules/@loaders.gl/core/dist/esm/lib/api/load.js","./lib/api/load-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js","./lib/api/encode":"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","./lib/api/save":"node_modules/@loaders.gl/core/dist/esm/lib/api/save.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./iterators/make-iterator/make-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","./iterators/make-stream/make-node-stream":"node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js","./null-loader":"node_modules/@loaders.gl/core/dist/esm/null-loader.js","./lib/progress/fetch-progress":"node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js","./lib/filesystems/browser-filesystem":"node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js","./javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const VERSION = typeof "3.4.6" !== 'undefined' ? "3.4.6" : 'latest';
exports.VERSION = VERSION;
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultImageType = getDefaultImageType;
exports.isImageTypeSupported = isImageTypeSupported;
var _loaderUtils = require("@loaders.gl/loader-utils");
const {
  _parseImageNode
} = globalThis;
const IMAGE_SUPPORTED = typeof Image !== 'undefined';
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
const DATA_SUPPORTED = _loaderUtils.isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;
    case 'image':
      return IMAGE_SUPPORTED;
    case 'data':
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return 'imagebitmap';
  }
  if (IMAGE_SUPPORTED) {
    return 'image';
  }
  if (DATA_SUPPORTED) {
    return 'data';
  }
  throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteImage = deleteImage;
exports.getImageData = getImageData;
exports.getImageSize = getImageSize;
exports.getImageType = getImageType;
exports.isImage = isImage;
function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}
function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;
    default:
  }
}
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error('Not an image');
  }
  return format;
}
function getImageSize(image) {
  return getImageData(image);
}
function getImageData(image) {
  switch (getImageType(image)) {
    case 'data':
      return image;
    case 'image':
    case 'imagebitmap':
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (!context) {
        throw new Error('getImageData');
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error('getImageData');
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }
  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'image';
  }
  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    return 'data';
  }
  return null;
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBlob = getBlob;
exports.getBlobOrSVGDataUrl = getBlobOrSVGDataUrl;
exports.isSVG = isSVG;
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error('SVG cannot be parsed directly to imagebitmap');
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToImage;
exports.loadToImage = loadToImage;
var _svgUtils = require("./svg-utils");
async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = (0, _svgUtils.getBlobOrSVGDataUrl)(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error) {
      reject(error);
    }
  });
}
},{"./svg-utils":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToImageBitmap;
var _svgUtils = require("./svg-utils");
var _parseToImage = _interopRequireDefault(require("./parse-to-image"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if ((0, _svgUtils.isSVG)(url)) {
    const image = await (0, _parseToImage.default)(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = (0, _svgUtils.getBlob)(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob) {
  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
},{"./svg-utils":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js","./parse-to-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeMajorBrand = decodeMajorBrand;
exports.getISOBMFFMediaType = getISOBMFFMediaType;
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, 'ftyp', 4)) {
    return null;
  }
  if ((buffer[8] & 0x60) === 0x00) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace('\0', ' ').trim();
  switch (brandMajor) {
    case 'avif':
    case 'avis':
      return {
        extension: 'avif',
        mimeType: 'image/avif'
      };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map(character => character.charCodeAt(0));
}
function checkString(buffer, header) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const headerBytes = stringToBytes(header);
  for (let i = 0; i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset]) {
      return false;
    }
  }
  return true;
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBinaryImageMetadata = getBinaryImageMetadata;
exports.getBmpMetadata = getBmpMetadata;
var _parseIsobmffBinary = require("./parse-isobmff-binary");
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = (0, _parseIsobmffBinary.getISOBMFFMediaType)(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: 'image/png',
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: 'image/gif',
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: 'image/bmp',
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
  if (!isJpeg) {
    return null;
  }
  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: 'image/jpeg',
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error('toDataView');
}
},{"./parse-isobmff-binary":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToNodeImage;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _binaryImageApi = require("../category-api/binary-image-api");
async function parseToNodeImage(arrayBuffer, options) {
  const {
    mimeType
  } = (0, _binaryImageApi.getBinaryImageMetadata)(arrayBuffer) || {};
  const _parseImageNode = globalThis._parseImageNode;
  (0, _loaderUtils.assert)(_parseImageNode);
  return await _parseImageNode(arrayBuffer, mimeType);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseImage;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _imageType = require("../category-api/image-type");
var _parsedImageApi = require("../category-api/parsed-image-api");
var _parseToImage = _interopRequireDefault(require("./parse-to-image"));
var _parseToImageBitmap = _interopRequireDefault(require("./parse-to-image-bitmap"));
var _parseToNodeImage = _interopRequireDefault(require("./parse-to-node-image"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || 'auto';
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case 'imagebitmap':
      image = await (0, _parseToImageBitmap.default)(arrayBuffer, options, url);
      break;
    case 'image':
      image = await (0, _parseToImage.default)(arrayBuffer, options, url);
      break;
    case 'data':
      image = await (0, _parseToNodeImage.default)(arrayBuffer, options);
      break;
    default:
      (0, _loaderUtils.assert)(false);
  }
  if (imageType === 'data') {
    image = (0, _parsedImageApi.getImageData)(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case 'auto':
    case 'data':
      return (0, _imageType.getDefaultImageType)();
    default:
      (0, _imageType.isImageTypeSupported)(type);
      return type;
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../category-api/image-type":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./parse-to-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js","./parse-to-image-bitmap":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js","./parse-to-node-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js"}],"node_modules/@loaders.gl/images/dist/esm/image-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckImageLoader = exports.ImageLoader = void 0;
var _version = require("./lib/utils/version");
var _parseImage = _interopRequireDefault(require("./lib/parsers/parse-image"));
var _binaryImageApi = require("./lib/category-api/binary-image-api");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg', 'avif'];
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: 'auto',
    decode: true
  }
};
const ImageLoader = {
  id: 'image',
  module: 'images',
  name: 'Images',
  version: _version.VERSION,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _parseImage.default,
  tests: [arrayBuffer => Boolean((0, _binaryImageApi.getBinaryImageMetadata)(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};
exports.ImageLoader = ImageLoader;
const _typecheckImageLoader = ImageLoader;
exports._typecheckImageLoader = _typecheckImageLoader;
},{"./lib/utils/version":"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","./lib/parsers/parse-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","./lib/category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeImage = encodeImage;
var _parsedImageApi = require("../category-api/parsed-image-api");
const {
  _encodeImageNode
} = globalThis;
async function encodeImage(image, options) {
  options = options || {};
  options.image = options.image || {};
  return _encodeImageNode ? _encodeImageNode(image, {
    type: options.image.mimeType
  }) : encodeImageInBrowser(image, options);
}
let qualityParamSupported = true;
async function encodeImageInBrowser(image, options) {
  const {
    mimeType,
    jpegQuality
  } = options.image;
  const {
    width,
    height
  } = (0, _parsedImageApi.getImageSize)(image);
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  drawImageToCanvas(image, canvas);
  const blob = await new Promise(resolve => {
    if (jpegQuality && qualityParamSupported) {
      try {
        canvas.toBlob(resolve, mimeType, jpegQuality);
        return;
      } catch (error) {
        qualityParamSupported = false;
      }
    }
    canvas.toBlob(resolve, mimeType);
  });
  if (!blob) {
    throw new Error('image encoding failed');
  }
  return await blob.arrayBuffer();
}
function drawImageToCanvas(image, canvas) {
  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    const context = canvas.getContext('bitmaprenderer');
    if (context) {
      context.transferFromImageBitmap(image);
      return canvas;
    }
  }
  const context = canvas.getContext('2d');
  if (image.data) {
    const clampedArray = new Uint8ClampedArray(image.data);
    const imageData = new ImageData(clampedArray, image.width, image.height);
    context.putImageData(imageData, 0, 0);
    return canvas;
  }
  context.drawImage(image, 0, 0);
  return canvas;
}
},{"../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/image-writer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageWriter = void 0;
var _version = require("./lib/utils/version");
var _encodeImage = require("./lib/encoders/encode-image");
const ImageWriter = {
  name: 'Images',
  id: 'image',
  module: 'images',
  version: _version.VERSION,
  extensions: ['jpeg'],
  options: {
    image: {
      mimeType: 'image/png',
      jpegQuality: null
    }
  },
  encode: _encodeImage.encodeImage
};
exports.ImageWriter = ImageWriter;
},{"./lib/utils/version":"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","./lib/encoders/encode-image":"node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSupportedImageFormats = getSupportedImageFormats;
exports.isImageFormatSupported = isImageFormatSupported;
var _loaderUtils = require("@loaders.gl/loader-utils");
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/tiff', 'image/svg', 'image/svg+xml', 'image/bmp', 'image/vnd.microsoft.icon'];
const mimeTypeSupportedPromise = null;
async function getSupportedImageFormats() {
  if (mimeTypeSupportedPromise) {
    return await mimeTypeSupportedPromise;
  }
  const supportedMimeTypes = new Set();
  for (const mimeType of MIME_TYPES) {
    const supported = _loaderUtils.isBrowser ? await checkBrowserImageFormatSupportAsync(mimeType) : checkNodeImageFormatSupport(mimeType);
    if (supported) {
      supportedMimeTypes.add(mimeType);
    }
  }
  return supportedMimeTypes;
}
const mimeTypeSupportedSync = {};
function isImageFormatSupported(mimeType) {
  if (mimeTypeSupportedSync[mimeType] === undefined) {
    const supported = _loaderUtils.isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
    mimeTypeSupportedSync[mimeType] = supported;
  }
  return mimeTypeSupportedSync[mimeType];
}
function checkNodeImageFormatSupport(mimeType) {
  const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];
  const {
    _parseImageNode,
    _imageFormatsNode = NODE_FORMAT_SUPPORT
  } = globalThis;
  return Boolean(_parseImageNode) && _imageFormatsNode.includes(mimeType);
}
function checkBrowserImageFormatSupport(mimeType) {
  switch (mimeType) {
    case 'image/avif':
    case 'image/webp':
      return testBrowserImageFormatSupport(mimeType);
    default:
      return true;
  }
}
const TEST_IMAGE = {
  'image/avif': 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',
  'image/webp': 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'
};
async function checkBrowserImageFormatSupportAsync(mimeType) {
  const dataURL = TEST_IMAGE[mimeType];
  return dataURL ? await testBrowserImageFormatSupportAsync(dataURL) : true;
}
function testBrowserImageFormatSupport(mimeType) {
  try {
    const element = document.createElement('canvas');
    const dataURL = element.toDataURL(mimeType);
    return dataURL.indexOf("data:".concat(mimeType)) === 0;
  } catch {
    return false;
  }
}
async function testBrowserImageFormatSupportAsync(testImageDataURL) {
  return new Promise(resolve => {
    const image = new Image();
    image.src = testImageDataURL;
    image.onload = () => resolve(image.height > 0);
    image.onerror = () => resolve(false);
  });
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateUrl = generateUrl;
var _loaderUtils = require("@loaders.gl/loader-utils");
function generateUrl(getUrl, options, urlOptions) {
  let url = getUrl;
  if (typeof getUrl === 'function') {
    url = getUrl({
      ...options,
      ...urlOptions
    });
  }
  (0, _loaderUtils.assert)(typeof url === 'string');
  const {
    baseUrl
  } = options;
  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === '/' ? "".concat(baseUrl).concat(url) : "".concat(baseUrl, "/").concat(url);
  }
  return (0, _loaderUtils.resolvePath)(url);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asyncDeepMap = asyncDeepMap;
exports.mapSubtree = mapSubtree;
const isObject = value => value && typeof value === 'object';
async function asyncDeepMap(tree, func) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return await mapSubtree(tree, func, options);
}
async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }
  if (isObject(object)) {
    return await mapObject(object, func, options);
  }
  const url = object;
  return await func(url, options);
}
async function mapObject(object, func, options) {
  const promises = [];
  const values = {};
  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then(value => {
      values[key] = value;
    });
    promises.push(promise);
  }
  await Promise.all(promises);
  return values;
}
async function mapArray(urlArray, func) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const promises = urlArray.map(url => mapSubtree(url, func, options));
  return await Promise.all(promises);
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepLoad = deepLoad;
exports.shallowLoad = shallowLoad;
var _asyncDeepMap = require("./async-deep-map");
async function deepLoad(urlTree, load, options) {
  return await (0, _asyncDeepMap.asyncDeepMap)(urlTree, url => shallowLoad(url, load, options));
}
async function shallowLoad(url, load, options) {
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}
},{"./async-deep-map":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImageUrls = getImageUrls;
exports.getMipLevels = getMipLevels;
exports.loadImage = loadImage;
var _loaderUtils = require("@loaders.gl/loader-utils");
var _parseImage = _interopRequireDefault(require("../parsers/parse-image"));
var _parsedImageApi = require("../category-api/parsed-image-api");
var _generateUrl = require("./generate-url");
var _deepLoad = require("./deep-load");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
async function loadImage(getUrl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const imageUrls = await getImageUrls(getUrl, options);
  return await (0, _deepLoad.deepLoad)(imageUrls, _parseImage.default, options);
}
async function getImageUrls(getUrl, options) {
  let urlOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const mipLevels = options && options.image && options.image.mipLevels || 0;
  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : (0, _generateUrl.generateUrl)(getUrl, options, urlOptions);
}
async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];
  if (mipLevels === 'auto') {
    const url = (0, _generateUrl.generateUrl)(getUrl, options, {
      ...urlOptions,
      lod: 0
    });
    const image = await (0, _deepLoad.shallowLoad)(url, _parseImage.default, options);
    const {
      width,
      height
    } = (0, _parsedImageApi.getImageSize)(image);
    mipLevels = getMipLevels({
      width,
      height
    });
    urls.push(url);
  }
  (0, _loaderUtils.assert)(mipLevels > 0);
  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = (0, _generateUrl.generateUrl)(getUrl, options, {
      ...urlOptions,
      lod: mipLevel
    });
    urls.push(url);
  }
  return urls;
}
function getMipLevels(_ref) {
  let {
    width,
    height
  } = _ref;
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../parsers/parse-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./generate-url":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js","./deep-load":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js"}],"node_modules/@loaders.gl/images/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ImageLoader", {
  enumerable: true,
  get: function () {
    return _imageLoader.ImageLoader;
  }
});
Object.defineProperty(exports, "ImageWriter", {
  enumerable: true,
  get: function () {
    return _imageWriter.ImageWriter;
  }
});
Object.defineProperty(exports, "getBinaryImageMetadata", {
  enumerable: true,
  get: function () {
    return _binaryImageApi.getBinaryImageMetadata;
  }
});
Object.defineProperty(exports, "getDefaultImageType", {
  enumerable: true,
  get: function () {
    return _imageType.getDefaultImageType;
  }
});
Object.defineProperty(exports, "getImageData", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageData;
  }
});
Object.defineProperty(exports, "getImageSize", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageSize;
  }
});
Object.defineProperty(exports, "getImageType", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageType;
  }
});
Object.defineProperty(exports, "getSupportedImageFormats", {
  enumerable: true,
  get: function () {
    return _imageFormat.getSupportedImageFormats;
  }
});
Object.defineProperty(exports, "isImage", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.isImage;
  }
});
Object.defineProperty(exports, "isImageFormatSupported", {
  enumerable: true,
  get: function () {
    return _imageFormat.isImageFormatSupported;
  }
});
Object.defineProperty(exports, "isImageTypeSupported", {
  enumerable: true,
  get: function () {
    return _imageType.isImageTypeSupported;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadImage.loadImage;
  }
});
var _imageLoader = require("./image-loader");
var _imageWriter = require("./image-writer");
var _binaryImageApi = require("./lib/category-api/binary-image-api");
var _imageType = require("./lib/category-api/image-type");
var _parsedImageApi = require("./lib/category-api/parsed-image-api");
var _imageFormat = require("./lib/category-api/image-format");
var _loadImage = require("./lib/texture-api/load-image");
},{"./image-loader":"node_modules/@loaders.gl/images/dist/esm/image-loader.js","./image-writer":"node_modules/@loaders.gl/images/dist/esm/image-writer.js","./lib/category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js","./lib/category-api/image-type":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","./lib/category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./lib/category-api/image-format":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js","./lib/texture-api/load-image":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js"}],"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;
function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }
  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions['electron'])) {
    return true;
  }
  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }
  return false;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;
var _isElectron = _interopRequireDefault(require("./is-electron"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !true;
  return !isNode || (0, _isElectron.default)();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
},{"./is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.process = exports.global = exports.document = exports.console = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: typeof process === 'object' && process
};
const global_ = globalThis;
exports.global = global_;
const self_ = globals.self || globals.window || globals.global;
exports.self = self_;
const window_ = globals.window || globals.self || globals.global;
exports.window = window_;
const document_ = globals.document || {};
exports.document = document_;
const process_ = globals.process || {};
exports.process = process_;
const console_ = console;
exports.console = console_;
},{"process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
exports.isBrowser = void 0;
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
var _isBrowser = _interopRequireDefault(require("../lib/is-browser"));
var _globals = require("../lib/globals");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
const isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;
},{"../lib/is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","../lib/globals":"node_modules/@probe.gl/env/dist/esm/lib/globals.js","process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/get-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBrowser;
exports.isMobile = isMobile;
var _isBrowser = _interopRequireDefault(require("./is-browser"));
var _isElectron = _interopRequireDefault(require("./is-electron"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const window = globalThis;
function isMobile() {
  return typeof window.orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }
  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }
  const navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  const userAgent = mockUserAgent || navigator_.userAgent || '';
  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  if (isMSIE || isTrident) {
    return 'IE';
  }
  if (window.chrome) {
    return 'Chrome';
  }
  if (window.safari) {
    return 'Safari';
  }
  if (window.mozInnerScreenX) {
    return 'Firefox';
  }
  return 'Unknown';
}
},{"./is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","./is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js"}],"node_modules/@probe.gl/env/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@probe.gl/env/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals2.window;
  }
});
var _globals = require("./utils/globals");
var _globals2 = require("./lib/globals");
var _isBrowser = _interopRequireWildcard(require("./lib/is-browser"));
var _getBrowser = _interopRequireWildcard(require("./lib/get-browser"));
var _isElectron = _interopRequireDefault(require("./lib/is-electron"));
var _assert = _interopRequireDefault(require("./utils/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./utils/globals":"node_modules/@probe.gl/env/dist/esm/utils/globals.js","./lib/globals":"node_modules/@probe.gl/env/dist/esm/lib/globals.js","./lib/is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","./lib/get-browser":"node_modules/@probe.gl/env/dist/esm/lib/get-browser.js","./lib/is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","./utils/assert":"node_modules/@probe.gl/env/dist/esm/utils/assert.js","process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorage = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}
class LocalStorage {
  constructor(id, defaultConfig) {
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _defineProperty2.default)(this, "storage", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "config", void 0);
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
}
exports.LocalStorage = LocalStorage;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@probe.gl/log/dist/esm/utils/formatters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatImage = formatImage;
exports.formatTime = formatTime;
exports.formatValue = formatValue;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}
function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');
  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }
  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;
exports.addColor = addColor;
var _env = require("@probe.gl/env");
let COLOR;
exports.COLOR = COLOR;
(function (COLOR) {
  COLOR[COLOR["BLACK"] = 30] = "BLACK";
  COLOR[COLOR["RED"] = 31] = "RED";
  COLOR[COLOR["GREEN"] = 32] = "GREEN";
  COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
  COLOR[COLOR["BLUE"] = 34] = "BLUE";
  COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
  COLOR[COLOR["CYAN"] = 36] = "CYAN";
  COLOR[COLOR["WHITE"] = 37] = "WHITE";
  COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (exports.COLOR = COLOR = {}));
function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}
function addColor(string, color, background) {
  if (!_env.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@probe.gl/log/dist/esm/utils/autobind.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  for (const key of propNames) {
    if (typeof obj[key] === 'function') {
      if (!predefined.find(name => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiResTimestamp = getHiResTimestamp;
var _env = require("@probe.gl/env");
function getHiResTimestamp() {
  let timestamp;
  if (_env.isBrowser && 'performance' in _env.window) {
    var _window$performance, _window$performance$n;
    timestamp = _env.window === null || _env.window === void 0 ? void 0 : (_window$performance = _env.window.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ('hrtime' in _env.process) {
    var _process$hrtime;
    const timeParts = _env.process === null || _env.process === void 0 ? void 0 : (_process$hrtime = _env.process.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(_env.process);
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@probe.gl/log/dist/esm/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Log = void 0;
exports.normalizeArguments = normalizeArguments;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _env = require("@probe.gl/env");
var _localStorage = require("./utils/local-storage");
var _formatters = require("./utils/formatters");
var _color = require("./utils/color");
var _autobind = require("./utils/autobind");
var _assert = _interopRequireDefault(require("./utils/assert"));
var _hiResTimestamp = require("./utils/hi-res-timestamp");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const originalConsole = {
  debug: _env.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};
function noop() {}
const cache = {};
const ONCE = {
  once: true
};
class Log {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    };
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "VERSION", _env.VERSION);
    (0, _defineProperty2.default)(this, "_startTs", (0, _hiResTimestamp.getHiResTimestamp)());
    (0, _defineProperty2.default)(this, "_deltaTs", (0, _hiResTimestamp.getHiResTimestamp)());
    (0, _defineProperty2.default)(this, "_storage", void 0);
    (0, _defineProperty2.default)(this, "userData", {});
    (0, _defineProperty2.default)(this, "LOG_THROTTLE_TIMEOUT", 0);
    this.id = id;
    this.userData = {};
    this._storage = new _localStorage.LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this._storage.setConfiguration({
      enabled
    });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({
      level
    });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({
      [setting]: value
    });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    (0, _assert.default)(condition, message);
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }
  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = '',
      scale = 1
    } = _ref;
    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }
    return _env.isBrowser ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      (0, _assert.default)(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
      const tag = opts.tag || opts.message;
      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = (0, _hiResTimestamp.getHiResTimestamp)();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
}
exports.Log = Log;
(0, _defineProperty2.default)(Log, "VERSION", _env.VERSION);
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;
    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  (0, _assert.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {}
  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case 'object':
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  (0, _assert.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref2;
  console.warn('removed');
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref3;
  if (typeof image === 'string') {
    const img = new Image();
    img.onload = () => {
      const args = (0, _formatters.formatImage)(img, message, scale);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || '';
  if (element.toLowerCase() === 'img') {
    console.log(...(0, _formatters.formatImage)(image, message, scale));
    return noop;
  }
  if (element.toLowerCase() === 'canvas') {
    const img = new Image();
    img.onload = () => console.log(...(0, _formatters.formatImage)(img, message, scale));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }
  return 'empty';
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","./utils/local-storage":"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","./utils/formatters":"node_modules/@probe.gl/log/dist/esm/utils/formatters.js","./utils/color":"node_modules/@probe.gl/log/dist/esm/utils/color.js","./utils/autobind":"node_modules/@probe.gl/log/dist/esm/utils/autobind.js","./utils/assert":"node_modules/@probe.gl/log/dist/esm/utils/assert.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@probe.gl/log/dist/esm/init.js":[function(require,module,exports) {
globalThis.probe = {};

},{}],"node_modules/@probe.gl/log/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _localStorage.LocalStorage;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.Log;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _autobind.autobind;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.getHiResTimestamp;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _formatters.rightPad;
  }
});
var _log = require("./log");
var _color = require("./utils/color");
var _formatters = require("./utils/formatters");
var _autobind = require("./utils/autobind");
var _localStorage = require("./utils/local-storage");
var _hiResTimestamp = require("./utils/hi-res-timestamp");
require("./init");
var _default = new _log.Log({
  id: '@probe.gl/log'
});
exports.default = _default;
},{"./log":"node_modules/@probe.gl/log/dist/esm/log.js","./utils/color":"node_modules/@probe.gl/log/dist/esm/utils/color.js","./utils/formatters":"node_modules/@probe.gl/log/dist/esm/utils/formatters.js","./utils/autobind":"node_modules/@probe.gl/log/dist/esm/utils/autobind.js","./utils/local-storage":"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js","./init":"node_modules/@probe.gl/log/dist/esm/init.js"}],"node_modules/@deck.gl/core/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _log = require("@probe.gl/log");
var _default = new _log.Log({
  id: 'deck'
});
exports.default = _default;
},{"@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/debug/loggers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoggers = void 0;
const logState = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
};
const LOG_LEVEL_MAJOR_UPDATE = 1;
const LOG_LEVEL_MINOR_UPDATE = 2;
const LOG_LEVEL_UPDATE_DETAIL = 3;
const LOG_LEVEL_INFO = 4;
const LOG_LEVEL_DRAW = 2;
const getLoggers = log => ({
  'layer.changeFlag': (layer, key, flags) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
  },
  'layer.initialize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
  },
  'layer.update': (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter(key => flags[key]).join(', ')))();
    } else {
      log.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
    }
  },
  'layer.matched': (layer, changed) => {
    if (changed) {
      log.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
    }
  },
  'layer.finalize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
  },
  'compositeLayer.renderLayers': (layer, updated, subLayers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
    } else {
      log.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
    }
  },
  'layerManager.setLayers': (layerManager, updated, layers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
    }
  },
  'layerManager.activateViewport': (layerManager, viewport) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();
  },
  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
  },
  'attributeManager.updateStart': attributeManager => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  'attributeManager.updateEnd': (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
    for (const updateMessage of logState.attributeUpdateMessages) {
      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }
    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  'attribute.updateStart': attribute => {
    logState.attributeUpdateStart = Date.now();
  },
  'attribute.allocate': (attribute, numInstances) => {
    const message = "".concat(attribute.id, " allocated ").concat(numInstances);
    logState.attributeUpdateMessages.push(message);
  },
  'attribute.updateEnd': (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
    logState.attributeUpdateMessages.push(message);
  },
  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {
    const {
      pass,
      redrawReason,
      stats
    } = opts;
    for (const status of renderStats) {
      const {
        totalCount,
        visibleCount,
        compositeCount,
        pickableCount
      } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
      if (stats) {
        stats.get('Redraw Layers').add(visibleCount);
      }
    }
  }
});
exports.getLoggers = getLoggers;
},{}],"node_modules/@deck.gl/core/dist/esm/debug/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debug;
exports.register = register;
var _log = _interopRequireDefault(require("../utils/log"));
var _loggers = require("./loggers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let loggers = {};
if ("development" !== 'production') {
  loggers = (0, _loggers.getLoggers)(_log.default);
}
function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (_log.default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","./loggers":"node_modules/@deck.gl/core/dist/esm/debug/loggers.js"}],"node_modules/@deck.gl/core/dist/esm/utils/json-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === '{' && lastChar === '}' || firstChar === '[' && lastChar === ']';
}
var _default = {
  id: 'JSON',
  name: 'JSON',
  module: '',
  version: '',
  options: {},
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json', 'application/geo+json'],
  testText: isJSON,
  parseTextSync: JSON.parse
};
exports.default = _default;
},{}],"node_modules/@deck.gl/core/dist/esm/lib/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
var _core = require("@loaders.gl/core");
var _images = require("@loaders.gl/images");
var _log = _interopRequireDefault(require("../utils/log"));
var _debug = require("../debug");
var _jsonLoader = _interopRequireDefault(require("../utils/json-loader"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function checkVersion() {
  const version = typeof "8.9.4" !== 'undefined' ? "8.9.4" : globalThis.DECK_VERSION || 'untranspiled source';
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;
  if (existingVersion && existingVersion !== version) {
    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
  }
  if (!existingVersion) {
    _log.default.log(1, "deck.gl ".concat(version))();
    globalThis.deck = {
      ...globalThis.deck,
      VERSION: version,
      version,
      log: _log.default,
      _registerLoggers: _debug.register
    };
    (0, _core.registerLoaders)([_jsonLoader.default, [_images.ImageLoader, {
      imagebitmap: {
        premultiplyAlpha: 'none'
      }
    }]]);
  }
  return version;
}
const VERSION = checkVersion();
exports.VERSION = VERSION;
},{"@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js","@loaders.gl/images":"node_modules/@loaders.gl/images/dist/esm/index.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/json-loader":"node_modules/@deck.gl/core/dist/esm/utils/json-loader.js"}],"node_modules/@deck.gl/core/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNIT = exports.PROJECTION_MODE = exports.OPERATION = exports.EVENTS = exports.COORDINATE_SYSTEM = void 0;
var _log = _interopRequireDefault(require("../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const COORDINATE_SYSTEM = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
exports.COORDINATE_SYSTEM = COORDINATE_SYSTEM;
Object.defineProperty(COORDINATE_SYSTEM, 'IDENTITY', {
  get: () => {
    _log.default.deprecated('COORDINATE_SYSTEM.IDENTITY', 'COORDINATE_SYSTEM.CARTESIAN')();
    return 0;
  }
});
const PROJECTION_MODE = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
};
exports.PROJECTION_MODE = PROJECTION_MODE;
const UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
exports.UNIT = UNIT;
const EVENTS = {
  click: {
    handler: 'onClick'
  },
  panstart: {
    handler: 'onDragStart'
  },
  panmove: {
    handler: 'onDrag'
  },
  panend: {
    handler: 'onDragEnd'
  }
};
exports.EVENTS = EVENTS;
const OPERATION = {
  DRAW: 'draw',
  MASK: 'mask',
  TERRAIN: 'terrain'
};
exports.OPERATION = OPERATION;
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = void 0;
var _log = require("@probe.gl/log");
const log = new _log.Log({
  id: 'luma.gl'
});
exports.log = log;
},{"@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERR_WEBGL2 = exports.ERR_WEBGL = void 0;
exports.assertWebGL2Context = assertWebGL2Context;
exports.assertWebGLContext = assertWebGLContext;
exports.getWebGL2Context = getWebGL2Context;
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;
var _assert = require("./assert");
const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
const ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  (0, _assert.assert)(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  (0, _assert.assert)(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}
},{"./assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillVertexArrayObject = polyfillVertexArrayObject;
const glErrorShadow = {};
function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}
function log(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}
function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== undefined) {
    error(opt_msg);
  }
}
function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);
    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }
    return 0;
  };
}
const WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
  const gl = ext.gl;
  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;
  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);
  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }
  this.maxAttrib = 0;
};
WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = 5126;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;
  this.cached = '';
  this.recache();
};
WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(':');
};
const OESVertexArrayObject = function OESVertexArrayObject(gl) {
  const self = this;
  this.gl = gl;
  wrapGLError(gl);
  const original = this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  };
  gl.getParameter = function getParameter(pname) {
    if (pname === self.VERTEX_ARRAY_BINDING_OES) {
      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
        return null;
      }
      return self.currentVertexArrayObject;
    }
    return original.getParameter.apply(this, arguments);
  };
  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };
  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };
  gl.bindBuffer = function bindBuffer(target, buffer) {
    switch (target) {
      case 34962:
        self.currentArrayBuffer = buffer;
        break;
      case 34963:
        self.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;
      default:
    }
    return original.bindBuffer.apply(this, arguments);
  };
  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self.currentVertexArrayObject;
    const attrib = vao.attribs[index];
    switch (pname) {
      case 34975:
        return attrib.buffer;
      case 34338:
        return attrib.enabled;
      case 34339:
        return attrib.size;
      case 34340:
        return attrib.stride;
      case 34341:
        return attrib.type;
      case 34922:
        return attrib.normalized;
      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };
  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self.currentArrayBuffer;
    attrib.size = size;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };
  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, 'OES_vertex_array_object');
  }
  if (gl.canvas) {
    gl.canvas.addEventListener('webglcontextrestored', () => {
      log('OESVertexArrayObject emulation library context restored');
      self.reset_();
    }, true);
  }
  this.reset_();
};
OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;
OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== undefined;
  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }
  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(34921);
  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];
  this.bindVertexArrayOES(null);
};
OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};
OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};
OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }
  return false;
};
OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;
  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(1282, 'bindVertexArrayOES: attempt to bind deleted arrayObject');
    return;
  }
  const original = this.original;
  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;
  if (oldVAO === newVAO) {
    return;
  }
  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
  }
  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }
    if (attrib.enabled) {
      let bufferChanged = false;
      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, 34962, attrib.buffer);
          currentBinding = attrib.buffer;
        }
        bufferChanged = true;
      }
      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      }
    }
  }
  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
  }
};
function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === 'function') {
    return;
  }
  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf('OES_vertex_array_object') < 0) {
      list.push('OES_vertex_array_object');
    }
    return list;
  };
  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== 'OES_vertex_array_object') {
      return null;
    }
    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameterPolyfill = getParameterPolyfill;
var _webglChecks = require("../utils/webgl-checks");
const OES_element_index = 'OES_element_index';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const GL_DONT_CARE = 0x1100;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const GL_UNMASKED_VENDOR_WEBGL = 0x9245;
const GL_UNMASKED_RENDERER_WEBGL = 0x9246;
const getWebGL2ValueOrZero = gl => !(0, _webglChecks.isWebGL2)(gl) ? 0 : undefined;
const WEBGL_PARAMETERS = {
  [3074]: gl => !(0, _webglChecks.isWebGL2)(gl) ? 36064 : undefined,
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => !(0, _webglChecks.isWebGL2)(gl) ? GL_DONT_CARE : undefined,
  [35977]: getWebGL2ValueOrZero,
  [32937]: getWebGL2ValueOrZero,
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = (0, _webglChecks.isWebGL2)(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
  },
  [32883]: getWebGL2ValueOrZero,
  [35071]: getWebGL2ValueOrZero,
  [37447]: getWebGL2ValueOrZero,
  [36063]: (gl, getParameter) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return undefined;
  },
  [35379]: getWebGL2ValueOrZero,
  [35374]: getWebGL2ValueOrZero,
  [35377]: getWebGL2ValueOrZero,
  [34852]: gl => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return undefined;
  },
  [36203]: gl => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
  [33001]: gl => gl.getExtension(OES_element_index) ? 16777216 : 65535,
  [33000]: gl => 16777216,
  [37157]: getWebGL2ValueOrZero,
  [35373]: getWebGL2ValueOrZero,
  [35657]: getWebGL2ValueOrZero,
  [36183]: getWebGL2ValueOrZero,
  [37137]: getWebGL2ValueOrZero,
  [34045]: getWebGL2ValueOrZero,
  [35978]: getWebGL2ValueOrZero,
  [35979]: getWebGL2ValueOrZero,
  [35968]: getWebGL2ValueOrZero,
  [35376]: getWebGL2ValueOrZero,
  [35375]: getWebGL2ValueOrZero,
  [35659]: getWebGL2ValueOrZero,
  [37154]: getWebGL2ValueOrZero,
  [35371]: getWebGL2ValueOrZero,
  [35658]: getWebGL2ValueOrZero,
  [35076]: getWebGL2ValueOrZero,
  [35077]: getWebGL2ValueOrZero,
  [35380]: getWebGL2ValueOrZero
};
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}
},{"../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBGL2_CONTEXT_POLYFILLS = exports.WEBGL2_CONTEXT_OVERRIDES = void 0;
var _assert = require("../utils/assert");
var _webglChecks = require("../utils/webgl-checks");
var _getParameterPolyfill = require("./get-parameter-polyfill");
const OES_vertex_array_object = 'OES_vertex_array_object';
const ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';
function getExtensionData(gl, extension) {
  return {
    webgl2: (0, _webglChecks.isWebGL2)(gl),
    ext: gl.getExtension(extension)
  };
}
const WEBGL2_CONTEXT_POLYFILLS = {
  [OES_vertex_array_object]: {
    meta: {
      suffix: 'OES'
    },
    createVertexArray: () => {
      (0, _assert.assert)(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {},
    bindVertexArray: () => {},
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: 'ANGLE'
    },
    vertexAttribDivisor(location, divisor) {
      (0, _assert.assert)(divisor === 0, 'WebGL instanced rendering not supported');
    },
    drawElementsInstanced: () => {},
    drawArraysInstanced: () => {}
  },
  [WEBGL_draw_buffers]: {
    meta: {
      suffix: 'WEBGL'
    },
    drawBuffers: () => {
      (0, _assert.assert)(false);
    }
  },
  [EXT_disjoint_timer_query]: {
    meta: {
      suffix: 'EXT'
    },
    createQuery: () => {
      (0, _assert.assert)(false);
    },
    deleteQuery: () => {
      (0, _assert.assert)(false);
    },
    beginQuery: () => {
      (0, _assert.assert)(false);
    },
    endQuery: () => {},
    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: () => {}
  }
};
exports.WEBGL2_CONTEXT_POLYFILLS = WEBGL2_CONTEXT_POLYFILLS;
const WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: (gl, originalFunc, attachment) => {
    if ((0, _webglChecks.isWebGL2)(gl)) {
      originalFunc(attachment);
    } else {}
  },
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    const {
      webgl2,
      ext
    } = getExtensionData(gl, ANGLE_instanced_arrays);
    let result;
    switch (pname) {
      case 35069:
        result = !webgl2 ? false : undefined;
        break;
      case 35070:
        result = !webgl2 && !ext ? 0 : undefined;
        break;
      default:
    }
    return result !== undefined ? result : originalFunc(location, pname);
  },
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      switch (pname) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
        default:
      }
    }
    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);
        default:
      }
    }
    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        const {
          extensions
        } = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
      default:
    }
    return originalFunc(target, pname);
  },
  getParameter: _getParameterPolyfill.getParameterPolyfill,
  hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }
};
exports.WEBGL2_CONTEXT_OVERRIDES = WEBGL2_CONTEXT_OVERRIDES;
},{"../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","./get-parameter-polyfill":"node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillContext = polyfillContext;
var _polyfillVertexArrayObject = require("./polyfill-vertex-array-object");
var _assert = require("../utils/assert");
var _polyfillTable = require("./polyfill-table");
function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;
  if (!luma.polyfilled) {
    (0, _polyfillVertexArrayObject.polyfillVertexArrayObject)(gl);
    initializeExtensions(gl);
    installPolyfills(gl, _polyfillTable.WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }
  return gl;
}
globalThis.polyfillContext = polyfillContext;
function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}
function installOverrides(gl, _ref) {
  let {
    target,
    target2
  } = _ref;
  Object.keys(_polyfillTable.WEBGL2_CONTEXT_OVERRIDES).forEach(key => {
    if (typeof _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key] === 'function') {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};
      const polyfill = _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}
function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== 'overrides') {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}
function polyfillExtension(gl, _ref2) {
  let {
    extension,
    target,
    target2
  } = _ref2;
  const defaults = _polyfillTable.WEBGL2_CONTEXT_POLYFILLS[extension];
  (0, _assert.assert)(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ''
  } = meta;
  const ext = gl.getExtension(extension);
  for (const key of Object.keys(defaults)) {
    const extKey = "".concat(key).concat(suffix);
    let polyfill = null;
    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {
      polyfill = function () {
        return ext[extKey](...arguments);
      };
    } else if (typeof defaults[key] === 'function') {
      polyfill = defaults[key].bind(target);
    }
    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
},{"./polyfill-vertex-array-object":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","./polyfill-table":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js"}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GL_PARAMETER_SETTERS = exports.GL_PARAMETER_GETTERS = exports.GL_PARAMETER_DEFAULTS = exports.GL_HOOKED_SETTERS = exports.GL_COMPOSITE_PARAMETER_SETTERS = void 0;
var _webglChecks = require("../utils/webgl-checks");
const GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  [2930]: true,
  [3024]: true,
  [36006]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32938]: 1.0,
  [32939]: false,
  [3089]: false,
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 0xffffffff,
  [36005]: 0xffffffff,
  [2962]: 519,
  [2967]: 0,
  [2963]: 0xffffffff,
  [34816]: 519,
  [36003]: 0,
  [36004]: 0xffffffff,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  [2978]: [0, 0, 1024, 1024],
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
exports.GL_PARAMETER_DEFAULTS = GL_PARAMETER_DEFAULTS;
const enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
const hint = (gl, value, key) => gl.hint(key, value);
const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
const drawFramebuffer = (gl, value) => {
  const target = (0, _webglChecks.isWebGL2)(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};
const readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(36008, value);
};
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}
const GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: 'blendEquation',
  [34877]: 'blendEquation',
  [32969]: 'blendFunc',
  [32968]: 'blendFunc',
  [32971]: 'blendFunc',
  [32970]: 'blendFunc',
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [36006]: drawFramebuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: 'polygonOffset',
  [10752]: 'polygonOffset',
  [35977]: enable,
  [32938]: 'sampleCoverage',
  [32939]: 'sampleCoverage',
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: 'stencilFuncFront',
  [2967]: 'stencilFuncFront',
  [2963]: 'stencilFuncFront',
  [34816]: 'stencilFuncBack',
  [36003]: 'stencilFuncBack',
  [36004]: 'stencilFuncBack',
  [2964]: 'stencilOpFront',
  [2965]: 'stencilOpFront',
  [2966]: 'stencilOpFront',
  [34817]: 'stencilOpBack',
  [34818]: 'stencilOpBack',
  [34819]: 'stencilOpBack',
  [2978]: (gl, value) => gl.viewport(...value),
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [36010]: readFramebuffer,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
exports.GL_PARAMETER_SETTERS = GL_PARAMETER_SETTERS;
function getValue(glEnum, values, cache) {
  return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}
const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache) => gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),
  blendFunc: (gl, values, cache) => gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),
  polygonOffset: (gl, values, cache) => gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),
  sampleCoverage: (gl, values, cache) => gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),
  stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),
  stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),
  stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),
  stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))
};
exports.GL_COMPOSITE_PARAMETER_SETTERS = GL_COMPOSITE_PARAMETER_SETTERS;
const GL_HOOKED_SETTERS = {
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint) => update({
    [pname]: hint
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });
      case 36009:
        return update({
          [36006]: framebuffer
        });
      case 36008:
        return update({
          [36010]: framebuffer
        });
      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [32938]: value,
    [32939]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: [x, y, width, height]
  })
};
exports.GL_HOOKED_SETTERS = GL_HOOKED_SETTERS;
const isEnabled = (gl, key) => gl.isEnabled(key);
const GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};
exports.GL_PARAMETER_GETTERS = GL_PARAMETER_GETTERS;
},{"../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepArrayEqual = deepArrayEqual;
exports.isObjectEmpty = isObjectEmpty;
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popContextState = popContextState;
exports.pushContextState = pushContextState;
exports.trackContextState = trackContextState;
var _webglParameterTables = require("./webgl-parameter-tables");
var _unifiedParameterApi = require("./unified-parameter-api");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get() {
    const pname = arguments.length <= 0 ? undefined : arguments[0];
    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...arguments);
    }
    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
  };
  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}
class GLState {
  constructor(gl) {
    let {
      copyState = false,
      log = () => {}
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? (0, _unifiedParameterApi.getParameters)(gl) : Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }
  push() {
    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.stateStack.push({});
  }
  pop() {
    (0, _assert.assert)(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    (0, _unifiedParameterApi.setParameters)(this.gl, oldValues);
    this.stateStack.pop();
  }
  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
    for (const key in values) {
      (0, _assert.assert)(key !== undefined);
      const value = values[key];
      const cached = this.cache[key];
      if (!(0, _utils.deepArrayEqual)(value, cached)) {
        valueChanged = true;
        oldValue = cached;
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }
        this.cache[key] = value;
      }
    }
    return {
      valueChanged,
      oldValue
    };
  }
}
function trackContextState(gl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    enable = true,
    copyState
  } = options;
  (0, _assert.assert)(copyState !== undefined);
  if (!gl.state) {
    const {
      polyfillContext
    } = globalThis;
    if (polyfillContext) {
      polyfillContext(gl);
    }
    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);
    for (const key in _webglParameterTables.GL_HOOKED_SETTERS) {
      const setter = _webglParameterTables.GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }
  gl.state.enable = enable;
  return gl;
}
function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }
  gl.state.push();
}
function popContextState(gl) {
  (0, _assert.assert)(gl.state);
  gl.state.pop();
}
},{"./webgl-parameter-tables":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js","./unified-parameter-api":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameters = getParameters;
exports.resetParameters = resetParameters;
exports.setParameters = setParameters;
exports.withParameters = withParameters;
var _webglParameterTables = require("./webgl-parameter-tables");
var _trackContextState = require("./track-context-state");
var _assert = require("../utils/assert");
var _webglChecks = require("../utils/webgl-checks");
var _utils = require("../utils/utils");
function setParameters(gl, values) {
  (0, _assert.assert)((0, _webglChecks.isWebGL)(gl), 'setParameters requires a WebGL context');
  if ((0, _utils.isObjectEmpty)(values)) {
    return;
  }
  const compositeSetters = {};
  for (const key in values) {
    const glConstant = Number(key);
    const setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }
  const cache = gl.state && gl.state.cache;
  if (cache) {
    for (const key in compositeSetters) {
      const compositeSetter = _webglParameterTables.GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, values, cache);
    }
  }
}
function getParameters(gl, parameters) {
  parameters = parameters || _webglParameterTables.GL_PARAMETER_DEFAULTS;
  if (typeof parameters === 'number') {
    const key = parameters;
    const getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetParameters(gl) {
  setParameters(gl, _webglParameterTables.GL_PARAMETER_DEFAULTS);
}
function withParameters(gl, parameters, func) {
  if ((0, _utils.isObjectEmpty)(parameters)) {
    return func(gl);
  }
  const {
    nocatch = true
  } = parameters;
  (0, _trackContextState.pushContextState)(gl);
  setParameters(gl, parameters);
  let value;
  if (nocatch) {
    value = func(gl);
    (0, _trackContextState.popContextState)(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      (0, _trackContextState.popContextState)(gl);
    }
  }
  return value;
}
},{"./webgl-parameter-tables":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js","./track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","../utils/utils":"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssToDevicePixels = cssToDevicePixels;
exports.cssToDeviceRatio = cssToDeviceRatio;
exports.getDevicePixelRatio = getDevicePixelRatio;
function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;
  if (gl.canvas && luma) {
    const cachedSize = luma.canvasSizeInfo;
    const clientWidth = 'clientWidth' in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }
  return 1;
}
function cssToDevicePixels(gl, cssPixel) {
  let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/context/context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGLContext = createGLContext;
exports.getContextDebugInfo = getContextDebugInfo;
exports.instrumentGLContext = instrumentGLContext;
exports.resizeGLContext = resizeGLContext;
var _env = require("@probe.gl/env");
var _trackContextState = require("../state-tracker/track-context-state");
var _log = require("../utils/log");
var _assert = require("../utils/assert");
var _devicePixels = require("../utils/device-pixels");
var _webglChecks = require("../utils/webgl-checks");
const isBrowser = (0, _env.isBrowser)();
const isPage = isBrowser && typeof document !== 'undefined';
const CONTEXT_DEFAULTS = {
  webgl2: true,
  webgl1: true,
  throwOnError: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};
function createGLContext() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  (0, _assert.assert)(isBrowser, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    console.error(message);
    return null;
  }
  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);
  if (!gl) {
    return null;
  }
  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
function instrumentGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!gl || gl._instrumented) {
    return gl;
  }
  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug
  } = options;
  if (manageState) {
    (0, _trackContextState.trackContextState)(gl, {
      copyState: false,
      log: function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _log.log.log(1, ...args)();
      }
    });
  }
  if (isBrowser && debug) {
    if (!globalThis.makeDebugContext) {
      _log.log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = globalThis.makeDebugContext(gl, options);
      _log.log.level = Math.max(_log.log.level, 1);
    }
  }
  gl._instrumented = true;
  return gl;
}
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
function resizeGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (gl.canvas) {
    const devicePixelRatio = (0, _devicePixels.getDevicePixelRatio)(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }
  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');
  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}
function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;
  const onCreateError = error => errorMessage = error.statusMessage || errorMessage;
  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;
  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }
  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);
  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', " context: ").concat(errorMessage || 'Unknown error'));
  }
  if (options.onContextLost) {
    canvas.addEventListener('webglcontextlost', options.onContextLost, false);
  }
  if (options.onContextRestored) {
    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);
  }
  return gl;
}
function getCanvas(_ref) {
  let {
    canvas,
    width = 800,
    height = 600,
    onError
  } = _ref;
  let targetCanvas;
  if (typeof canvas === 'string') {
    const isPageLoaded = isPage && document.readyState === 'complete';
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement('canvas');
    targetCanvas.id = 'lumagl-canvas';
    targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
    targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%';
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }
  return targetCanvas;
}
function logInfo(gl) {
  const webGL = (0, _webglChecks.isWebGL2)(gl) ? 'WebGL2' : 'WebGL1';
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
  const debug = gl.debug ? ' debug' : '';
  _log.log.info(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}
function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return 2;
  }
  return 1;
}
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;
  if (!clientWidth || !clientHeight) {
    _log.log.log(1, 'Canvas clientWidth/clientHeight is 0')();
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _log.log.warn("Device pixel ratio clamped")();
      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }
    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","../state-tracker/track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","../utils/log":"node_modules/@luma.gl/gltools/dist/esm/utils/log.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/device-pixels":"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assertWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGL2Context;
  }
});
Object.defineProperty(exports, "assertWebGLContext", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGLContext;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "cssToDevicePixels", {
  enumerable: true,
  get: function () {
    return _devicePixels.cssToDevicePixels;
  }
});
Object.defineProperty(exports, "cssToDeviceRatio", {
  enumerable: true,
  get: function () {
    return _devicePixels.cssToDeviceRatio;
  }
});
Object.defineProperty(exports, "getContextDebugInfo", {
  enumerable: true,
  get: function () {
    return _context.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.getParameters;
  }
});
Object.defineProperty(exports, "getWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.getWebGL2Context;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.log;
  }
});
Object.defineProperty(exports, "polyfillContext", {
  enumerable: true,
  get: function () {
    return _polyfillContext.polyfillContext;
  }
});
Object.defineProperty(exports, "popContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.popContextState;
  }
});
Object.defineProperty(exports, "pushContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.pushContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.resetParameters;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function () {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.setParameters;
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.trackContextState;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.withParameters;
  }
});
var _log = require("./utils/log");
var _webglChecks = require("./utils/webgl-checks");
var _polyfillContext = require("./polyfill/polyfill-context");
var _unifiedParameterApi = require("./state-tracker/unified-parameter-api");
var _trackContextState = require("./state-tracker/track-context-state");
var _context = require("./context/context");
var _devicePixels = require("./utils/device-pixels");
},{"./utils/log":"node_modules/@luma.gl/gltools/dist/esm/utils/log.js","./utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","./polyfill/polyfill-context":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js","./state-tracker/unified-parameter-api":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js","./state-tracker/track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","./context/context":"node_modules/@luma.gl/gltools/dist/esm/context/context.js","./utils/device-pixels":"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js"}],"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
},{"process":"node_modules/process/browser.js"}],"node_modules/@probe.gl/stats/dist/esm/lib/stat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stat {
  constructor(name, type) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "sampleSize", 1);
    (0, _defineProperty2.default)(this, "time", void 0);
    (0, _defineProperty2.default)(this, "count", void 0);
    (0, _defineProperty2.default)(this, "samples", void 0);
    (0, _defineProperty2.default)(this, "lastTiming", void 0);
    (0, _defineProperty2.default)(this, "lastSampleTime", void 0);
    (0, _defineProperty2.default)(this, "lastSampleCount", void 0);
    (0, _defineProperty2.default)(this, "_count", 0);
    (0, _defineProperty2.default)(this, "_time", 0);
    (0, _defineProperty2.default)(this, "_samples", 0);
    (0, _defineProperty2.default)(this, "_startTime", 0);
    (0, _defineProperty2.default)(this, "_timerPending", false);
    this.name = name;
    this.type = type;
    this.reset();
  }
  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }
  incrementCount() {
    this.addCount(1);
    return this;
  }
  decrementCount() {
    this.subtractCount(1);
    return this;
  }
  addCount(value) {
    this._count += value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  subtractCount(value) {
    this._count -= value;
    this._samples++;
    this._checkSampling();
    return this;
  }
  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;
    this._checkSampling();
    return this;
  }
  timeStart() {
    this._startTime = (0, _hiResTimestamp.default)();
    this._timerPending = true;
    return this;
  }
  timeEnd() {
    if (!this._timerPending) {
      return this;
    }
    this.addTime((0, _hiResTimestamp.default)() - this._startTime);
    this._timerPending = false;
    this._checkSampling();
    return this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1000) : 0;
  }
  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }
  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }
}
exports.default = Stat;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/hi-res-timestamp":"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@probe.gl/stats/dist/esm/lib/stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _stat = _interopRequireDefault(require("./stat"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Stats {
  constructor(options) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "stats", {});
    this.id = options.id;
    this.stats = {};
    this._initializeStats(options.stats);
    Object.seal(this);
  }
  get(name) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
    return this._getOrCreate({
      name,
      type
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const key in this.stats) {
      this.stats[key].reset();
    }
    return this;
  }
  forEach(fn) {
    for (const key in this.stats) {
      fn(this.stats[key]);
    }
  }
  getTable() {
    const table = {};
    this.forEach(stat => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }
  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    stats.forEach(stat => this._getOrCreate(stat));
  }
  _getOrCreate(stat) {
    if (!stat || !stat.name) {
      return null;
    }
    const {
      name,
      type
    } = stat;
    if (!this.stats[name]) {
      if (stat instanceof _stat.default) {
        this.stats[name] = stat;
      } else {
        this.stats[name] = new _stat.default(name, type);
      }
    }
    return this.stats[name];
  }
}
exports.default = Stats;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./stat":"node_modules/@probe.gl/stats/dist/esm/lib/stat.js"}],"node_modules/@probe.gl/stats/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _stat.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.default;
  }
});
var _stats = _interopRequireDefault(require("./lib/stats"));
var _stat = _interopRequireDefault(require("./lib/stat"));
var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/stats":"node_modules/@probe.gl/stats/dist/esm/lib/stats.js","./lib/stat":"node_modules/@probe.gl/stats/dist/esm/lib/stat.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@luma.gl/webgl/dist/esm/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lumaStats = exports.default = exports.StatsManager = void 0;
var _gltools = require("@luma.gl/gltools");
var _stats = require("@probe.gl/stats");
var _env = require("@probe.gl/env");
const VERSION = typeof "8.5.20" !== 'undefined' ? "8.5.20" : 'untranspiled source';
const STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';
class StatsManager {
  constructor() {
    this.stats = new Map();
  }
  get(name) {
    if (!this.stats.has(name)) {
      this.stats.set(name, new _stats.Stats({
        id: name
      }));
    }
    return this.stats.get(name);
  }
}
exports.StatsManager = StatsManager;
const lumaStats = new StatsManager();
exports.lumaStats = lumaStats;
if (globalThis.luma && globalThis.luma.VERSION !== VERSION) {
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION));
}
if (!globalThis.luma) {
  if ((0, _env.isBrowser)()) {
    _gltools.log.log(1, "luma.gl ".concat(VERSION, " - ").concat(STARTUP_MESSAGE))();
  }
  globalThis.luma = globalThis.luma || {
    VERSION,
    version: VERSION,
    log: _gltools.log,
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}
var _default = globalThis.luma;
exports.default = _default;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cancelAnimationFrame = cancelAnimationFrame;
exports.requestAnimationFrame = requestAnimationFrame;
function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKey = getKey;
exports.getKeyType = getKeyType;
exports.getKeyValue = getKeyValue;
var _assert = require("../utils/assert");
function getKeyValue(gl, name) {
  if (typeof name !== 'string') {
    return name;
  }
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }
  name = name.replace(/^.*\./, '');
  const value = gl[name];
  (0, _assert.assert)(value !== undefined, "Accessing undefined constant GL.".concat(name));
  return value;
}
function getKey(gl, value) {
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }
  return String(value);
}
function getKeyType(gl, value) {
  (0, _assert.assert)(value !== undefined, 'undefined key');
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }
  return String(value);
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectEmpty = isObjectEmpty;
exports.isPowerOfTwo = isPowerOfTwo;
exports.uid = uid;
var _assert = require("./assert");
const uidCounters = {};
function uid() {
  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return "".concat(id, "-").concat(count);
}
function isPowerOfTwo(n) {
  (0, _assert.assert)(typeof n === 'number', 'Input must be a number');
  return n && (n & n - 1) === 0;
}
function isObjectEmpty(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}
},{"./assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stubRemovedMethods = stubRemovedMethods;
var _gltools = require("@luma.gl/gltools");
function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach(methodName => {
    if (prototype.methodName) {
      return;
    }
    prototype[methodName] = () => {
      _gltools.log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
      throw new Error(methodName);
    };
  });
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _init = require("../init");
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
var _stubMethods = require("../utils/stub-methods");
const ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';
class Resource {
  get [Symbol.toStringTag]() {
    return 'Resource';
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGLContext)(gl);
    const {
      id,
      userData = {}
    } = opts;
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || (0, _utils.uid)(this[Symbol.toStringTag]);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;
    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }
    this.byteLength = 0;
    this._addStats();
  }
  toString() {
    return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const children = this._handle && this._deleteHandle(this._handle);
    if (this._handle) {
      this._removeStats();
    }
    this._handle = null;
    if (children && deleteChildren) {
      children.filter(Boolean).forEach(child => child.delete());
    }
    return this;
  }
  bind() {
    let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;
    if (typeof funcOrHandle !== 'function') {
      this._bindHandle(funcOrHandle);
      return this;
    }
    let value;
    if (!this._bound) {
      this._bindHandle(this.handle);
      this._bound = true;
      value = funcOrHandle();
      this._bound = false;
      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }
    return value;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(pname) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    pname = (0, _constantsToKeys.getKeyValue)(this.gl, pname);
    (0, _assert.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }
    return this._getParameter(pname, opts);
  }
  getParameters() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      parameters,
      keys
    } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);
    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (parameterAvailable) {
        const key = keys ? (0, _constantsToKeys.getKey)(this.gl, pname) : pname;
        values[key] = this.getParameter(pname, options);
        if (keys && parameter.type === 'GLenum') {
          values[key] = (0, _constantsToKeys.getKey)(this.gl, values[key]);
        }
      }
    }
    return values;
  }
  setParameter(pname, value) {
    pname = (0, _constantsToKeys.getKeyValue)(this.gl, pname);
    (0, _assert.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));
      if (!parameterAvailable) {
        throw new Error('Parameter not available on this platform');
      }
      if (parameter.type === 'GLenum') {
        value = (0, _constantsToKeys.getKeyValue)(value);
      }
    }
    this._setParameter(pname, value);
    return this;
  }
  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }
    return this;
  }
  stubRemovedMethods(className, version, methodNames) {
    return (0, _stubMethods.stubRemovedMethods)(this, className, version, methodNames);
  }
  initialize(opts) {}
  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _getParameter(pname, opts) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }
  _context() {
    this.gl.luma = this.gl.luma || {};
    return this.gl.luma;
  }
  _addStats() {
    const name = this[Symbol.toStringTag];
    const stats = _init.lumaStats.get('Resource Counts');
    stats.get('Resources Created').incrementCount();
    stats.get("".concat(name, "s Created")).incrementCount();
    stats.get("".concat(name, "s Active")).incrementCount();
  }
  _removeStats() {
    const name = this[Symbol.toStringTag];
    const stats = _init.lumaStats.get('Resource Counts');
    stats.get("".concat(name, "s Active")).decrementCount();
  }
  _trackAllocatedMemory(bytes) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
    this._trackAllocatedMemoryForContext(bytes, name);
    this._trackAllocatedMemoryForContext(bytes, name, this.gl.canvas && this.gl.canvas.id);
    this.byteLength = bytes;
  }
  _trackAllocatedMemoryForContext(bytes) {
    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    const stats = _init.lumaStats.get("Memory Usage".concat(id));
    stats.get('GPU Memory').addCount(bytes);
    stats.get("".concat(name, " Memory")).addCount(bytes);
  }
  _trackDeallocatedMemory() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
    this._trackDeallocatedMemoryForContext(name);
    this._trackDeallocatedMemoryForContext(name, this.gl.canvas && this.gl.canvas.id);
    this.byteLength = 0;
  }
  _trackDeallocatedMemoryForContext() {
    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
    let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const stats = _init.lumaStats.get("Memory Usage".concat(id));
    stats.get('GPU Memory').subtractCount(this.byteLength);
    stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
  }
}
exports.default = Resource;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../init":"node_modules/@luma.gl/webgl/dist/esm/init.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","../utils/stub-methods":"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flipRows = flipRows;
exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
exports.scalePixels = scalePixels;
const ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType) {
  let {
    clamped = true
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}
function flipRows(_ref) {
  let {
    data,
    width,
    height,
    bytesPerPixel = 4,
    temp
  } = _ref;
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);
  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}
function scalePixels(_ref2) {
  let {
    data,
    width,
    height
  } = _ref2;
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }
  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkProps = checkProps;
var _gltools = require("@luma.gl/gltools");
function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : 'N/A';
      _gltools.log.removed("".concat(className, ".").concat(propName), replacement)();
    }
  }
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      _gltools.log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
    }
  }
  let newProps = null;
  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      _gltools.log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }
  return newProps || props;
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_ACCESSOR_VALUES = void 0;
var _typedArrayUtils = require("../webgl-utils/typed-array-utils");
var _assert = require("../utils/assert");
var _checkProps = require("../utils/check-props");
const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
exports.DEFAULT_ACCESSOR_VALUES = DEFAULT_ACCESSOR_VALUES;
const PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};
class Accessor {
  static getBytesPerElement(accessor) {
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(accessor) {
    (0, _assert.assert)(accessor.size);
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }
  static resolve() {
    for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
      accessors[_key] = arguments[_key];
    }
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }
  constructor() {
    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }
    accessors.forEach(accessor => this._assign(accessor));
    Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }
  _assign() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    props = (0, _checkProps.checkProps)('Accessor', props, PROP_CHECKS);
    if (props.type !== undefined) {
      this.type = props.type;
      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }
    if (props.size !== undefined) {
      this.size = props.size;
    }
    if (props.offset !== undefined) {
      this.offset = props.offset;
    }
    if (props.stride !== undefined) {
      this.stride = props.stride;
    }
    if (props.normalized !== undefined) {
      this.normalized = props.normalized;
    }
    if (props.integer !== undefined) {
      this.integer = props.integer;
    }
    if (props.divisor !== undefined) {
      this.divisor = props.divisor;
    }
    if (props.buffer !== undefined) {
      this.buffer = props.buffer;
    }
    if (props.index !== undefined) {
      if (typeof props.index === 'boolean') {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }
    if (props.instanced !== undefined) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== undefined) {
      this.divisor = props.isInstanced ? 1 : 0;
    }
    return this;
  }
}
exports.default = Accessor;
},{"../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/check-props":"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _accessor = _interopRequireDefault(require("./accessor"));
var _typedArrayUtils = require("../webgl-utils/typed-array-utils");
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
var _checkProps = require("../utils/check-props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEBUG_DATA_LENGTH = 10;
const DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};
const PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  deprecatedProps: DEPRECATED_PROPS
};
const PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};
class Buffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Buffer';
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, props);
    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);
    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
    this.initialize(props);
    Object.seal(this);
  }
  getElementCount() {
    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / _accessor.default.getBytesPerElement(accessor));
  }
  getVertexCount() {
    let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / _accessor.default.getBytesPerVertex(accessor));
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }
    if (Number.isFinite(props)) {
      props = {
        byteLength: props
      };
    }
    props = (0, _checkProps.checkProps)('Buffer', props, PROP_CHECKS_INITIALIZE);
    this.usage = props.usage || 35044;
    this.debugData = null;
    this.setAccessor(Object.assign({}, props, props.accessor));
    if (props.data) {
      this._setData(props.data, props.offset, props.byteLength);
    } else {
      this._setByteLength(props.byteLength || 0);
    }
    return this;
  }
  setProps(props) {
    props = (0, _checkProps.checkProps)('Buffer', props, PROP_CHECKS_SET_PROPS);
    if ('accessor' in props) {
      this.setAccessor(props.accessor);
    }
    return this;
  }
  setAccessor(accessor) {
    accessor = Object.assign({}, accessor);
    delete accessor.buffer;
    this.accessor = new _accessor.default(accessor);
    return this;
  }
  reallocate(byteLength) {
    if (byteLength > this.byteLength) {
      this._setByteLength(byteLength);
      return true;
    }
    this.bytesUsed = byteLength;
    return false;
  }
  setData(props) {
    return this.initialize(props);
  }
  subData(props) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }
    const {
      data,
      offset = 0,
      srcOffset = 0
    } = props;
    const byteLength = props.byteLength || props.length;
    (0, _assert.assert)(data);
    const target = this.gl.webgl2 ? 36663 : this.target;
    this.gl.bindBuffer(target, this.handle);
    if (srcOffset !== 0 || byteLength !== undefined) {
      (0, _gltools.assertWebGL2Context)(this.gl);
      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(target, offset, data);
    }
    this.gl.bindBuffer(target, null);
    this.debugData = null;
    this._inferType(data);
    return this;
  }
  copyData(_ref) {
    let {
      sourceBuffer,
      readOffset = 0,
      writeOffset = 0,
      size
    } = _ref;
    const {
      gl
    } = this;
    (0, _gltools.assertWebGL2Context)(gl);
    gl.bindBuffer(36662, sourceBuffer.handle);
    gl.bindBuffer(36663, this.handle);
    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
    gl.bindBuffer(36662, null);
    gl.bindBuffer(36663, null);
    this.debugData = null;
    return this;
  }
  getData() {
    let {
      dstData = null,
      srcByteOffset = 0,
      dstOffset = 0,
      length = 0
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _gltools.assertWebGL2Context)(this.gl);
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
    const dstElementOffset = dstOffset;
    let dstAvailableElementCount;
    let dstElementCount;
    if (dstData) {
      dstElementCount = dstData.length;
      dstAvailableElementCount = dstElementCount - dstElementOffset;
    } else {
      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
      dstElementCount = dstElementOffset + dstAvailableElementCount;
    }
    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
    length = length || copyElementCount;
    (0, _assert.assert)(length <= copyElementCount);
    dstData = dstData || new ArrayType(dstElementCount);
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
    this.gl.bindBuffer(36662, null);
    return dstData;
  }
  bind() {
    let {
      target = this.target,
      index = this.accessor && this.accessor.index,
      offset = 0,
      size
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (target === 35345 || target === 35982) {
      if (size !== undefined) {
        this.gl.bindBufferRange(target, index, this.handle, offset, size);
      } else {
        (0, _assert.assert)(offset === 0);
        this.gl.bindBufferBase(target, index, this.handle);
      }
    } else {
      this.gl.bindBuffer(target, this.handle);
    }
    return this;
  }
  unbind() {
    let {
      target = this.target,
      index = this.accessor && this.accessor.index
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const isIndexedBuffer = target === 35345 || target === 35982;
    if (isIndexedBuffer) {
      this.gl.bindBufferBase(target, index, null);
    } else {
      this.gl.bindBuffer(target, null);
    }
    return this;
  }
  getDebugData() {
    if (!this.debugData) {
      this.debugData = this.getData({
        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
      });
      return {
        data: this.debugData,
        changed: true
      };
    }
    return {
      data: this.debugData,
      changed: false
    };
  }
  invalidateDebugData() {
    this.debugData = null;
  }
  _setData(data) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;
    (0, _assert.assert)(ArrayBuffer.isView(data));
    this._trackDeallocatedMemory();
    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, byteLength, this.usage);
    this.gl.bufferSubData(target, offset, data);
    this.gl.bindBuffer(target, null);
    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
    this.bytesUsed = byteLength;
    this._trackAllocatedMemory(byteLength);
    const type = (0, _typedArrayUtils.getGLTypeFromTypedArray)(data);
    (0, _assert.assert)(type);
    this.setAccessor(new _accessor.default(this.accessor, {
      type
    }));
    return this;
  }
  _setByteLength(byteLength) {
    let usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
    (0, _assert.assert)(byteLength >= 0);
    this._trackDeallocatedMemory();
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }
    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data, usage);
    this.gl.bindBuffer(target, null);
    this.usage = usage;
    this.debugData = null;
    this.bytesUsed = byteLength;
    this._trackAllocatedMemory(byteLength);
    return this;
  }
  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }
  _getAvailableElementCount(srcByteOffset) {
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
    return this.getElementCount() - sourceElementOffset;
  }
  _inferType(data) {
    if (!this.accessor.type) {
      this.setAccessor(new _accessor.default(this.accessor, {
        type: (0, _typedArrayUtils.getGLTypeFromTypedArray)(data)
      }));
    }
  }
  _createHandle() {
    return this.gl.createBuffer();
  }
  _deleteHandle() {
    this.gl.deleteBuffer(this.handle);
    this._trackDeallocatedMemory();
  }
  _getParameter(pname) {
    this.gl.bindBuffer(this.target, this.handle);
    const value = this.gl.getBufferParameter(this.target, pname);
    this.gl.bindBuffer(this.target, null);
    return value;
  }
  get type() {
    _gltools.log.deprecated('Buffer.type', 'Buffer.accessor.type')();
    return this.accessor.type;
  }
  get bytes() {
    _gltools.log.deprecated('Buffer.bytes', 'Buffer.byteLength')();
    return this.byteLength;
  }
  setByteLength(byteLength) {
    _gltools.log.deprecated('setByteLength', 'reallocate')();
    return this.reallocate(byteLength);
  }
  updateAccessor(opts) {
    _gltools.log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();
    this.accessor = new _accessor.default(this.accessor, opts);
    return this;
  }
}
exports.default = Buffer;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/check-props":"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TYPE_SIZES = exports.TEXTURE_FORMATS = exports.DATA_FORMAT_CHANNELS = void 0;
exports.isFormatSupported = isFormatSupported;
exports.isLinearFilteringSupported = isLinearFilteringSupported;
var _gltools = require("@luma.gl/gltools");
const TEXTURE_FORMATS = {
  [6407]: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  [6408]: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  [6406]: {
    dataFormat: 6406,
    types: [5121]
  },
  [6409]: {
    dataFormat: 6409,
    types: [5121]
  },
  [6410]: {
    dataFormat: 6410,
    types: [5121]
  },
  [33326]: {
    dataFormat: 6403,
    types: [5126],
    gl2: true
  },
  [33328]: {
    dataFormat: 33319,
    types: [5126],
    gl2: true
  },
  [34837]: {
    dataFormat: 6407,
    types: [5126],
    gl2: true
  },
  [34836]: {
    dataFormat: 6408,
    types: [5126],
    gl2: true
  }
};
exports.TEXTURE_FORMATS = TEXTURE_FORMATS;
const DATA_FORMAT_CHANNELS = {
  [6403]: 1,
  [36244]: 1,
  [33319]: 2,
  [33320]: 2,
  [6407]: 3,
  [36248]: 3,
  [6408]: 4,
  [36249]: 4,
  [6402]: 1,
  [34041]: 1,
  [6406]: 1,
  [6409]: 1,
  [6410]: 2
};
exports.DATA_FORMAT_CHANNELS = DATA_FORMAT_CHANNELS;
const TYPE_SIZES = {
  [5126]: 4,
  [5125]: 4,
  [5124]: 4,
  [5123]: 2,
  [5122]: 2,
  [5131]: 2,
  [5120]: 1,
  [5121]: 1
};
exports.TYPE_SIZES = TYPE_SIZES;
function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (info.gl1 === undefined && info.gl2 === undefined) {
    return true;
  }
  const value = (0, _gltools.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}
function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension('OES_texture_float_linear');
    case 5131:
      return gl.getExtension('OES_texture_half_float_linear');
    default:
      return true;
  }
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _resource = _interopRequireDefault(require("./resource"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _textureFormats = require("./texture-formats");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NPOT_MIN_FILTERS = [9729, 9728];
const WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};
class Texture extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Texture';
  }
  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      format,
      linearFiltering
    } = opts;
    let supported = true;
    if (format) {
      supported = supported && (0, _textureFormats.isFormatSupported)(gl, format);
      supported = supported && (!linearFiltering || (0, _textureFormats.isLinearFilteringSupported)(gl, format));
    }
    return supported;
  }
  constructor(gl, props) {
    const {
      id = (0, _utils.uid)('texture'),
      handle,
      target
    } = props;
    super(gl, {
      id,
      handle
    });
    this.target = target;
    this.textureUnit = undefined;
    this.loaded = false;
    this.width = undefined;
    this.height = undefined;
    this.depth = undefined;
    this.format = undefined;
    this.type = undefined;
    this.dataFormat = undefined;
    this.border = undefined;
    this.textureUnit = undefined;
    this.mipmaps = undefined;
  }
  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let data = props.data;
    if (data instanceof Promise) {
      data.then(resolvedImageData => this.initialize(Object.assign({}, props, {
        pixels: resolvedImageData,
        data: resolvedImageData
      })));
      return this;
    }
    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;
    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data.addEventListener('loadeddata', () => this.initialize(props));
      return this;
    }
    const {
      pixels = null,
      format = 6408,
      border = 0,
      recreate = false,
      parameters = {},
      pixelStore = {},
      textureUnit = undefined
    } = props;
    if (!data) {
      data = pixels;
    }
    let {
      width,
      height,
      dataFormat,
      type,
      compressed = false,
      mipmaps = true
    } = props;
    const {
      depth = 0
    } = props;
    ({
      width,
      height,
      compressed,
      dataFormat,
      type
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.format = format;
    this.type = type;
    this.dataFormat = dataFormat;
    this.border = border;
    this.textureUnit = textureUnit;
    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(33984 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }
    if (mipmaps && this._isNPOT()) {
      _gltools.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      mipmaps = false;
      this._updateForNPOT(parameters);
    }
    this.mipmaps = mipmaps;
    this.setImageData({
      data,
      width,
      height,
      depth,
      format,
      type,
      dataFormat,
      border,
      mipmaps,
      parameters: pixelStore,
      compressed
    });
    if (mipmaps) {
      this.generateMipmap();
    }
    this.setParameters(parameters);
    if (recreate) {
      this.data = data;
    }
    if (isVideo) {
      this._video = {
        video: data,
        parameters,
        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
      };
    }
    return this;
  }
  update() {
    if (this._video) {
      const {
        video,
        parameters,
        lastTime
      } = this._video;
      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }
      this.setSubImageData({
        data: video,
        parameters
      });
      if (this.mipmaps) {
        this.generateMipmap();
      }
      this._video.lastTime = video.currentTime;
    }
  }
  resize(_ref) {
    let {
      height,
      width,
      mipmaps = false
    } = _ref;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        border: this.border,
        mipmaps
      });
    }
    return this;
  }
  generateMipmap() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this._isNPOT()) {
      _gltools.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
      return this;
    }
    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }
  setImageData(options) {
    this._trackDeallocatedMemory('Texture');
    const {
      target = this.target,
      pixels = null,
      level = 0,
      format = this.format,
      border = this.border,
      offset = 0,
      parameters = {}
    } = options;
    let {
      data = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;
    if (!data) {
      data = pixels;
    }
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    const {
      gl
    } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({
      data,
      dataType
    } = this._getDataType({
      data,
      compressed
    }));
    let gl2;
    let compressedTextureSize = 0;
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      switch (dataType) {
        case 'null':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          break;
        case 'typed-array':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
          break;
        case 'buffer':
          gl2 = (0, _gltools.assertWebGL2Context)(gl);
          gl2.bindBuffer(35052, data.handle || data);
          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
          break;
        case 'browser-object':
          if ((0, _gltools.isWebGL2)(gl)) {
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          } else {
            gl.texImage2D(target, level, format, dataFormat, type, data);
          }
          break;
        case 'compressed':
          for (const [levelIndex, levelData] of data.entries()) {
            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
            compressedTextureSize += levelData.levelSize;
          }
          break;
        default:
          (0, _assert.assert)(false, 'Unknown image data type');
      }
    });
    if (dataType === 'compressed') {
      this._trackAllocatedMemory(compressedTextureSize, 'Texture');
    } else if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
    }
    this.loaded = true;
    return this;
  }
  setSubImageData(_ref2) {
    let {
      target = this.target,
      pixels = null,
      data = null,
      x = 0,
      y = 0,
      width = this.width,
      height = this.height,
      level = 0,
      format = this.format,
      type = this.type,
      dataFormat = this.dataFormat,
      compressed = false,
      offset = 0,
      border = this.border,
      parameters = {}
    } = _ref2;
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    (0, _assert.assert)(this.depth === 0, 'texSubImage not supported for 3D textures');
    if (!data) {
      data = pixels;
    }
    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }
    if (data instanceof _buffer.default) {
      data = data.handle;
    }
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
      } else if (data instanceof WebGLBuffer) {
        const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
        gl2.bindBuffer(35052, data);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        gl2.bindBuffer(35052, null);
      } else if ((0, _gltools.isWebGL2)(this.gl)) {
        const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
      }
    });
    this.gl.bindTexture(this.target, null);
  }
  copyFramebuffer() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();
    return null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind() {
    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
    const {
      gl
    } = this;
    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }
  unbind() {
    let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
    const {
      gl
    } = this;
    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }
    gl.bindTexture(this.target, null);
    return textureUnit;
  }
  _getDataType(_ref3) {
    let {
      data,
      compressed = false
    } = _ref3;
    if (compressed) {
      return {
        data,
        dataType: 'compressed'
      };
    }
    if (data === null) {
      return {
        data,
        dataType: 'null'
      };
    }
    if (ArrayBuffer.isView(data)) {
      return {
        data,
        dataType: 'typed-array'
      };
    }
    if (data instanceof _buffer.default) {
      return {
        data: data.handle,
        dataType: 'buffer'
      };
    }
    if (data instanceof WebGLBuffer) {
      return {
        data,
        dataType: 'buffer'
      };
    }
    return {
      data,
      dataType: 'browser-object'
    };
  }
  _deduceParameters(opts) {
    const {
      format,
      data
    } = opts;
    let {
      width,
      height,
      dataFormat,
      type,
      compressed
    } = opts;
    const textureFormat = _textureFormats.TEXTURE_FORMATS[format];
    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
    type = type || textureFormat && textureFormat.types[0];
    compressed = compressed || textureFormat && textureFormat.compressed;
    ({
      width,
      height
    } = this._deduceImageSize(data, width, height));
    return {
      dataFormat,
      type,
      compressed,
      width,
      height,
      format,
      data
    };
  }
  _deduceImageSize(data, width, height) {
    let size;
    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
      size = {
        width: data.naturalWidth,
        height: data.naturalHeight
      };
    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
      size = {
        width: data.videoWidth,
        height: data.videoHeight
      };
    } else if (!data) {
      size = {
        width: width >= 0 ? width : 1,
        height: height >= 0 ? height : 1
      };
    } else {
      size = {
        width,
        height
      };
    }
    (0, _assert.assert)(size, 'Could not deduced texture size');
    (0, _assert.assert)(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
    (0, _assert.assert)(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
    return size;
  }
  _createHandle() {
    return this.gl.createTexture();
  }
  _deleteHandle() {
    this.gl.deleteTexture(this.handle);
    this._trackDeallocatedMemory('Texture');
  }
  _getParameter(pname) {
    switch (pname) {
      case 4096:
        return this.width;
      case 4097:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const value = this.gl.getTexParameter(this.target, pname);
        this.gl.bindTexture(this.target, null);
        return value;
    }
  }
  _setParameter(pname, param) {
    this.gl.bindTexture(this.target, this.handle);
    param = this._getNPOTParam(pname, param);
    switch (pname) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, pname, param);
        break;
      case 4096:
      case 4097:
        (0, _assert.assert)(false);
        break;
      default:
        this.gl.texParameteri(this.target, pname, param);
        break;
    }
    this.gl.bindTexture(this.target, null);
    return this;
  }
  _isNPOT() {
    if ((0, _gltools.isWebGL2)(this.gl)) {
      return false;
    }
    if (!this.width || !this.height) {
      return false;
    }
    return !(0, _utils.isPowerOfTwo)(this.width) || !(0, _utils.isPowerOfTwo)(this.height);
  }
  _updateForNPOT(parameters) {
    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
    }
    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
    }
    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
  }
  _getNPOTParam(pname, param) {
    if (this._isNPOT()) {
      switch (pname) {
        case 10241:
          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
            param = 9729;
          }
          break;
        case 10242:
        case 10243:
          if (param !== 33071) {
            param = 33071;
          }
          break;
        default:
          break;
      }
    }
    return param;
  }
}
exports.default = Texture;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./texture-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFile = loadFile;
exports.loadImage = loadImage;
exports.setPathPrefix = setPathPrefix;
var _assert = require("../utils/assert");
let pathPrefix = '';
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function loadFile(url) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assert.assert)(typeof url === 'string');
  url = pathPrefix + url;
  const dataType = options.dataType || 'text';
  return fetch(url, options).then(res => res[dataType]());
}
function loadImage(url, opts) {
  (0, _assert.assert)(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _texture = _interopRequireDefault(require("./texture"));
var _loadFile = require("../utils/load-file");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Texture2D extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'Texture2D';
  }
  static isSupported(gl, opts) {
    return _texture.default.isSupported(gl, opts);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGLContext)(gl);
    if (props instanceof Promise || typeof props === 'string') {
      props = {
        data: props
      };
    }
    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {
        data: (0, _loadFile.loadImage)(props.data)
      });
    }
    super(gl, Object.assign({}, props, {
      target: 3553
    }));
    this.initialize(props);
    Object.seal(this);
  }
}
exports.default = Texture2D;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils/load-file":"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _texture = _interopRequireDefault(require("./texture"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const FACES = [34069, 34070, 34071, 34072, 34073, 34074];
class TextureCube extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'TextureCube';
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGLContext)(gl);
    super(gl, Object.assign({}, props, {
      target: 34067
    }));
    this.initialize(props);
    Object.seal(this);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      mipmaps = true,
      parameters = {}
    } = props;
    this.opts = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;
      if (mipmaps) {
        this.generateMipmap(props);
      }
      this.setParameters(parameters);
    });
    return this;
  }
  subImage(_ref) {
    let {
      face,
      data,
      x = 0,
      y = 0,
      mipmapLevel = 0
    } = _ref;
    return this._subImage({
      target: face,
      data,
      x,
      y,
      mipmapLevel
    });
  }
  async setCubeMapImageData(_ref2) {
    let {
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = _ref2;
    const {
      gl
    } = this;
    const imageDataMap = pixels || data;
    const resolvedFaces = await Promise.all(FACES.map(face => {
      const facePixels = imageDataMap[face];
      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
    }));
    this.bind();
    FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
        _gltools.log.warn("".concat(this.id, " has mipmap and multiple LODs."))();
      }
      resolvedFaces[index].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });
    this.unbind();
  }
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = options;
    const {
      gl
    } = this;
    const imageData = pixels || data;
    this.bind();
    if (imageData instanceof Promise) {
      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }
    return this;
  }
}
exports.default = TextureCube;
TextureCube.FACES = FACES;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _texture = _interopRequireDefault(require("./texture"));
var _textureFormats = require("./texture-formats");
var _buffer = _interopRequireDefault(require("./buffer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Texture3D extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'Texture3D';
  }
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGL2Context)(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    super(gl, props);
    this.initialize(props);
    Object.seal(this);
  }
  setImageData(_ref) {
    let {
      level = 0,
      dataFormat = 6408,
      width,
      height,
      depth = 1,
      border = 0,
      format,
      type = 5121,
      offset = 0,
      data,
      parameters = {}
    } = _ref;
    this._trackDeallocatedMemory('Texture');
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
      }
      if (data instanceof _buffer.default) {
        this.gl.bindBuffer(35052, data.handle);
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
      }
    });
    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');
    }
    this.loaded = true;
    return this;
  }
}
exports.default = Texture3D;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./texture-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';
var _default = {
  [33189]: {
    bpp: 2
  },
  [33190]: {
    gl2: true,
    bpp: 3
  },
  [36012]: {
    gl2: true,
    bpp: 4
  },
  [36168]: {
    bpp: 1
  },
  [34041]: {
    bpp: 4
  },
  [35056]: {
    gl2: true,
    bpp: 4
  },
  [36013]: {
    gl2: true,
    bpp: 5
  },
  [32854]: {
    bpp: 2
  },
  [36194]: {
    bpp: 2
  },
  [32855]: {
    bpp: 2
  },
  [33321]: {
    gl2: true,
    bpp: 1
  },
  [33330]: {
    gl2: true,
    bpp: 1
  },
  [33329]: {
    gl2: true,
    bpp: 1
  },
  [33332]: {
    gl2: true,
    bpp: 2
  },
  [33331]: {
    gl2: true,
    bpp: 2
  },
  [33334]: {
    gl2: true,
    bpp: 4
  },
  [33333]: {
    gl2: true,
    bpp: 4
  },
  [33323]: {
    gl2: true,
    bpp: 2
  },
  [33336]: {
    gl2: true,
    bpp: 2
  },
  [33335]: {
    gl2: true,
    bpp: 2
  },
  [33338]: {
    gl2: true,
    bpp: 4
  },
  [33337]: {
    gl2: true,
    bpp: 4
  },
  [33340]: {
    gl2: true,
    bpp: 8
  },
  [33339]: {
    gl2: true,
    bpp: 8
  },
  [32849]: {
    gl2: true,
    bpp: 3
  },
  [32856]: {
    gl2: true,
    bpp: 4
  },
  [32857]: {
    gl2: true,
    bpp: 4
  },
  [36220]: {
    gl2: true,
    bpp: 4
  },
  [36238]: {
    gl2: true,
    bpp: 4
  },
  [36975]: {
    gl2: true,
    bpp: 4
  },
  [36214]: {
    gl2: true,
    bpp: 8
  },
  [36232]: {
    gl2: true,
    bpp: 8
  },
  [36226]: {
    gl2: true,
    bpp: 16
  },
  [36208]: {
    gl2: true,
    bpp: 16
  },
  [33325]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 2
  },
  [33327]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [34842]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [33326]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [33328]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [34836]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 16
  },
  [35898]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }
};
exports.default = _default;
},{}],"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _renderbufferFormats = _interopRequireDefault(require("./renderbuffer-formats"));
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function isFormatSupported(gl, format, formats) {
  const info = formats[format];
  if (!info) {
    return false;
  }
  const value = (0, _gltools.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  if (typeof value === 'string') {
    return gl.getExtension(value);
  }
  return value;
}
class Renderbuffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Renderbuffer';
  }
  static isSupported(gl) {
    let {
      format
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      format: null
    };
    return !format || isFormatSupported(gl, format, _renderbufferFormats.default);
  }
  static getSamplesForFormat(gl, _ref) {
    let {
      format
    } = _ref;
    return gl.getInternalformatParameter(36161, format, 32937);
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.initialize(opts);
    Object.seal(this);
  }
  initialize(_ref2) {
    let {
      format,
      width = 1,
      height = 1,
      samples = 0
    } = _ref2;
    (0, _assert.assert)(format, 'Needs format');
    this._trackDeallocatedMemory();
    this.gl.bindRenderbuffer(36161, this.handle);
    if (samples !== 0 && (0, _gltools.isWebGL2)(this.gl)) {
      this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
    } else {
      this.gl.renderbufferStorage(36161, format, width, height);
    }
    this.format = format;
    this.width = width;
    this.height = height;
    this.samples = samples;
    this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * _renderbufferFormats.default[this.format].bpp);
    return this;
  }
  resize(_ref3) {
    let {
      width,
      height
    } = _ref3;
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        samples: this.samples
      });
    }
    return this;
  }
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);
    this._trackDeallocatedMemory();
  }
  _bindHandle(handle) {
    this.gl.bindRenderbuffer(36161, handle);
  }
  _syncHandle(handle) {
    this.format = this.getParameter(36164);
    this.width = this.getParameter(36162);
    this.height = this.getParameter(36163);
    this.samples = this.getParameter(36011);
  }
  _getParameter(pname) {
    this.gl.bindRenderbuffer(36161, this.handle);
    const value = this.gl.getRenderbufferParameter(36161, pname);
    return value;
  }
}
exports.default = Renderbuffer;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./renderbuffer-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearBuffer = clearBuffer;
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_COLOR = 0x1800;
const GL_DEPTH = 0x1801;
const GL_STENCIL = 0x1802;
const GL_DEPTH_STENCIL = 0x84f9;
const ERR_ARGUMENTS = 'clear: bad arguments';
function clear(gl) {
  let {
    framebuffer = null,
    color = null,
    depth = null,
    stencil = null
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  (0, _assert.assert)(clearFlags !== 0, ERR_ARGUMENTS);
  (0, _gltools.withParameters)(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
function clearBuffer(gl) {
  let {
    framebuffer = null,
    buffer = GL_COLOR,
    drawBuffer = 0,
    value = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _gltools.assertWebGL2Context)(gl);
  (0, _gltools.withParameters)(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;
          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;
          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }
        break;
      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;
      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;
      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;
      default:
        (0, _assert.assert)(false, ERR_ARGUMENTS);
    }
  });
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glFormatToComponents = glFormatToComponents;
exports.glTypeToBytes = glTypeToBytes;
var _assert = require("../utils/assert");
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blit = blit;
exports.copyToDataUrl = copyToDataUrl;
exports.copyToImage = copyToImage;
exports.copyToTexture = copyToTexture;
exports.readPixelsToArray = readPixelsToArray;
exports.readPixelsToBuffer = readPixelsToBuffer;
var _buffer = _interopRequireDefault(require("./buffer"));
var _framebuffer = _interopRequireDefault(require("./framebuffer"));
var _texture = _interopRequireDefault(require("./texture"));
var _gltools = require("@luma.gl/gltools");
var _typedArrayUtils = require("../webgl-utils/typed-array-utils");
var _formatUtils = require("../webgl-utils/format-utils");
var _textureUtils = require("../webgl-utils/texture-utils");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function readPixelsToArray(source) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }
  (0, _assert.assert)(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || (0, _typedArrayUtils.getGLTypeFromTypedArray)(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function readPixelsToBuffer(source, _ref) {
  let {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    target = null,
    targetByteOffset = 0,
    sourceWidth,
    sourceHeight,
    sourceType
  } = _ref;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const gl2 = (0, _gltools.assertWebGL2Context)(framebuffer.gl);
  sourceType = sourceType || (target ? target.type : 5121);
  if (!target) {
    const components = (0, _formatUtils.glFormatToComponents)(sourceFormat);
    const byteCount = (0, _formatUtils.glTypeToBytes)(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer.default(gl2, {
      byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }
  target.bind({
    target: 35051
  });
  (0, _gltools.withParameters)(gl2, {
    framebuffer
  }, () => {
    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function copyToDataUrl(source) {
  let {
    sourceAttachment = 36064,
    targetMaxHeight = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let data = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;
  while (height > targetMaxHeight) {
    ({
      data,
      width,
      height
    } = (0, _typedArrayUtils.scalePixels)({
      data,
      width,
      height
    }));
  }
  (0, _typedArrayUtils.flipRows)({
    data,
    width,
    height
  });
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d');
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}
function copyToImage(source) {
  let {
    sourceAttachment = 36064,
    targetImage = null
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const dataUrl = copyToDataUrl(source, {
    sourceAttachment
  });
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}
function copyToTexture(source, target) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  (0, _assert.assert)(target);
  let texture = null;
  if (target instanceof _texture.default) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }
  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        const gl2 = (0, _gltools.assertWebGL2Context)(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return texture;
}
function blit(source, target) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    sourceX0 = 0,
    sourceY0 = 0,
    targetX0 = 0,
    targetY0 = 0,
    color = true,
    depth = false,
    stencil = false,
    filter = 9728
  } = options;
  let {
    sourceX1,
    sourceY1,
    targetX1,
    targetY1,
    sourceAttachment = 36064,
    mask = 0
  } = options;
  const {
    framebuffer: srcFramebuffer,
    deleteFramebuffer: deleteSrcFramebuffer
  } = getFramebuffer(source);
  const {
    framebuffer: dstFramebuffer,
    deleteFramebuffer: deleteDstFramebuffer
  } = getFramebuffer(target);
  (0, _assert.assert)(srcFramebuffer);
  (0, _assert.assert)(dstFramebuffer);
  const {
    gl,
    handle,
    width,
    height,
    readBuffer
  } = dstFramebuffer;
  const gl2 = (0, _gltools.assertWebGL2Context)(gl);
  if (!srcFramebuffer.handle && sourceAttachment === 36064) {
    sourceAttachment = 1028;
  }
  if (color) {
    mask |= 16384;
  }
  if (depth) {
    mask |= 256;
  }
  if (stencil) {
    mask |= 1024;
  }
  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    if (mask & (256 | 1024)) {
      mask = 16384;
      _gltools.log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }
  (0, _assert.assert)(mask);
  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;
  const prevDrawHandle = gl.bindFramebuffer(36009, handle);
  const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
  gl2.readBuffer(sourceAttachment);
  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
  gl2.readBuffer(readBuffer);
  gl2.bindFramebuffer(36008, prevReadHandle || null);
  gl2.bindFramebuffer(36009, prevDrawHandle || null);
  if (deleteSrcFramebuffer) {
    srcFramebuffer.delete();
  }
  if (deleteDstFramebuffer) {
    dstFramebuffer.delete();
  }
  return dstFramebuffer;
}
function getFramebuffer(source) {
  if (!(source instanceof _framebuffer.default)) {
    return {
      framebuffer: (0, _textureUtils.toFramebuffer)(source),
      deleteFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(type, {
    clamped: false
  });
  const components = (0, _formatUtils.glFormatToComponents)(format);
  return new ArrayType(width * height * components);
}
},{"./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../webgl-utils/format-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js","../webgl-utils/texture-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  [33902]: {
    gl1: new Float32Array([1, 1])
  },
  [33901]: {
    gl1: new Float32Array([1, 1])
  },
  [3379]: {
    gl1: 64,
    gl2: 2048
  },
  [34076]: {
    gl1: 16
  },
  [34930]: {
    gl1: 8
  },
  [35661]: {
    gl1: 8
  },
  [35660]: {
    gl1: 0
  },
  [34024]: {
    gl1: 1
  },
  [36348]: {
    gl1: 8
  },
  [34921]: {
    gl1: 8
  },
  [36347]: {
    gl1: 128
  },
  [36349]: {
    gl1: 16
  },
  [3386]: {
    gl1: new Int32Array([0, 0])
  },
  [32883]: {
    gl1: 0,
    gl2: 256
  },
  [35071]: {
    gl1: 0,
    gl2: 256
  },
  [37447]: {
    gl1: 0,
    gl2: 0
  },
  [36063]: {
    gl1: 0,
    gl2: 4
  },
  [35379]: {
    gl1: 0,
    gl2: 0
  },
  [35374]: {
    gl1: 0,
    gl2: 0
  },
  [35377]: {
    gl1: 0,
    gl2: 0
  },
  [34852]: {
    gl1: 0,
    gl2: 4
  },
  [36203]: {
    gl1: 0,
    gl2: 0
  },
  [33001]: {
    gl1: 0,
    gl2: 0
  },
  [33000]: {
    gl1: 0,
    gl2: 0
  },
  [37157]: {
    gl1: 0,
    gl2: 0
  },
  [35373]: {
    gl1: 0,
    gl2: 0
  },
  [35657]: {
    gl1: 0,
    gl2: 0
  },
  [36183]: {
    gl1: 0,
    gl2: 0
  },
  [37137]: {
    gl1: 0,
    gl2: 0
  },
  [34045]: {
    gl1: 0,
    gl2: 0
  },
  [35978]: {
    gl1: 0,
    gl2: 0
  },
  [35979]: {
    gl1: 0,
    gl2: 0
  },
  [35968]: {
    gl1: 0,
    gl2: 0
  },
  [35376]: {
    gl1: 0,
    gl2: 0
  },
  [35375]: {
    gl1: 0,
    gl2: 0
  },
  [35659]: {
    gl1: 0,
    gl2: 0
  },
  [37154]: {
    gl1: 0,
    gl2: 0
  },
  [35371]: {
    gl1: 0,
    gl2: 0
  },
  [35658]: {
    gl1: 0,
    gl2: 0
  },
  [35076]: {
    gl1: 0,
    gl2: -8,
    negative: true
  },
  [35077]: {
    gl1: 0,
    gl2: 7
  },
  [35380]: {
    gl1: 0,
    gl2: 0
  }
};
exports.default = _default;
},{}],"node_modules/@luma.gl/webgl/dist/esm/features/limits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextInfo = getContextInfo;
exports.getContextLimits = getContextLimits;
exports.getGLContextInfo = getGLContextInfo;
var _webglLimitsTable = _interopRequireDefault(require("./webgl-limits-table"));
var _gltools = require("@luma.gl/gltools");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getContextLimits(gl) {
  gl.luma = gl.luma || {};
  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};
    const isWebgl2 = (0, _gltools.isWebGL2)(gl);
    for (const parameter in _webglLimitsTable.default) {
      const limit = _webglLimitsTable.default[parameter];
      const webgl1MinLimit = limit.gl1;
      const webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      const minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;
      const limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
      const value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }
  return gl.luma.limits;
}
function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};
  const info = (0, _gltools.getContextDebugInfo)(gl);
  if (!gl.luma.info) {
    gl.luma.info = {
      [37445]: info.vendor,
      [37446]: info.renderer,
      [7936]: info.vendorMasked,
      [7937]: info.rendererMasked,
      [7938]: info.version,
      [35724]: info.shadingLanguageVersion
    };
  }
  return gl.luma.info;
}
function getContextInfo(gl) {
  return Object.assign((0, _gltools.getContextDebugInfo)(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}
},{"./webgl-limits-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FEATURES = void 0;
var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));
var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const FEATURES = {
  WEBGL2: 'WEBGL2',
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  FLOAT_BLEND: 'FLOAT_BLEND',
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',
  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};
exports.FEATURES = FEATURES;
function checkFloat32ColorAttachment(gl) {
  const testTexture = new _texture2d.default(gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new _framebuffer.default(gl, {
    id: "test-framebuffer",
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}
var _default = {
  [FEATURES.WEBGL2]: [false, true],
  [FEATURES.VERTEX_ARRAY_OBJECT]: ['OES_vertex_array_object', true],
  [FEATURES.TIMER_QUERY]: ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2'],
  [FEATURES.INSTANCED_RENDERING]: ['ANGLE_instanced_arrays', true],
  [FEATURES.MULTIPLE_RENDER_TARGETS]: ['WEBGL_draw_buffers', true],
  [FEATURES.ELEMENT_INDEX_UINT32]: ['OES_element_index_uint', true],
  [FEATURES.BLEND_EQUATION_MINMAX]: ['EXT_blend_minmax', true],
  [FEATURES.FLOAT_BLEND]: ['EXT_float_blend'],
  [FEATURES.COLOR_ENCODING_SRGB]: ['EXT_sRGB', true],
  [FEATURES.TEXTURE_DEPTH]: ['WEBGL_depth_texture', true],
  [FEATURES.TEXTURE_FLOAT]: ['OES_texture_float', true],
  [FEATURES.TEXTURE_HALF_FLOAT]: ['OES_texture_half_float', true],
  [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ['OES_texture_float_linear'],
  [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ['OES_texture_half_float_linear'],
  [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ['EXT_texture_filter_anisotropic'],
  [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ['EXT_color_buffer_half_float'],
  [FEATURES.GLSL_FRAG_DATA]: ['WEBGL_draw_buffers', true],
  [FEATURES.GLSL_FRAG_DEPTH]: ['EXT_frag_depth', true],
  [FEATURES.GLSL_DERIVATIVES]: ['OES_standard_derivatives', true],
  [FEATURES.GLSL_TEXTURE_LOD]: ['EXT_shader_texture_lod', true]
};
exports.default = _default;
},{"../classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/features.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFeatures = getFeatures;
exports.hasFeature = hasFeature;
exports.hasFeatures = hasFeatures;
var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_UNSUPPORTED_FEATURE = 2;
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => {
    return isFeatureSupported(gl, feature);
  });
}
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  for (const cap in _webglFeaturesTable.default) {
    if (gl.luma.caps[cap] === undefined) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }
  return gl.luma.caps;
}
function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  if (gl.luma.caps[cap] === undefined) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }
  if (!gl.luma.caps[cap]) {
    _gltools.log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
  }
  return gl.luma.caps[cap];
}
function queryFeature(gl, cap) {
  const feature = _webglFeaturesTable.default[cap];
  (0, _assert.assert)(feature, cap);
  let isSupported;
  const featureDefinition = (0, _gltools.isWebGL2)(gl) ? feature[1] || feature[0] : feature[0];
  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    (0, _assert.assert)(false);
  }
  return isSupported;
}
},{"./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;
function isOldIE() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const navigator = typeof window !== 'undefined' && window.navigator || {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = canCompileGLGSExtension;
var _checkOldIe = _interopRequireDefault(require("./check-old-ie"));
var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const feature = _webglFeaturesTable.default[cap];
  (0, _assert.assert)(feature, cap);
  if (!(0, _checkOldIe.default)(options)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const source = "#extension GL_".concat(extensionName, " : enable\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
},{"./check-old-ie":"node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js","./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
var _limits = require("./limits");
var _webglFeaturesTable = require("./webgl-features-table");
var _features = require("./features");
var _checkGlslExtension = _interopRequireDefault(require("./check-glsl-extension"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./limits":"node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features":"node_modules/@luma.gl/webgl/dist/esm/features/features.js","./check-glsl-extension":"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = void 0;
var _gltools = require("@luma.gl/gltools");
var _resource = _interopRequireDefault(require("./resource"));
var _texture2d = _interopRequireDefault(require("./texture-2d"));
var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));
var _clear = require("./clear");
var _copyAndBlit = require("./copy-and-blit.js");
var _features = require("../features");
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';
class Framebuffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Framebuffer';
  }
  static isSupported(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      colorBufferFloat,
      colorBufferHalfFloat
    } = options;
    let supported = true;
    if (colorBufferFloat) {
      supported = Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float') || gl.getExtension('OES_texture_float'));
    }
    if (colorBufferHalfFloat) {
      supported = supported && Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float'));
    }
    return supported;
  }
  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
      id: 'default-framebuffer',
      handle: null,
      attachments: {}
    });
    return gl.luma.defaultFramebuffer;
  }
  get MAX_COLOR_ATTACHMENTS() {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
  }
  get MAX_DRAW_BUFFERS() {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = 36064;
    this.drawBuffers = [36064];
    this.ownResources = [];
    this.initialize(opts);
    Object.seal(this);
  }
  get color() {
    return this.attachments[36064] || null;
  }
  get texture() {
    return this.attachments[36064] || null;
  }
  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }
  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }
  initialize(_ref) {
    let {
      width = 1,
      height = 1,
      attachments = null,
      color = true,
      depth = true,
      stencil = false,
      check = true,
      readBuffer = undefined,
      drawBuffers = undefined
    } = _ref;
    (0, _assert.assert)(width >= 0 && height >= 0, 'Width and height need to be integers');
    this.width = width;
    this.height = height;
    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({
          width,
          height
        });
      }
    } else {
      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
    }
    this.update({
      clearAttachments: true,
      attachments,
      readBuffer,
      drawBuffers
    });
    if (attachments && check) {
      this.checkStatus();
    }
  }
  delete() {
    for (const resource of this.ownResources) {
      resource.delete();
    }
    super.delete();
    return this;
  }
  update(_ref2) {
    let {
      attachments = {},
      readBuffer,
      drawBuffers,
      clearAttachments = false,
      resizeAttachments = true
    } = _ref2;
    this.attach(attachments, {
      clearAttachments,
      resizeAttachments
    });
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }
    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }
    gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }
  resize() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let {
      width,
      height
    } = options;
    if (this.handle === null) {
      (0, _assert.assert)(width === undefined && height === undefined);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }
    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }
    if (width !== this.width && height !== this.height) {
      _gltools.log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
    }
    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({
        width,
        height
      });
    }
    this.width = width;
    this.height = height;
    return this;
  }
  attach(attachments) {
    let {
      clearAttachments = false,
      resizeAttachments = true
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const newAttachments = {};
    if (clearAttachments) {
      Object.keys(this.attachments).forEach(key => {
        newAttachments[key] = null;
      });
    }
    Object.assign(newAttachments, attachments);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    for (const key in newAttachments) {
      (0, _assert.assert)(key !== undefined, 'Misspelled framebuffer binding point?');
      const attachment = Number(key);
      const descriptor = newAttachments[attachment];
      let object = descriptor;
      if (!object) {
        this._unattach(attachment);
      } else if (object instanceof _renderbuffer.default) {
        this._attachRenderbuffer({
          attachment,
          renderbuffer: object
        });
      } else if (Array.isArray(descriptor)) {
        const [texture, layer = 0, level = 0] = descriptor;
        object = texture;
        this._attachTexture({
          attachment,
          texture,
          layer,
          level
        });
      } else {
        this._attachTexture({
          attachment,
          texture: object,
          layer: 0,
          level: 0
        });
      }
      if (resizeAttachments && object) {
        object.resize({
          width: this.width,
          height: this.height
        });
      }
    }
    this.gl.bindFramebuffer(36160, prevHandle || null);
    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {
      delete this.attachments[key];
    });
  }
  checkStatus() {
    const {
      gl
    } = this;
    const status = this.getStatus();
    if (status !== 36053) {
      throw new Error(_getFrameBufferStatus(status));
    }
    return this;
  }
  getStatus() {
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);
    return status;
  }
  clear() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      color,
      depth,
      stencil,
      drawBuffers = []
    } = options;
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
    if (color || depth || stencil) {
      (0, _clear.clear)(this.gl, {
        color,
        depth,
        stencil
      });
    }
    drawBuffers.forEach((value, drawBuffer) => {
      (0, _clear.clearBuffer)(this.gl, {
        drawBuffer,
        value
      });
    });
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }
  readPixels() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();
    return null;
  }
  readPixelsToBuffer() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();
    return null;
  }
  copyToDataUrl() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();
    return null;
  }
  copyToImage() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();
    return null;
  }
  copyToTexture() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();
    return null;
  }
  blit() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _gltools.log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();
    return null;
  }
  invalidate(_ref3) {
    let {
      attachments = [],
      x = 0,
      y = 0,
      width,
      height
    } = _ref3;
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    const prevHandle = gl2.bindFramebuffer(36008, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;
    if (invalidateAll) {
      gl2.invalidateFramebuffer(36008, attachments);
    } else {
      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
    }
    gl2.bindFramebuffer(36008, prevHandle);
    return this;
  }
  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);
    if (value === null) {
      this.gl.bindFramebuffer(36160, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
      this.gl.bindFramebuffer(36160, null);
    }
    if (keys && value > 1000) {
      value = (0, _constantsToKeys.getKey)(this.gl, value);
    }
    return value;
  }
  getAttachmentParameters() {
    let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;
    let keys = arguments.length > 1 ? arguments[1] : undefined;
    let parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
    const values = {};
    for (const pname of parameters) {
      const key = keys ? (0, _constantsToKeys.getKey)(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }
    return values;
  }
  getParameters() {
    let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    const attachments = Object.keys(this.attachments);
    const parameters = {};
    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? (0, _constantsToKeys.getKey)(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }
    return parameters;
  }
  show() {
    if (typeof window !== 'undefined') {
      window.open((0, _copyAndBlit.copyToDataUrl)(this), 'luma-debug-texture');
    }
    return this;
  }
  log() {
    let logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (logLevel > _gltools.log.level || typeof window === 'undefined') {
      return this;
    }
    message = message || "Framebuffer ".concat(this.id);
    const image = (0, _copyAndBlit.copyToDataUrl)(this, {
      targetMaxHeight: 100
    });
    _gltools.log.image({
      logLevel,
      message,
      image
    }, message)();
    return this;
  }
  bind() {
    let {
      target = 36160
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }
  unbind() {
    let {
      target = 36160
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.gl.bindFramebuffer(target, null);
    return this;
  }
  _createDefaultAttachments(color, depth, stencil, width, height) {
    let defaultAttachments = null;
    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36064] = new _texture2d.default(this.gl, {
        id: "".concat(this.id, "-color0"),
        pixels: null,
        format: 6408,
        type: 5121,
        width,
        height,
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.ownResources.push(defaultAttachments[36064]);
    }
    if (depth && stencil) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[33306] = new _renderbuffer.default(this.gl, {
        id: "".concat(this.id, "-depth-stencil"),
        format: 35056,
        width,
        height: 111
      });
      this.ownResources.push(defaultAttachments[33306]);
    } else if (depth) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36096] = new _renderbuffer.default(this.gl, {
        id: "".concat(this.id, "-depth"),
        format: 33189,
        width,
        height
      });
      this.ownResources.push(defaultAttachments[36096]);
    } else if (stencil) {
      (0, _assert.assert)(false);
    }
    return defaultAttachments;
  }
  _unattach(attachment) {
    const oldAttachment = this.attachments[attachment];
    if (!oldAttachment) {
      return;
    }
    if (oldAttachment instanceof _renderbuffer.default) {
      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
    } else {
      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
    }
    delete this.attachments[attachment];
  }
  _attachRenderbuffer(_ref4) {
    let {
      attachment = 36064,
      renderbuffer
    } = _ref4;
    const {
      gl
    } = this;
    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
    this.attachments[attachment] = renderbuffer;
  }
  _attachTexture(_ref5) {
    let {
      attachment = 36064,
      texture,
      layer,
      level
    } = _ref5;
    const {
      gl
    } = this;
    gl.bindTexture(texture.target, texture.handle);
    switch (texture.target) {
      case 35866:
      case 32879:
        const gl2 = (0, _gltools.assertWebGL2Context)(gl);
        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;
      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;
      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;
      default:
        (0, _assert.assert)(false, 'Illegal texture type');
    }
    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  }
  _setReadBuffer(readBuffer) {
    const gl2 = (0, _gltools.getWebGL2Context)(this.gl);
    if (gl2) {
      gl2.readBuffer(readBuffer);
    } else {
      (0, _assert.assert)(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
    }
    this.readBuffer = readBuffer;
  }
  _setDrawBuffers(drawBuffers) {
    const {
      gl
    } = this;
    const gl2 = (0, _gltools.assertWebGL2Context)(gl);
    if (gl2) {
      gl2.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension('WEBGL_draw_buffers');
      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        (0, _assert.assert)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
      }
    }
    this.drawBuffers = drawBuffers;
  }
  _getAttachmentParameterFallback(pname) {
    const caps = (0, _features.getFeatures)(this.gl);
    switch (pname) {
      case 36052:
        return !caps.WEBGL2 ? 0 : null;
      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return !caps.WEBGL2 ? 8 : null;
      case 33297:
        return !caps.WEBGL2 ? 5125 : null;
      case 33296:
        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
      default:
        return null;
    }
  }
  _createHandle() {
    return this.gl.createFramebuffer();
  }
  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }
  _bindHandle(handle) {
    return this.gl.bindFramebuffer(36160, handle);
  }
}
exports.default = Framebuffer;
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}
const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./clear":"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./copy-and-blit.js":"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","../features":"node_modules/@luma.gl/webgl/dist/esm/features/index.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTextureFrom = cloneTextureFrom;
exports.toFramebuffer = toFramebuffer;
var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));
var _textureCube = _interopRequireDefault(require("../classes/texture-cube"));
var _texture3d = _interopRequireDefault(require("../classes/texture-3d"));
var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function cloneTextureFrom(refTexture, overrides) {
  (0, _assert.assert)(refTexture instanceof _texture2d.default || refTexture instanceof _textureCube.default || refTexture instanceof _texture3d.default);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}
function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new _framebuffer.default(gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}
},{"../classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","../classes/texture-cube":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","../classes/texture-3d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","../classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderName;
function getShaderName(shader) {
  let defaultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unnamed';
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderTypeName;
const GL_FRAGMENT_SHADER = 0x8b30;
const GL_VERTEX_SHADER = 0x8b31;
function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';
    case GL_VERTEX_SHADER:
      return 'vertex';
    default:
      return 'unknown type';
  }
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatGLSLCompilerError;
exports.parseGLSLCompilerError = parseGLSLCompilerError;
var _getShaderName = _interopRequireDefault(require("./get-shader-name"));
var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function formatGLSLCompilerError(errLog, src, shaderType) {
  const {
    shaderName,
    errors,
    warnings
  } = parseGLSLCompilerError(errLog, src, shaderType);
  return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || (0, _getShaderName.default)(src) || '(unnamed)';
  const shaderDescription = "".concat((0, _getShaderTypeName.default)(shaderType), " shader ").concat(name);
  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    const segments = errorString.split(':');
    const type = segments[0];
    const line = parseInt(segments[2], 10);
    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }
    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }
  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}
function formatErrors(errors, lines) {
  let message = '';
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }
    message += "".concat(line, "\n");
    if (errors[i + 1]) {
      const error = errors[i + 1];
      const segments = error.split(':', 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }
  return message;
}
function addLineNumbers(string) {
  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start);
    const digits = lineNumber.length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}
function padLeft(string, digits) {
  let result = '';
  for (let i = 0; i < digits; ++i) {
    result += ' ';
  }
  return "".concat(result).concat(string);
}
},{"./get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-type-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderVersion;
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);
  if (words.length >= 2 && words[0] === '#version') {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version = v;
    }
  }
  return version;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "formatGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.default;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderTypeName", {
  enumerable: true,
  get: function () {
    return _getShaderTypeName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "parseGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.parseGLSLCompilerError;
  }
});
var _formatGlslError = _interopRequireWildcard(require("./format-glsl-error"));
var _getShaderName = _interopRequireDefault(require("./get-shader-name"));
var _getShaderVersion = _interopRequireDefault(require("./get-shader-version"));
var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./format-glsl-error":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js","./get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-version":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","./get-shader-type-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VertexShader = exports.Shader = exports.FragmentShader = void 0;
var _gltools = require("@luma.gl/gltools");
var _glslUtils = require("../glsl-utils");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
var _resource = _interopRequireDefault(require("./resource"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';
class Shader extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Shader';
  }
  static getTypeName(shaderType) {
    switch (shaderType) {
      case 35633:
        return 'vertex-shader';
      case 35632:
        return 'fragment-shader';
      default:
        (0, _assert.assert)(false);
        return 'unknown';
    }
  }
  constructor(gl, props) {
    (0, _gltools.assertWebGLContext)(gl);
    (0, _assert.assert)(typeof props.source === 'string', ERR_SOURCE);
    const id = (0, _glslUtils.getShaderName)(props.source, null) || props.id || (0, _utils.uid)("unnamed ".concat(Shader.getTypeName(props.shaderType)));
    super(gl, {
      id
    });
    this.shaderType = props.shaderType;
    this.source = props.source;
    this.initialize(props);
  }
  initialize(_ref) {
    let {
      source
    } = _ref;
    const shaderName = (0, _glslUtils.getShaderName)(source, null);
    if (shaderName) {
      this.id = (0, _utils.uid)(shaderName);
    }
    this._compile(source);
  }
  getParameter(pname) {
    return this.gl.getShaderParameter(this.handle, pname);
  }
  toString() {
    return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
  }
  getName() {
    return (0, _glslUtils.getShaderName)(this.source) || 'unnamed-shader';
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  getTranslatedSource() {
    const extension = this.gl.getExtension('WEBGL_debug_shaders');
    return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';
  }
  _compile() {
    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;
    if (!source.startsWith('#version ')) {
      source = "#version 100\n".concat(source);
    }
    this.source = source;
    this.gl.shaderSource(this.handle, this.source);
    this.gl.compileShader(this.handle);
    const compileStatus = this.getParameter(35713);
    if (!compileStatus) {
      const infoLog = this.gl.getShaderInfoLog(this.handle);
      const {
        shaderName,
        errors,
        warnings
      } = (0, _glslUtils.parseGLSLCompilerError)(infoLog, this.source, this.shaderType, this.id);
      _gltools.log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
      _gltools.log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
      throw new Error("GLSL compilation errors in ".concat(shaderName));
    }
  }
  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }
}
exports.Shader = Shader;
class VertexShader extends Shader {
  get [Symbol.toStringTag]() {
    return 'VertexShader';
  }
  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }
    super(gl, Object.assign({}, props, {
      shaderType: 35633
    }));
  }
  _createHandle() {
    return this.gl.createShader(35633);
  }
}
exports.VertexShader = VertexShader;
class FragmentShader extends Shader {
  get [Symbol.toStringTag]() {
    return 'FragmentShader';
  }
  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }
    super(gl, Object.assign({}, props, {
      shaderType: 35632
    }));
  }
  _createHandle() {
    return this.gl.createShader(35632);
  }
}
exports.FragmentShader = FragmentShader;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../glsl-utils":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkUniformValues = checkUniformValues;
exports.copyUniform = copyUniform;
exports.getUniformSetter = getUniformSetter;
exports.parseUniformName = parseUniformName;
var _gltools = require("@luma.gl/gltools");
var _framebuffer = _interopRequireDefault(require("./framebuffer"));
var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));
var _texture = _interopRequireDefault(require("./texture"));
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const UNIFORM_SETTERS = {
  [5126]: getArraySetter.bind(null, 'uniform1fv', toFloatArray, 1, setVectorUniform),
  [35664]: getArraySetter.bind(null, 'uniform2fv', toFloatArray, 2, setVectorUniform),
  [35665]: getArraySetter.bind(null, 'uniform3fv', toFloatArray, 3, setVectorUniform),
  [35666]: getArraySetter.bind(null, 'uniform4fv', toFloatArray, 4, setVectorUniform),
  [5124]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35667]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35668]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35669]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35670]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35671]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35672]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35673]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35674]: getArraySetter.bind(null, 'uniformMatrix2fv', toFloatArray, 4, setMatrixUniform),
  [35675]: getArraySetter.bind(null, 'uniformMatrix3fv', toFloatArray, 9, setMatrixUniform),
  [35676]: getArraySetter.bind(null, 'uniformMatrix4fv', toFloatArray, 16, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [5125]: getArraySetter.bind(null, 'uniform1uiv', toUIntArray, 1, setVectorUniform),
  [36294]: getArraySetter.bind(null, 'uniform2uiv', toUIntArray, 2, setVectorUniform),
  [36295]: getArraySetter.bind(null, 'uniform3uiv', toUIntArray, 3, setVectorUniform),
  [36296]: getArraySetter.bind(null, 'uniform4uiv', toUIntArray, 4, setVectorUniform),
  [35685]: getArraySetter.bind(null, 'uniformMatrix2x3fv', toFloatArray, 6, setMatrixUniform),
  [35686]: getArraySetter.bind(null, 'uniformMatrix2x4fv', toFloatArray, 8, setMatrixUniform),
  [35687]: getArraySetter.bind(null, 'uniformMatrix3x2fv', toFloatArray, 6, setMatrixUniform),
  [35688]: getArraySetter.bind(null, 'uniformMatrix3x4fv', toFloatArray, 12, setMatrixUniform),
  [35689]: getArraySetter.bind(null, 'uniformMatrix4x2fv', toFloatArray, 8, setMatrixUniform),
  [35690]: getArraySetter.bind(null, 'uniformMatrix4x3fv', toFloatArray, 12, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [35679]: getSamplerSetter,
  [35682]: getSamplerSetter,
  [36289]: getSamplerSetter,
  [36292]: getSamplerSetter,
  [36293]: getSamplerSetter,
  [36298]: getSamplerSetter,
  [36299]: getSamplerSetter,
  [36300]: getSamplerSetter,
  [36303]: getSamplerSetter,
  [36306]: getSamplerSetter,
  [36307]: getSamplerSetter,
  [36308]: getSamplerSetter,
  [36311]: getSamplerSetter
};
const FLOAT_ARRAY = {};
const INT_ARRAY = {};
const UINT_ARRAY = {};
const array1 = [0];
function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }
  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }
  const length = value.length;
  if (length % uniformLength) {
    _gltools.log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }
  if (value instanceof Type) {
    return value;
  }
  let result = cache[length];
  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }
  for (let i = 0; i < length; i++) {
    result[i] = value[i];
  }
  return result;
}
function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}
function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }
  return setter().bind(null, gl, location);
}
function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = name.match(UNIFORM_NAME_REGEXP);
  if (!matches || matches.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }
  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}
function checkUniformValues(uniforms, source, uniformMap) {
  for (const uniformName in uniforms) {
    const value = uniforms[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : '';
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }
  return true;
}
function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }
  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture.default) {
    return true;
  } else if (value instanceof _renderbuffer.default) {
    return true;
  } else if (value instanceof _framebuffer.default) {
    return Boolean(value.texture);
  }
  return false;
}
function copyUniform(uniforms, key, value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    if (uniforms[key]) {
      const dest = uniforms[key];
      for (let i = 0, len = value.length; i < len; ++i) {
        dest[i] = value[i];
      }
    } else {
      uniforms[key] = value.slice();
    }
  } else {
    uniforms[key] = value;
  }
}
function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }
  const checkLength = Math.min(value.length, 16);
  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }
  return true;
}
function getSamplerSetter() {
  let cache = null;
  return (gl, location, value) => {
    const update = cache !== value;
    if (update) {
      gl.uniform1i(location, value);
      cache = value;
    }
    return update;
  };
}
function getArraySetter(functionName, toArray, size, uniformSetter) {
  let cache = null;
  let cacheLength = null;
  return (gl, location, value) => {
    const arrayValue = toArray(value, size);
    const length = arrayValue.length;
    let update = false;
    if (cache === null) {
      cache = new Float32Array(length);
      cacheLength = length;
      update = true;
    } else {
      (0, _assert.assert)(cacheLength === length, 'Uniform length cannot change.');
      for (let i = 0; i < length; ++i) {
        if (arrayValue[i] !== cache[i]) {
          update = true;
          break;
        }
      }
    }
    if (update) {
      uniformSetter(gl, functionName, location, arrayValue);
      cache.set(arrayValue);
    }
    return update;
  };
}
function setVectorUniform(gl, functionName, location, value) {
  gl[functionName](location, value);
}
function setMatrixUniform(gl, functionName, location, value) {
  gl[functionName](location, false, value);
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decomposeCompositeGLType = decomposeCompositeGLType;
exports.getCompositeGLType = getCompositeGLType;
exports.getPrimitiveCount = getPrimitiveCount;
exports.getPrimitiveDrawMode = getPrimitiveDrawMode;
exports.getVertexCount = getVertexCount;
var _assert = require("../utils/assert");
const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_POINTS = 0x0;
const GL_LINES = 0x1;
const GL_LINE_LOOP = 0x2;
const GL_LINE_STRIP = 0x3;
const GL_TRIANGLES = 0x4;
const GL_TRIANGLE_STRIP = 0x5;
const GL_TRIANGLE_FAN = 0x6;
const GL_FLOAT = 0x1406;
const GL_FLOAT_VEC2 = 0x8b50;
const GL_FLOAT_VEC3 = 0x8b51;
const GL_FLOAT_VEC4 = 0x8b52;
const GL_INT = 0x1404;
const GL_INT_VEC2 = 0x8b53;
const GL_INT_VEC3 = 0x8b54;
const GL_INT_VEC4 = 0x8b55;
const GL_UNSIGNED_INT = 0x1405;
const GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const GL_UNSIGNED_INT_VEC4 = 0x8dc8;
const GL_BOOL = 0x8b56;
const GL_BOOL_VEC2 = 0x8b57;
const GL_BOOL_VEC3 = 0x8b58;
const GL_BOOL_VEC4 = 0x8b59;
const GL_FLOAT_MAT2 = 0x8b5a;
const GL_FLOAT_MAT3 = 0x8b5b;
const GL_FLOAT_MAT4 = 0x8b5c;
const GL_FLOAT_MAT2x3 = 0x8b65;
const GL_FLOAT_MAT2x4 = 0x8b66;
const GL_FLOAT_MAT3x2 = 0x8b67;
const GL_FLOAT_MAT3x4 = 0x8b68;
const GL_FLOAT_MAT4x2 = 0x8b69;
const GL_FLOAT_MAT4x3 = 0x8b6a;
const COMPOSITE_GL_TYPES = {
  [GL_FLOAT]: [GL_FLOAT, 1, 'float'],
  [GL_FLOAT_VEC2]: [GL_FLOAT, 2, 'vec2'],
  [GL_FLOAT_VEC3]: [GL_FLOAT, 3, 'vec3'],
  [GL_FLOAT_VEC4]: [GL_FLOAT, 4, 'vec4'],
  [GL_INT]: [GL_INT, 1, 'int'],
  [GL_INT_VEC2]: [GL_INT, 2, 'ivec2'],
  [GL_INT_VEC3]: [GL_INT, 3, 'ivec3'],
  [GL_INT_VEC4]: [GL_INT, 4, 'ivec4'],
  [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, 'uint'],
  [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, 'uvec2'],
  [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, 'uvec3'],
  [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, 'uvec4'],
  [GL_BOOL]: [GL_FLOAT, 1, 'bool'],
  [GL_BOOL_VEC2]: [GL_FLOAT, 2, 'bvec2'],
  [GL_BOOL_VEC3]: [GL_FLOAT, 3, 'bvec3'],
  [GL_BOOL_VEC4]: [GL_FLOAT, 4, 'bvec4'],
  [GL_FLOAT_MAT2]: [GL_FLOAT, 8, 'mat2'],
  [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, 'mat2x3'],
  [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, 'mat2x4'],
  [GL_FLOAT_MAT3]: [GL_FLOAT, 12, 'mat3'],
  [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, 'mat3x2'],
  [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, 'mat3x4'],
  [GL_FLOAT_MAT4]: [GL_FLOAT, 16, 'mat4'],
  [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, 'mat4x2'],
  [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, 'mat4x3']
};
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;
    case GL_LINES:
      return GL_LINES;
    case GL_LINE_STRIP:
      return GL_LINES;
    case GL_LINE_LOOP:
      return GL_LINES;
    case GL_TRIANGLES:
      return GL_TRIANGLES;
    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;
    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function getPrimitiveCount(_ref) {
  let {
    drawMode,
    vertexCount
  } = _ref;
  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;
    case GL_LINES:
      return vertexCount / 2;
    case GL_LINE_STRIP:
      return vertexCount - 1;
    case GL_TRIANGLES:
      return vertexCount / 3;
    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function getVertexCount(_ref2) {
  let {
    drawMode,
    vertexCount
  } = _ref2;
  const primitiveCount = getPrimitiveCount({
    drawMode,
    vertexCount
  });
  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;
    case GL_LINES:
      return primitiveCount * 2;
    case GL_TRIANGLES:
      return primitiveCount * 3;
    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
  if (!typeAndSize) {
    return null;
  }
  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}
function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;
    default:
  }
  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }
  return null;
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _accessor = _interopRequireDefault(require("./accessor"));
var _gltools = require("@luma.gl/gltools");
var _attributeUtils = require("../webgl-utils/attribute-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ProgramConfiguration {
  constructor(program) {
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);
    this._readAttributesFromProgram(program);
    this._readVaryingsFromProgram(program);
  }
  getAttributeInfo(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return this.attributeInfosByLocation[location];
    }
    return this.attributeInfosByName[locationOrName] || null;
  }
  getAttributeLocation(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.location : -1;
  }
  getAttributeAccessor(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.accessor : null;
  }
  getVaryingInfo(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return this.varyingInfos[location];
    }
    return this.varyingInfosByName[locationOrName] || null;
  }
  getVaryingIndex(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.location : -1;
  }
  getVaryingAccessor(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.accessor : null;
  }
  _readAttributesFromProgram(program) {
    const {
      gl
    } = program;
    const count = gl.getProgramParameter(program.handle, 35721);
    for (let index = 0; index < count; index++) {
      const {
        name,
        type,
        size
      } = gl.getActiveAttrib(program.handle, index);
      const location = gl.getAttribLocation(program.handle, name);
      if (location >= 0) {
        this._addAttribute(location, name, type, size);
      }
    }
    this.attributeInfos.sort((a, b) => a.location - b.location);
  }
  _readVaryingsFromProgram(program) {
    const {
      gl
    } = program;
    if (!(0, _gltools.isWebGL2)(gl)) {
      return;
    }
    const count = gl.getProgramParameter(program.handle, 35971);
    for (let location = 0; location < count; location++) {
      const {
        name,
        type,
        size
      } = gl.getTransformFeedbackVarying(program.handle, location);
      this._addVarying(location, name, type, size);
    }
    this.varyingInfos.sort((a, b) => a.location - b.location);
  }
  _addAttribute(location, name, compositeType, size) {
    const {
      type,
      components
    } = (0, _attributeUtils.decomposeCompositeGLType)(compositeType);
    const accessor = {
      type,
      size: size * components
    };
    this._inferProperties(location, name, accessor);
    const attributeInfo = {
      location,
      name,
      accessor: new _accessor.default(accessor)
    };
    this.attributeInfos.push(attributeInfo);
    this.attributeInfosByLocation[location] = attributeInfo;
    this.attributeInfosByName[attributeInfo.name] = attributeInfo;
  }
  _inferProperties(location, name, accessor) {
    if (/instance/i.test(name)) {
      accessor.divisor = 1;
    }
  }
  _addVarying(location, name, compositeType, size) {
    const {
      type,
      components
    } = (0, _attributeUtils.decomposeCompositeGLType)(compositeType);
    const accessor = new _accessor.default({
      type,
      size: size * components
    });
    const varying = {
      location,
      name,
      accessor
    };
    this.varyingInfos.push(varying);
    this.varyingInfosByName[varying.name] = varying;
  }
}
exports.default = ProgramConfiguration;
},{"./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/program.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _texture = _interopRequireDefault(require("./texture"));
var _framebuffer = _interopRequireDefault(require("./framebuffer"));
var _uniforms = require("./uniforms");
var _shader = require("./shader");
var _programConfiguration = _interopRequireDefault(require("./program-configuration"));
var _gltools = require("@luma.gl/gltools");
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _attributeUtils = require("../webgl-utils/attribute-utils");
var _assert = require("../utils/assert");
var _utils = require("../utils/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_PROGRAM_PERF_PRIORITY = 4;
const GL_SEPARATE_ATTRIBS = 0x8c8d;
const V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];
class Program extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Program';
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, props);
    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);
    this._isCached = false;
    this.initialize(props);
    Object.seal(this);
    this._setId(props.id);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      hash,
      vs,
      fs,
      varyings,
      bufferMode = GL_SEPARATE_ATTRIBS
    } = props;
    this.hash = hash || '';
    this.vs = typeof vs === 'string' ? new _shader.VertexShader(this.gl, {
      id: "".concat(props.id, "-vs"),
      source: vs
    }) : vs;
    this.fs = typeof fs === 'string' ? new _shader.FragmentShader(this.gl, {
      id: "".concat(props.id, "-fs"),
      source: fs
    }) : fs;
    (0, _assert.assert)(this.vs instanceof _shader.VertexShader);
    (0, _assert.assert)(this.fs instanceof _shader.FragmentShader);
    this.uniforms = {};
    this._textureUniforms = {};
    if (varyings && varyings.length > 0) {
      (0, _gltools.assertWebGL2Context)(this.gl);
      this.varyings = varyings;
      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }
    this._compileAndLink();
    this._readUniformLocationsFromLinkedProgram();
    this.configuration = new _programConfiguration.default(this);
    return this.setProps(props);
  }
  delete() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this._isCached) {
      return this;
    }
    return super.delete(options);
  }
  setProps(props) {
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }
    return this;
  }
  draw(_ref) {
    let {
      logPriority,
      drawMode = 4,
      vertexCount,
      offset = 0,
      start,
      end,
      isIndexed = false,
      indexType = 5123,
      instanceCount = 0,
      isInstanced = instanceCount > 0,
      vertexArray = null,
      transformFeedback,
      framebuffer,
      parameters = {},
      uniforms,
      samplers
    } = _ref;
    if (uniforms || samplers) {
      _gltools.log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();
      this.setUniforms(uniforms || {});
    }
    if (_gltools.log.priority >= logPriority) {
      const fb = framebuffer ? framebuffer.id : 'default';
      const message = "mode=".concat((0, _constantsToKeys.getKey)(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat((0, _constantsToKeys.getKey)(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
      _gltools.log.log(logPriority, message)();
    }
    (0, _assert.assert)(vertexArray);
    this.gl.useProgram(this.handle);
    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
      return false;
    }
    vertexArray.bindForDraw(vertexCount, instanceCount, () => {
      if (framebuffer !== undefined) {
        parameters = Object.assign({}, parameters, {
          framebuffer
        });
      }
      if (transformFeedback) {
        const primitiveMode = (0, _attributeUtils.getPrimitiveDrawMode)(drawMode);
        transformFeedback.begin(primitiveMode);
      }
      this._bindTextures();
      (0, _gltools.withParameters)(this.gl, parameters, () => {
        if (isIndexed && isInstanced) {
          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
        } else if (isIndexed && (0, _gltools.isWebGL2)(this.gl) && !isNaN(start) && !isNaN(end)) {
          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
        } else if (isIndexed) {
          this.gl.drawElements(drawMode, vertexCount, indexType, offset);
        } else if (isInstanced) {
          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
        } else {
          this.gl.drawArrays(drawMode, offset, vertexCount);
        }
      });
      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    return true;
  }
  setUniforms() {
    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (_gltools.log.priority >= 2) {
      (0, _uniforms.checkUniformValues)(uniforms, this.id, this._uniformSetters);
    }
    this.gl.useProgram(this.handle);
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      const uniformSetter = this._uniformSetters[uniformName];
      if (uniformSetter) {
        let value = uniform;
        let textureUpdate = false;
        if (value instanceof _framebuffer.default) {
          value = value.texture;
        }
        if (value instanceof _texture.default) {
          textureUpdate = this.uniforms[uniformName] !== uniform;
          if (textureUpdate) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }
            const texture = value;
            const {
              textureIndex
            } = uniformSetter;
            texture.bind(textureIndex);
            value = textureIndex;
            this._textureUniforms[uniformName] = texture;
          } else {
            value = uniformSetter.textureIndex;
          }
        } else if (this._textureUniforms[uniformName]) {
          delete this._textureUniforms[uniformName];
        }
        if (uniformSetter(value) || textureUpdate) {
          (0, _uniforms.copyUniform)(this.uniforms, uniformName, uniform);
        }
      }
    }
    return this;
  }
  _areTexturesRenderable() {
    let texturesRenderable = true;
    for (const uniformName in this._textureUniforms) {
      const texture = this._textureUniforms[uniformName];
      texture.update();
      texturesRenderable = texturesRenderable && texture.loaded;
    }
    return texturesRenderable;
  }
  _bindTextures() {
    for (const uniformName in this._textureUniforms) {
      const textureIndex = this._uniformSetters[uniformName].textureIndex;
      this._textureUniforms[uniformName].bind(textureIndex);
    }
  }
  _createHandle() {
    return this.gl.createProgram();
  }
  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  _getOptionsFromHandle(handle) {
    const shaderHandles = this.gl.getAttachedShaders(handle);
    const opts = {};
    for (const shaderHandle of shaderHandles) {
      const type = this.gl.getShaderParameter(this.handle, 35663);
      switch (type) {
        case 35633:
          opts.vs = new _shader.VertexShader({
            handle: shaderHandle
          });
          break;
        case 35632:
          opts.fs = new _shader.FragmentShader({
            handle: shaderHandle
          });
          break;
        default:
      }
    }
    return opts;
  }
  _getParameter(pname) {
    return this.gl.getProgramParameter(this.handle, pname);
  }
  _setId(id) {
    if (!id) {
      const programName = this._getName();
      this.id = (0, _utils.uid)(programName);
    }
  }
  _getName() {
    let programName = this.vs.getName() || this.fs.getName();
    programName = programName.replace(/shader/i, '');
    programName = programName ? "".concat(programName, "-program") : 'program';
    return programName;
  }
  _compileAndLink() {
    const {
      gl
    } = this;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    _gltools.log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    gl.linkProgram(this.handle);
    _gltools.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
    if (gl.debug || _gltools.log.level > 0) {
      const linked = gl.getProgramParameter(this.handle, 35714);
      if (!linked) {
        throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);
      if (!validated) {
        throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
      }
    }
  }
  _readUniformLocationsFromLinkedProgram() {
    const {
      gl
    } = this;
    this._uniformSetters = {};
    this._uniformCount = this._getParameter(35718);
    for (let i = 0; i < this._uniformCount; i++) {
      const info = this.gl.getActiveUniform(this.handle, i);
      const {
        name
      } = (0, _uniforms.parseUniformName)(info.name);
      let location = gl.getUniformLocation(this.handle, name);
      this._uniformSetters[name] = (0, _uniforms.getUniformSetter)(gl, location, info);
      if (info.size > 1) {
        for (let l = 0; l < info.size; l++) {
          location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
          this._uniformSetters["".concat(name, "[").concat(l, "]")] = (0, _uniforms.getUniformSetter)(gl, location, info);
        }
      }
    }
    this._textureIndexCounter = 0;
  }
  getActiveUniforms(uniformIndices, pname) {
    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
  }
  getUniformBlockIndex(blockName) {
    return this.gl2.getUniformBlockIndex(this.handle, blockName);
  }
  getActiveUniformBlockParameter(blockIndex, pname) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
  }
  uniformBlockBinding(blockIndex, blockBinding) {
    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
  }
}
exports.default = Program;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./uniforms":"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./shader":"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./program-configuration":"node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/query.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _features = require("../features");
var _gltools = require("@luma.gl/gltools");
var _assert = require("../utils/assert");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const GL_QUERY_RESULT = 0x8866;
const GL_QUERY_RESULT_AVAILABLE = 0x8867;
const GL_TIME_ELAPSED_EXT = 0x88bf;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const GL_ANY_SAMPLES_PASSED = 0x8c2f;
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;
class Query extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Query';
  }
  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const webgl2 = (0, _gltools.isWebGL2)(gl);
    const hasTimerQuery = (0, _features.hasFeatures)(gl, _features.FEATURES.TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;
    for (const key of opts) {
      switch (key) {
        case 'queries':
          supported = supported && webgl2;
          break;
        case 'timers':
          supported = supported && hasTimerQuery;
          break;
        default:
          (0, _assert.assert)(false);
      }
    }
    return supported;
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;
    Object.seal(this);
  }
  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }
  beginOcclusionQuery() {
    let {
      conservative = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }
  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }
  begin(target) {
    if (this._queryPending) {
      return this;
    }
    this.target = target;
    this.gl2.beginQuery(this.target, this.handle);
    return this;
  }
  end() {
    if (this._queryPending) {
      return this;
    }
    if (this.target) {
      this.gl2.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return this;
  }
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }
    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }
  isTimerDisjoint() {
    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);
  }
  getResult() {
    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  createPoll() {
    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise) {
      return this._pollingPromise;
    }
    let counter = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject('Timed out');
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };
      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }
  _createHandle() {
    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }
  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }
}
exports.default = Query;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","../features":"node_modules/@luma.gl/webgl/dist/esm/features/index.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _resource = _interopRequireDefault(require("./resource"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _utils = require("../utils/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TransformFeedback extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'TransformFeedback';
  }
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _gltools.assertWebGL2Context)(gl);
    super(gl, props);
    this.initialize(props);
    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);
    Object.seal(this);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.buffers = {};
    this.unused = {};
    this.configuration = null;
    this.bindOnUse = true;
    if (!(0, _utils.isObjectEmpty)(this.buffers)) {
      this.bind(() => this._unbindBuffers());
    }
    this.setProps(props);
    return this;
  }
  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ('configuration' in props) {
      this.configuration = props.configuration;
    }
    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }
    if ('buffers' in props) {
      this.setBuffers(props.buffers);
    }
  }
  setBuffers() {
    let buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
    return this;
  }
  setBuffer(locationOrName, bufferOrParams) {
    const location = this._getVaryingIndex(locationOrName);
    const {
      buffer,
      byteSize,
      byteOffset
    } = this._getBufferParams(bufferOrParams);
    if (location < 0) {
      this.unused[locationOrName] = buffer;
      _gltools.log.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
      return this;
    }
    this.buffers[location] = bufferOrParams;
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteSize);
    }
    return this;
  }
  begin() {
    let primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    this.gl.bindTransformFeedback(36386, this.handle);
    this._bindBuffers();
    this.gl.beginTransformFeedback(primitiveMode);
    return this;
  }
  end() {
    this.gl.endTransformFeedback();
    this._unbindBuffers();
    this.gl.bindTransformFeedback(36386, null);
    return this;
  }
  _getBufferParams(bufferOrParams) {
    let byteOffset;
    let byteSize;
    let buffer;
    if (bufferOrParams instanceof _buffer.default === false) {
      buffer = bufferOrParams.buffer;
      byteSize = bufferOrParams.byteSize;
      byteOffset = bufferOrParams.byteOffset;
    } else {
      buffer = bufferOrParams;
    }
    if (byteOffset !== undefined || byteSize !== undefined) {
      byteOffset = byteOffset || 0;
      byteSize = byteSize || buffer.byteLength - byteOffset;
    }
    return {
      buffer,
      byteOffset,
      byteSize
    };
  }
  _getVaryingInfo(locationOrName) {
    return this.configuration && this.configuration.getVaryingInfo(locationOrName);
  }
  _getVaryingIndex(locationOrName) {
    if (this.configuration) {
      return this.configuration.getVaryingInfo(locationOrName).location;
    }
    const location = Number(locationOrName);
    return Number.isFinite(location) ? location : -1;
  }
  _bindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(this.buffers[bufferIndex]);
        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
      }
    }
  }
  _unbindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        this._bindBuffer(bufferIndex, null);
      }
    }
  }
  _bindBuffer(index, buffer) {
    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let byteSize = arguments.length > 3 ? arguments[3] : undefined;
    const handle = buffer && buffer.handle;
    if (!handle || byteSize === undefined) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
    }
    return this;
  }
  _createHandle() {
    return this.gl.createTransformFeedback();
  }
  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }
  _bindHandle(handle) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }
}
exports.default = TransformFeedback;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillArray = fillArray;
exports.getScratchArray = getScratchArray;
exports.getScratchArrayBuffer = getScratchArrayBuffer;
let arrayBuffer = null;
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}
function fillArray(_ref) {
  let {
    target,
    source,
    start = 0,
    count = 1
  } = _ref;
  const length = source.length;
  const total = count * length;
  let copied = 0;
  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _resource = _interopRequireDefault(require("./resource"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _gltools = require("@luma.gl/gltools");
var _arrayUtilsFlat = require("../utils/array-utils-flat");
var _assert = require("../utils/assert");
var _env = require("@probe.gl/env");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';
class VertexArrayObject extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'VertexArrayObject';
  }
  static isSupported(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (options.constantAttributeZero) {
      return (0, _gltools.isWebGL2)(gl) || (0, _env.getBrowser)() === 'Chrome';
    }
    return true;
  }
  static getDefaultArray(gl) {
    gl.luma = gl.luma || {};
    if (!gl.luma.defaultVertexArray) {
      gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
        handle: null,
        isDefaultArray: true
      });
    }
    return gl.luma.defaultVertexArray;
  }
  static getMaxAttributes(gl) {
    VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
    return VertexArrayObject.MAX_ATTRIBUTES;
  }
  static setConstant(gl, location, array) {
    switch (array.constructor) {
      case Float32Array:
        VertexArrayObject._setConstantFloatArray(gl, location, array);
        break;
      case Int32Array:
        VertexArrayObject._setConstantIntArray(gl, location, array);
        break;
      case Uint32Array:
        VertexArrayObject._setConstantUintArray(gl, location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const id = opts.id || opts.program && opts.program.id;
    super(gl, Object.assign({}, opts, {
      id
    }));
    this.buffer = null;
    this.bufferValue = null;
    this.isDefaultArray = opts.isDefaultArray || false;
    this.gl2 = gl;
    this.initialize(opts);
    Object.seal(this);
  }
  delete() {
    super.delete();
    if (this.buffer) {
      this.buffer.delete();
    }
    return this;
  }
  get MAX_ATTRIBUTES() {
    return VertexArrayObject.getMaxAttributes(this.gl);
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.setProps(props);
  }
  setProps(props) {
    return this;
  }
  setElementBuffer() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assert.assert)(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
    this.bind(() => {
      this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
    });
    return this;
  }
  setBuffer(location, buffer, accessor) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, accessor);
    }
    const {
      size,
      type,
      stride,
      offset,
      normalized,
      integer,
      divisor
    } = accessor;
    const {
      gl,
      gl2
    } = this;
    location = Number(location);
    this.bind(() => {
      gl.bindBuffer(34962, buffer.handle);
      if (integer) {
        (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
        gl2.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      gl.enableVertexAttribArray(location);
      gl2.vertexAttribDivisor(location, divisor || 0);
    });
    return this;
  }
  enable(location) {
    let enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const disablingAttributeZero = !enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {
      constantAttributeZero: true
    });
    if (!disablingAttributeZero) {
      location = Number(location);
      this.bind(() => enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
    }
    return this;
  }
  getConstantBuffer(elementCount, value) {
    const constantValue = this._normalizeConstantArrayValue(value);
    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || new _buffer.default(this.gl, byteLength);
    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
    updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
    if (updateNeeded) {
      const typedArray = (0, _arrayUtilsFlat.getScratchArray)(value.constructor, length);
      (0, _arrayUtilsFlat.fillArray)({
        target: typedArray,
        source: constantValue,
        start: 0,
        count: length
      });
      this.buffer.subData(typedArray);
      this.bufferValue = value;
    }
    return this.buffer;
  }
  _normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  _compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }
  static _setConstantFloatArray(gl, location, array) {
    switch (array.length) {
      case 1:
        gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        gl.vertexAttrib4fv(location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  static _setConstantIntArray(gl, location, array) {
    (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1iv(location, array);
        break;
      case 2:
        gl.vertexAttribI2iv(location, array);
        break;
      case 3:
        gl.vertexAttribI3iv(location, array);
        break;
      case 4:
        gl.vertexAttribI4iv(location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  static _setConstantUintArray(gl, location, array) {
    (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1uiv(location, array);
        break;
      case 2:
        gl.vertexAttribI2uiv(location, array);
        break;
      case 3:
        gl.vertexAttribI3uiv(location, array);
        break;
      case 4:
        gl.vertexAttribI4uiv(location, array);
        break;
      default:
        (0, _assert.assert)(false);
    }
  }
  _createHandle() {
    const gl2 = this.gl;
    return gl2.createVertexArray();
  }
  _deleteHandle(handle) {
    this.gl2.deleteVertexArray(handle);
    return [this.elements];
  }
  _bindHandle(handle) {
    this.gl2.bindVertexArray(handle);
  }
  _getParameter(pname, _ref) {
    let {
      location
    } = _ref;
    (0, _assert.assert)(Number.isFinite(location));
    return this.bind(() => {
      switch (pname) {
        case 34373:
          return this.gl.getVertexAttribOffset(location, pname);
        default:
          return this.gl.getVertexAttrib(location, pname);
      }
    });
  }
}
exports.default = VertexArrayObject;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/array-utils-flat":"node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _accessor = _interopRequireDefault(require("./accessor"));
var _buffer = _interopRequireDefault(require("./buffer"));
var _vertexArrayObject = _interopRequireDefault(require("./vertex-array-object"));
var _assert = require("../utils/assert");
var _stubMethods = require("../utils/stub-methods");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';
const MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
const DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];
class VertexArray {
  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.attributes = {};
    this.vertexArrayObject = new _vertexArrayObject.default(gl);
    (0, _stubMethods.stubRemovedMethods)(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }
  delete() {
    if (this.buffer) {
      this.buffer.delete();
    }
    this.vertexArrayObject.delete();
  }
  initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.reset();
    this.configuration = null;
    this.bindOnUse = false;
    return this.setProps(props);
  }
  reset() {
    this.elements = null;
    this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES
    } = this.vertexArrayObject;
    this.values = new Array(MAX_ATTRIBUTES).fill(null);
    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
    this.unused = {};
    this.drawParams = null;
    return this;
  }
  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ('configuration' in props) {
      this.configuration = props.configuration;
    }
    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }
    if ('elements' in props) {
      this.setElementBuffer(props.elements);
    }
    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }
    return this;
  }
  clearDrawParams() {
    this.drawParams = null;
  }
  getDrawParams() {
    this.drawParams = this.drawParams || this._updateDrawParams();
    return this.drawParams;
  }
  setAttributes(attributes) {
    Object.assign(this.attributes, attributes);
    this.vertexArrayObject.bind(() => {
      for (const locationOrName in attributes) {
        const value = attributes[locationOrName];
        this._setAttribute(locationOrName, value);
      }
      this.gl.bindBuffer(34962, null);
    });
    return this;
  }
  setElementBuffer() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.elements = elementBuffer;
    this.elementsAccessor = accessor;
    this.clearDrawParams();
    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
    return this;
  }
  setBuffer(locationOrName, buffer) {
    let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, appAccessor);
    }
    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
    if (location >= 0) {
      this.values[location] = buffer;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setBuffer(location, buffer, accessor);
    }
    return this;
  }
  setConstant(locationOrName, arrayValue) {
    let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
      size: arrayValue.length
    }, appAccessor));
    if (location >= 0) {
      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
      this.values[location] = arrayValue;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.enable(location, false);
    }
    return this;
  }
  unbindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.vertexArrayObject.setElementBuffer(null);
      }
      this.buffer = this.buffer || new _buffer.default(this.gl, {
        accessor: {
          size: 4
        }
      });
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        if (this.values[location] instanceof _buffer.default) {
          this.gl.disableVertexAttribArray(location);
          this.gl.bindBuffer(34962, this.buffer.handle);
          this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
        }
      }
    });
    return this;
  }
  bindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.setElementBuffer(this.elements);
      }
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        const buffer = this.values[location];
        if (buffer instanceof _buffer.default) {
          this.setBuffer(location, buffer);
        }
      }
    });
    return this;
  }
  bindForDraw(vertexCount, instanceCount, func) {
    let value;
    this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(vertexCount, instanceCount);
      value = func();
    });
    return value;
  }
  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
    const INVALID_RESULT = {
      location: -1,
      accessor: null
    };
    const {
      location,
      name
    } = this._getAttributeIndex(locationOrName);
    if (!Number.isFinite(location) || location < 0) {
      this.unused[locationOrName] = value;
      _gltools.log.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
      return INVALID_RESULT;
    }
    const accessInfo = this._getAttributeInfo(name || location);
    if (!accessInfo) {
      return INVALID_RESULT;
    }
    const currentAccessor = this.accessors[location] || {};
    const accessor = _accessor.default.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
    const {
      size,
      type
    } = accessor;
    (0, _assert.assert)(Number.isFinite(size) && Number.isFinite(type));
    return {
      location,
      accessor
    };
  }
  _getAttributeInfo(attributeName) {
    return this.configuration && this.configuration.getAttributeInfo(attributeName);
  }
  _getAttributeIndex(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return {
        location
      };
    }
    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
    const name = multiLocation ? multiLocation[1] : locationOrName;
    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
    if (this.configuration) {
      return {
        location: this.configuration.getAttributeLocation(name) + locationOffset,
        name
      };
    }
    return {
      location: -1
    };
  }
  _setAttribute(locationOrName, value) {
    if (value instanceof _buffer.default) {
      this.setBuffer(locationOrName, value);
    } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer.default) {
      const buffer = value[0];
      const accessor = value[1];
      this.setBuffer(locationOrName, buffer, accessor);
    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
      const constant = value;
      this.setConstant(locationOrName, constant);
    } else if (value.buffer instanceof _buffer.default) {
      const accessor = value;
      this.setBuffer(locationOrName, accessor.buffer, accessor);
    } else {
      throw new Error(ERR_ATTRIBUTE_TYPE);
    }
  }
  _setConstantAttributes(vertexCount, instanceCount) {
    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
    let constant = this.values[0];
    if (ArrayBuffer.isView(constant)) {
      this._setConstantAttributeZero(constant, elementCount);
    }
    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      constant = this.values[location];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttribute(location, constant);
      }
    }
  }
  _setConstantAttributeZero(constant, elementCount) {
    if (_vertexArrayObject.default.isSupported(this.gl, {
      constantAttributeZero: true
    })) {
      this._setConstantAttribute(0, constant);
      return;
    }
    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
  }
  _setConstantAttribute(location, constant) {
    _vertexArrayObject.default.setConstant(this.gl, location, constant);
  }
  _updateDrawParams() {
    const drawParams = {
      isIndexed: false,
      isInstanced: false,
      indexCount: Infinity,
      vertexCount: Infinity,
      instanceCount: Infinity
    };
    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      this._updateDrawParamsForLocation(drawParams, location);
    }
    if (this.elements) {
      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
      drawParams.isIndexed = true;
      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
      drawParams.indexOffset = this.elementsAccessor.offset || 0;
    }
    if (drawParams.indexCount === Infinity) {
      drawParams.indexCount = 0;
    }
    if (drawParams.vertexCount === Infinity) {
      drawParams.vertexCount = 0;
    }
    if (drawParams.instanceCount === Infinity) {
      drawParams.instanceCount = 0;
    }
    return drawParams;
  }
  _updateDrawParamsForLocation(drawParams, location) {
    const value = this.values[location];
    const accessor = this.accessors[location];
    if (!value) {
      return;
    }
    const {
      divisor
    } = accessor;
    const isInstanced = divisor > 0;
    drawParams.isInstanced = drawParams.isInstanced || isInstanced;
    if (value instanceof _buffer.default) {
      const buffer = value;
      if (isInstanced) {
        const instanceCount = buffer.getVertexCount(accessor);
        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
      } else {
        const vertexCount = buffer.getVertexCount(accessor);
        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
      }
    }
  }
  setElements() {
    let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _gltools.log.deprecated('setElements', 'setElementBuffer')();
    return this.setElementBuffer(elementBuffer, accessor);
  }
}
exports.default = VertexArray;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./vertex-array-object":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/stub-methods":"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _attributeUtils = require("../webgl-utils/attribute-utils");
var _assert = require("../utils/assert");
const ERR_ARGUMENT = 'UniformBufferLayout illegal argument';
const GL_FLOAT = 0x1406;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;
class UniformBufferLayout {
  constructor(layout) {
    this.layout = {};
    this.size = 0;
    for (const key in layout) {
      this._addUniform(key, layout[key]);
    }
    this.size += (4 - this.size % 4) % 4;
    const data = new Float32Array(this.size);
    this.typedArray = {
      [GL_FLOAT]: data,
      [GL_INT]: new Int32Array(data.buffer),
      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)
    };
  }
  getBytes() {
    return this.size * 4;
  }
  getData() {
    return this.typedArray[GL_FLOAT];
  }
  getSubData(index) {
    let data;
    let offset;
    if (index === undefined) {
      data = this.data;
      offset = 0;
    } else {
      const begin = this.offsets[index];
      const end = begin + this.sizes[index];
      data = this.data.subarray(begin, end);
      offset = begin * 4;
    }
    return {
      data,
      offset
    };
  }
  setUniforms(values) {
    for (const key in values) {
      this._setValue(key, values[key]);
    }
    return this;
  }
  _setValue(key, value) {
    const layout = this.layout[key];
    (0, _assert.assert)(layout, 'UniformLayoutStd140 illegal argument');
    const typedArray = this.typedArray[layout.type];
    if (layout.size === 1) {
      typedArray[layout.offset] = value;
    } else {
      typedArray.set(value, layout.offset);
    }
  }
  _addUniform(key, uniformType) {
    const typeAndComponents = (0, _attributeUtils.decomposeCompositeGLType)(uniformType);
    (0, _assert.assert)(typeAndComponents, ERR_ARGUMENT);
    const {
      type,
      components: count
    } = typeAndComponents;
    this.size = this._alignTo(this.size, count);
    const offset = this.size;
    this.size += count;
    this.layout[key] = {
      type,
      size: count,
      offset
    };
  }
  _alignTo(size, count) {
    switch (count) {
      case 1:
        return size;
      case 2:
        return size + size % 2;
      default:
        return size + (4 - size % 4) % 4;
    }
  }
}
exports.default = UniformBufferLayout;
},{"../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatValue = formatValue;
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForUniforms = getDebugTableForUniforms;
var _assert = require("../utils/assert");
var _formatValue = require("../utils/format-value");
function getDebugTableForUniforms(_ref) {
  let {
    header = 'Uniforms',
    program,
    uniforms,
    undefinedOnly = false
  } = _ref;
  (0, _assert.assert)(program);
  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count = 0;
  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }
  let unusedCount = 0;
  const unusedTable = {};
  if (!undefinedOnly) {
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: "NOT USED: ".concat(uniform),
          [header]: (0, _formatValue.formatValue)(uniform)
        };
      }
    }
  }
  return {
    table,
    count,
    unusedTable,
    unusedCount
  };
}
function addUniformToTable(_ref2) {
  let {
    table,
    header,
    uniforms,
    uniformName,
    undefinedOnly
  } = _ref2;
  const value = uniforms[uniformName];
  const isDefined = isUniformDefined(value);
  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? (0, _formatValue.formatValue)(value) : 'N/A',
      'Uniform Type': isDefined ? value : 'NOT PROVIDED'
    };
    return true;
  }
  return false;
}
function isUniformDefined(value) {
  return value !== undefined && value !== null;
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/format-value":"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForVertexArray = getDebugTableForVertexArray;
var _buffer = _interopRequireDefault(require("../classes/buffer"));
var _constantsToKeys = require("../webgl-utils/constants-to-keys");
var _attributeUtils = require("../webgl-utils/attribute-utils");
var _formatValue = require("../utils/format-value");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getDebugTableForVertexArray(_ref) {
  let {
    vertexArray,
    header = 'Attributes'
  } = _ref;
  if (!vertexArray.configuration) {
    return {};
  }
  const table = {};
  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }
  const attributes = vertexArray.values;
  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);
    if (info) {
      let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      const accessor = vertexArray.accessors[info.location];
      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }
      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }
  return table;
}
function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;
  if (!attribute) {
    return {
      [header]: 'null',
      'Format ': 'N/A'
    };
  }
  let type = 'NOT PROVIDED';
  let size = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value;
  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace('Array', '');
    isInteger = type.indexOf('nt') !== -1;
  }
  if (attribute instanceof _buffer.default) {
    const buffer = attribute;
    const {
      data,
      changed
    } = buffer.getDebugData();
    marker = changed ? '*' : '';
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    let format;
    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = "".concat(instanced ? 'I ' : 'P ', " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat((0, _constantsToKeys.getKey)(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }
    return {
      [header]: "".concat(marker).concat((0, _formatValue.formatValue)(value, {
        size,
        isInteger
      })),
      'Format ': format
    };
  }
  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace('Array', '');
  isInteger = type.indexOf('nt') !== -1;
  return {
    [header]: "".concat((0, _formatValue.formatValue)(value, {
      size,
      isInteger
    }), " (constant)"),
    'Format ': "".concat(size, "x").concat(type, " (constant)")
  };
}
function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size
  } = accessor;
  const typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);
  return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}
},{"../classes/buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/format-value":"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForProgramConfiguration = getDebugTableForProgramConfiguration;
var _attributeUtils = require("../webgl-utils/attribute-utils");
function getDebugTableForProgramConfiguration(config) {
  const table = {};
  const header = "Accessors for ".concat(config.id);
  for (const attributeInfo of config.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration(attributeInfo);
      table["in ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }
  for (const varyingInfo of config.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration(varyingInfo);
      table["out ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }
  return table;
}
function getGLSLDeclaration(attributeInfo) {
  const {
    type,
    size
  } = attributeInfo.accessor;
  const typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);
  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }
  return attributeInfo.name;
}
},{"../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Accessor", {
  enumerable: true,
  get: function () {
    return _accessor.default;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _buffer.default;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _shader.FragmentShader;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _framebuffer.default;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _program.default;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function () {
    return _query.default;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _renderbuffer.default;
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function () {
    return _shader.Shader;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _texture2d.default;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _texture3d.default;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _textureCube.default;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _transformFeedback.default;
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function () {
    return _uniformBufferLayout.default;
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function () {
    return _vertexArray.default;
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function () {
    return _vertexArrayObject.default;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _shader.VertexShader;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.blit;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _clear.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function () {
    return _clear.clearBuffer;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _textureUtils.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToTexture;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getDebugTableForProgramConfiguration", {
  enumerable: true,
  get: function () {
    return _debugProgramConfiguration.getDebugTableForProgramConfiguration;
  }
});
Object.defineProperty(exports, "getDebugTableForUniforms", {
  enumerable: true,
  get: function () {
    return _debugUniforms.getDebugTableForUniforms;
  }
});
Object.defineProperty(exports, "getDebugTableForVertexArray", {
  enumerable: true,
  get: function () {
    return _debugVertexArray.getDebugTableForVertexArray;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "getUniformSetter", {
  enumerable: true,
  get: function () {
    return _uniforms.getUniformSetter;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function () {
    return _loadFile.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadFile.loadImage;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _gltools.log;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _init.lumaStats;
  }
});
Object.defineProperty(exports, "parseUniformName", {
  enumerable: true,
  get: function () {
    return _uniforms.parseUniformName;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loadFile.setPathPrefix;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _utils.uid;
  }
});
var _init = require("./init");
var _requestAnimationFrame = require("./webgl-utils/request-animation-frame");
var _textureUtils = require("./webgl-utils/texture-utils");
var _constantsToKeys = require("./webgl-utils/constants-to-keys");
var _limits = require("./features/limits");
var _webglFeaturesTable = require("./features/webgl-features-table");
var _features = require("./features/features");
var _checkGlslExtension = _interopRequireDefault(require("./features/check-glsl-extension"));
var _accessor = _interopRequireDefault(require("./classes/accessor"));
var _buffer = _interopRequireDefault(require("./classes/buffer"));
var _shader = require("./classes/shader");
var _program = _interopRequireDefault(require("./classes/program"));
var _framebuffer = _interopRequireDefault(require("./classes/framebuffer"));
var _renderbuffer = _interopRequireDefault(require("./classes/renderbuffer"));
var _texture2d = _interopRequireDefault(require("./classes/texture-2d"));
var _textureCube = _interopRequireDefault(require("./classes/texture-cube"));
var _clear = require("./classes/clear");
var _copyAndBlit = require("./classes/copy-and-blit");
var _query = _interopRequireDefault(require("./classes/query"));
var _texture3d = _interopRequireDefault(require("./classes/texture-3d"));
var _transformFeedback = _interopRequireDefault(require("./classes/transform-feedback"));
var _vertexArrayObject = _interopRequireDefault(require("./classes/vertex-array-object"));
var _vertexArray = _interopRequireDefault(require("./classes/vertex-array"));
var _uniformBufferLayout = _interopRequireDefault(require("./classes/uniform-buffer-layout"));
var _loadFile = require("./utils/load-file");
var _getShaderName = _interopRequireDefault(require("./glsl-utils/get-shader-name"));
var _getShaderVersion = _interopRequireDefault(require("./glsl-utils/get-shader-version"));
var _gltools = require("@luma.gl/gltools");
var _assert = require("./utils/assert");
var _utils = require("./utils/utils");
var _uniforms = require("./classes/uniforms");
var _debugUniforms = require("./debug/debug-uniforms");
var _debugVertexArray = require("./debug/debug-vertex-array");
var _debugProgramConfiguration = require("./debug/debug-program-configuration");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./init":"node_modules/@luma.gl/webgl/dist/esm/init.js","./webgl-utils/request-animation-frame":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js","./webgl-utils/texture-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","./webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","./features/limits":"node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./features/webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features/features":"node_modules/@luma.gl/webgl/dist/esm/features/features.js","./features/check-glsl-extension":"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js","./classes/accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./classes/buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./classes/shader":"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./classes/program":"node_modules/@luma.gl/webgl/dist/esm/classes/program.js","./classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./classes/renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./classes/texture-cube":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","./classes/clear":"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./classes/copy-and-blit":"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","./classes/query":"node_modules/@luma.gl/webgl/dist/esm/classes/query.js","./classes/texture-3d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","./classes/transform-feedback":"node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js","./classes/vertex-array-object":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","./classes/vertex-array":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js","./classes/uniform-buffer-layout":"node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js","./utils/load-file":"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js","./glsl-utils/get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./glsl-utils/get-shader-version":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","./utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./classes/uniforms":"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./debug/debug-uniforms":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js","./debug/debug-vertex-array":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js","./debug/debug-program-configuration":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
var _env = require("@probe.gl/env");
const isPage = (0, _env.isBrowser)() && typeof document !== 'undefined';
let statIdCounter = 0;
class AnimationLoop {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      onCreateContext = opts => (0, _gltools.createGLContext)(opts),
      onAddHTML = null,
      onInitialize = () => {},
      onRender = () => {},
      onFinalize = () => {},
      onError,
      gl = null,
      glOptions = {},
      debug = false,
      createFramebuffer = false,
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = _webgl.lumaStats.get("animation-loop-".concat(statIdCounter++))
    } = props;
    let {
      useDevicePixels = true
    } = props;
    if ('useDevicePixelRatio' in props) {
      _webgl.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();
      useDevicePixels = props.useDevicePixelRatio;
    }
    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,
      onError,
      gl,
      glOptions,
      debug,
      createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._pageLoadPromise = null;
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }
  delete() {
    this.stop();
    this._setDisplay(null);
  }
  setNeedsRedraw(reason) {
    (0, _webgl.assert)(typeof reason === 'string');
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }
  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }
    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }
    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }
    return this;
  }
  start() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (this._running) {
      return this;
    }
    this._running = true;
    const startPromise = this._getPageLoadPromise().then(() => {
      if (!this._running || this._initialized) {
        return null;
      }
      this._createWebGLContext(opts);
      this._createFramebuffer();
      this._startEventHandling();
      this._initializeCallbackData();
      this._updateCallbackData();
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._gpuTimeQuery = _webgl.Query.isSupported(this.gl, ['timers']) ? new _webgl.Query(this.gl) : null;
      this._initialized = true;
      return this.onInitialize(this.animationProps);
    }).then(appContext => {
      if (this._running) {
        this._addCallbackData(appContext || {});
        if (appContext !== false) {
          this._startLoop();
        }
      }
    });
    if (this.props.onError) {
      startPromise.catch(this.props.onError);
    }
    return this;
  }
  redraw() {
    if (this.isContextLost()) {
      return this;
    }
    this._beginTimers();
    this._setupFrame();
    this._updateCallbackData();
    this._renderFrame(this.animationProps);
    this._clearNeedsRedraw();
    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }
    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }
    this._endTimers();
    return this;
  }
  stop() {
    if (this._running) {
      this._finalizeCallbackData();
      this._cancelAnimationFrame(this._animationFrameId);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }
    return this;
  }
  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    this.setNeedsRedraw('waitForRender');
    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }
    return this._nextFramePromise;
  }
  async toDataURL() {
    this.setNeedsRedraw('toDataURL');
    await this.waitForRender();
    return this.gl.canvas.toDataURL();
  }
  isContextLost() {
    return this.gl.isContextLost();
  }
  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }
  onInitialize() {
    return this.props.onInitialize(...arguments);
  }
  onRender() {
    return this.props.onRender(...arguments);
  }
  onFinalize() {
    return this.props.onFinalize(...arguments);
  }
  getHTMLControlValue(id) {
    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }
  setViewParameters() {
    _webgl.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();
    return this;
  }
  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };
    this._cancelAnimationFrame(this._animationFrameId);
    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }
  _getPageLoadPromise() {
    if (!this._pageLoadPromise) {
      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {
        if (isPage && document.readyState === 'complete') {
          resolve(document);
          return;
        }
        window.addEventListener('load', () => {
          resolve(document);
        });
      }) : Promise.resolve({});
    }
    return this._pageLoadPromise;
  }
  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }
    if (display) {
      display.animationLoop = this;
    }
    this.display = display;
  }
  _cancelAnimationFrame(animationFrameId) {
    if (this.display && this.display.cancelAnimationFrame) {
      return this.display.cancelAnimationFrame(animationFrameId);
    }
    return (0, _webgl.cancelAnimationFrame)(animationFrameId);
  }
  _requestAnimationFrame(renderFrameCallback) {
    if (this._running) {
      if (this.display && this.display.requestAnimationFrame) {
        return this.display.requestAnimationFrame(renderFrameCallback);
      }
      return (0, _webgl.requestAnimationFrame)(renderFrameCallback);
    }
    return undefined;
  }
  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);
      return;
    }
    this.onRender(...arguments);
  }
  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer();
    this._resizeViewport();
    this._resizeFramebuffer();
  }
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }
  _updateCallbackData() {
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }
    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }
    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    this.animationProps._offScreen = this.offScreen;
  }
  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }
  _addCallbackData(appContext) {
    if (typeof appContext === 'object' && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }
  _createWebGLContext(opts) {
    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? (0, _gltools.instrumentGLContext)(this.props.gl, opts) : this.onCreateContext(opts);
    if (!(0, _gltools.isWebGL)(this.gl)) {
      throw new Error('AnimationLoop.onCreateContext - illegal context returned');
    }
    (0, _gltools.resetParameters)(this.gl);
    this._createInfoDiv();
  }
  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);
      if (html) {
        div.innerHTML = html;
      }
    }
  }
  _getSizeAndAspect() {
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;
    let aspect = 1;
    const {
      canvas
    } = this.gl;
    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }
    return {
      width,
      height,
      aspect
    };
  }
  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }
  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      (0, _gltools.resizeGLContext)(this.gl, {
        useDevicePixels: this.useDevicePixels
      });
    }
  }
  _createFramebuffer() {
    if (this.props.createFramebuffer) {
      this.framebuffer = new _webgl.Framebuffer(this.gl);
    }
  }
  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }
  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();
    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }
    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }
    this.cpuTime.timeStart();
  }
  _endTimers() {
    this.cpuTime.timeEnd();
    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.end();
    }
  }
  _startEventHandling() {
    const {
      canvas
    } = this.gl;
    if (canvas) {
      canvas.addEventListener('mousemove', this._onMousemove);
      canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }
  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
}
exports.default = AnimationLoop;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERTEX_SHADER = exports.FRAGMENT_SHADER = void 0;
const VERTEX_SHADER = 'vs';
exports.VERTEX_SHADER = VERTEX_SHADER;
const FRAGMENT_SHADER = 'fs';
exports.FRAGMENT_SHADER = FRAGMENT_SHADER;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./assert":"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;
const TYPE_DEFINITIONS = {
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  array: {
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }
  return propTypes;
}
function parsePropType(propDef) {
  let type = getTypeOf(propDef);
  if (type === 'object') {
    if (!propDef) {
      return {
        type: 'object',
        value: null
      };
    }
    if ('type' in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }
    if (!('value' in propDef)) {
      return {
        type: 'object',
        value: propDef
      };
    }
    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }
  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }
  return typeof value;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.normalizeShaderModule = normalizeShaderModule;
var _utils = require("../utils");
var _propTypes = require("./filters/prop-types");
const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';
class ShaderModule {
  constructor(_ref) {
    let {
      name,
      vs,
      fs,
      dependencies = [],
      uniforms,
      getUniforms,
      deprecations = [],
      defines = {},
      inject = {},
      vertexShader,
      fragmentShader
    } = _ref;
    (0, _utils.assert)(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;
    this.injections = normalizeInjections(inject);
    if (uniforms) {
      this.uniforms = (0, _propTypes.parsePropTypes)(uniforms);
    }
  }
  getModuleSource(type) {
    let moduleSource;
    switch (type) {
      case VERTEX_SHADER:
        moduleSource = this.vs || '';
        break;
      case FRAGMENT_SHADER:
        moduleSource = this.fs || '';
        break;
      default:
        (0, _utils.assert)(false);
    }
    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_'), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
  }
  getUniforms(opts, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }
    if (this.uniforms) {
      return this._defaultGetUniforms(opts);
    }
    return {};
  }
  getDefines() {
    return this.defines;
  }
  checkDeprecations(shaderSource, log) {
    this.deprecations.forEach(def => {
      if (def.regex.test(shaderSource)) {
        if (def.deprecated) {
          log.deprecated(def.old, def.new)();
        } else {
          log.removed(def.old, def.new)();
        }
      }
    });
  }
  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach(def => {
      switch (def.type) {
        case 'function':
          def.regex = new RegExp("\\b".concat(def.old, "\\("));
          break;
        default:
          def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
      }
    });
    return deprecations;
  }
  _defaultGetUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const uniforms = {};
    const propTypes = this.uniforms;
    for (const key in propTypes) {
      const propDef = propTypes[key];
      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          (0, _utils.assert)(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
        }
        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }
    return uniforms;
  }
}
exports.default = ShaderModule;
function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;
    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }
  return module;
}
function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);
    if (typeof injection === 'string') {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
},{"../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js","./filters/prop-types":"node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TEST_EXPORTS = void 0;
exports.resolveModules = resolveModules;
var _shaderModule = _interopRequireDefault(require("./shader-module"));
var _utils = require("../utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);
}
function getDependencyGraph(_ref) {
  let {
    modules,
    level,
    moduleMap,
    moduleDepth
  } = _ref;
  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}
function instantiateModules(modules, seen) {
  return modules.map(module => {
    if (module instanceof _shaderModule.default) {
      return module;
    }
    (0, _utils.assert)(typeof module !== 'string', "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
    (0, _utils.assert)(module.name, 'shader module has no name');
    module = new _shaderModule.default(module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}
const TEST_EXPORTS = {
  getShaderDependencies,
  getDependencyGraph
};
exports.TEST_EXPORTS = TEST_EXPORTS;
},{"./shader-module":"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;
function isOldIE() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FEATURES = void 0;
exports.canCompileGLGSExtension = canCompileGLGSExtension;
exports.getContextInfo = getContextInfo;
exports.hasFeatures = hasFeatures;
var _isOldIe = _interopRequireDefault(require("./is-old-ie"));
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const GL_VENDOR = 0x1f00;
const GL_RENDERER = 0x1f01;
const GL_VERSION = 0x1f02;
const GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
const WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};
const FEATURES = {};
exports.FEATURES = FEATURES;
Object.keys(WEBGL_FEATURES).forEach(key => {
  FEATURES[key] = key;
});
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContextInfo(gl) {
  const info = gl.getExtension('WEBGL_debug_renderer_info');
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}
function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }
  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }
  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return 'AMD';
  }
  return 'UNKNOWN GPU';
}
const compiledGlslExtensions = {};
function canCompileGLGSExtension(gl, cap) {
  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);
  if (!(0, _isOldIe.default)(opts)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const behavior = opts.behavior || 'enable';
  const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);
  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  const value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
  (0, _assert.default)(value === false || value === true);
  return value;
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => getFeature(gl, feature));
}
},{"./is-old-ie":"node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js","./assert":"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.getVersionDefines = getVersionDefines;
var _webglInfo = require("../utils/webgl-info");
function getPlatformShaderDefines(gl) {
  const debugInfo = (0, _webglInfo.getContextInfo)(gl);
  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
    case 'intel':
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    case 'amd':
      return "#define AMD_GPU\n";
    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}
function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DEPTH)) {
    versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES)) {
    versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
  }
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA, {
    behavior: 'require'
  })) {
    versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
  }
  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
  }
  return versionDefines;
}
},{"../utils/webgl-info":"node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MODULE_INJECTORS_VS = exports.MODULE_INJECTORS_FS = void 0;
const MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
exports.MODULE_INJECTORS_VS = MODULE_INJECTORS_VS;
const MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
exports.MODULE_INJECTORS_FS = MODULE_INJECTORS_FS;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DECLARATION_INJECT_MARKER = void 0;
exports.combineInjects = combineInjects;
exports.default = injectShader;
var _moduleInjectors = require("../modules/module-injectors");
var _constants = require("./constants");
var _utils = require("../utils");
const MODULE_INJECTORS = {
  [_constants.VERTEX_SHADER]: _moduleInjectors.MODULE_INJECTORS_VS,
  [_constants.FRAGMENT_SHADER]: _moduleInjectors.MODULE_INJECTORS_FS
};
const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
exports.DECLARATION_INJECT_MARKER = DECLARATION_INJECT_MARKER;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const fragments = [];
function injectShader(source, type, inject) {
  let injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const isVertex = type === _constants.VERTEX_SHADER;
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = "".concat(fragments.join('\n'), "\n");
    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, match => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, '');
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, match => match + MODULE_INJECTORS[type]);
  }
  return source;
}
function combineInjects(injects) {
  const result = {};
  (0, _utils.assert)(Array.isArray(injects) && injects.length > 1);
  injects.forEach(inject => {
    for (const key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}
},{"../modules/module-injectors":"node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js","./constants":"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transpileShader;
function testVariable(qualifier) {
  return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), 'g');
}
const ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, '#version 300 es\n'], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, 'textureLod('], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, 'texture(']];
const ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']];
const ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('varying'), 'in $1']];
const ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, '#version 100'], [/\btexture(2D|2DProj|Cube)Lod\(/g, 'texture$1LodEXT('], [/\btexture\(/g, 'texture2D('], [/\btextureLod\(/g, 'texture2DLodEXT(']];
const ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']];
const ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'varying $1']];
const ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';
const ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), 'g'), outputName);
  } else {
    const outputName = 'fragmentColor';
    source = source.replace(REGEX_START_OF_MAIN, match => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), 'g'), outputName);
  }
  return source;
}
function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp("\\b".concat(outputName, "\\b"), 'g'), ES100_FRAGMENT_OUTPUT_NAME);
  }
  return source;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assembleShaders = assembleShaders;
var _constants = require("./constants");
var _resolveModules = require("./resolve-modules");
var _platformDefines = require("./platform-defines");
var _injectShader = _interopRequireWildcard(require("./inject-shader"));
var _transpileShader = _interopRequireDefault(require("./transpile-shader"));
var _utils = require("../utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const INJECT_SHADER_DECLARATIONS = "\n\n".concat(_injectShader.DECLARATION_INJECT_MARKER, "\n\n");
const SHADER_TYPE = {
  [_constants.VERTEX_SHADER]: 'vertex',
  [_constants.FRAGMENT_SHADER]: 'fragment'
};
const FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
function assembleShaders(gl, opts) {
  const {
    vs,
    fs
  } = opts;
  const modules = (0, _resolveModules.resolveModules)(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: _constants.VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: _constants.FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShader(gl, _ref) {
  let {
    id,
    source,
    type,
    modules,
    defines = {},
    hookFunctions = [],
    inject = {},
    transpileToGLSL100 = false,
    prologue = true,
    log
  } = _ref;
  (0, _utils.assert)(typeof source === 'string', 'shader source must be a string');
  const isVertex = type === _constants.VERTEX_SHADER;
  const sourceLines = source.split('\n');
  let glslVersion = 100;
  let versionLine = '';
  let coreSource = source;
  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  } else {
    versionLine = "#version ".concat(glslVersion);
  }
  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat((0, _platformDefines.getPlatformShaderDefines)(gl), "\n").concat((0, _platformDefines.getVersionDefines)(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === 'decl') {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log) {
      module.checkDeprecations(coreSource, log);
    }
    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];
    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);
      if (match) {
        const name = match[2];
        const injectionType = name === 'decl' ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = (0, _injectShader.default)(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = (0, _injectShader.default)(assembledSource, type, mainInjections);
  assembledSource = (0, _transpileShader.default)(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}
function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}
function getShaderType(_ref2) {
  let {
    type
  } = _ref2;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}
function getShaderName(_ref3) {
  let {
    id,
    source,
    type
  } = _ref3;
  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
}
function getApplicationDefines() {
  let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let count = 0;
  let sourceText = '';
  for (const define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }
    count++;
    const value = defines[define];
    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
  }
  if (count === 0) {
    sourceText += '\n';
  }
  return sourceText;
}
function getHookFunctions(hookFunctions, hookInjections) {
  let result = '';
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");
    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);
      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }
    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }
    result += '}\n';
  }
  return result;
}
function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach(hook => {
    let opts;
    if (typeof hook !== 'string') {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}
},{"./constants":"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","./resolve-modules":"node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js","./platform-defines":"node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js","./inject-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./transpile-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToVec4 = convertToVec4;
exports.getPassthroughFS = getPassthroughFS;
exports.getQualifierDetails = getQualifierDetails;
exports.typeToChannelCount = typeToChannelCount;
exports.typeToChannelSuffix = typeToChannelSuffix;
var _utils = require("../utils");
const FS100 = "void main() {gl_FragColor = vec4(0);}";
const FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
const FS300 = "#version 300 es\n".concat(FS_GLES);
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, '').split(/\s+/);
  const [qualifier, type, definition] = words;
  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }
  const name = definition.split(';')[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;
  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return "#version ".concat(version, "\n").concat(FS_GLES);
    }
    return FS100;
  }
  const outputValue = convertToVec4(input, inputType);
  if (version >= 300) {
    return "#version ".concat(version, " ").concat(version === 300 ? 'es' : '', "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }
  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';
    case 'vec2':
      return 'xy';
    case 'vec3':
      return 'xyz';
    case 'vec4':
      return 'xyzw';
    default:
      (0, _utils.assert)(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;
    case 'vec2':
      return 2;
    case 'vec3':
      return 3;
    case 'vec4':
      return 4;
    default:
      (0, _utils.assert)(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
    case 'vec2':
      return "vec4(".concat(variable, ", 0.0, 1.0)");
    case 'vec3':
      return "vec4(".concat(variable, ", 1.0)");
    case 'vec4':
      return variable;
    default:
      (0, _utils.assert)(false);
      return null;
  }
}
},{"../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.random = void 0;
const fs = "float random(vec3 scale, float seed) {\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n";
const random = {
  name: 'random',
  fs
};
exports.random = random;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp32 = void 0;
const fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
const fp32 = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};
exports.fp32 = fp32;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64LowPart = fp64LowPart;
exports.fp64ify = fp64ify;
exports.fp64ifyMatrix4 = fp64ifyMatrix4;
function fp64ify(a) {
  let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const hiPart = Math.fround(a);
  const loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a) {
  return a - Math.fround(a);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64 = void 0;
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64LowPart;
  }
});
exports.fp64arithmetic = void 0;
Object.defineProperty(exports, "fp64ify", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ify;
  }
});
Object.defineProperty(exports, "fp64ifyMatrix4", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ifyMatrix4;
  }
});
var _fp64Utils = require("./fp64-utils");
var _fp64Arithmetic = _interopRequireDefault(require("./fp64-arithmetic.glsl"));
var _fp64Functions = _interopRequireDefault(require("./fp64-functions.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CONST_UNIFORMS = {
  ONE: 1.0
};
function getUniforms() {
  return CONST_UNIFORMS;
}
const fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: _fp64Arithmetic.default,
  fs: null,
  getUniforms,
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
};
exports.fp64arithmetic = fp64arithmetic;
const fp64 = {
  name: 'fp64',
  vs: _fp64Functions.default,
  fs: null,
  dependencies: [fp64arithmetic],
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
};
exports.fp64 = fp64;
},{"./fp64-utils":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js","./fp64-arithmetic.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js","./fp64-functions.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js"}],"node_modules/@math.gl/core/dist/esm/lib/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
},{}],"node_modules/@math.gl/core/dist/esm/lib/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acos = acos;
exports.asin = asin;
exports.atan = atan;
exports.clamp = clamp;
exports.clone = clone;
exports.config = void 0;
exports.configure = configure;
exports.cos = cos;
exports.degrees = degrees;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.formatValue = formatValue;
exports.isArray = isArray;
exports.lerp = lerp;
exports.radians = radians;
exports.sin = sin;
exports.tan = tan;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.withEpsilon = withEpsilon;
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const RADIANS_TO_DEGREES = 1 / Math.PI * 180;
const DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
const config = {
  EPSILON: 1e-12,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true
};
exports.config = config;
function configure(options) {
  for (const key in options) {
    (0, _assert.default)(key in config);
    config[key] = options[key];
  }
  return config;
}
function formatValue(value, {
  precision = config.precision
} = {}) {
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function clone(array) {
  return 'clone' in array ? array.clone() : array.slice();
}
function toRadians(degrees) {
  return radians(degrees);
}
function toDegrees(radians) {
  return degrees(radians);
}
function radians(degrees, result) {
  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);
}
function degrees(radians, result) {
  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);
}
function sin(radians, result) {
  return map(radians, angle => Math.sin(angle), result);
}
function cos(radians, result) {
  return map(radians, angle => Math.cos(angle), result);
}
function tan(radians, result) {
  return map(radians, angle => Math.tan(angle), result);
}
function asin(radians, result) {
  return map(radians, angle => Math.asin(angle), result);
}
function acos(radians, result) {
  return map(radians, angle => Math.acos(angle), result);
}
function atan(radians, result) {
  return map(radians, angle => Math.atan(angle), result);
}
function clamp(value, min, max) {
  return map(value, value => Math.max(min, Math.min(max, value)));
}
function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map((ai, i) => lerp(ai, b[i], t));
  }
  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a === b) {
      return true;
    }
    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a && a.equals) {
      return a.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a);
    }
    if (typeof a === 'number' && typeof b === 'number') {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function exactEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (a && typeof a === 'object' && b && typeof b === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }
    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }
  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function withEpsilon(epsilon, func) {
  const oldPrecision = config.EPSILON;
  config.EPSILON = epsilon;
  let value;
  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }
  return value;
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value, func, result) {
  if (isArray(value)) {
    const array = value;
    result = result || duplicateArray(array);
    for (let i = 0; i < result.length && i < array.length; ++i) {
      result[i] = func(value[i], i, result);
    }
    return result;
  }
  return func(value);
}
},{"./assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _common = require("../../lib/common");
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
class MathArray extends _extendableBuiltin(Array) {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      targetArray[offset + i] = this[i];
    }
    return targetArray;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return (0, _common.isArray)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(_common.config);
  }
  formatString(opts) {
    let string = '';
    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i], opts);
    }
    return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!(0, _common.equals)(this[i], array[i])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }
    return true;
  }
  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }
    return this.check();
  }
  lerp(a, b, t) {
    if (t === undefined) {
      return this.lerp(this, a, b);
    }
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a[i];
      this[i] = ai + t * (b[i] - ai);
    }
    return this.check();
  }
  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }
    return this.check();
  }
  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }
    return this.check();
  }
  scale(scale) {
    if (typeof scale === 'number') {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scale;
      }
    } else {
      for (let i = 0; i < this.ELEMENTS && i < scale.length; ++i) {
        this[i] *= scale[i];
      }
    }
    return this.check();
  }
  multiplyByScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  check() {
    if (_common.config.debug && !this.validate()) {
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    }
    return this;
  }
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }
    return valid;
  }
  sub(a) {
    return this.subtract(a);
  }
  setScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a;
    }
    return this.check();
  }
  addScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a;
    }
    return this.check();
  }
  subScalar(a) {
    return this.addScalar(-a);
  }
  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  divideScalar(a) {
    return this.multiplyByScalar(1 / a);
  }
  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }
    return this.check();
  }
  get elements() {
    return this;
  }
}
exports.default = MathArray;
},{"../../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@math.gl/core/dist/esm/lib/validators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkNumber = checkNumber;
exports.checkVector = checkVector;
exports.deprecated = deprecated;
exports.validateVector = validateVector;
var _common = require("./common");
function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }
  return value;
}
function checkVector(v, length, callerName = '') {
  if (_common.config.debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }
  return v;
}
const map = {};
function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}
},{"./common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./math-array"));
var _validators = require("../../lib/validators");
var _assert = _interopRequireDefault(require("../../lib/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Vector extends _mathArray.default {
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }
    return length;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }
    return (0, _validators.checkNumber)(length);
  }
  dot(mathArray) {
    let product = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }
    return (0, _validators.checkNumber)(product);
  }
  normalize() {
    const length = this.magnitude();
    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i) {
    (0, _assert.default)(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    return (0, _validators.checkNumber)(this[i]);
  }
  setComponent(i, value) {
    (0, _assert.default)(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    this[i] = value;
    return this.check();
  }
  addVectors(a, b) {
    return this.copy(a).add(b);
  }
  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }
  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }
  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }
}
exports.default = Vector;
},{"./math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../../lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */
exports.RANDOM = RANDOM;
function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
    i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};
},{}],"node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(2);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
    y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
    y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
    p1 = a[1] - b[1],
    sinC = Math.sin(rad),
    cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
    y1 = a[1],
    x2 = b[0],
    y2 = b[1],
    // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
    // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1];
  var b0 = b[0],
    b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */
exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */
exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */
exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */
exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec2_transformMat4AsVector = vec2_transformMat4AsVector;
exports.vec3_transformMat2 = vec3_transformMat2;
exports.vec3_transformMat4AsVector = vec3_transformMat4AsVector;
exports.vec4_transformMat2 = vec4_transformMat2;
exports.vec4_transformMat3 = vec4_transformMat3;
function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
},{}],"node_modules/@math.gl/core/dist/esm/classes/vector2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vector = _interopRequireDefault(require("./base/vector"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var _glMatrixExtras = require("../lib/gl-matrix-extras");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Vector2 extends _vector.default {
  constructor(x = 0, y = 0) {
    super(2);
    if ((0, _common.isArray)(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
      }
      this[0] = x;
      this[1] = y;
    }
  }
  set(x, y) {
    this[0] = x;
    this[1] = y;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    return this.check();
  }
  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
    }
    this[0] = object.x;
    this[1] = object.y;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    return object;
  }
  get ELEMENTS() {
    return 2;
  }
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    vec2.transformMat4(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    (0, _glMatrixExtras.vec2_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    vec2.transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2x3(matrix2x3) {
    vec2.transformMat2d(this, this, matrix2x3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec2.transformMat2(this, this, matrix2);
    return this.check();
  }
}
exports.default = Vector2;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(3);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2];
  var bx = b[0],
    by = b[1],
    bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3];
  var x = a[0],
    y = a[1],
    z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
    uvy = qz * x - qx * z,
    uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
    uuvy = qz * uvx - qx * uvz,
    uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
    r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    bx = b[0],
    by = b[1],
    bz = b[2],
    mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
    mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
    mag = mag1 * mag2,
    cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */
exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */
exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */
exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */
exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/vector3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vector = _interopRequireDefault(require("./base/vector"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _glMatrixExtras = require("../lib/gl-matrix-extras");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ORIGIN = [0, 0, 0];
let ZERO;
class Vector3 extends _vector.default {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && (0, _common.isArray)(x)) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
        (0, _validators.checkNumber)(z);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }
  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
      (0, _validators.checkNumber)(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  angle(vector) {
    return vec3.angle(this, vector);
  }
  cross(vector) {
    vec3.cross(this, this, vector);
    return this.check();
  }
  rotateX({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateX(this, this, origin, radians);
    return this.check();
  }
  rotateY({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateY(this, this, origin, radians);
    return this.check();
  }
  rotateZ({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateZ(this, this, origin, radians);
    return this.check();
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    vec3.transformMat4(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    (0, _glMatrixExtras.vec3_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    vec3.transformMat3(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    (0, _glMatrixExtras.vec3_transformMat2)(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    vec3.transformQuat(this, this, quaternion);
    return this.check();
  }
}
exports.default = Vector3;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/dist/esm/classes/vector4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vector = _interopRequireDefault(require("./base/vector"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
var vec4 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _glMatrixExtras = require("../lib/gl-matrix-extras");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let ZERO;
class Vector4 extends _vector.default {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new Vector4(0, 0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  constructor(x = 0, y = 0, z = 0, w = 0) {
    super(-0, -0, -0, -0);
    if ((0, _common.isArray)(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
        (0, _validators.checkNumber)(z);
        (0, _validators.checkNumber)(w);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
    }
  }
  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }
  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
      (0, _validators.checkNumber)(object.z);
      (0, _validators.checkNumber)(object.w);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this;
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    object.w = this[3];
    return object;
  }
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get w() {
    return this[3];
  }
  set w(value) {
    this[3] = (0, _validators.checkNumber)(value);
  }
  transform(matrix4) {
    vec4.transformMat4(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    (0, _glMatrixExtras.vec4_transformMat3)(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    (0, _glMatrixExtras.vec4_transformMat2)(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    vec4.transformQuat(this, this, quaternion);
    return this.check();
  }
  applyMatrix4(m) {
    m.transform(this, this);
    return this;
  }
}
exports.default = Vector4;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./math-array"));
var _validators = require("../../lib/validators");
var _common = require("../../lib/common");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Matrix extends _mathArray.default {
  toString() {
    let string = '[';
    if (_common.config.printRowMajor) {
      string += 'row-major:';
      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += " ".concat(this[col * this.RANK + row]);
        }
      }
    } else {
      string += 'column-major:';
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += " ".concat(this[i]);
      }
    }
    string += ']';
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  setElement(row, col, value) {
    this[col * this.RANK + row] = (0, _validators.checkNumber)(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }
    return this;
  }
}
exports.default = Matrix;
},{"./math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/gl-matrix/esm/mat3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromMat2d = fromMat2d;
exports.fromMat4 = fromMat4;
exports.fromQuat = fromQuat;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(9);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    x = v[0],
    y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a10 = a[3],
    a11 = a[4],
    a12 = a[5],
    a20 = a[6],
    a21 = a[7],
    a22 = a[8],
    s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
    y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3],
    a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7],
    a8 = a[8];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */
exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/matrix3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _matrix = _interopRequireDefault(require("./base/matrix"));
var _validators = require("../lib/validators");
var _glMatrixExtras = require("../lib/gl-matrix-extras");
var mat3 = _interopRequireWildcard(require("gl-matrix/mat3"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INDICES;
(function (INDICES) {
  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES[INDICES["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES[INDICES["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES[INDICES["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES[INDICES["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES[INDICES["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES[INDICES["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
const IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class Matrix3 extends _matrix.default {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array, ...args) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else if (args.length > 0) {
      this.copy([array, ...args]);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  fromObject(object) {
    return this.check();
  }
  fromQuaternion(q) {
    mat3.fromQuat(this, q);
    return this.check();
  }
  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  determinant() {
    return mat3.determinant(this);
  }
  transpose() {
    mat3.transpose(this, this);
    return this.check();
  }
  invert() {
    mat3.invert(this, this);
    return this.check();
  }
  multiplyLeft(a) {
    mat3.multiply(this, a, this);
    return this.check();
  }
  multiplyRight(a) {
    mat3.multiply(this, this, a);
    return this.check();
  }
  rotate(radians) {
    mat3.rotate(this, this, radians);
    return this.check();
  }
  scale(factor) {
    if (Array.isArray(factor)) {
      mat3.scale(this, this, factor);
    } else {
      mat3.scale(this, this, [factor, factor]);
    }
    return this.check();
  }
  translate(vec) {
    mat3.translate(this, this, vec);
    return this.check();
  }
  transform(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = vec2.transformMat3(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3.transformMat3(result || [-0, -0, -0], vector, this);
        break;
      case 4:
        out = (0, _glMatrixExtras.vec4_transformMat3)(result || [-0, -0, -0, -0], vector, this);
        break;
      default:
        throw new Error('Illegal vector');
    }
    (0, _validators.checkVector)(out, vector.length);
    return out;
  }
  transformVector(vector, result) {
    return this.transform(vector, result);
  }
  transformVector2(vector, result) {
    return this.transform(vector, result);
  }
  transformVector3(vector, result) {
    return this.transform(vector, result);
  }
}
exports.default = Matrix3;
let ZERO_MATRIX3;
let IDENTITY_MATRIX3;
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3();
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}
},{"./base/matrix":"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js","gl-matrix/mat3":"node_modules/gl-matrix/esm/mat3.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js"}],"node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = void 0;
exports.orthoNO = orthoNO;
exports.orthoZO = orthoZO;
exports.perspective = void 0;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.perspectiveNO = perspectiveNO;
exports.perspectiveZO = perspectiveZO;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(16);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a03 = a[3];
    var a12 = a[6],
      a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3];
  var a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  var a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  var a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication

  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  if (len < glMatrix.EPSILON) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
    by = -a[1],
    bz = -a[2],
    bw = a[3],
    ax = a[4],
    ay = a[5],
    az = a[6],
    aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
exports.perspective = perspective;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */

var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
exports.ortho = ortho;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2];
  var z0 = eyex - target[0],
    z1 = eyey - target[1],
    z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }
  var x0 = upy * z2 - upz * z1,
    x1 = upz * z0 - upx * z2,
    x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var a4 = a[4],
    a5 = a[5],
    a6 = a[6],
    a7 = a[7];
  var a8 = a[8],
    a9 = a[9],
    a10 = a[10],
    a11 = a[11];
  var a12 = a[12],
    a13 = a[13],
    a14 = a[14],
    a15 = a[15];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  var b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7];
  var b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11];
  var b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */
exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
var glMatrix = _interopRequireWildcard(require("./common.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
    B = v[0] * w[2] - v[2] * w[0],
    C = v[0] * w[3] - v[3] * w[0],
    D = v[1] * w[2] - v[2] * w[1],
    E = v[1] * w[3] - v[3] * w[1],
    F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
    y = a[1],
    z = a[2];
  var qx = q[0],
    qy = q[1],
    qz = q[2],
    qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */
exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */
exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */
exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */
exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
exports.sqrLen = sqrLen;
var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();
exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/matrix4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _matrix = _interopRequireDefault(require("./base/matrix"));
var _validators = require("../lib/validators");
var _glMatrixExtras = require("../lib/gl-matrix-extras");
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INDICES;
(function (INDICES) {
  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES[INDICES["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES[INDICES["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES[INDICES["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES[INDICES["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES[INDICES["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES[INDICES["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES[INDICES["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES[INDICES["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES[INDICES["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES[INDICES["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES[INDICES["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES[INDICES["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES[INDICES["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));
const DEFAULT_FOVY = 45 * Math.PI / 180;
const DEFAULT_ASPECT = 1;
const DEFAULT_NEAR = 0.1;
const DEFAULT_FAR = 500;
const IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Matrix4 extends _matrix.default {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }
  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }
  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  fromObject(object) {
    return this.check();
  }
  fromQuaternion(quaternion) {
    mat4.fromQuat(this, quaternion);
    return this.check();
  }
  frustum(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      mat4.frustum(this, left, right, bottom, top, near, far);
    }
    return this.check();
  }
  lookAt(view) {
    const {
      eye,
      center = [0, 0, 0],
      up = [0, 1, 0]
    } = view;
    mat4.lookAt(this, eye, center, up);
    return this.check();
  }
  ortho(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    mat4.ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }
  orthographic(view) {
    const {
      fovy = DEFAULT_FOVY,
      aspect = DEFAULT_ASPECT,
      focalDistance = 1,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }
  perspective(view) {
    const {
      fovy = 45 * Math.PI / 180,
      aspect = 1,
      near = 0.1,
      far = 500
    } = view;
    checkRadians(fovy);
    mat4.perspective(this, fovy, aspect, near, far);
    return this.check();
  }
  determinant() {
    return mat4.determinant(this);
  }
  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }
  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }
  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }
  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }
  transpose() {
    mat4.transpose(this, this);
    return this.check();
  }
  invert() {
    mat4.invert(this, this);
    return this.check();
  }
  multiplyLeft(a) {
    mat4.multiply(this, a, this);
    return this.check();
  }
  multiplyRight(a) {
    mat4.multiply(this, this, a);
    return this.check();
  }
  rotateX(radians) {
    mat4.rotateX(this, this, radians);
    return this.check();
  }
  rotateY(radians) {
    mat4.rotateY(this, this, radians);
    return this.check();
  }
  rotateZ(radians) {
    mat4.rotateZ(this, this, radians);
    return this.check();
  }
  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }
  rotateAxis(radians, axis) {
    mat4.rotate(this, this, radians, axis);
    return this.check();
  }
  scale(factor) {
    mat4.scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }
  translate(vector) {
    mat4.translate(this, this, vector);
    return this.check();
  }
  transform(vector, result) {
    if (vector.length === 4) {
      result = vec4.transformMat4(result || [-0, -0, -0, -0], vector, this);
      (0, _validators.checkVector)(result, 4);
      return result;
    }
    return this.transformAsPoint(vector, result);
  }
  transformAsPoint(vector, result) {
    const {
      length
    } = vector;
    let out;
    switch (length) {
      case 2:
        out = vec2.transformMat4(result || [-0, -0], vector, this);
        break;
      case 3:
        out = vec3.transformMat4(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error('Illegal vector');
    }
    (0, _validators.checkVector)(out, vector.length);
    return out;
  }
  transformAsVector(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = (0, _glMatrixExtras.vec2_transformMat4AsVector)(result || [-0, -0], vector, this);
        break;
      case 3:
        out = (0, _glMatrixExtras.vec3_transformMat4AsVector)(result || [-0, -0, -0], vector, this);
        break;
      default:
        throw new Error('Illegal vector');
    }
    (0, _validators.checkVector)(out, vector.length);
    return out;
  }
  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }
  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }
  makeRotationX(radians) {
    return this.identity().rotateX(radians);
  }
  makeTranslation(x, y, z) {
    return this.identity().translate([x, y, z]);
  }
}
exports.default = Matrix4;
let ZERO;
let IDENTITY;
function getZeroMatrix() {
  if (!ZERO) {
    ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO);
  }
  return ZERO;
}
function getIdentityMatrix() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error('expected radians');
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}
},{"./base/matrix":"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/gl-matrix/esm/quat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = void 0;
exports.calculateW = calculateW;
exports.clone = void 0;
exports.conjugate = conjugate;
exports.copy = void 0;
exports.create = create;
exports.exactEquals = exports.equals = exports.dot = void 0;
exports.exp = exp;
exports.fromEuler = fromEuler;
exports.fromMat3 = fromMat3;
exports.fromValues = void 0;
exports.getAngle = getAngle;
exports.getAxisAngle = getAxisAngle;
exports.identity = identity;
exports.invert = invert;
exports.lerp = exports.length = exports.len = void 0;
exports.ln = ln;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = void 0;
exports.pow = pow;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
exports.setAxisAngle = setAxisAngle;
exports.slerp = slerp;
exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
exports.str = str;
var glMatrix = _interopRequireWildcard(require("./common.js"));
var mat3 = _interopRequireWildcard(require("./mat3.js"));
var vec3 = _interopRequireWildcard(require("./vec3.js"));
var vec4 = _interopRequireWildcard(require("./vec4.js"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new glMatrix.ARRAY_TYPE(4);
  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var by = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bz = Math.sin(rad),
    bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3];
  var bx = b[0],
    by = b[1],
    bz = b[2],
    bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients

  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values

  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
    a1 = a[1],
    a2 = a[2],
    a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */
exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */
exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */
exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */
exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */
exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */
exports.equals = equals;
var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
exports.rotationTo = rotationTo;
var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
exports.sqlerp = sqlerp;
var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();
exports.setAxes = setAxes;
},{"./common.js":"node_modules/gl-matrix/esm/common.js","./mat3.js":"node_modules/gl-matrix/esm/mat3.js","./vec3.js":"node_modules/gl-matrix/esm/vec3.js","./vec4.js":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/dist/esm/classes/quaternion.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./base/math-array"));
var _validators = require("../lib/validators");
var _vector = _interopRequireDefault(require("./vector4"));
var quat = _interopRequireWildcard(require("gl-matrix/quat"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const IDENTITY_QUATERNION = [0, 0, 0, 1];
class Quaternion extends _mathArray.default {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    super(-0, -0, -0, -0);
    if (Array.isArray(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      this.set(x, y, z, w);
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }
  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }
  fromObject(object) {
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this.check();
  }
  fromMatrix3(m) {
    quat.fromMat3(this, m);
    return this.check();
  }
  fromAxisRotation(axis, rad) {
    quat.setAxisAngle(this, axis, rad);
    return this.check();
  }
  identity() {
    quat.identity(this);
    return this.check();
  }
  setAxisAngle(axis, rad) {
    return this.fromAxisRotation(axis, rad);
  }
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get w() {
    return this[3];
  }
  set w(value) {
    this[3] = (0, _validators.checkNumber)(value);
  }
  len() {
    return quat.length(this);
  }
  lengthSquared() {
    return quat.squaredLength(this);
  }
  dot(a) {
    return quat.dot(this, a);
  }
  rotationTo(vectorA, vectorB) {
    quat.rotationTo(this, vectorA, vectorB);
    return this.check();
  }
  add(a) {
    quat.add(this, this, a);
    return this.check();
  }
  calculateW() {
    quat.calculateW(this, this);
    return this.check();
  }
  conjugate() {
    quat.conjugate(this, this);
    return this.check();
  }
  invert() {
    quat.invert(this, this);
    return this.check();
  }
  lerp(a, b, t) {
    if (t === undefined) {
      return this.lerp(this, a, b);
    }
    quat.lerp(this, a, b, t);
    return this.check();
  }
  multiplyRight(a) {
    quat.multiply(this, this, a);
    return this.check();
  }
  multiplyLeft(a) {
    quat.multiply(this, a, this);
    return this.check();
  }
  normalize() {
    const length = this.len();
    const l = length > 0 ? 1 / length : 0;
    this[0] = this[0] * l;
    this[1] = this[1] * l;
    this[2] = this[2] * l;
    this[3] = this[3] * l;
    if (length === 0) {
      this[3] = 1;
    }
    return this.check();
  }
  rotateX(rad) {
    quat.rotateX(this, this, rad);
    return this.check();
  }
  rotateY(rad) {
    quat.rotateY(this, this, rad);
    return this.check();
  }
  rotateZ(rad) {
    quat.rotateZ(this, this, rad);
    return this.check();
  }
  scale(b) {
    quat.scale(this, this, b);
    return this.check();
  }
  slerp(arg0, arg1, arg2) {
    let start;
    let target;
    let ratio;
    switch (arguments.length) {
      case 1:
        ({
          start = IDENTITY_QUATERNION,
          target,
          ratio
        } = arg0);
        break;
      case 2:
        start = this;
        target = arg0;
        ratio = arg1;
        break;
      default:
        start = arg0;
        target = arg1;
        ratio = arg2;
    }
    quat.slerp(this, start, target, ratio);
    return this.check();
  }
  transformVector4(vector, result = new _vector.default()) {
    vec4.transformQuat(result, vector, this);
    return (0, _validators.checkVector)(result, 4);
  }
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(axis, rad) {
    return this.setAxisAngle(axis, rad);
  }
  premultiply(a) {
    return this.multiplyLeft(a);
  }
  multiply(a) {
    return this.multiplyRight(a);
  }
}
exports.default = Quaternion;
},{"./base/math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","./vector4":"node_modules/@math.gl/core/dist/esm/classes/vector4.js","gl-matrix/quat":"node_modules/gl-matrix/esm/quat.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _vector = _interopRequireDefault(require("./vector3"));
var _common = require("../lib/common");
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EPSILON = 0.000001;
const EARTH_RADIUS_METERS = 6371000;
class SphericalCoordinates {
  constructor({
    phi = 0,
    theta = 0,
    radius = 1,
    bearing,
    pitch,
    altitude,
    radiusScale = EARTH_RADIUS_METERS
  } = {}) {
    (0, _defineProperty2.default)(this, "phi", void 0);
    (0, _defineProperty2.default)(this, "theta", void 0);
    (0, _defineProperty2.default)(this, "radius", void 0);
    (0, _defineProperty2.default)(this, "radiusScale", void 0);
    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;
    if (bearing !== undefined) {
      this.bearing = bearing;
    }
    if (pitch !== undefined) {
      this.pitch = pitch;
    }
    this.check();
  }
  toString() {
    return this.formatString(_common.config);
  }
  formatString({
    printTypes = false
  }) {
    const f = _common.formatValue;
    return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
  }
  equals(other) {
    return (0, _common.equals)(this.radius, other.radius) && (0, _common.equals)(this.theta, other.theta) && (0, _common.equals)(this.phi, other.phi);
  }
  exactEquals(other) {
    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
  }
  get bearing() {
    return 180 - (0, _common.degrees)(this.phi);
  }
  set bearing(v) {
    this.phi = Math.PI - (0, _common.radians)(v);
  }
  get pitch() {
    return (0, _common.degrees)(this.theta);
  }
  set pitch(v) {
    this.theta = (0, _common.radians)(v);
  }
  get longitude() {
    return (0, _common.degrees)(this.phi);
  }
  get latitude() {
    return (0, _common.degrees)(this.theta);
  }
  get lng() {
    return (0, _common.degrees)(this.phi);
  }
  get lat() {
    return (0, _common.degrees)(this.theta);
  }
  get z() {
    return (this.radius - 1) * this.radiusScale;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this.check();
  }
  clone() {
    return new SphericalCoordinates().copy(this);
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this.check();
  }
  fromLngLatZ([lng, lat, z]) {
    this.radius = 1 + z / this.radiusScale;
    this.phi = (0, _common.radians)(lat);
    this.theta = (0, _common.radians)(lng);
    return this.check();
  }
  fromVector3(v) {
    this.radius = vec3.length(v);
    if (this.radius > 0) {
      this.theta = Math.atan2(v[0], v[1]);
      this.phi = Math.acos((0, _common.clamp)(v[2] / this.radius, -1, 1));
    }
    return this.check();
  }
  toVector3() {
    return new _vector.default(0, 0, this.radius).rotateX({
      radians: this.theta
    }).rotateZ({
      radians: this.phi
    });
  }
  makeSafe() {
    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    return this;
  }
  check() {
    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
      throw new Error('SphericalCoordinates: some fields set to invalid numbers');
    }
    return this;
  }
}
exports.default = SphericalCoordinates;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/core/dist/esm/classes/euler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _mathArray = _interopRequireDefault(require("./base/math-array"));
var _quaternion = _interopRequireDefault(require("./quaternion"));
var _common = require("../lib/common");
var _validators = require("../lib/validators");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
const ALMOST_ONE = 0.99999;
var RotationOrder;
(function (RotationOrder) {
  RotationOrder[RotationOrder["ZYX"] = 0] = "ZYX";
  RotationOrder[RotationOrder["YXZ"] = 1] = "YXZ";
  RotationOrder[RotationOrder["XZY"] = 2] = "XZY";
  RotationOrder[RotationOrder["ZXY"] = 3] = "ZXY";
  RotationOrder[RotationOrder["YZX"] = 4] = "YZX";
  RotationOrder[RotationOrder["XYZ"] = 5] = "XYZ";
})(RotationOrder || (RotationOrder = {}));
class Euler extends _mathArray.default {
  static get ZYX() {
    return RotationOrder.ZYX;
  }
  static get YXZ() {
    return RotationOrder.YXZ;
  }
  static get XZY() {
    return RotationOrder.XZY;
  }
  static get ZXY() {
    return RotationOrder.ZXY;
  }
  static get YZX() {
    return RotationOrder.YZX;
  }
  static get XYZ() {
    return RotationOrder.XYZ;
  }
  static get RollPitchYaw() {
    return RotationOrder.ZYX;
  }
  static get DefaultOrder() {
    return RotationOrder.ZYX;
  }
  static get RotationOrders() {
    return RotationOrder;
  }
  static rotationOrder(order) {
    return RotationOrder[order];
  }
  get ELEMENTS() {
    return 4;
  }
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    super(-0, -0, -0, -0);
    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      this.fromVector3(...arguments);
    } else {
      this.set(x, y, z, order);
    }
  }
  fromQuaternion(quaternion) {
    const [x, y, z, w] = quaternion;
    const ysqr = y * y;
    const t0 = -2 * (ysqr + z * z) + 1;
    const t1 = +2 * (x * y + w * z);
    let t2 = -2 * (x * z - w * y);
    const t3 = +2 * (y * z + w * x);
    const t4 = -2 * (x * x + ysqr) + 1;
    t2 = t2 > 1 ? 1 : t2;
    t2 = t2 < -1 ? -1 : t2;
    const roll = Math.atan2(t3, t4);
    const pitch = Math.asin(t2);
    const yaw = Math.atan2(t1, t0);
    return this.set(roll, pitch, yaw, Euler.RollPitchYaw);
  }
  fromObject(object) {
    throw new Error('not implemented');
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = Number.isFinite(array[3]) || this.order;
    return this.check();
  }
  set(x = 0, y = 0, z = 0, order) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = Number.isFinite(order) ? order : this[3];
    return this.check();
  }
  validate() {
    return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
  }
  toArray(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    return array;
  }
  toArray4(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    array[offset + 3] = this[3];
    return array;
  }
  toVector3(result = [-0, -0, -0]) {
    result[0] = this[0];
    result[1] = this[1];
    result[2] = this[2];
    return result;
  }
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get alpha() {
    return this[0];
  }
  set alpha(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get beta() {
    return this[1];
  }
  set beta(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get gamma() {
    return this[2];
  }
  set gamma(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get phi() {
    return this[0];
  }
  set phi(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get theta() {
    return this[1];
  }
  set theta(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get psi() {
    return this[2];
  }
  set psi(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get roll() {
    return this[0];
  }
  set roll(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }
  get pitch() {
    return this[1];
  }
  set pitch(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }
  get yaw() {
    return this[2];
  }
  set yaw(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }
  get order() {
    return this[3];
  }
  set order(value) {
    this[3] = checkOrder(value);
  }
  fromVector3(v, order) {
    return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
  }
  fromArray(array, offset = 0) {
    this[0] = array[0 + offset];
    this[1] = array[1 + offset];
    this[2] = array[2 + offset];
    if (array[3] !== undefined) {
      this[3] = array[3];
    }
    return this.check();
  }
  fromRollPitchYaw(roll, pitch, yaw) {
    return this.set(roll, pitch, yaw, RotationOrder.ZYX);
  }
  fromRotationMatrix(m, order = Euler.DefaultOrder) {
    this._fromRotationMatrix(m, order);
    return this.check();
  }
  getRotationMatrix(m) {
    return this._getRotationMatrix(m);
  }
  getQuaternion() {
    const q = new _quaternion.default();
    switch (this[4]) {
      case RotationOrder.XYZ:
        return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);
      case RotationOrder.YXZ:
        return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);
      case RotationOrder.ZXY:
        return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);
      case RotationOrder.ZYX:
        return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);
      case RotationOrder.YZX:
        return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);
      case RotationOrder.XZY:
        return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);
      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
  }
  _fromRotationMatrix(m, order = Euler.DefaultOrder) {
    const m11 = m[0],
      m12 = m[4],
      m13 = m[8];
    const m21 = m[1],
      m22 = m[5],
      m23 = m[9];
    const m31 = m[2],
      m32 = m[6],
      m33 = m[10];
    order = order || this[3];
    switch (order) {
      case Euler.XYZ:
        this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));
        if (Math.abs(m13) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m33);
          this[2] = Math.atan2(-m12, m11);
        } else {
          this[0] = Math.atan2(m32, m22);
          this[2] = 0;
        }
        break;
      case Euler.YXZ:
        this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));
        if (Math.abs(m23) < ALMOST_ONE) {
          this[1] = Math.atan2(m13, m33);
          this[2] = Math.atan2(m21, m22);
        } else {
          this[1] = Math.atan2(-m31, m11);
          this[2] = 0;
        }
        break;
      case Euler.ZXY:
        this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));
        if (Math.abs(m32) < ALMOST_ONE) {
          this[1] = Math.atan2(-m31, m33);
          this[2] = Math.atan2(-m12, m22);
        } else {
          this[1] = 0;
          this[2] = Math.atan2(m21, m11);
        }
        break;
      case Euler.ZYX:
        this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));
        if (Math.abs(m31) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m33);
          this[2] = Math.atan2(m21, m11);
        } else {
          this[0] = 0;
          this[2] = Math.atan2(-m12, m22);
        }
        break;
      case Euler.YZX:
        this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));
        if (Math.abs(m21) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m22);
          this[1] = Math.atan2(-m31, m11);
        } else {
          this[0] = 0;
          this[1] = Math.atan2(m13, m33);
        }
        break;
      case Euler.XZY:
        this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));
        if (Math.abs(m12) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m22);
          this[1] = Math.atan2(m13, m11);
        } else {
          this[0] = Math.atan2(-m23, m33);
          this[1] = 0;
        }
        break;
      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
    this[3] = order;
    return this;
  }
  _getRotationMatrix(result) {
    const te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    const x = this.x,
      y = this.y,
      z = this.z;
    const a = Math.cos(x);
    const c = Math.cos(y);
    const e = Math.cos(z);
    const b = Math.sin(x);
    const d = Math.sin(y);
    const f = Math.sin(z);
    switch (this[3]) {
      case Euler.XYZ:
        {
          const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
          break;
        }
      case Euler.YXZ:
        {
          const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
          break;
        }
      case Euler.ZXY:
        {
          const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
          break;
        }
      case Euler.ZYX:
        {
          const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
          break;
        }
      case Euler.YZX:
        {
          const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
          break;
        }
      case Euler.XZY:
        {
          const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
          break;
        }
      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return te;
  }
  toQuaternion() {
    const cy = Math.cos(this.yaw * 0.5);
    const sy = Math.sin(this.yaw * 0.5);
    const cr = Math.cos(this.roll * 0.5);
    const sr = Math.sin(this.roll * 0.5);
    const cp = Math.cos(this.pitch * 0.5);
    const sp = Math.sin(this.pitch * 0.5);
    const w = cy * cr * cp + sy * sr * sp;
    const x = cy * sr * cp - sy * cr * sp;
    const y = cy * cr * sp + sy * sr * cp;
    const z = sy * cr * cp - cy * sr * sp;
    return new _quaternion.default(x, y, z, w);
  }
}
exports.default = Euler;
function validateOrder(value) {
  return value >= 0 && value < 6;
}
function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }
  return value;
}
},{"./base/math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","./quaternion":"node_modules/@math.gl/core/dist/esm/classes/quaternion.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js"}],"node_modules/@math.gl/core/dist/esm/classes/pose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _matrix = _interopRequireDefault(require("./matrix4"));
var _vector = _interopRequireDefault(require("./vector3"));
var _euler = _interopRequireDefault(require("./euler"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Pose {
  constructor({
    x = 0,
    y = 0,
    z = 0,
    roll = 0,
    pitch = 0,
    yaw = 0,
    position,
    orientation
  } = {}) {
    (0, _defineProperty2.default)(this, "position", void 0);
    (0, _defineProperty2.default)(this, "orientation", void 0);
    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector.default(position);
    } else {
      this.position = new _vector.default(x, y, z);
    }
    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler.default(orientation, orientation[3]);
    } else {
      this.orientation = new _euler.default(roll, pitch, yaw, _euler.default.RollPitchYaw);
    }
  }
  get x() {
    return this.position.x;
  }
  set x(value) {
    this.position.x = value;
  }
  get y() {
    return this.position.y;
  }
  set y(value) {
    this.position.y = value;
  }
  get z() {
    return this.position.z;
  }
  set z(value) {
    this.position.z = value;
  }
  get roll() {
    return this.orientation.roll;
  }
  set roll(value) {
    this.orientation.roll = value;
  }
  get pitch() {
    return this.orientation.pitch;
  }
  set pitch(value) {
    this.orientation.pitch = value;
  }
  get yaw() {
    return this.orientation.yaw;
  }
  set yaw(value) {
    this.orientation.yaw = value;
  }
  getPosition() {
    return this.position;
  }
  getOrientation() {
    return this.orientation;
  }
  equals(pose) {
    if (!pose) {
      return false;
    }
    return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
  }
  exactEquals(pose) {
    if (!pose) {
      return false;
    }
    return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
  }
  getTransformationMatrix() {
    const sr = Math.sin(this.roll);
    const sp = Math.sin(this.pitch);
    const sw = Math.sin(this.yaw);
    const cr = Math.cos(this.roll);
    const cp = Math.cos(this.pitch);
    const cw = Math.cos(this.yaw);
    return new _matrix.default().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
  }
  getTransformationMatrixFromPose(pose) {
    return new _matrix.default().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
  }
  getTransformationMatrixToPose(pose) {
    return new _matrix.default().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
  }
}
exports.default = Pose;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./matrix4":"node_modules/@math.gl/core/dist/esm/classes/matrix4.js","./vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","./euler":"node_modules/@math.gl/core/dist/esm/classes/euler.js"}],"node_modules/@math.gl/core/dist/esm/lib/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  EPSILON1: 1e-1,
  EPSILON2: 1e-2,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
};
exports.default = _default;
},{}],"node_modules/@math.gl/core/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "Matrix3", {
  enumerable: true,
  get: function () {
    return _matrix.default;
  }
});
Object.defineProperty(exports, "Matrix4", {
  enumerable: true,
  get: function () {
    return _matrix2.default;
  }
});
Object.defineProperty(exports, "Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "Quaternion", {
  enumerable: true,
  get: function () {
    return _quaternion.default;
  }
});
Object.defineProperty(exports, "SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "Vector2", {
  enumerable: true,
  get: function () {
    return _vector.default;
  }
});
Object.defineProperty(exports, "Vector3", {
  enumerable: true,
  get: function () {
    return _vector2.default;
  }
});
Object.defineProperty(exports, "Vector4", {
  enumerable: true,
  get: function () {
    return _vector3.default;
  }
});
Object.defineProperty(exports, "_Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "_MathUtils", {
  enumerable: true,
  get: function () {
    return _mathUtils.default;
  }
});
Object.defineProperty(exports, "_Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "_SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "acos", {
  enumerable: true,
  get: function () {
    return _common.acos;
  }
});
Object.defineProperty(exports, "asin", {
  enumerable: true,
  get: function () {
    return _common.asin;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "atan", {
  enumerable: true,
  get: function () {
    return _common.atan;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function () {
    return _common.clamp;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _common.clone;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () {
    return _common.config;
  }
});
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function () {
    return _common.configure;
  }
});
Object.defineProperty(exports, "cos", {
  enumerable: true,
  get: function () {
    return _common.cos;
  }
});
Object.defineProperty(exports, "degrees", {
  enumerable: true,
  get: function () {
    return _common.degrees;
  }
});
Object.defineProperty(exports, "equals", {
  enumerable: true,
  get: function () {
    return _common.equals;
  }
});
Object.defineProperty(exports, "exactEquals", {
  enumerable: true,
  get: function () {
    return _common.exactEquals;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function () {
    return _common.formatValue;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function () {
    return _common.isArray;
  }
});
Object.defineProperty(exports, "lerp", {
  enumerable: true,
  get: function () {
    return _common.lerp;
  }
});
Object.defineProperty(exports, "radians", {
  enumerable: true,
  get: function () {
    return _common.radians;
  }
});
Object.defineProperty(exports, "sin", {
  enumerable: true,
  get: function () {
    return _common.sin;
  }
});
Object.defineProperty(exports, "tan", {
  enumerable: true,
  get: function () {
    return _common.tan;
  }
});
Object.defineProperty(exports, "toDegrees", {
  enumerable: true,
  get: function () {
    return _common.toDegrees;
  }
});
Object.defineProperty(exports, "toRadians", {
  enumerable: true,
  get: function () {
    return _common.toRadians;
  }
});
Object.defineProperty(exports, "withEpsilon", {
  enumerable: true,
  get: function () {
    return _common.withEpsilon;
  }
});
var _vector = _interopRequireDefault(require("./classes/vector2"));
var _vector2 = _interopRequireDefault(require("./classes/vector3"));
var _vector3 = _interopRequireDefault(require("./classes/vector4"));
var _matrix = _interopRequireDefault(require("./classes/matrix3"));
var _matrix2 = _interopRequireDefault(require("./classes/matrix4"));
var _quaternion = _interopRequireDefault(require("./classes/quaternion"));
var _sphericalCoordinates = _interopRequireDefault(require("./classes/spherical-coordinates"));
var _pose = _interopRequireDefault(require("./classes/pose"));
var _euler = _interopRequireDefault(require("./classes/euler"));
var _mathUtils = _interopRequireDefault(require("./lib/math-utils"));
var _assert = _interopRequireDefault(require("./lib/assert"));
var _common = require("./lib/common");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./classes/vector2":"node_modules/@math.gl/core/dist/esm/classes/vector2.js","./classes/vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","./classes/vector4":"node_modules/@math.gl/core/dist/esm/classes/vector4.js","./classes/matrix3":"node_modules/@math.gl/core/dist/esm/classes/matrix3.js","./classes/matrix4":"node_modules/@math.gl/core/dist/esm/classes/matrix4.js","./classes/quaternion":"node_modules/@math.gl/core/dist/esm/classes/quaternion.js","./classes/spherical-coordinates":"node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js","./classes/pose":"node_modules/@math.gl/core/dist/esm/classes/pose.js","./classes/euler":"node_modules/@math.gl/core/dist/esm/classes/euler.js","./lib/math-utils":"node_modules/@math.gl/core/dist/esm/lib/math-utils.js","./lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js","./lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.project = void 0;
var _core = require("@math.gl/core");
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  let prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const uniforms = {};
  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }
  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }
  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }
  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }
  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new _core.Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }
  return uniforms;
}
const common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
const vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
const fs = "\n".concat(common);
const project = {
  name: 'project',
  getUniforms,
  vs,
  fs
};
exports.project = project;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lights = void 0;
var _lights = _interopRequireDefault(require("./lights.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_MODULE_OPTIONS = {
  lightSources: {}
};
function convertColor() {
  let {
    color = [0, 0, 0],
    intensity = 1.0
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return color.map(component => component * intensity / 255.0);
}
function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};
  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }
  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if ('lightSources' in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }
    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }
  if ('lights' in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };
    for (const light of opts.lights || []) {
      switch (light.type) {
        case 'ambient':
          lightSources.ambientLight = light;
          break;
        case 'directional':
          lightSources.directionalLights.push(light);
          break;
        case 'point':
          lightSources.pointLights.push(light);
          break;
        default:
      }
    }
    return getUniforms({
      lightSources
    });
  }
  return {};
}
const lights = {
  name: 'lights',
  vs: _lights.default,
  fs: _lights.default,
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};
exports.lights = lights;
},{"./lights.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirlight = void 0;
var _project = require("../project/project");
const DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
const DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  const uniforms = {};
  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }
  return uniforms;
}
const vs = null;
const fs = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
const dirlight = {
  name: 'dirlight',
  vs,
  fs,
  getUniforms,
  dependencies: [_project.project]
};
exports.dirlight = dirlight;
},{"../project/project":"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.picking = void 0;
const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
const DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingActive: false,
  pickingAttribute: false
};
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  const uniforms = {};
  if (opts.pickingSelectedColor !== undefined) {
    if (!opts.pickingSelectedColor) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, x => x / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms.picking_uHighlightColor = color;
  }
  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = Boolean(opts.pickingActive);
    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
  }
  return uniforms;
}
const vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
const fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
const picking = {
  name: 'picking',
  vs,
  fs,
  getUniforms
};
exports.picking = picking;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phongLighting = exports.gouraudLighting = void 0;
var _lights = require("../lights/lights");
var _phongLighting = _interopRequireDefault(require("./phong-lighting.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_MODULE_OPTIONS = {};
function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map(x => x / 255)
  };
}
function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if (!('material' in opts)) {
    return {};
  }
  const {
    material
  } = opts;
  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }
  return getMaterialUniforms(material);
}
const gouraudLighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights.lights],
  vs: _phongLighting.default,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms
};
exports.gouraudLighting = gouraudLighting;
const phongLighting = {
  name: 'phong-lighting',
  dependencies: [_lights.lights],
  fs: _phongLighting.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms
};
exports.phongLighting = phongLighting;
},{"../lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./phong-lighting.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pbr = void 0;
var _lights = require("../lights/lights");
var _pbrVertex = _interopRequireDefault(require("./pbr-vertex.glsl"));
var _pbrFragment = _interopRequireDefault(require("./pbr-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const pbr = {
  name: 'pbr',
  vs: _pbrVertex.default,
  fs: _pbrFragment.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_lights.lights]
};
exports.pbr = pbr;
},{"../lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./pbr-vertex.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js","./pbr-fragment.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tiltShift = void 0;
var _random = require("../utils/random");
const fs = "uniform float blurRadius;\nuniform float gradientRadius;\nuniform vec2 start;\nuniform vec2 end;\nuniform bool invert;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((end - start) * texSize);\n  return invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((start.y - end.y) * texSize.y, (end.x - start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - start * texSize, normal)) / gradientRadius) * blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  blurRadius: {
    value: 15,
    min: 0,
    max: 50
  },
  gradientRadius: {
    value: 200,
    min: 0,
    max: 400
  },
  start: [0, 0],
  end: [1, 1],
  invert: {
    value: false,
    private: true
  }
};
const tiltShift = {
  name: 'tiltShift',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true,
    uniforms: {
      invert: false
    }
  }, {
    sampler: true,
    uniforms: {
      invert: true
    }
  }]
};
exports.tiltShift = tiltShift;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.triangleBlur = void 0;
var _random = require("../utils/random");
const fs = "uniform float radius;\nuniform vec2 delta;\n\nvec4 triangleBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = delta * radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 sample = texture2D(texture, texCoord + adjustedDelta * percent);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  radius: {
    value: 20,
    min: 0,
    softMax: 100
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const triangleBlur = {
  name: 'triangleBlur',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true,
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: true,
    uniforms: {
      delta: [0, 1]
    }
  }]
};
exports.triangleBlur = triangleBlur;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomBlur = void 0;
var _random = require("../utils/random");
const fs = "\nuniform vec2 center;\nuniform float strength;\n\nvec4 zoomBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = center * texSize - texCoord * texSize;\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);\n    sample.rgb *= sample.a;\n\n    color += sample * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  strength: {
    value: 0.3,
    min: 0,
    softMax: 1
  }
};
const zoomBlur = {
  name: 'zoomBlur',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true
  }]
};
exports.zoomBlur = zoomBlur;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brightnessContrast = void 0;
const fs = "uniform float brightness;\nuniform float contrast;\n\nvec4 brightnessContrast_filterColor(vec4 color) {\n  color.rgb += brightness;\n  if (contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\n  }\n  return color;\n}\n\nvec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {\n  return brightnessContrast_filterColor(color);\n}\n";
const uniforms = {
  brightness: {
    value: 0,
    min: -1,
    max: 1
  },
  contrast: {
    value: 0,
    min: -1,
    max: 1
  }
};
const brightnessContrast = {
  name: 'brightnessContrast',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.brightnessContrast = brightnessContrast;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.denoise = void 0;
const fs = "uniform float strength;\n\nvec4 denoise_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  float adjustedExponent = 3. + 200. * pow(1. - strength, 4.);\n\n  vec4 center = texture2D(texture, texCoord);\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float x = -4.0; x <= 4.0; x += 1.0) {\n    for (float y = -4.0; y <= 4.0; y += 1.0) {\n      vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);\n      float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));\n      weight = pow(weight, adjustedExponent);\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  return color / total;\n}\n";
const uniforms = {
  strength: {
    value: 0.5,
    min: 0,
    max: 0.1,
    adjust: strength => 0.53 + 200 * Math.pow(1 - strength, 4)
  }
};
const denoise = {
  name: 'denoise',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }, {
    sampler: true
  }]
};
exports.denoise = denoise;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hueSaturation = void 0;
const fs = "uniform float hue;\nuniform float saturation;\n\nvec4 hueSaturation_filterColor(vec4 color) {\n  float angle = hue * 3.14159265;\n  float s = sin(angle), c = cos(angle);\n  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n  float len = length(color.rgb);\n  color.rgb = vec3(\n    dot(color.rgb, weights.xyz),\n    dot(color.rgb, weights.zxy),\n    dot(color.rgb, weights.yzx)\n  );\n  float average = (color.r + color.g + color.b) / 3.0;\n  if (saturation > 0.0) {\n    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\n  } else {\n    color.rgb += (average - color.rgb) * (-saturation);\n  }\n\n  return color;\n}\n\nvec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return hueSaturation_filterColor(color);\n}\n";
const uniforms = {
  hue: {
    value: 0,
    min: -1,
    max: 1
  },
  saturation: {
    value: 0,
    min: -1,
    max: 1
  }
};
const hueSaturation = {
  name: 'hueSaturation',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.hueSaturation = hueSaturation;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noise = void 0;
const fs = "uniform float amount;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n\nvec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return noise_filterColor(color, texCoord);\n}\n";
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const noise = {
  name: 'noise',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.noise = noise;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sepia = void 0;
const fs = "uniform float amount;\n\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));\n  color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));\n  color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n";
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const sepia = {
  name: 'sepia',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.sepia = sepia;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vibrance = void 0;
const fs = "uniform float amount;\n\nvec4 vibrance_filterColor(vec4 color) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  float mx = max(color.r, max(color.g, color.b));\n  float amt = (mx - average) * (-amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n";
const uniforms = {
  amount: {
    value: 0,
    min: -1,
    max: 1
  }
};
const vibrance = {
  name: 'vibrance',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.vibrance = vibrance;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vignette = void 0;
const fs = "uniform float radius;\nuniform float amount;\n\nvec4 vignette_filterColor(vec4 color, vec2 texCoord) {\n  float dist = distance(texCoord, vec2(0.5, 0.5));\n  float ratio = smoothstep(0.8, radius * 0.799, dist * (amount + radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vignette_filterColor(color, texCoord);\n}\n";
const uniforms = {
  radius: {
    value: 0.5,
    min: 0,
    max: 1
  },
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const vignette = {
  name: 'vignette',
  fs,
  uniforms,
  passes: [{
    filter: true
  }]
};
exports.vignette = vignette;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colorHalftone = void 0;
const fs = "uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat scale = 3.1514 / size;\n\nfloat pattern(float angle, vec2 texSize, vec2 texCoord) {\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n\tc * tex.x - s * tex.y,\n\ts * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\tcmy * 10.0 - 3.0 + vec3(\n    pattern(angle + 0.26179, texSize, texCoord),\n\t  pattern(angle + 1.30899, texSize, texCoord),\n    pattern(angle, texSize, texCoord)\n  ),\n\t0.0,\n\t1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 4,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const colorHalftone = {
  name: 'colorHalftone',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.colorHalftone = colorHalftone;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dotScreen = void 0;
const fs = "uniform vec2 center;\nuniform float angle;\nuniform float size;\n\nfloat pattern(vec2 texSize, vec2 texCoord) {\n  float scale = 3.1415 / size;\n\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 3,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const dotScreen = {
  name: 'dotScreen',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.dotScreen = dotScreen;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.edgeWork = void 0;
var _random = require("../utils/random");
const fs = "uniform float radius;\nuniform vec2 delta;\n\nvec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture2D(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n\nvec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 relativeDelta = radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec2 sampleColor = texture2D(source, texCoord + relativeDelta * percent).xy;\n    color.x += sampleColor.x * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += sampleColor.y * weight;\n      total.y += weight;\n    }\n  }\n  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\n  return vec4(c, c, c, 1.0);\n}\n";
const uniforms = {
  radius: {
    value: 2,
    min: 1,
    softMax: 50
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const edgeWork = {
  name: 'edgeWork',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: 'edgeWork_sampleColor1',
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: 'edgeWork_sampleColor2',
    uniforms: {
      delta: [0, 1]
    }
  }]
};
exports.edgeWork = edgeWork;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hexagonalPixelate = void 0;
const fs = "uniform vec2 center;\nuniform float scale;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - center * texSize) / scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= scale / texSize;\n\n  return texture2D(texture, choice + center);\n}\n";
const uniforms = {
  center: {
    value: [0.5, 0.5],
    hint: 'screenspace'
  },
  scale: {
    value: 10,
    min: 1,
    softMin: 5,
    softMax: 50
  }
};
const hexagonalPixelate = {
  name: 'hexagonalPixelate',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.hexagonalPixelate = hexagonalPixelate;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ink = void 0;
const fs = "uniform float strength;\n\nvec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture2D(texture, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\n      bigAverage += sample;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += sample;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = strength * strength * strength * strength * strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n";
const uniforms = {
  strength: {
    value: 0.25,
    min: 0,
    softMax: 1
  }
};
const ink = {
  name: 'ink',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.ink = ink;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.magnify = void 0;
const fs = "uniform vec2 screenXY;\nuniform float radiusPixels;\nuniform float zoom;\nuniform float borderWidthPixels;\nuniform vec4 borderColor;\n\nvec4 magnify_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 pos = vec2(screenXY.x, 1.0 - screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < radiusPixels) {\n    return texture2D(texture, (texCoord - pos) / zoom + pos);\n  }\n\n  if (dist <= radiusPixels + borderWidthPixels) {\n    return borderColor;\n  }\n  return texture2D(texture, texCoord);\n}\n";
const uniforms = {
  screenXY: [0, 0],
  radiusPixels: 200,
  zoom: 2.0,
  borderWidthPixels: 0.0,
  borderColor: [255, 255, 255, 255]
};
const magnify = {
  name: 'magnify',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.magnify = magnify;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warp = void 0;
const fs = "vec4 warp_sampleColor(sampler2D texture, vec2 texSize, vec2 coord) {\n  vec4 color = texture2D(texture, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n\n  return color;\n}\n";
const warp = {
  name: 'warp',
  fs
};
exports.warp = warp;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bulgePinch = void 0;
var _warp = require("./warp");
const fs = "uniform float radius;\nuniform float strength;\nuniform vec2 center;\n\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = distance / radius;\n    if (strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 bulgePinch_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  strength: {
    value: 0.5,
    min: -1,
    max: 1
  }
};
const bulgePinch = {
  name: 'bulgePinch',
  fs,
  uniforms,
  dependencies: [_warp.warp],
  passes: [{
    sampler: true
  }]
};
exports.bulgePinch = bulgePinch;
},{"./warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.swirl = void 0;
var _warp = require("./warp");
const fs = "uniform float radius;\nuniform float angle;\nuniform vec2 center;\n\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < radius) {\n    float percent = (radius - distance) / radius;\n    float theta = percent * percent * angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 swirl_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, center * texSize);\n\n  return warp_sampleColor(texture, texSize, coord);\n}\n";
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  angle: {
    value: 3,
    softMin: -25,
    softMax: 25
  }
};
const swirl = {
  name: 'swirl',
  fs,
  uniforms,
  dependencies: [_warp.warp],
  passes: [{
    sampler: true
  }]
};
exports.swirl = swirl;
},{"./warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fxaa = void 0;
/**
 * ORIGINAL LICENCE
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
const fs = "\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture2D(t, p)\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n\n\n    FxaaFloat2 pos,\n\n\n\n\n    FxaaTex tex,\n\n\n\n\n    FxaaFloat2 fxaaQualityRcpFrame,\n\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualitySubpix,\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualityEdgeThreshold,\n\n\n\n\n\n\n\n\n\n\n\n\n\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n    if(earlyExit)\n        return rgbyM;\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    #endif\n                        }\n                        #endif\n                    }\n                    #endif\n                }\n                #endif\n            }\n            #endif\n        }\n        #endif\n    }\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        texture,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n";
const fxaa = {
  name: 'fxaa',
  uniforms: {},
  fs,
  passes: [{
    sampler: true
  }]
};
exports.fxaa = fxaa;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = void 0;
const vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const transform = {
  name: 'transform',
  vs,
  fs: null
};
exports.transform = transform;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function () {
    return _transform.transform;
  }
});
Object.defineProperty(exports, "_warp", {
  enumerable: true,
  get: function () {
    return _warp.warp;
  }
});
Object.defineProperty(exports, "brightnessContrast", {
  enumerable: true,
  get: function () {
    return _brightnesscontrast.brightnessContrast;
  }
});
Object.defineProperty(exports, "bulgePinch", {
  enumerable: true,
  get: function () {
    return _bulgepinch.bulgePinch;
  }
});
Object.defineProperty(exports, "colorHalftone", {
  enumerable: true,
  get: function () {
    return _colorhalftone.colorHalftone;
  }
});
Object.defineProperty(exports, "denoise", {
  enumerable: true,
  get: function () {
    return _denoise.denoise;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _dirlight.dirlight;
  }
});
Object.defineProperty(exports, "dotScreen", {
  enumerable: true,
  get: function () {
    return _dotscreen.dotScreen;
  }
});
Object.defineProperty(exports, "edgeWork", {
  enumerable: true,
  get: function () {
    return _edgework.edgeWork;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _fp.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _fp2.fp64;
  }
});
Object.defineProperty(exports, "fp64arithmetic", {
  enumerable: true,
  get: function () {
    return _fp2.fp64arithmetic;
  }
});
Object.defineProperty(exports, "fxaa", {
  enumerable: true,
  get: function () {
    return _fxaa.fxaa;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.gouraudLighting;
  }
});
Object.defineProperty(exports, "hexagonalPixelate", {
  enumerable: true,
  get: function () {
    return _hexagonalpixelate.hexagonalPixelate;
  }
});
Object.defineProperty(exports, "hueSaturation", {
  enumerable: true,
  get: function () {
    return _huesaturation.hueSaturation;
  }
});
Object.defineProperty(exports, "ink", {
  enumerable: true,
  get: function () {
    return _ink.ink;
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function () {
    return _lights.lights;
  }
});
Object.defineProperty(exports, "magnify", {
  enumerable: true,
  get: function () {
    return _magnify.magnify;
  }
});
Object.defineProperty(exports, "noise", {
  enumerable: true,
  get: function () {
    return _noise.noise;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _pbr.pbr;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.project;
  }
});
Object.defineProperty(exports, "random", {
  enumerable: true,
  get: function () {
    return _random.random;
  }
});
Object.defineProperty(exports, "sepia", {
  enumerable: true,
  get: function () {
    return _sepia.sepia;
  }
});
Object.defineProperty(exports, "swirl", {
  enumerable: true,
  get: function () {
    return _swirl.swirl;
  }
});
Object.defineProperty(exports, "tiltShift", {
  enumerable: true,
  get: function () {
    return _tiltshift.tiltShift;
  }
});
Object.defineProperty(exports, "triangleBlur", {
  enumerable: true,
  get: function () {
    return _triangleblur.triangleBlur;
  }
});
Object.defineProperty(exports, "vibrance", {
  enumerable: true,
  get: function () {
    return _vibrance.vibrance;
  }
});
Object.defineProperty(exports, "vignette", {
  enumerable: true,
  get: function () {
    return _vignette.vignette;
  }
});
Object.defineProperty(exports, "zoomBlur", {
  enumerable: true,
  get: function () {
    return _zoomblur.zoomBlur;
  }
});
var _random = require("./utils/random");
var _fp = require("./fp32/fp32");
var _fp2 = require("./fp64/fp64");
var _project = require("./project/project");
var _lights = require("./lights/lights");
var _dirlight = require("./dirlight/dirlight");
var _picking = require("./picking/picking");
var _phongLighting = require("./phong-lighting/phong-lighting");
var _pbr = require("./pbr/pbr");
var _tiltshift = require("./image-blur-filters/tiltshift");
var _triangleblur = require("./image-blur-filters/triangleblur");
var _zoomblur = require("./image-blur-filters/zoomblur");
var _brightnesscontrast = require("./image-adjust-filters/brightnesscontrast");
var _denoise = require("./image-adjust-filters/denoise");
var _huesaturation = require("./image-adjust-filters/huesaturation");
var _noise = require("./image-adjust-filters/noise");
var _sepia = require("./image-adjust-filters/sepia");
var _vibrance = require("./image-adjust-filters/vibrance");
var _vignette = require("./image-adjust-filters/vignette");
var _colorhalftone = require("./image-fun-filters/colorhalftone");
var _dotscreen = require("./image-fun-filters/dotscreen");
var _edgework = require("./image-fun-filters/edgework");
var _hexagonalpixelate = require("./image-fun-filters/hexagonalpixelate");
var _ink = require("./image-fun-filters/ink");
var _magnify = require("./image-fun-filters/magnify");
var _bulgepinch = require("./image-warp-filters/bulgepinch");
var _swirl = require("./image-warp-filters/swirl");
var _warp = require("./image-warp-filters/warp");
var _fxaa = require("./fxaa/fxaa");
var _transform = require("./transform/transform");
},{"./utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js","./fp32/fp32":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js","./fp64/fp64":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js","./project/project":"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js","./lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./dirlight/dirlight":"node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js","./picking/picking":"node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js","./phong-lighting/phong-lighting":"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","./pbr/pbr":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js","./image-blur-filters/tiltshift":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js","./image-blur-filters/triangleblur":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js","./image-blur-filters/zoomblur":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js","./image-adjust-filters/brightnesscontrast":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js","./image-adjust-filters/denoise":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js","./image-adjust-filters/huesaturation":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js","./image-adjust-filters/noise":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js","./image-adjust-filters/sepia":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js","./image-adjust-filters/vibrance":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js","./image-adjust-filters/vignette":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js","./image-fun-filters/colorhalftone":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js","./image-fun-filters/dotscreen":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js","./image-fun-filters/edgework":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js","./image-fun-filters/hexagonalpixelate":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js","./image-fun-filters/ink":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js","./image-fun-filters/magnify":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js","./image-warp-filters/bulgepinch":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js","./image-warp-filters/swirl":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js","./image-warp-filters/warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js","./fxaa/fxaa":"node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js","./transform/transform":"node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js"}],"node_modules/@luma.gl/shadertools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  assembleShaders: true,
  combineInjects: true,
  normalizeShaderModule: true,
  getQualifierDetails: true,
  getPassthroughFS: true,
  typeToChannelSuffix: true,
  typeToChannelCount: true,
  convertToVec4: true
};
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function () {
    return _assembleShaders.assembleShaders;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function () {
    return _injectShader.combineInjects;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function () {
    return _shaderUtils.convertToVec4;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getPassthroughFS;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getQualifierDetails;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shaderModule.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelCount;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelSuffix;
  }
});
var _assembleShaders = require("./lib/assemble-shaders");
var _injectShader = require("./lib/inject-shader");
var _shaderModule = require("./lib/shader-module");
var _shaderUtils = require("./utils/shader-utils");
var _modules = require("./modules");
Object.keys(_modules).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _modules[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modules[key];
    }
  });
});
},{"./lib/assemble-shaders":"node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js","./lib/inject-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./lib/shader-module":"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","./utils/shader-utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js","./modules":"node_modules/@luma.gl/shadertools/dist/esm/modules/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _shadertools = require("@luma.gl/shadertools");
var _webgl = require("@luma.gl/webgl");
class ProgramManager {
  static getDefaultProgramManager(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
    return gl.luma.defaultProgramManager;
  }
  constructor(gl) {
    this.gl = gl;
    this._programCache = {};
    this._getUniforms = {};
    this._registeredModules = {};
    this._hookFunctions = [];
    this._defaultModules = [];
    this._hashes = {};
    this._hashCounter = 0;
    this.stateHash = 0;
    this._useCounts = {};
  }
  addDefaultModule(module) {
    if (!this._defaultModules.find(m => m.name === module.name)) {
      this._defaultModules.push(module);
    }
    this.stateHash++;
  }
  removeDefaultModule(module) {
    const moduleName = typeof module === 'string' ? module : module.name;
    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);
    this.stateHash++;
  }
  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, {
        hook
      });
    }
    this._hookFunctions.push(hook);
    this.stateHash++;
  }
  get() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      vs = '',
      fs = '',
      defines = {},
      inject = {},
      varyings = [],
      bufferMode = 0x8c8d,
      transpileToGLSL100 = false
    } = props;
    const modules = this._getModuleList(props.modules);
    const vsHash = this._getHash(vs);
    const fsHash = this._getHash(fs);
    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();
    const varyingHashes = varyings.map(v => this._getHash(v));
    const defineKeys = Object.keys(defines).sort();
    const injectKeys = Object.keys(inject).sort();
    const defineHashes = [];
    const injectHashes = [];
    for (const key of defineKeys) {
      defineHashes.push(this._getHash(key));
      defineHashes.push(this._getHash(defines[key]));
    }
    for (const key of injectKeys) {
      injectHashes.push(this._getHash(key));
      injectHashes.push(this._getHash(inject[key]));
    }
    const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join('/'), "M").concat(moduleHashes.join('/'), "I").concat(injectHashes.join('/'), "V").concat(varyingHashes.join('/'), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? 'T' : '');
    if (!this._programCache[hash]) {
      const assembled = (0, _shadertools.assembleShaders)(this.gl, {
        vs,
        fs,
        modules,
        inject,
        defines,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100
      });
      this._programCache[hash] = new _webgl.Program(this.gl, {
        hash,
        vs: assembled.vs,
        fs: assembled.fs,
        varyings,
        bufferMode
      });
      this._getUniforms[hash] = assembled.getUniforms || (x => {});
      this._useCounts[hash] = 0;
    }
    this._useCounts[hash]++;
    return this._programCache[hash];
  }
  getUniforms(program) {
    return this._getUniforms[program.hash] || null;
  }
  release(program) {
    const hash = program.hash;
    this._useCounts[hash]--;
    if (this._useCounts[hash] === 0) {
      this._programCache[hash].delete();
      delete this._programCache[hash];
      delete this._getUniforms[hash];
      delete this._useCounts[hash];
    }
  }
  _getHash(key) {
    if (this._hashes[key] === undefined) {
      this._hashes[key] = this._hashCounter++;
    }
    return this._hashes[key];
  }
  _getModuleList() {
    let appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count = 0;
    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name = module.name;
      modules[count++] = module;
      seen[name] = true;
    }
    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name = module.name;
      if (!seen[name]) {
        modules[count++] = module;
        seen[name] = true;
      }
    }
    modules.length = count;
    return modules;
  }
}
exports.default = ProgramManager;
},{"@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuffersFromGeometry = getBuffersFromGeometry;
exports.inferAttributeAccessor = inferAttributeAccessor;
var _webgl = require("@luma.gl/webgl");
const GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};
function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;
  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);
    if (name === 'indices') {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = {
        ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new _webgl.Buffer(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }
  if (indices) {
    const data = indices.value || indices;
    (0, _webgl.assert)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
    };
    buffers.indices = [new _webgl.Buffer(gl, {
      data,
      target: 34963
    }), accessor];
  }
  return buffers;
}
function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}
function inferAttributeAccessor(attributeName, attribute) {
  let category;
  switch (attributeName) {
    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;
    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;
    default:
  }
  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;
    case 'uvs':
      attribute.size = attribute.size || 2;
      break;
    default:
  }
  (0, _webgl.assert)(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/model.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _programManager = _interopRequireDefault(require("./program-manager"));
var _webgl = require("@luma.gl/webgl");
var _modelUtils = require("./model-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
const ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';
const NOOP = () => {};
const DRAW_PARAMS = {};
class Model {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      id = (0, _webgl.uid)('model')
    } = props;
    (0, _webgl.assert)((0, _gltools.isWebGL)(gl));
    this.id = id;
    this.gl = gl;
    this.id = props.id || (0, _webgl.uid)('Model');
    this.lastLogTime = 0;
    this.animated = false;
    this.initialize(props);
  }
  initialize(props) {
    this.props = {};
    this.programManager = props.programManager || _programManager.default.getDefaultProgramManager(this.gl);
    this._programManagerState = -1;
    this._managedProgram = false;
    const {
      program = null,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this.program = null;
    this.vertexArray = null;
    this._programDirty = true;
    this.userData = {};
    this.needsRedraw = true;
    this._attributes = {};
    this.attributes = {};
    this.uniforms = {};
    this.pickable = true;
    this._checkProgram();
    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
    this.vertexCount = props.vertexCount || 0;
    this.geometryBuffers = {};
    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
    this._setModelProps(props);
    this.geometry = {};
    (0, _webgl.assert)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
  }
  setProps(props) {
    this._setModelProps(props);
  }
  delete() {
    for (const key in this._attributes) {
      if (this._attributes[key] !== this.attributes[key]) {
        this._attributes[key].delete();
      }
    }
    if (this._managedProgram) {
      this.programManager.release(this.program);
      this._managedProgram = false;
    }
    this.vertexArray.delete();
    this._deleteGeometryBuffers();
  }
  getDrawMode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getProgram() {
    return this.program;
  }
  setProgram(props) {
    const {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this._programDirty = true;
  }
  getUniforms() {
    return this.uniforms;
  }
  setDrawMode(drawMode) {
    this.drawMode = drawMode;
    return this;
  }
  setVertexCount(vertexCount) {
    (0, _webgl.assert)(Number.isFinite(vertexCount));
    this.vertexCount = vertexCount;
    return this;
  }
  setInstanceCount(instanceCount) {
    (0, _webgl.assert)(Number.isFinite(instanceCount));
    this.instanceCount = instanceCount;
    return this;
  }
  setGeometry(geometry) {
    this.drawMode = geometry.drawMode;
    this.vertexCount = geometry.getVertexCount();
    this._deleteGeometryBuffers();
    this.geometryBuffers = (0, _modelUtils.getBuffersFromGeometry)(this.gl, geometry);
    this.vertexArray.setAttributes(this.geometryBuffers);
    return this;
  }
  setAttributes() {
    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if ((0, _webgl.isObjectEmpty)(attributes)) {
      return this;
    }
    const normalizedAttributes = {};
    for (const name in attributes) {
      const attribute = attributes[name];
      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
    }
    this.vertexArray.setAttributes(normalizedAttributes);
    return this;
  }
  setUniforms() {
    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    Object.assign(this.uniforms, uniforms);
    return this;
  }
  getModuleUniforms(opts) {
    this._checkProgram();
    const getUniforms = this.programManager.getUniforms(this.program);
    if (getUniforms) {
      return getUniforms(opts);
    }
    return {};
  }
  updateModuleSettings(opts) {
    const uniforms = this.getModuleUniforms(opts || {});
    return this.setUniforms(uniforms);
  }
  clear(opts) {
    (0, _webgl.clear)(this.program.gl, opts);
    return this;
  }
  draw() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._checkProgram();
    const {
      moduleSettings = null,
      framebuffer,
      uniforms = {},
      attributes = {},
      transformFeedback = this.transformFeedback,
      parameters = {},
      vertexArray = this.vertexArray
    } = opts;
    this.setAttributes(attributes);
    this.updateModuleSettings(moduleSettings);
    this.setUniforms(uniforms);
    let logPriority;
    if (_webgl.log.priority >= LOG_DRAW_PRIORITY) {
      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
    }
    const drawParams = this.vertexArray.getDrawParams();
    const {
      isIndexed = drawParams.isIndexed,
      indexType = drawParams.indexType,
      indexOffset = drawParams.indexOffset,
      vertexArrayInstanced = drawParams.isInstanced
    } = this.props;
    if (vertexArrayInstanced && !this.isInstanced) {
      _webgl.log.warn('Found instanced attributes on non-instanced model', this.id)();
    }
    const {
      isInstanced,
      instanceCount
    } = this;
    const {
      onBeforeRender = NOOP,
      onAfterRender = NOOP
    } = this.props;
    onBeforeRender();
    this.program.setUniforms(this.uniforms);
    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
      logPriority,
      uniforms: null,
      framebuffer,
      parameters,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray,
      transformFeedback,
      isIndexed,
      indexType,
      isInstanced,
      instanceCount,
      offset: isIndexed ? indexOffset : 0
    }));
    onAfterRender();
    if (_webgl.log.priority >= LOG_DRAW_PRIORITY) {
      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
    }
    return didDraw;
  }
  transform() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      discard = true,
      feedbackBuffers,
      unbindModels = []
    } = opts;
    let {
      parameters
    } = opts;
    if (feedbackBuffers) {
      this._setFeedbackBuffers(feedbackBuffers);
    }
    if (discard) {
      parameters = Object.assign({}, parameters, {
        [35977]: discard
      });
    }
    unbindModels.forEach(model => model.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, opts, {
        parameters
      }));
    } finally {
      unbindModels.forEach(model => model.vertexArray.bindBuffers());
    }
    return this;
  }
  render() {
    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _webgl.log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();
    return this.setUniforms(uniforms).draw();
  }
  _setModelProps(props) {
    Object.assign(this.props, props);
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }
    if ('pickable' in props) {
      this.pickable = props.pickable;
    }
    if ('instanceCount' in props) {
      this.instanceCount = props.instanceCount;
    }
    if ('geometry' in props) {
      this.setGeometry(props.geometry);
    }
    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }
    if ('_feedbackBuffers' in props) {
      this._setFeedbackBuffers(props._feedbackBuffers);
    }
  }
  _checkProgram() {
    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
    if (!needsUpdate) {
      return;
    }
    let {
      program
    } = this.programProps;
    if (program) {
      this._managedProgram = false;
    } else {
      const {
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = this.programProps;
      program = this.programManager.get({
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      });
      if (this.program && this._managedProgram) {
        this.programManager.release(this.program);
      }
      this._programManagerState = this.programManager.stateHash;
      this._managedProgram = true;
    }
    (0, _webgl.assert)(program instanceof _webgl.Program, 'Model needs a program');
    this._programDirty = false;
    if (program === this.program) {
      return;
    }
    this.program = program;
    if (this.vertexArray) {
      this.vertexArray.setProps({
        program: this.program,
        attributes: this.vertexArray.attributes
      });
    } else {
      this.vertexArray = new _webgl.VertexArray(this.gl, {
        program: this.program
      });
    }
    this.setUniforms(Object.assign({}, this.getModuleUniforms()));
  }
  _deleteGeometryBuffers() {
    for (const name in this.geometryBuffers) {
      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
      if (buffer instanceof _webgl.Buffer) {
        buffer.delete();
      }
    }
  }
  _setAnimationProps(animationProps) {
    if (this.animated) {
      (0, _webgl.assert)(animationProps, 'Model.draw(): animated uniforms but no animationProps');
    }
  }
  _setFeedbackBuffers() {
    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if ((0, _webgl.isObjectEmpty)(feedbackBuffers)) {
      return this;
    }
    const {
      gl
    } = this.program;
    this.transformFeedback = this.transformFeedback || new _webgl.TransformFeedback(gl, {
      program: this.program
    });
    this.transformFeedback.setBuffers(feedbackBuffers);
    return this;
  }
  _logDrawCallStart(logLevel) {
    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (Date.now() - this.lastLogTime < logDrawTimeout) {
      return undefined;
    }
    this.lastLogTime = Date.now();
    _webgl.log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
      collapsed: _webgl.log.level <= 2
    })();
    return logLevel;
  }
  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
    if (logLevel === undefined) {
      return;
    }
    const attributeTable = (0, _webgl.getDebugTableForVertexArray)({
      vertexArray,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    });
    const {
      table: uniformTable,
      unusedTable,
      unusedCount
    } = (0, _webgl.getDebugTableForUniforms)({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms)
    });
    const {
      table: missingTable,
      count: missingCount
    } = (0, _webgl.getDebugTableForUniforms)({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms),
      undefinedOnly: true
    });
    if (missingCount > 0) {
      _webgl.log.log('MISSING UNIFORMS', Object.keys(missingTable))();
    }
    if (unusedCount > 0) {
      _webgl.log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();
    }
    const configTable = (0, _webgl.getDebugTableForProgramConfiguration)(this.vertexArray.configuration);
    _webgl.log.table(logLevel, attributeTable)();
    _webgl.log.table(logLevel, uniformTable)();
    _webgl.log.table(logLevel + 1, configTable)();
    if (framebuffer) {
      framebuffer.log({
        logLevel: LOG_DRAW_PRIORITY,
        message: "Rendered to ".concat(framebuffer.id)
      });
    }
    _webgl.log.groupEnd(LOG_DRAW_PRIORITY)();
  }
}
exports.default = Model;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./program-manager":"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","./model-utils":"node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
class BufferTransform {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};
    this._initialize(props);
    Object.seal(this);
  }
  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }
  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      varyings
    } = this;
    if (varyings.length > 0) {
      props = Object.assign({}, props, {
        varyings
      });
    }
    return props;
  }
  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const binding = this.bindings[this.currentIndex];
    const {
      sourceBuffers,
      transformFeedback
    } = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    return {
      attributes,
      transformFeedback
    };
  }
  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._setupBuffers(opts);
  }
  getBuffer(varyingName) {
    const {
      feedbackBuffers
    } = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
    if (!bufferOrParams) {
      return null;
    }
    return bufferOrParams instanceof _webgl.Buffer ? bufferOrParams : bufferOrParams.buffer;
  }
  getData() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      varyingName
    } = options;
    const buffer = this.getBuffer(varyingName);
    if (buffer) {
      return buffer.getData();
    }
    return null;
  }
  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._setupBuffers(props);
    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
    if (this.varyings.length > 0) {
      (0, _webgl.assert)((0, _gltools.isWebGL2)(this.gl));
    }
  }
  _getFeedbackBuffers(props) {
    const {
      sourceBuffers = {}
    } = props;
    const feedbackBuffers = {};
    if (this.bindings[this.currentIndex]) {
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }
    if (this.feedbackMap) {
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];
        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }
    Object.assign(feedbackBuffers, props.feedbackBuffers);
    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];
      if (typeof bufferOrRef === 'string') {
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {
          byteLength,
          usage,
          accessor
        } = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }
    return feedbackBuffers;
  }
  _setupBuffers() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers = null
    } = props;
    Object.assign(this.feedbackMap, props.feedbackMap);
    const feedbackBuffers = this._getFeedbackBuffers(props);
    this._updateBindings({
      sourceBuffers,
      feedbackBuffers
    });
  }
  _setupTransformFeedback(binding, _ref) {
    let {
      model
    } = _ref;
    const {
      program
    } = model;
    binding.transformFeedback = new _webgl.TransformFeedback(this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }
  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this.feedbackMap) {
      const {
        sourceBuffers,
        feedbackBuffers
      } = this._swapBuffers(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }
  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }
    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }
    return binding;
  }
  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }
    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
      (0, _webgl.assert)(feedbackBuffers[dstName] instanceof _webgl.Buffer);
    }
    return {
      sourceBuffers,
      feedbackBuffers
    };
  }
  _createNewBuffer(name, opts) {
    const buffer = new _webgl.Buffer(this.gl, opts);
    if (this.resources[name]) {
      this.resources[name].delete();
    }
    this.resources[name] = buffer;
    return buffer;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
}
exports.default = BufferTransform;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSizeUniforms = getSizeUniforms;
exports.getVaryingType = getVaryingType;
exports.processAttributeDefinition = processAttributeDefinition;
exports.updateForTextures = updateForTextures;
var _webgl = require("@luma.gl/webgl");
var _shadertools = require("@luma.gl/shadertools");
const SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
const SIZE_UNIFORM_PREFIX = 'transform_uSize_';
const VS_POS_VARIABLE = 'transform_position';
function updateForTextures(_ref) {
  let {
    vs,
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref;
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs;
  let finalInject = {};
  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split('\n');
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);
        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }
      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });
    if (targetTextureVarying) {
      (0, _webgl.assert)(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
    }
    updatedVs = updateVsLines.join('\n');
  }
  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms(_ref2) {
  let {
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref2;
  const uniforms = {};
  let width;
  let height;
  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }
  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }
  return uniforms;
}
function getAttributeDefinition(line) {
  return (0, _shadertools.getQualifierDetails)(line, ['attribute', 'in']);
}
function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}
function getVaryingType(line, varying) {
  const qualaiferDetails = (0, _shadertools.getQualifierDetails)(line, ['varying', 'out']);
  if (!qualaiferDetails) {
    return null;
  }
  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);
  if (!attributeData) {
    return null;
  }
  const {
    type,
    name
  } = attributeData;
  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = (0, _shadertools.typeToChannelSuffix)(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }
  return null;
}
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _webgl = require("@luma.gl/webgl");
var _shadertools = require("@luma.gl/shadertools");
var _transformShaderUtils = require("./transform-shader-utils");
const SRC_TEX_PARAMETER_OVERRIDES = {
  [10241]: 9728,
  [10240]: 9728,
  [10242]: 33071,
  [10243]: 33071
};
const FS_OUTPUT_VARIABLE = 'transform_output';
class TextureTransform {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.id = this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};
    this._initialize(props);
    Object.seal(this);
  }
  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const updatedModelProps = this._processVertexShader(props);
    return Object.assign({}, props, updatedModelProps);
  }
  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers,
      sourceTextures,
      framebuffer,
      targetTexture
    } = this.bindings[this.currentIndex];
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;
    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;
      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }
      this._setSourceTextureParameters();
      const sizeUniforms = (0, _transformShaderUtils.getSizeUniforms)({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }
    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }
    return {
      attributes,
      framebuffer,
      uniforms,
      discard,
      parameters
    };
  }
  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._setupTextures(opts);
  }
  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }
  getData() {
    let {
      packed = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const pixels = (0, _webgl.readPixelsToArray)(framebuffer);
    if (!packed) {
      return pixels;
    }
    const ArrayType = pixels.constructor;
    const channelCount = (0, _shadertools.typeToChannelCount)(this.targetTextureType);
    const packedPixels = new ArrayType(pixels.length * channelCount / 4);
    let packCount = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }
    return packedPixels;
  }
  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }
  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      _targetTextureVarying,
      _swapTexture
    } = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;
    this._setupTextures(props);
  }
  _createTargetTexture(props) {
    const {
      sourceTextures,
      textureOrReference
    } = props;
    if (textureOrReference instanceof _webgl.Texture2D) {
      return textureOrReference;
    }
    const refTexture = sourceTextures[textureOrReference];
    if (!refTexture) {
      return null;
    }
    this._targetRefTexName = textureOrReference;
    return this._createNewTexture(refTexture);
  }
  _setupTextures() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers,
      _sourceTextures = {},
      _targetTexture
    } = props;
    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });
    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
    this._updateBindings({
      sourceBuffers,
      sourceTextures: _sourceTextures,
      targetTexture
    });
    if ('elementCount' in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }
  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {
      return;
    }
    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });
    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new _webgl.Buffer(this.gl, {
        data: elementIds,
        accessor: {
          size: 1
        }
      });
    } else {
      this.elementIDBuffer.setData({
        data: elementIds
      });
    }
    this.elementCount = elementCount;
  }
  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this._swapTexture) {
      const {
        sourceTextures,
        targetTexture
      } = this._swapTextures(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }
  _updateBinding(binding, opts) {
    const {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = opts;
    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }
    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);
    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      const {
        framebuffer
      } = binding;
      if (framebuffer) {
        framebuffer.update({
          attachments: {
            [36064]: targetTexture
          },
          resizeAttachments: false
        });
        framebuffer.resize({
          width,
          height
        });
      } else {
        binding.framebuffer = new _webgl.Framebuffer(this.gl, {
          id: "transform-framebuffer",
          width,
          height,
          attachments: {
            [36064]: targetTexture
          }
        });
      }
    }
    return binding;
  }
  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];
    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }
  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }
    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;
    const targetTexture = opts.sourceTextures[this._swapTexture];
    return {
      sourceTextures,
      targetTexture
    };
  }
  _createNewTexture(refTexture) {
    const texture = (0, _webgl.cloneTextureFrom)(refTexture, {
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      },
      pixelStore: {
        [37440]: false
      }
    });
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    this.ownTexture = texture;
    return texture;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
  _processVertexShader() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceTextures,
      targetTexture
    } = this.bindings[this.currentIndex];
    const {
      vs,
      uniforms,
      targetTextureType,
      inject,
      samplerTextureMap
    } = (0, _transformShaderUtils.updateForTextures)({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = (0, _shadertools.combineInjects)([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs = props._fs || (0, _shadertools.getPassthroughFS)({
      version: (0, _webgl.getShaderVersion)(vs),
      input: this.targetTextureVarying,
      inputType: targetTextureType,
      output: FS_OUTPUT_VARIABLE
    });
    const modules = this.hasSourceTextures || this.targetTextureVarying ? [_shadertools._transform].concat(props.modules || []) : props.modules;
    return {
      vs,
      fs,
      modules,
      uniforms,
      inject: combinedInject
    };
  }
}
exports.default = TextureTransform;
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","./transform-shader-utils":"node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _shadertools = require("@luma.gl/shadertools");
var _bufferTransform = _interopRequireDefault(require("./buffer-transform"));
var _textureTransform = _interopRequireDefault(require("./texture-transform"));
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
var _model = _interopRequireDefault(require("../lib/model"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Transform {
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;
    this._initialize(props);
    Object.seal(this);
  }
  delete() {
    const {
      model,
      bufferTransform,
      textureTransform
    } = this;
    if (model) {
      model.delete();
    }
    if (bufferTransform) {
      bufferTransform.delete();
    }
    if (textureTransform) {
      textureTransform.delete();
    }
  }
  run() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      clearRenderTarget = true
    } = opts;
    const updatedOpts = this._updateDrawOptions(opts);
    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({
        color: true
      });
    }
    this.model.transform(updatedOpts);
  }
  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }
    (0, _webgl.assert)(swapped, 'Nothing to swap');
  }
  getBuffer() {
    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }
  getData() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      const data = resourceTransform.getData(opts);
      if (data) {
        return data;
      }
    }
    return null;
  }
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }
  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if ('elementCount' in opts) {
      this.model.setVertexCount(opts.elementCount);
    }
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }
  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      gl
    } = this;
    this._buildResourceTransforms(gl, props);
    props = this._updateModelProps(props);
    this.model = new _model.default(gl, Object.assign({}, props, {
      fs: props.fs || (0, _shadertools.getPassthroughFS)({
        version: (0, _webgl.getShaderVersion)(props.vs)
      }),
      id: props.id || 'transform-model',
      drawMode: props.drawMode || 0,
      vertexCount: props.elementCount
    }));
    this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }
  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }
    return updatedProps;
  }
  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new _bufferTransform.default(gl, props);
    }
    if (canCreateTextureTransform(props)) {
      this.textureTransform = new _textureTransform.default(gl, props);
    }
    (0, _webgl.assert)(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');
  }
  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }
    return updatedOpts;
  }
}
exports.default = Transform;
function canCreateBufferTransform(props) {
  if (!(0, _webgl.isObjectEmpty)(props.feedbackBuffers) || !(0, _webgl.isObjectEmpty)(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }
  return false;
}
function canCreateTextureTransform(props) {
  if (!(0, _webgl.isObjectEmpty)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }
  return false;
}
},{"@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","./buffer-transform":"node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js","./texture-transform":"node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","../lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js"}],"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DRAW_MODE = void 0;
var _webgl = require("@luma.gl/webgl");
const DRAW_MODE = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006
};
exports.DRAW_MODE = DRAW_MODE;
class Geometry {
  static get DRAW_MODE() {
    return DRAW_MODE;
  }
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('geometry'),
      drawMode = DRAW_MODE.TRIANGLES,
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;
    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};
    this._setAttributes(attributes, indices);
    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }
  get mode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(attributeName) {
    return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
  }
  _setAttributes(attributes, indices) {
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {
        value: indices,
        size: 1
      } : indices;
    }
    for (const attributeName in attributes) {
      let attribute = attributes[attributeName];
      attribute = ArrayBuffer.isView(attribute) ? {
        value: attribute
      } : attribute;
      (0, _webgl.assert)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
        attribute.size = 3;
      }
      if (attributeName === 'indices') {
        (0, _webgl.assert)(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }
    if (this.indices && this.indices.isIndexed !== undefined) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }
    return this;
  }
  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        value,
        size,
        constant
      } = attribute;
      if (!constant && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }
    (0, _webgl.assert)(Number.isFinite(vertexCount));
    return vertexCount;
  }
}
exports.default = Geometry;
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};
class TruncatedConeGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('truncated-code-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateTruncatedCone(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = TruncatedConeGeometry;
function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = 'y',
    topCap = false,
    bottomCap = false
  } = props;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;
  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  let i3 = 0;
  let i2 = 0;
  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;
    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }
    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin = msin(j * mpi * 2 / nradial);
      const cos = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }
  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ConeGeometry extends _truncatedConeGeometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('cone-geometry'),
      radius = 1,
      cap = true
    } = props;
    super({
      ...props,
      id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    });
  }
}
exports.default = ConeGeometry;
},{"./truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
const CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
const CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
const CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
const ATTRIBUTES = {
  POSITION: {
    size: 3,
    value: new Float32Array(CUBE_POSITIONS)
  },
  NORMAL: {
    size: 3,
    value: new Float32Array(CUBE_NORMALS)
  },
  TEXCOORD_0: {
    size: 2,
    value: new Float32Array(CUBE_TEX_COORDS)
  }
};
class CubeGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('cube-geometry')
    } = props;
    super({
      ...props,
      id,
      indices: {
        size: 1,
        value: new Uint16Array(CUBE_INDICES)
      },
      attributes: {
        ...ATTRIBUTES,
        ...props.attributes
      }
    });
  }
}
exports.default = CubeGeometry;
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class CylinderGeometry extends _truncatedConeGeometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('cylinder-geometry'),
      radius = 1
    } = props;
    super({
      ...props,
      id,
      bottomRadius: radius,
      topRadius: radius
    });
  }
}
exports.default = CylinderGeometry;
},{"./truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@math.gl/core");
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
const ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
class IcoSphereGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('ico-sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateIcosaHedron(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = IcoSphereGeometry;
function tesselateIcosaHedron(props) {
  const {
    iterations = 0
  } = props;
  const PI = Math.PI;
  const PI2 = PI * 2;
  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];
  positions.push();
  indices.push();
  const getMiddlePoint = (() => {
    const pointMemo = {};
    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = "".concat(mini, "|").concat(maxi);
      if (key in pointMemo) {
        return pointMemo[key];
      }
      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len;
      ym /= len;
      zm /= len;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  })();
  for (let i = 0; i < iterations; i++) {
    const indices2 = [];
    for (let j = 0; j < indices.length; j += 3) {
      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }
    indices = indices2;
  }
  const normals = new Array(positions.length);
  const texCoords = new Array(positions.length / 3 * 2);
  const l = indices.length;
  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI;
    const v1 = theta1 / PI;
    const u1 = 1 - phi1 / PI2;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI;
    const v2 = theta2 / PI;
    const u2 = 1 - phi2 / PI2;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI;
    const v3 = theta3 / PI;
    const u3 = 1 - phi3 / PI2;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new _core.Vector3(vec1).cross(vec2).normalize();
    let newIndex;
    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }
    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }
  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackIndexedGeometry = unpackIndexedGeometry;
function unpackIndexedGeometry(geometry) {
  const {
    indices,
    attributes
  } = geometry;
  if (!indices) {
    return geometry;
  }
  const vertexCount = indices.value.length;
  const unpackedAttributes = {};
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {
      constant,
      value,
      size
    } = attribute;
    if (constant || !size) {
      continue;
    }
    const unpackedValue = new value.constructor(vertexCount * size);
    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];
      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }
    unpackedAttributes[attributeName] = {
      size,
      value: unpackedValue
    };
  }
  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}
},{}],"node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _geometryUtils = require("../geometry/geometry-utils");
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PlaneGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('plane-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselatePlane(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = PlaneGeometry;
function tesselatePlane(props) {
  const {
    type = 'x,y',
    offset = 0,
    flipCull = false,
    unpack = false
  } = props;
  const coords = type.split(',');
  let c1len = props["".concat(coords[0], "len")] || 1;
  const c2len = props["".concat(coords[1], "len")] || 1;
  const subdivisions1 = props["n".concat(coords[0])] || 1;
  const subdivisions2 = props["n".concat(coords[1])] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  if (flipCull) {
    c1len = -c1len;
  }
  let i2 = 0;
  let i3 = 0;
  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;
      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;
        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;
        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;
        default:
          throw new Error('PlaneGeometry: unknown type');
      }
      i2 += 2;
      i3 += 3;
    }
  }
  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);
  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }
  const geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? (0, _geometryUtils.unpackIndexedGeometry)(geometry) : geometry;
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","../geometry/geometry-utils":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class SphereGeometry extends _geometry.default {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      id = (0, _webgl.uid)('sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateSphere(props);
    super({
      ...props,
      id,
      indices,
      attributes: {
        ...attributes,
        ...props.attributes
      }
    });
  }
}
exports.default = SphereGeometry;
function tesselateSphere(props) {
  const {
    nlat = 10,
    nlong = 10
  } = props;
  let {
    radius = 1
  } = props;
  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);
  if (typeof radius === 'number') {
    const value = radius;
    radius = (n1, n2, n3, u, v) => value;
  }
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;
  const indices = new IndexType(nlat * nlong * 6);
  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;
      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;
      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      const r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }
  const numVertsAround = nlong + 1;
  for (let x = 0; x < nlong; x++) {
    for (let y = 0; y < nlat; y++) {
      const index = (x * nlat + y) * 6;
      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;
      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }
  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/animation/timeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timeline = void 0;
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
  constructor() {
    this.time = 0;
    this.channels = new Map();
    this.animations = new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }
  addChannel(props) {
    const {
      delay = 0,
      duration = Number.POSITIVE_INFINITY,
      rate = 1,
      repeat = 1
    } = props;
    const handle = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };
    this._setChannelTime(channel, this.time);
    this.channels.set(handle, channel);
    return handle;
  }
  removeChannel(handle) {
    this.channels.delete(handle);
    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === handle) {
        this.detachAnimation(animationHandle);
      }
    }
  }
  isFinished(handle) {
    const channel = this.channels.get(handle);
    if (channel === undefined) {
      return false;
    }
    return this.time >= channel.delay + channel.duration * channel.repeat;
  }
  getTime(handle) {
    if (handle === undefined) {
      return this.time;
    }
    const channel = this.channels.get(handle);
    if (channel === undefined) {
      return -1;
    }
    return channel.time;
  }
  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();
    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }
    const animations = this.animations.values();
    for (const animationData of animations) {
      const {
        animation,
        channel
      } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }
  play() {
    this.playing = true;
  }
  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }
  detachAnimation(handle) {
    this.animations.delete(handle);
  }
  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }
      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }
  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;
    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }
}
exports.Timeline = Timeline;
},{}],"node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyFrames = void 0;
class KeyFrames {
  constructor(keyFrames) {
    this._lastTime = -1;
    this.startIndex = -1;
    this.endIndex = -1;
    this.factor = 0;
    this.times = [];
    this.values = [];
    this.setKeyFrames(keyFrames);
    this.setTime(0);
  }
  setKeyFrames(keyFrames) {
    const numKeys = keyFrames.length;
    this.times.length = numKeys;
    this.values.length = numKeys;
    for (let i = 0; i < numKeys; ++i) {
      this.times[i] = keyFrames[i][0];
      this.values[i] = keyFrames[i][1];
    }
    this._calculateKeys(this._lastTime);
  }
  setTime(time) {
    time = Math.max(0, time);
    if (time !== this._lastTime) {
      this._calculateKeys(time);
      this._lastTime = time;
    }
  }
  getStartTime() {
    return this.times[this.startIndex];
  }
  getEndTime() {
    return this.times[this.endIndex];
  }
  getStartData() {
    return this.values[this.startIndex];
  }
  getEndData() {
    return this.values[this.endIndex];
  }
  _calculateKeys(time) {
    let index = 0;
    const numKeys = this.times.length;
    for (index = 0; index < numKeys - 2; ++index) {
      if (this.times[index + 1] > time) {
        break;
      }
    }
    this.startIndex = index;
    this.endIndex = index + 1;
    const startTime = this.times[this.startIndex];
    const endTime = this.times[this.endIndex];
    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);
  }
}
exports.KeyFrames = KeyFrames;
},{}],"node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _model = _interopRequireDefault(require("../lib/model"));
var _geometry = _interopRequireDefault(require("../geometry/geometry"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
const POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
class ClipSpace extends _model.default {
  constructor(gl, opts) {
    const TEX_COORDS = POSITIONS.map(coord => coord === -1 ? 0 : coord);
    super(gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry.default({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    }));
    this.setVertexCount(4);
  }
}
exports.default = ClipSpace;
},{"../lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js","../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js"}],"node_modules/@luma.gl/engine/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _animationLoop.default;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _clipSpace.default;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _coneGeometry.default;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _cubeGeometry.default;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _cylinderGeometry.default;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _geometry.default;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _icoSphereGeometry.default;
  }
});
Object.defineProperty(exports, "KeyFrames", {
  enumerable: true,
  get: function () {
    return _keyFrames.KeyFrames;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _model.default;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _planeGeometry.default;
  }
});
Object.defineProperty(exports, "ProgramManager", {
  enumerable: true,
  get: function () {
    return _programManager.default;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _sphereGeometry.default;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _timeline.Timeline;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _truncatedConeGeometry.default;
  }
});
var _animationLoop = _interopRequireDefault(require("./lib/animation-loop"));
var _model = _interopRequireDefault(require("./lib/model"));
var _programManager = _interopRequireDefault(require("./lib/program-manager"));
var _transform = _interopRequireDefault(require("./transform/transform"));
var _geometry = _interopRequireDefault(require("./geometry/geometry"));
var _coneGeometry = _interopRequireDefault(require("./geometries/cone-geometry"));
var _cubeGeometry = _interopRequireDefault(require("./geometries/cube-geometry"));
var _cylinderGeometry = _interopRequireDefault(require("./geometries/cylinder-geometry"));
var _icoSphereGeometry = _interopRequireDefault(require("./geometries/ico-sphere-geometry"));
var _planeGeometry = _interopRequireDefault(require("./geometries/plane-geometry"));
var _sphereGeometry = _interopRequireDefault(require("./geometries/sphere-geometry"));
var _truncatedConeGeometry = _interopRequireDefault(require("./geometries/truncated-cone-geometry"));
var _timeline = require("./animation/timeline");
var _keyFrames = require("./animation/key-frames");
var _clipSpace = _interopRequireDefault(require("./utils/clip-space"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/animation-loop":"node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js","./lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js","./lib/program-manager":"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js","./transform/transform":"node_modules/@luma.gl/engine/dist/esm/transform/transform.js","./geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","./geometries/cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js","./geometries/cube-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","./geometries/cylinder-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js","./geometries/ico-sphere-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js","./geometries/plane-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js","./geometries/sphere-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js","./geometries/truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","./animation/timeline":"node_modules/@luma.gl/engine/dist/esm/animation/timeline.js","./animation/key-frames":"node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js","./utils/clip-space":"node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js"}],"node_modules/@luma.gl/core/dist/esm/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _engine.AnimationLoop;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _webgl.Buffer;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _engine.ClipSpace;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.ConeGeometry;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.CubeGeometry;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _engine.CylinderGeometry;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webgl.FEATURES;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _webgl.FragmentShader;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Framebuffer;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _engine.Geometry;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _engine.IcoSphereGeometry;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _engine.Model;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _engine.PlaneGeometry;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _webgl.Program;
  }
});
Object.defineProperty(exports, "ProgramManager", {
  enumerable: true,
  get: function () {
    return _engine.ProgramManager;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Renderbuffer;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _engine.SphereGeometry;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture2D;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture3D;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _webgl.TextureCube;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _engine.Timeline;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _engine.Transform;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _webgl.TransformFeedback;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.TruncatedConeGeometry;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _webgl.VertexShader;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _webgl.clear;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _webgl.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _webgl.copyToTexture;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _gltools.createGLContext;
  }
});
Object.defineProperty(exports, "cssToDevicePixels", {
  enumerable: true,
  get: function () {
    return _gltools.cssToDevicePixels;
  }
});
Object.defineProperty(exports, "cssToDeviceRatio", {
  enumerable: true,
  get: function () {
    return _gltools.cssToDeviceRatio;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _shadertools.dirlight;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _shadertools.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _shadertools.fp64;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _gltools.getParameters;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _shadertools.gouraudLighting;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeatures;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _gltools.instrumentGLContext;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _gltools.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _gltools.isWebGL2;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _webgl.lumaStats;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shadertools.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _shadertools.pbr;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _shadertools.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shadertools.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shadertools.project;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _gltools.resetParameters;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _gltools.setParameters;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _gltools.withParameters;
  }
});
var _gltools = require("@luma.gl/gltools");
var _webgl = require("@luma.gl/webgl");
var _engine = require("@luma.gl/engine");
var _shadertools = require("@luma.gl/shadertools");
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/engine":"node_modules/@luma.gl/engine/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","buffer":"node_modules/buffer/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmbientLight = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
let idCount = 0;
class AmbientLight {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "color", void 0);
    (0, _defineProperty2.default)(this, "intensity", void 0);
    (0, _defineProperty2.default)(this, "type", 'ambient');
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    this.id = props.id || "ambient-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
  }
}
exports.AmbientLight = AmbientLight;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectionalLight = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];
let idCount = 0;
class DirectionalLight {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "color", void 0);
    (0, _defineProperty2.default)(this, "intensity", void 0);
    (0, _defineProperty2.default)(this, "type", 'directional');
    (0, _defineProperty2.default)(this, "direction", void 0);
    (0, _defineProperty2.default)(this, "shadow", void 0);
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      direction = DEFAULT_LIGHT_DIRECTION
    } = props;
    const {
      _shadow = false
    } = props;
    this.id = props.id || "directional-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'directional';
    this.direction = new _core.Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }
  getProjectedLight(opts) {
    return this;
  }
}
exports.DirectionalLight = DirectionalLight;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Pass {
  constructor(gl, props = {
    id: 'pass'
  }) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    const {
      id
    } = props;
    this.id = id;
    this.gl = gl;
    this.props = {
      ...props
    };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  render(params) {}
  cleanup() {}
}
exports.default = Pass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.layerIndexResolver = layerIndexResolver;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _pass = _interopRequireDefault(require("./pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LayersPass extends _pass.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "_lastRenderIndex", -1);
  }
  render(options) {
    const gl = this.gl;
    (0, _core.setParameters)(gl, {
      framebuffer: options.target
    });
    return this._drawLayers(options);
  }
  _drawLayers(options) {
    const {
      target,
      moduleParameters,
      viewports,
      views,
      onViewportActive,
      clearStack = true,
      clearCanvas = true
    } = options;
    options.pass = options.pass || 'unknown';
    const gl = this.gl;
    if (clearCanvas) {
      clearGLCanvas(gl, target);
    }
    if (clearStack) {
      this._lastRenderIndex = -1;
    }
    const renderStats = [];
    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);
      const drawLayerParams = this._getDrawLayerParams(viewport, options);
      const subViewports = viewport.subViewports || [viewport];
      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(gl, {
          target,
          moduleParameters,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);
        renderStats.push(stats);
      }
    }
    return renderStats;
  }
  _getDrawLayerParams(viewport, {
    layers,
    pass,
    isPicking = false,
    layerFilter,
    cullRect,
    effects,
    moduleParameters
  }, evaluateShouldDrawOnly = false) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
      const layerParam = {
        shouldDrawLayer
      };
      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
      }
      drawLayerParams[layerIndex] = layerParam;
    }
    return drawLayerParams;
  }
  _drawLayersInViewport(gl, {
    layers,
    moduleParameters: globalModuleParameters,
    pass,
    target,
    viewport,
    view
  }, drawLayerParams) {
    const glViewport = getGLViewport(gl, {
      moduleParameters: globalModuleParameters,
      target,
      viewport
    });
    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? {
        color: true,
        depth: true
      } : view.props.clear;
      (0, _core.withParameters)(gl, {
        scissorTest: true,
        scissor: glViewport
      }, () => (0, _core.clear)(gl, clearOpts));
    }
    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    (0, _core.setParameters)(gl, {
      viewport: glViewport
    });
    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const {
        shouldDrawLayer,
        layerRenderIndex,
        moduleParameters,
        layerParameters
      } = drawLayerParams[layerIndex];
      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }
      if (layer.isComposite) {
        renderStatus.compositeCount++;
      } else if (shouldDrawLayer) {
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        moduleParameters.viewport = viewport;
        try {
          layer._drawLayer({
            moduleParameters,
            uniforms: {
              layerIndex: layerRenderIndex
            },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
        }
      }
    }
    return renderStatus;
  }
  shouldDrawLayer(layer) {
    return true;
  }
  getModuleParameters(layer, effects) {
    return null;
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }
  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
    if (!shouldDrawLayer) {
      return false;
    }
    drawContext.layer = layer;
    let parent = layer.parent;
    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }
      drawContext.layer = parent;
      parent = parent.parent;
    }
    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;
      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }
      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }
    layer.activateViewport(drawContext.viewport);
    return true;
  }
  _getModuleParameters(layer, effects, pass, overrides) {
    var _layer$internalState;
    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
      autoWrapLongitude: layer.wrapLongitude,
      viewport: layer.context.viewport,
      mousePosition: layer.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: (0, _core.cssToDeviceRatio)(this.gl)
    });
    if (effects) {
      for (const effect of effects) {
        var _effect$getModulePara;
        Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
      }
    }
    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
  }
}
exports.default = LayersPass;
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};
  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;
    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }
    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
  return resolveLayerIndex;
}
function getGLViewport(gl, {
  moduleParameters,
  target,
  viewport
}) {
  const useTarget = target && target.id !== 'default-framebuffer';
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || (0, _core.cssToDeviceRatio)(gl);
  const height = useTarget ? target.height : gl.drawingBufferHeight;
  const dimensions = viewport;
  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}
function clearGLCanvas(gl, targetFramebuffer) {
  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
  (0, _core.setParameters)(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./pass":"node_modules/@deck.gl/core/dist/esm/passes/pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layersPass = _interopRequireDefault(require("./layers-pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ShadowPass extends _layersPass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "shadowMap", void 0);
    (0, _defineProperty2.default)(this, "depthBuffer", void 0);
    (0, _defineProperty2.default)(this, "fbo", void 0);
    this.shadowMap = new _core.Texture2D(gl, {
      width: 1,
      height: 1,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.depthBuffer = new _core.Renderbuffer(gl, {
      format: 33189,
      width: 1,
      height: 1
    });
    this.fbo = new _core.Framebuffer(gl, {
      id: 'shadowmap',
      width: 1,
      height: 1,
      attachments: {
        [36064]: this.shadowMap,
        [36096]: this.depthBuffer
      }
    });
  }
  render(params) {
    const target = this.fbo;
    (0, _core.withParameters)(this.gl, {
      depthRange: [0, 1],
      depthTest: true,
      blend: false,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const viewport = params.viewports[0];
      const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;
      if (width !== target.width || height !== target.height) {
        target.resize({
          width,
          height
        });
      }
      super.render({
        ...params,
        target,
        pass: 'shadow'
      });
    });
  }
  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: true
    };
  }
  delete() {
    if (this.fbo) {
      this.fbo.delete();
      this.fbo = null;
    }
    if (this.shadowMap) {
      this.shadowMap.delete();
      this.shadowMap = null;
    }
    if (this.depthBuffer) {
      this.depthBuffer.delete();
      this.depthBuffer = null;
    }
  }
}
exports.default = ShadowPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const defines = '#define SMOOTH_EDGE_RADIUS 0.5';
const vs = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
const fs = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
var _default = {
  name: 'geometry',
  vs,
  fs
};
exports.default = _default;
},{}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../../lib/constants");
const COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(_constants.COORDINATE_SYSTEM).map(key => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(_constants.COORDINATE_SYSTEM[key], ";")).join('');
const PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(_constants.PROJECTION_MODE).map(key => "const int PROJECTION_MODE_".concat(key, " = ").concat(_constants.PROJECTION_MODE[key], ";")).join('');
const UNIT_GLSL_CONSTANTS = Object.keys(_constants.UNIT).map(key => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(_constants.UNIT[key], ";")).join('');
var _default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");
exports.default = _default;
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/utils/memoize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memoize;
function isEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a)) {
    const len = a.length;
    if (!b || b.length !== len) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return args => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsetOrigin = getOffsetOrigin;
exports.getUniformsFromViewport = getUniformsFromViewport;
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
var _constants = require("../../lib/constants");
var _memoize = _interopRequireDefault(require("../../utils/memoize"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const ZERO_VECTOR = [0, 0, 0, 0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
const getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }
  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === _constants.COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }
  switch (viewport.projectionMode) {
    case _constants.PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }
      break;
    case _constants.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case _constants.PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;
    case _constants.PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;
    default:
      offsetMode = false;
  }
  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const {
    viewMatrixUncentered,
    projectionMatrix
  } = viewport;
  let {
    viewMatrix,
    viewProjectionMatrix
  } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
    originCommon[3] = 1;
    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix = viewMatrixUncentered || viewMatrix;
    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  coordinateSystem = _constants.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN;
  }
  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.project_uWrapLongitude = autoWrapLongitude;
  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;
  return uniforms;
}
function calculateViewportUniforms({
  viewport,
  devicePixelRatio,
  coordinateSystem,
  coordinateOrigin
}) {
  const {
    projectionCenter,
    viewProjectionMatrix,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  const focalDistance = vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uWrapLongitude: false,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uModelMatrix: IDENTITY_MATRIX,
    project_uCameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case _constants.COORDINATE_SYSTEM.LNGLAT:
      case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case _constants.COORDINATE_SYSTEM.CARTESIAN:
        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms;
}
},{"gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js","../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@luma.gl/core");
var _geometry = _interopRequireDefault(require("../misc/geometry"));
var _project = _interopRequireDefault(require("./project.glsl"));
var _viewportUniforms = require("./viewport-uniforms");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const INITIAL_MODULE_OPTIONS = {};
function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if ('viewport' in opts) {
    return (0, _viewportUniforms.getUniformsFromViewport)(opts);
  }
  return {};
}
var _default = {
  name: 'project',
  dependencies: [_core.fp32, _geometry.default],
  vs: _project.default,
  getUniforms
};
exports.default = _default;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../misc/geometry":"node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js","./project.glsl":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js","./viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clamp = clamp;
exports.createMat4 = createMat4;
exports.lerp = lerp;
exports.log2 = void 0;
exports.mod = mod;
exports.transformVector = transformVector;
var _vec = require("gl-matrix/vec4");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = (0, _vec.transformMat4)([], vector, matrix);
  (0, _vec.scale)(result, result, 1 / result[3]);
  return result;
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function lerp(start, end, step) {
  return step * end + (1 - step) * start;
}
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
  return Math.log(x) * Math.LOG2E;
}
const log2 = Math.log2 || ieLog2;
exports.log2 = log2;
},{"gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/web-mercator/dist/esm/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '@math.gl/web-mercator: assertion failed.');
  }
}
},{}],"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_LATITUDE = exports.DEFAULT_ALTITUDE = void 0;
exports.addMetersToLngLat = addMetersToLngLat;
exports.altitudeToFovy = altitudeToFovy;
exports.fovyToAltitude = fovyToAltitude;
exports.getDistanceScales = getDistanceScales;
exports.getMeterZoom = getMeterZoom;
exports.getProjectionMatrix = getProjectionMatrix;
exports.getProjectionParameters = getProjectionParameters;
exports.getViewMatrix = getViewMatrix;
exports.lngLatToWorld = lngLatToWorld;
exports.pixelsToWorld = pixelsToWorld;
exports.scaleToZoom = scaleToZoom;
exports.unitsPerMeter = unitsPerMeter;
exports.worldToLngLat = worldToLngLat;
exports.worldToPixels = worldToPixels;
exports.zoomToScale = zoomToScale;
var _mathUtils = require("./math-utils");
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _assert = _interopRequireDefault(require("./assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE = 512;
const EARTH_CIRCUMFERENCE = 40.03e6;
const MAX_LATITUDE = 85.051129;
exports.MAX_LATITUDE = MAX_LATITUDE;
const DEFAULT_ALTITUDE = 1.5;
exports.DEFAULT_ALTITUDE = DEFAULT_ALTITUDE;
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}
function scaleToZoom(scale) {
  return (0, _mathUtils.log2)(scale);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  (0, _assert.default)(Number.isFinite(lng));
  (0, _assert.default)(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
  const lambda2 = lng * DEGREES_TO_RADIANS;
  const phi2 = lat * DEGREES_TO_RADIANS;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}
function worldToLngLat(xy) {
  const [x, y] = xy;
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}
function getMeterZoom(options) {
  const {
    latitude
  } = options;
  (0, _assert.default)(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}
function getDistanceScales(options) {
  const {
    latitude,
    longitude,
    highPrecision = false
  } = options;
  (0, _assert.default)(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x, y, z] = xyz;
  const {
    unitsPerMeter,
    unitsPerMeter2
  } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);
  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    height,
    pitch,
    bearing,
    altitude,
    scale,
    center
  } = options;
  const vm = (0, _mathUtils.createMat4)();
  mat4.translate(vm, vm, [0, 0, -altitude]);
  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);
  const relativeScale = scale / height;
  mat4.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    mat4.translate(vm, vm, vec3.negate([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const {
    width,
    height,
    altitude,
    pitch = 0,
    offset,
    center,
    scale,
    nearZMultiplier = 1,
    farZMultiplier = 1
  } = options;
  let {
    fovy = altitudeToFovy(DEFAULT_ALTITUDE)
  } = options;
  if (altitude !== undefined) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS;
  const pitchRadians = pitch * DEGREES_TO_RADIANS;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin((0, _mathUtils.clamp)(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function getProjectionMatrix(options) {
  const {
    fov,
    aspect,
    near,
    far
  } = getProjectionParameters(options);
  const projectionMatrix = mat4.perspective([], fov, aspect, near, far);
  return projectionMatrix;
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x, y, z = 0] = xyz;
  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x, y, z] = xyz;
  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');
  if (Number.isFinite(z)) {
    const coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }
  const coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  const coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2.lerp([], coord0, coord1, t);
}
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","./assert":"node_modules/@math.gl/web-mercator/dist/esm/assert.js"}],"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fitBounds;
var _assert = _interopRequireDefault(require("./assert"));
var _mathUtils = require("./math-utils");
var _webMercatorUtils = require("./web-mercator-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    maxZoom = 24,
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = (0, _webMercatorUtils.lngLatToWorld)([west, (0, _mathUtils.clamp)(north, -_webMercatorUtils.MAX_LATITUDE, _webMercatorUtils.MAX_LATITUDE)]);
  const se = (0, _webMercatorUtils.lngLatToWorld)([east, (0, _mathUtils.clamp)(south, -_webMercatorUtils.MAX_LATITUDE, _webMercatorUtils.MAX_LATITUDE)]);
  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  (0, _assert.default)(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX = targetSize[0] / size[0];
  const scaleY = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = (0, _webMercatorUtils.worldToLngLat)(center);
  const zoom = Math.min(maxZoom, (0, _mathUtils.log2)(Math.abs(Math.min(scaleX, scaleY))));
  (0, _assert.default)(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === 'number') {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  (0, _assert.default)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}
},{"./assert":"node_modules/@math.gl/web-mercator/dist/esm/assert.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBounds;
var _webMercatorUtils = require("./web-mercator-utils");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var _mathUtils = require("./math-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const DEGREES_TO_RADIANS = Math.PI / 180;
function getBounds(viewport, z = 0) {
  const {
    width,
    height,
    unproject
  } = viewport;
  const unprojectOps = {
    targetZ: z
  };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x, targetZ) {
  const {
    pixelUnprojectionMatrix
  } = viewport;
  const coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, 0, 1, 1]);
  const coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = vec2.lerp([], coord0, coord1, t);
  const result = (0, _webMercatorUtils.worldToLngLat)(coord);
  result.push(targetZ);
  return result;
}
},{"./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _mathUtils = require("./math-utils");
var _webMercatorUtils = require("./web-mercator-utils");
var _fitBounds = _interopRequireDefault(require("./fit-bounds"));
var _getBounds = _interopRequireDefault(require("./get-bounds"));
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WebMercatorViewport {
  constructor(props = {
    width: 1,
    height: 1
  }) {
    (0, _defineProperty2.default)(this, "latitude", void 0);
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "zoom", void 0);
    (0, _defineProperty2.default)(this, "pitch", void 0);
    (0, _defineProperty2.default)(this, "bearing", void 0);
    (0, _defineProperty2.default)(this, "altitude", void 0);
    (0, _defineProperty2.default)(this, "fovy", void 0);
    (0, _defineProperty2.default)(this, "meterOffset", void 0);
    (0, _defineProperty2.default)(this, "center", void 0);
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "scale", void 0);
    (0, _defineProperty2.default)(this, "distanceScales", void 0);
    (0, _defineProperty2.default)(this, "viewMatrix", void 0);
    (0, _defineProperty2.default)(this, "projectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "viewProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelUnprojectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "equals", viewport => {
      if (!(viewport instanceof WebMercatorViewport)) {
        return false;
      }
      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
    });
    (0, _defineProperty2.default)(this, "project", (lngLatZ, options = {}) => {
      const {
        topLeft = true
      } = options;
      const worldPosition = this.projectPosition(lngLatZ);
      const coord = (0, _webMercatorUtils.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
      const [x, y] = coord;
      const y2 = topLeft ? y : this.height - y;
      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];
    });
    (0, _defineProperty2.default)(this, "unproject", (xyz, options = {}) => {
      const {
        topLeft = true,
        targetZ = undefined
      } = options;
      const [x, y, z] = xyz;
      const y2 = topLeft ? y : this.height - y;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    });
    (0, _defineProperty2.default)(this, "projectPosition", xyz => {
      const [X, Y] = (0, _webMercatorUtils.lngLatToWorld)(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    });
    (0, _defineProperty2.default)(this, "unprojectPosition", xyz => {
      const [X, Y] = (0, _webMercatorUtils.worldToLngLat)(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    });
    let {
      width,
      height,
      altitude = null,
      fovy = null
    } = props;
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      position = null,
      nearZMultiplier = 0.02,
      farZMultiplier = 1.01
    } = props;
    width = width || 1;
    height = height || 1;
    if (fovy === null && altitude === null) {
      altitude = _webMercatorUtils.DEFAULT_ALTITUDE;
      fovy = (0, _webMercatorUtils.altitudeToFovy)(altitude);
    } else if (fovy === null) {
      fovy = (0, _webMercatorUtils.altitudeToFovy)(altitude);
    } else if (altitude === null) {
      altitude = (0, _webMercatorUtils.fovyToAltitude)(fovy);
    }
    const scale = (0, _webMercatorUtils.zoomToScale)(zoom);
    altitude = Math.max(0.75, altitude);
    const distanceScales = (0, _webMercatorUtils.getDistanceScales)({
      longitude,
      latitude
    });
    const center = (0, _webMercatorUtils.lngLatToWorld)([longitude, latitude]);
    center.push(0);
    if (position) {
      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));
    }
    this.projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
      width,
      height,
      scale,
      center,
      pitch,
      fovy,
      nearZMultiplier,
      farZMultiplier
    });
    this.viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
      height,
      scale,
      center,
      pitch,
      bearing,
      altitude
    });
    this.width = width;
    this.height = height;
    this.scale = scale;
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.center = center;
    this.meterOffset = position || [0, 0, 0];
    this.distanceScales = distanceScales;
    this._initMatrices();
    Object.freeze(this);
  }
  _initMatrices() {
    const {
      width,
      height,
      projectionMatrix,
      viewMatrix
    } = this;
    const vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, projectionMatrix);
    mat4.multiply(vpm, vpm, viewMatrix);
    this.viewProjectionMatrix = vpm;
    const m = (0, _mathUtils.createMat4)();
    mat4.scale(m, m, [width / 2, -height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);
    mat4.multiply(m, m, vpm);
    const mInverse = mat4.invert((0, _mathUtils.createMat4)(), m);
    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }
    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
  }
  projectFlat(lngLat) {
    return (0, _webMercatorUtils.lngLatToWorld)(lngLat);
  }
  unprojectFlat(xy) {
    return (0, _webMercatorUtils.worldToLngLat)(xy);
  }
  getMapCenterByLngLatPosition({
    lngLat,
    pos
  }) {
    const fromLocation = (0, _webMercatorUtils.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
    const toLocation = (0, _webMercatorUtils.lngLatToWorld)(lngLat);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    return (0, _webMercatorUtils.worldToLngLat)(newCenter);
  }
  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0, _fitBounds.default)(Object.assign({
      width,
      height,
      bounds
    }, options));
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }
  getBounds(options) {
    const corners = this.getBoundingRegion(options);
    const west = Math.min(...corners.map(p => p[0]));
    const east = Math.max(...corners.map(p => p[0]));
    const south = Math.min(...corners.map(p => p[1]));
    const north = Math.max(...corners.map(p => p[1]));
    return [[west, south], [east, north]];
  }
  getBoundingRegion(options = {}) {
    return (0, _getBounds.default)(this, options.z || 0);
  }
  getLocationAtPoint({
    lngLat,
    pos
  }) {
    return this.getMapCenterByLngLatPosition({
      lngLat,
      pos
    });
  }
}
exports.default = WebMercatorViewport;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","./fit-bounds":"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js","./get-bounds":"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeViewportProps;
var _webMercatorUtils = require("./web-mercator-utils");
var _mathUtils = require("./math-utils");
const TILE_SIZE = 512;
function normalizeViewportProps(props) {
  const {
    width,
    height,
    pitch = 0
  } = props;
  let {
    longitude,
    latitude,
    zoom,
    bearing = 0
  } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
  }
  const minZoom = (0, _mathUtils.log2)(height / TILE_SIZE);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = (0, _webMercatorUtils.worldToLngLat)([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = (0, _webMercatorUtils.worldToLngLat)([0, TILE_SIZE - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return {
    width,
    height,
    longitude,
    latitude,
    zoom,
    pitch,
    bearing
  };
}
},{"./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flyToViewport;
exports.getFlyToDuration = getFlyToDuration;
var _mathUtils = require("./math-utils");
var _webMercatorUtils = require("./web-mercator-utils");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const EPSILON = 0.01;
const VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];
const DEFAULT_OPTS = {
  curve: 1.414,
  speed: 1.2
};
function flyToViewport(startProps, endProps, t, options) {
  const {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0
  } = getFlyToTransitionParams(startProps, endProps, options);
  if (u1 < EPSILON) {
    const viewport = {};
    for (const key of VIEWPORT_TRANSITION_PROPS) {
      const startValue = startProps[key];
      const endValue = endProps[key];
      viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
    }
    return viewport;
  }
  const s = t * S;
  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  const scaleIncrement = 1 / w;
  const newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);
  const newCenterWorld = vec2.scale([], uDelta, u);
  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);
  const newCenter = (0, _webMercatorUtils.worldToLngLat)(newCenterWorld);
  return {
    longitude: newCenter[0],
    latitude: newCenter[1],
    zoom: newZoom
  };
}
function getFlyToDuration(startProps, endProps, options) {
  const opts = {
    ...DEFAULT_OPTS,
    ...options
  };
  const {
    screenSpeed,
    speed,
    maxDuration
  } = opts;
  const {
    S,
    rho
  } = getFlyToTransitionParams(startProps, endProps, opts);
  const length = 1000 * S;
  let duration;
  if (Number.isFinite(screenSpeed)) {
    duration = length / (screenSpeed / rho);
  } else {
    duration = length / speed;
  }
  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function getFlyToTransitionParams(startProps, endProps, opts) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const rho = opts.curve;
  const startZoom = startProps.zoom;
  const startCenter = [startProps.longitude, startProps.latitude];
  const startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
  const endZoom = endProps.zoom;
  const endCenter = [endProps.longitude, endProps.latitude];
  const scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);
  const startCenterXY = (0, _webMercatorUtils.lngLatToWorld)(startCenter);
  const endCenterXY = (0, _webMercatorUtils.lngLatToWorld)(endCenter);
  const uDelta = vec2.sub([], endCenterXY, startCenterXY);
  const w0 = Math.max(startProps.width, startProps.height);
  const w1 = w0 / scale;
  const u1 = vec2.length(uDelta) * startScale;
  const _u1 = Math.max(u1, EPSILON);
  const rho2 = rho * rho;
  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  const S = (r1 - r0) / rho;
  return {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0,
    r1
  };
}
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js"}],"node_modules/@math.gl/web-mercator/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MAX_LATITUDE", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.MAX_LATITUDE;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "addMetersToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.addMetersToLngLat;
  }
});
Object.defineProperty(exports, "altitudeToFovy", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.altitudeToFovy;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "fitBounds", {
  enumerable: true,
  get: function () {
    return _fitBounds.default;
  }
});
Object.defineProperty(exports, "flyToViewport", {
  enumerable: true,
  get: function () {
    return _flyToViewport.default;
  }
});
Object.defineProperty(exports, "fovyToAltitude", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.fovyToAltitude;
  }
});
Object.defineProperty(exports, "getBounds", {
  enumerable: true,
  get: function () {
    return _getBounds.default;
  }
});
Object.defineProperty(exports, "getDistanceScales", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getDistanceScales;
  }
});
Object.defineProperty(exports, "getFlyToDuration", {
  enumerable: true,
  get: function () {
    return _flyToViewport.getFlyToDuration;
  }
});
Object.defineProperty(exports, "getMeterZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getMeterZoom;
  }
});
Object.defineProperty(exports, "getProjectionMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionMatrix;
  }
});
Object.defineProperty(exports, "getProjectionParameters", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionParameters;
  }
});
Object.defineProperty(exports, "getViewMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "lngLatToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "normalizeViewportProps", {
  enumerable: true,
  get: function () {
    return _normalizeViewportProps.default;
  }
});
Object.defineProperty(exports, "pixelsToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.pixelsToWorld;
  }
});
Object.defineProperty(exports, "scaleToZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.scaleToZoom;
  }
});
Object.defineProperty(exports, "unitsPerMeter", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.unitsPerMeter;
  }
});
Object.defineProperty(exports, "worldToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToLngLat;
  }
});
Object.defineProperty(exports, "worldToPixels", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToPixels;
  }
});
Object.defineProperty(exports, "zoomToScale", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.zoomToScale;
  }
});
var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));
var _getBounds = _interopRequireDefault(require("./get-bounds"));
var _fitBounds = _interopRequireDefault(require("./fit-bounds"));
var _normalizeViewportProps = _interopRequireDefault(require("./normalize-viewport-props"));
var _flyToViewport = _interopRequireWildcard(require("./fly-to-viewport"));
var _webMercatorUtils = require("./web-mercator-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./web-mercator-viewport":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js","./get-bounds":"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","./fit-bounds":"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js","./normalize-viewport-props":"node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js","./fly-to-viewport":"node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _constants = require("../../lib/constants");
var _project = _interopRequireDefault(require("../project/project"));
var _core = require("@math.gl/core");
var _memoize = _interopRequireDefault(require("../../utils/memoize"));
var _webMercator = require("@math.gl/web-mercator");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
const fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
const getMemoizedViewportCenterPosition = (0, _memoize.default)(getViewportCenterPosition);
const getMemoizedViewProjectionMatrices = (0, _memoize.default)(getViewProjectionMatrices);
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x, y, z] = xyz;
  const coord = (0, _webMercator.pixelsToWorld)([x, y, z], pixelUnprojectionMatrix);
  if (Number.isFinite(z)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition({
  viewport,
  center
}) {
  return new _core.Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices({
  viewport,
  shadowMatrices
}) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? undefined : 1;
  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix = shadowMatrix.clone().translate(new _core.Vector3(viewport.center).negate());
    const positions = corners.map(corner => viewMatrix.transform(corner));
    const projectionMatrix = new _core.Matrix4().ortho({
      left: Math.min(...positions.map(position => position[0])),
      right: Math.max(...positions.map(position => position[0])),
      bottom: Math.min(...positions.map(position => position[1])),
      top: Math.max(...positions.map(position => position[1])),
      near: Math.min(...positions.map(position => -position[2])),
      far: Math.max(...positions.map(position => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }
  return projectionMatrices;
}
function createShadowUniforms(opts, context) {
  const {
    shadowEnabled = true
  } = opts;
  if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      shadow_uDrawShadowMap: false,
      shadow_uUseShadowMap: false
    };
  }
  const uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();
  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new _core.Vector3(opts.viewport.center).negate());
    if (context.project_uCoordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === _constants.PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }
  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
    uniforms["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];
    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
    } else {
      uniforms["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
    }
  }
  return uniforms;
}
var _default = {
  name: 'shadow',
  dependencies: [_project.default],
  vs,
  fs,
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
    'fs:DECKGL_FILTER_COLOR': "\n    color = shadow_filterShadowColor(color);\n    "
  },
  getUniforms: (opts = {}, context = {}) => {
    if ('viewport' in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
      return createShadowUniforms(opts, context);
    }
    return {};
  }
};
exports.default = _default;
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _ambientLight = require("./ambient-light");
var _directionalLight = require("./directional-light");
var _core2 = require("@math.gl/core");
var _shadowPass = _interopRequireDefault(require("../../passes/shadow-pass"));
var _shadow = _interopRequireDefault(require("../../shaderlib/shadow/shadow"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1.0
};
const DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
  color: [255, 255, 255],
  intensity: 1.0,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}];
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];
class LightingEffect {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", 'lighting-effect');
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "shadowColor", DEFAULT_SHADOW_COLOR);
    (0, _defineProperty2.default)(this, "shadow", void 0);
    (0, _defineProperty2.default)(this, "ambientLight", void 0);
    (0, _defineProperty2.default)(this, "directionalLights", void 0);
    (0, _defineProperty2.default)(this, "pointLights", void 0);
    (0, _defineProperty2.default)(this, "shadowPasses", []);
    (0, _defineProperty2.default)(this, "shadowMaps", []);
    (0, _defineProperty2.default)(this, "dummyShadowMap", null);
    (0, _defineProperty2.default)(this, "programManager", void 0);
    (0, _defineProperty2.default)(this, "shadowMatrices", void 0);
    this.setProps(props);
  }
  setProps(props) {
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];
    for (const key in props) {
      const lightSource = props[key];
      switch (lightSource.type) {
        case 'ambient':
          this.ambientLight = lightSource;
          break;
        case 'directional':
          this.directionalLights.push(lightSource);
          break;
        case 'point':
          this.pointLights.push(lightSource);
          break;
        default:
      }
    }
    this._applyDefaultLights();
    this.shadow = this.directionalLights.some(light => light.shadow);
    this.props = props;
  }
  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.shadow) return;
    this.shadowMatrices = this._calculateMatrices();
    if (this.shadowPasses.length === 0) {
      this._createShadowPasses(gl);
    }
    if (!this.programManager) {
      this.programManager = _core.ProgramManager.getDefaultProgramManager(gl);
      if (_shadow.default) {
        this.programManager.addDefaultModule(_shadow.default);
      }
    }
    if (!this.dummyShadowMap) {
      this.dummyShadowMap = new _core.Texture2D(gl, {
        width: 1,
        height: 1
      });
    }
    for (let i = 0; i < this.shadowPasses.length; i++) {
      const shadowPass = this.shadowPasses[i];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        moduleParameters: {
          shadowLightId: i,
          dummyShadowMap: this.dummyShadowMap,
          shadowMatrices: this.shadowMatrices
        }
      });
    }
  }
  getModuleParameters(layer) {
    const parameters = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    parameters.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({
        layer
      })),
      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({
        layer
      }))
    };
    return parameters;
  }
  cleanup() {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }
    this.shadowPasses.length = 0;
    this.shadowMaps.length = 0;
    if (this.dummyShadowMap) {
      this.dummyShadowMap.delete();
      this.dummyShadowMap = null;
    }
    if (this.shadow && this.programManager) {
      this.programManager.removeDefaultModule(_shadow.default);
      this.programManager = null;
    }
  }
  _calculateMatrices() {
    const lightMatrices = [];
    for (const light of this.directionalLights) {
      const viewMatrix = new _core2.Matrix4().lookAt({
        eye: new _core2.Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix);
    }
    return lightMatrices;
  }
  _createShadowPasses(gl) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const shadowPass = new _shadowPass.default(gl);
      this.shadowPasses[i] = shadowPass;
      this.shadowMaps[i] = shadowPass.shadowMap;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = this;
    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new _ambientLight.AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new _directionalLight.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new _directionalLight.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }
}
exports.default = LightingEffect;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./ambient-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js","./directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../passes/shadow-pass":"node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js","../../shaderlib/shadow/shadow":"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js"}],"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TypedArrayManager = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TypedArrayManager {
  constructor(options = {}) {
    (0, _defineProperty2.default)(this, "_pool", []);
    (0, _defineProperty2.default)(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    });
    this.setOptions(options);
  }
  setOptions(options) {
    Object.assign(this.opts, options);
  }
  allocate(typedArray, count, {
    size = 1,
    type,
    padding = 0,
    copy = false,
    initialize = false,
    maxCount
  }) {
    const Type = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count * size + padding;
    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }
      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type(typedArray.buffer, 0, newSize);
      }
    }
    let maxSize = Infinity;
    if (maxCount) {
      maxSize = maxCount * size + padding;
    }
    const newArray = this._allocate(Type, newSize, initialize, maxSize);
    if (typedArray && copy) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }
    this._release(typedArray);
    return newArray;
  }
  release(typedArray) {
    this._release(typedArray);
  }
  _allocate(Type, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }
    const pool = this._pool;
    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
    const i = pool.findIndex(b => b.byteLength >= byteLength);
    if (i >= 0) {
      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
      if (initialize) {
        array.fill(0);
      }
      return array;
    }
    return new Type(sizeToAllocate);
  }
  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }
    const pool = this._pool;
    const {
      buffer
    } = typedArray;
    const {
      byteLength
    } = buffer;
    const i = pool.findIndex(b => b.byteLength >= byteLength);
    if (i < 0) {
      pool.push(buffer);
    } else if (i > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i, 0, buffer);
    }
    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }
}
exports.TypedArrayManager = TypedArrayManager;
var _default = new TypedArrayManager();
exports.default = _default;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMat4 = createMat4;
exports.fp64LowPart = fp64LowPart;
exports.getCameraPosition = getCameraPosition;
exports.getFrustumPlanes = getFrustumPlanes;
exports.mergeBounds = mergeBounds;
exports.mod = mod;
exports.toDoublePrecisionArray = toDoublePrecisionArray;
var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
const scratchVector = new _core.Vector3();
function getFrustumPlane(a, b, c, d) {
  scratchVector.set(a, b, c);
  const L = scratchVector.len();
  return {
    distance: d / L,
    normal: new _core.Vector3(-a / L, -b / L, -c / L)
  };
}
function fp64LowPart(x) {
  return x - Math.fround(x);
}
let scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const {
    size = 1,
    startIndex = 0
  } = options;
  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;
  const count = (endIndex - startIndex) / size;
  scratchArray = _typedArrayManager.default.allocate(scratchArray, count, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (let j = 0; j < size; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size] = fp64LowPart(value);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;
  for (const bounds of boundsList) {
    if (!bounds) continue;
    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
        isMerged = true;
      }
      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }
  return mergedBounds;
}
},{"./typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _log = _interopRequireDefault(require("../utils/log"));
var _mathUtils = require("../utils/math-utils");
var _core = require("@math.gl/core");
var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));
var _webMercator = require("@math.gl/web-mercator");
var _constants = require("../lib/constants");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEGREES_TO_RADIANS = Math.PI / 180;
const IDENTITY = (0, _mathUtils.createMat4)();
const ZERO_VECTOR = [0, 0, 0];
const DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function createProjectionMatrix({
  width,
  height,
  orthographic,
  fovyRadians,
  focalDistance,
  padding,
  near,
  far
}) {
  const aspect = width / height;
  const matrix = orthographic ? new _core.Matrix4().orthographic({
    fovy: fovyRadians,
    aspect,
    focalDistance,
    near,
    far
  }) : new _core.Matrix4().perspective({
    fovy: fovyRadians,
    aspect,
    near,
    far
  });
  if (padding) {
    const {
      left = 0,
      right = 0,
      top = 0,
      bottom = 0
    } = padding;
    const offsetX = (0, _core.clamp)((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = (0, _core.clamp)((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }
  return matrix;
}
class Viewport {
  constructor(opts = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "x", void 0);
    (0, _defineProperty2.default)(this, "y", void 0);
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "padding", void 0);
    (0, _defineProperty2.default)(this, "isGeospatial", void 0);
    (0, _defineProperty2.default)(this, "zoom", void 0);
    (0, _defineProperty2.default)(this, "focalDistance", void 0);
    (0, _defineProperty2.default)(this, "position", void 0);
    (0, _defineProperty2.default)(this, "modelMatrix", void 0);
    (0, _defineProperty2.default)(this, "distanceScales", void 0);
    (0, _defineProperty2.default)(this, "scale", void 0);
    (0, _defineProperty2.default)(this, "center", void 0);
    (0, _defineProperty2.default)(this, "cameraPosition", void 0);
    (0, _defineProperty2.default)(this, "projectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "viewMatrix", void 0);
    (0, _defineProperty2.default)(this, "viewMatrixUncentered", void 0);
    (0, _defineProperty2.default)(this, "viewMatrixInverse", void 0);
    (0, _defineProperty2.default)(this, "viewProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelProjectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "pixelUnprojectionMatrix", void 0);
    (0, _defineProperty2.default)(this, "resolution", void 0);
    (0, _defineProperty2.default)(this, "_frustumPlanes", {});
    this.id = opts.id || this.constructor.displayName || 'viewport';
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR;
    this.modelMatrix = opts.modelMatrix || null;
    const {
      longitude,
      latitude
    } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this._initProps(opts);
    this._initMatrices(opts);
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? _constants.PROJECTION_MODE.WEB_MERCATOR : _constants.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }
    return _constants.PROJECTION_MODE.IDENTITY;
  }
  equals(viewport) {
    if (!(viewport instanceof Viewport)) {
      return false;
    }
    if (this === viewport) {
      return true;
    }
    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, _core.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _core.equals)(viewport.viewMatrix, this.viewMatrix);
  }
  project(xyz, {
    topLeft = true
  } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = (0, _webMercator.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
    const [x, y] = coord;
    const y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }
  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = (0, _webMercator.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X, Y, Z] = this.unprojectPosition(coord);
    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }
    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }
  projectPosition(xyz) {
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X, Y, Z];
  }
  unprojectPosition(xyz) {
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X, Y, Z];
  }
  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = (0, _webMercator.lngLatToWorld)(xyz);
      result[1] = (0, _core.clamp)(result[1], -318, 830);
      return result;
    }
    return xyz;
  }
  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return (0, _webMercator.worldToLngLat)(xyz);
    }
    return xyz;
  }
  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }
  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin) {
      return (0, _webMercator.getDistanceScales)({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }
    return this.distanceScales;
  }
  containsPixel({
    x,
    y,
    width = 1,
    height = 1
  }) {
    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
  }
  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }
    Object.assign(this._frustumPlanes, (0, _mathUtils.getFrustumPlanes)(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }
  panByPosition(coords, pixel) {
    return null;
  }
  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;
    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = (0, _webMercator.getMeterZoom)({
          latitude
        }) + Math.log2(this.focalDistance);
      }
      this.distanceScales = opts.distanceScales || (0, _webMercator.getDistanceScales)({
        latitude,
        longitude
      });
    }
    const scale = Math.pow(2, this.zoom);
    this.scale = scale;
    const {
      position,
      modelMatrix
    } = opts;
    let meterOffset = ZERO_VECTOR;
    if (position) {
      meterOffset = modelMatrix ? new _core.Matrix4(modelMatrix).transformAsVector(position, []) : position;
    }
    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new _core.Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }
  _initMatrices(opts) {
    const {
      viewMatrix = IDENTITY,
      projectionMatrix = null,
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      far = 1000,
      padding = null,
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix;
    this.viewMatrix = new _core.Matrix4().multiplyRight(viewMatrix).translate(new _core.Vector3(this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = (0, _mathUtils.getCameraPosition)(this.viewMatrixInverse);
    const viewportMatrix = (0, _mathUtils.createMat4)();
    const pixelProjectionMatrix = (0, _mathUtils.createMat4)();
    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = mat4.invert((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);
    if (!this.pixelUnprojectionMatrix) {
      _log.default.warn('Pixel project matrix not invertible')();
    }
  }
}
exports.default = Viewport;
(0, _defineProperty2.default)(Viewport, "displayName", 'Viewport');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("./viewport"));
var _webMercator = require("@math.gl/web-mercator");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
var _core = require("@math.gl/core");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class WebMercatorViewport extends _viewport.default {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      legacyMeterSizes = false
    } = opts;
    let {
      width,
      height,
      altitude = 1.5
    } = opts;
    const scale = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;
    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = (0, _webMercator.altitudeToFovy)(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = (0, _webMercator.fovyToAltitude)(fovy);
      } else {
        fovy = (0, _webMercator.altitudeToFovy)(altitude);
      }
      let offset;
      if (padding) {
        const {
          top = 0,
          bottom = 0
        } = padding;
        offset = [0, (0, _core.clamp)((top + height - bottom) / 2, 0, height) - height / 2];
      }
      projectionParameters = (0, _webMercator.getProjectionParameters)({
        width,
        height,
        scale,
        center: position && [0, 0, position[2] * (0, _webMercator.unitsPerMeter)(latitude)],
        offset,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
    }
    let viewMatrixUncentered = (0, _webMercator.getViewMatrix)({
      height,
      pitch,
      bearing,
      scale,
      altitude
    });
    if (worldOffset) {
      const viewOffset = new _core.Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }
    super({
      ...opts,
      width,
      height,
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "latitude", void 0);
    (0, _defineProperty2.default)(this, "pitch", void 0);
    (0, _defineProperty2.default)(this, "bearing", void 0);
    (0, _defineProperty2.default)(this, "altitude", void 0);
    (0, _defineProperty2.default)(this, "fovy", void 0);
    (0, _defineProperty2.default)(this, "orthographic", void 0);
    (0, _defineProperty2.default)(this, "_subViewports", void 0);
    (0, _defineProperty2.default)(this, "_pseudoMeters", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);
      for (let x = minOffset; x <= maxOffset; x++) {
        const offsetViewport = x ? new WebMercatorViewport({
          ...this,
          worldOffset: x
        }) : this;
        this._subViewports.push(offsetViewport);
      }
    }
    return this._subViewports;
  }
  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * (0, _webMercator.unitsPerMeter)(xyz[1]);
    return [X, Y, Z];
  }
  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) / (0, _webMercator.unitsPerMeter)(Y);
    return [X, Y, Z];
  }
  addMetersToLngLat(lngLatZ, xyz) {
    return (0, _webMercator.addMetersToLngLat)(lngLatZ, xyz);
  }
  panByPosition(coords, pixel) {
    const fromLocation = (0, _webMercator.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return {
      longitude,
      latitude
    };
  }
  getBounds(options = {}) {
    const corners = (0, _webMercator.getBounds)(this, options.z || 0);
    return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
  }
  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0, _webMercator.fitBounds)({
      width,
      height,
      bounds,
      ...options
    });
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }
}
exports.default = WebMercatorViewport;
(0, _defineProperty2.default)(WebMercatorViewport, "displayName", 'WebMercatorViewport');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorldPosition = getWorldPosition;
exports.projectPosition = projectPosition;
var _constants = require("../../lib/constants");
var _viewportUniforms = require("./viewport-uniforms");
var _webMercatorViewport = _interopRequireDefault(require("../../viewports/web-mercator-viewport"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var _webMercator = require("@math.gl/web-mercator");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof _webMercatorViewport.default) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }
  return p;
}
function normalizeParameters(opts) {
  const {
    viewport,
    modelMatrix,
    coordinateOrigin
  } = opts;
  let {
    coordinateSystem,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = opts;
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === undefined) {
    fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === undefined) {
    fromCoordinateOrigin = coordinateOrigin;
  }
  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}
function getWorldPosition(position, {
  viewport,
  modelMatrix,
  coordinateSystem,
  coordinateOrigin,
  offsetMode
}) {
  let [x, y, z = 0] = position;
  if (modelMatrix) {
    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);
  }
  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);
    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition((0, _webMercator.addMetersToLngLat)(coordinateOrigin, [x, y, z]), viewport, offsetMode);
    case _constants.COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}
function projectPosition(position, params) {
  const {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = normalizeParameters(params);
  const {
    autoOffset = true
  } = params;
  const {
    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN,
    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    offsetMode = false
  } = autoOffset ? (0, _viewportUniforms.getOffsetOrigin)(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    vec3.sub(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js","../../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointLight = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _projectFunctions = require("../../shaderlib/project/project-functions");
var _constants = require("../../lib/constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_ATTENUATION = [0, 0, 1];
const DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];
let idCount = 0;
class PointLight {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "color", void 0);
    (0, _defineProperty2.default)(this, "intensity", void 0);
    (0, _defineProperty2.default)(this, "type", 'point');
    (0, _defineProperty2.default)(this, "position", void 0);
    (0, _defineProperty2.default)(this, "attenuation", void 0);
    (0, _defineProperty2.default)(this, "projectedLight", void 0);
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      position = DEFAULT_LIGHT_POSITION
    } = props;
    this.id = props.id || "point-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'point';
    this.position = position;
    this.attenuation = getAttenuation(props);
    this.projectedLight = {
      ...this
    };
  }
  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin
    } = layer.props;
    const position = (0, _projectFunctions.projectPosition)(this.position, {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      fromCoordinateSystem: viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN,
      fromCoordinateOrigin: [0, 0, 0]
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = position;
    return projectedLight;
  }
}
exports.PointLight = PointLight;
function getAttenuation(props) {
  if (props.attenuation) {
    return props.attenuation;
  }
  if ('intensity' in props) {
    return [0, 0, props.intensity || 0];
  }
  return DEFAULT_ATTENUATION;
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../shaderlib/project/project-functions":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _pointLight = require("./point-light");
var _viewportUniforms = require("../../shaderlib/project/viewport-uniforms");
class CameraLight extends _pointLight.PointLight {
  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin,
      modelMatrix
    } = layer.props;
    const {
      project_uCameraPosition
    } = (0, _viewportUniforms.getUniformsFromViewport)({
      viewport,
      modelMatrix,
      coordinateSystem,
      coordinateOrigin
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = project_uCameraPosition;
    return projectedLight;
  }
}
exports.default = CameraLight;
},{"./point-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","../../shaderlib/project/viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"node_modules/@math.gl/sun/dist/esm/suncalc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSunDirection = getSunDirection;
exports.getSunPosition = getSunPosition;
const DEGREES_TO_RADIANS = Math.PI / 180;
const DAY_IN_MS = 1000 * 60 * 60 * 24;
const JD1970 = 2440588;
const JD2000 = 2451545;
const e = DEGREES_TO_RADIANS * 23.4397;
const M0 = 357.5291;
const M1 = 0.98560028;
const THETA0 = 280.147;
const THETA1 = 360.9856235;
function getSunPosition(timestamp, latitude, longitude) {
  const longitudeWestInRadians = DEGREES_TO_RADIANS * -longitude;
  const phi = DEGREES_TO_RADIANS * latitude;
  const d = toDays(timestamp);
  const c = getSunCoords(d);
  const H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}
function getSunDirection(timestamp, latitude, longitude) {
  const {
    azimuth,
    altitude
  } = getSunPosition(timestamp, latitude, longitude);
  return [Math.sin(azimuth) * Math.cos(altitude), Math.cos(azimuth) * Math.cos(altitude), -Math.sin(altitude)];
}
function toJulianDay(timestamp) {
  const ts = typeof timestamp === 'number' ? timestamp : timestamp.getTime();
  return ts / DAY_IN_MS - 0.5 + JD1970;
}
function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}
function getRightAscension(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}
function getDeclination(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}
function getAzimuth(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}
function getAltitude(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}
function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}
function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS * (M0 + M1 * days);
}
function getEclipticLongitude(meanAnomaly) {
  const M = meanAnomaly;
  const C = DEGREES_TO_RADIANS * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
  const P = DEGREES_TO_RADIANS * 102.9372;
  return M + C + P + Math.PI;
}
function getSunCoords(dates) {
  const M = getSolarMeanAnomaly(dates);
  const L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}
},{}],"node_modules/@math.gl/sun/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getSunDirection", {
  enumerable: true,
  get: function () {
    return _suncalc.getSunDirection;
  }
});
Object.defineProperty(exports, "getSunPosition", {
  enumerable: true,
  get: function () {
    return _suncalc.getSunPosition;
  }
});
var _suncalc = require("./suncalc");
},{"./suncalc":"node_modules/@math.gl/sun/dist/esm/suncalc.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _directionalLight = require("./directional-light");
var _sun = require("@math.gl/sun");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class SunLight extends _directionalLight.DirectionalLight {
  constructor(opts) {
    super(opts);
    (0, _defineProperty2.default)(this, "timestamp", void 0);
    this.timestamp = opts.timestamp;
  }
  getProjectedLight({
    layer
  }) {
    const {
      viewport
    } = layer.context;
    const isGlobe = viewport.resolution && viewport.resolution > 0;
    if (isGlobe) {
      const [x, y, z] = (0, _sun.getSunDirection)(this.timestamp, 0, 0);
      this.direction = [x, -z, y];
    } else {
      const {
        latitude,
        longitude
      } = viewport;
      this.direction = (0, _sun.getSunDirection)(this.timestamp, latitude, longitude);
    }
    return this;
  }
}
exports.default = SunLight;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","@math.gl/sun":"node_modules/@math.gl/sun/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _pass = _interopRequireDefault(require("./pass"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ScreenPass extends _pass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "model", void 0);
    const {
      module,
      fs,
      id
    } = props;
    this.model = new _core.ClipSpace(gl, {
      id,
      fs,
      modules: [module]
    });
  }
  render(params) {
    const gl = this.gl;
    (0, _core.setParameters)(gl, {
      viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
    });
    (0, _core.withParameters)(gl, {
      framebuffer: params.outputBuffer,
      clearColor: [0, 0, 0, 0]
    }, () => this._renderPass(gl, params));
  }
  delete() {
    this.model.delete();
    this.model = null;
  }
  _renderPass(gl, options) {
    const {
      inputBuffer
    } = options;
    (0, _core.clear)(gl, {
      color: true
    });
    this.model.draw({
      moduleSettings: options.moduleSettings,
      uniforms: {
        texture: inputBuffer,
        texSize: [inputBuffer.width, inputBuffer.height]
      },
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }
}
exports.default = ScreenPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./pass":"node_modules/@deck.gl/core/dist/esm/passes/pass.js"}],"node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _screenPass = _interopRequireDefault(require("../passes/screen-pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class PostProcessEffect {
  constructor(module, props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "module", void 0);
    (0, _defineProperty2.default)(this, "passes", void 0);
    this.id = "".concat(module.name, "-pass");
    this.props = props;
    (0, _core.normalizeShaderModule)(module);
    this.module = module;
  }
  setProps(props) {
    this.props = props;
  }
  preRender() {}
  postRender(gl, params) {
    const passes = this.passes || createPasses(gl, this.module, this.id);
    this.passes = passes;
    const {
      target
    } = params;
    let inputBuffer = params.inputBuffer;
    let outputBuffer = params.swapBuffer;
    for (let index = 0; index < this.passes.length; index++) {
      if (target && index === this.passes.length - 1) {
        outputBuffer = target;
      }
      this.passes[index].render({
        inputBuffer,
        outputBuffer,
        moduleSettings: this.props
      });
      const switchBuffer = outputBuffer;
      outputBuffer = inputBuffer;
      inputBuffer = switchBuffer;
    }
    return inputBuffer;
  }
  cleanup() {
    if (this.passes) {
      for (const pass of this.passes) {
        pass.delete();
      }
      this.passes = undefined;
    }
  }
}
exports.default = PostProcessEffect;
function createPasses(gl, module, id) {
  if (!module.passes) {
    const fs = getFragmentShaderForRenderPass(module);
    const pass = new _screenPass.default(gl, {
      id,
      module,
      fs
    });
    return [pass];
  }
  return module.passes.map((pass, index) => {
    const fs = getFragmentShaderForRenderPass(module, pass);
    const idn = "".concat(id, "-").concat(index);
    return new _screenPass.default(gl, {
      id: idn,
      module,
      fs
    });
  });
}
const FILTER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
const SAMPLER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
function getFragmentShaderForRenderPass(module, pass = module) {
  if (pass.filter) {
    const func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }
  if (pass.sampler) {
    const func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");
    return SAMPLER_FS_TEMPLATE(func);
  }
  return null;
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../passes/screen-pass":"node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layersPass = _interopRequireDefault(require("./layers-pass"));
var _core = require("@luma.gl/core");
var _log = _interopRequireDefault(require("../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const PICKING_PARAMETERS = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
class PickLayersPass extends _layersPass.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "pickZ", void 0);
    (0, _defineProperty2.default)(this, "_colorEncoderState", null);
  }
  render(props) {
    if ('pickingFBO' in props) {
      return this._drawPickingBuffer(props);
    }
    return super.render(props);
  }
  _drawPickingBuffer({
    layers,
    layerFilter,
    views,
    viewports,
    onViewportActive,
    pickingFBO,
    deviceRect: {
      x,
      y,
      width,
      height
    },
    cullRect,
    effects,
    pass = 'picking',
    pickZ,
    moduleParameters
  }) {
    const gl = this.gl;
    this.pickZ = pickZ;
    const colorEncoderState = this._resetColorEncoder(pickZ);
    const renderStatus = (0, _core.withParameters)(gl, {
      scissorTest: true,
      scissor: [x, y, width, height],
      clearColor: [0, 0, 0, 0],
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      colorMask: [true, true, true, true],
      ...PICKING_PARAMETERS,
      blend: !pickZ
    }, () => super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects === null || effects === void 0 ? void 0 : effects.filter(e => e.useInPicking),
      pass,
      isPicking: true,
      moduleParameters
    }));
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return {
      decodePickingColor,
      stats: renderStatus
    };
  }
  shouldDrawLayer(layer) {
    const {
      pickable,
      operation
    } = layer.props;
    return pickable && operation.includes('draw') || operation.includes('terrain');
  }
  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }
  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = {
      ...layer.props.parameters
    };
    const {
      pickable,
      operation
    } = layer.props;
    if (!this._colorEncoderState) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes('draw')) {
      Object.assign(pickParameters, PICKING_PARAMETERS);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }
    if (operation.includes('terrain')) {
      pickParameters.blend = false;
    }
    return pickParameters;
  }
  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }
}
exports.default = PickLayersPass;
function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;
  let entry = byLayer.get(layer);
  if (entry) {
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;
    if (a <= 255) {
      entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      _log.default.warn('Too many pickable layers, only picking the first 255')();
      a = 0;
    }
  }
  return [0, 0, 0, a / 255];
}
function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROP_TYPES_SYMBOL = exports.LIFECYCLE = exports.DEPRECATED_PROPS_SYMBOL = exports.COMPONENT_SYMBOL = exports.ASYNC_RESOLVED_SYMBOL = exports.ASYNC_ORIGINAL_SYMBOL = exports.ASYNC_DEFAULTS_SYMBOL = void 0;
const LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Initialized',
  AWAITING_GC: 'Discarded. Awaiting garbage collection',
  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
exports.LIFECYCLE = LIFECYCLE;
const COMPONENT_SYMBOL = Symbol.for('component');
exports.COMPONENT_SYMBOL = COMPONENT_SYMBOL;
const PROP_TYPES_SYMBOL = Symbol.for('propTypes');
exports.PROP_TYPES_SYMBOL = PROP_TYPES_SYMBOL;
const DEPRECATED_PROPS_SYMBOL = Symbol.for('deprecatedProps');
exports.DEPRECATED_PROPS_SYMBOL = DEPRECATED_PROPS_SYMBOL;
const ASYNC_DEFAULTS_SYMBOL = Symbol.for('asyncPropDefaults');
exports.ASYNC_DEFAULTS_SYMBOL = ASYNC_DEFAULTS_SYMBOL;
const ASYNC_ORIGINAL_SYMBOL = Symbol.for('asyncPropOriginal');
exports.ASYNC_ORIGINAL_SYMBOL = ASYNC_ORIGINAL_SYMBOL;
const ASYNC_RESOLVED_SYMBOL = Symbol.for('asyncPropResolved');
exports.ASYNC_RESOLVED_SYMBOL = ASYNC_RESOLVED_SYMBOL;
},{}],"node_modules/@deck.gl/core/dist/esm/utils/flatten.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillArray = fillArray;
exports.flatten = flatten;
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }
  return result;
}
function fillArray({
  target,
  source,
  start = 0,
  count = 1
}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;
  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@loaders.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Resource {
  constructor(id, data, context) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "isLoaded", void 0);
    (0, _defineProperty2.default)(this, "persistent", void 0);
    (0, _defineProperty2.default)(this, "_loadCount", 0);
    (0, _defineProperty2.default)(this, "_subscribers", new Set());
    (0, _defineProperty2.default)(this, "_data", void 0);
    (0, _defineProperty2.default)(this, "_loader", void 0);
    (0, _defineProperty2.default)(this, "_error", void 0);
    (0, _defineProperty2.default)(this, "_content", void 0);
    this.id = id;
    this.context = context;
    this.setData(data);
  }
  subscribe(consumer) {
    this._subscribers.add(consumer);
  }
  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {}
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }
    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;
    if (typeof data === 'string') {
      loader = (0, _core.load)(data);
    }
    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then(result => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = undefined;
          this._content = result;
        }
      }).catch(error => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = undefined;
      this._content = data;
    }
    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }
}
exports.default = Resource;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _resource = _interopRequireDefault(require("./resource"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ResourceManager {
  constructor({
    gl,
    protocol
  }) {
    (0, _defineProperty2.default)(this, "protocol", void 0);
    (0, _defineProperty2.default)(this, "_context", void 0);
    (0, _defineProperty2.default)(this, "_resources", void 0);
    (0, _defineProperty2.default)(this, "_consumers", void 0);
    (0, _defineProperty2.default)(this, "_pruneRequest", void 0);
    this.protocol = protocol || 'resource://';
    this._context = {
      gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }
  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }
    return resourceId in this._resources;
  }
  add({
    resourceId,
    data,
    forceUpdate = false,
    persistent = true
  }) {
    let res = this._resources[resourceId];
    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new _resource.default(resourceId, data, this._context);
      this._resources[resourceId] = res;
    }
    res.persistent = persistent;
  }
  remove(resourceId) {
    const res = this._resources[resourceId];
    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }
  unsubscribe({
    consumerId
  }) {
    const consumer = this._consumers[consumerId];
    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];
        if (resource) {
          resource.unsubscribe(request);
        }
      }
      delete this._consumers[consumerId];
      this.prune();
    }
  }
  subscribe({
    resourceId,
    onChange,
    consumerId,
    requestId = 'default'
  }) {
    const {
      _resources: resources,
      protocol
    } = this;
    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, '');
      if (!resources[resourceId]) {
        this.add({
          resourceId,
          data: null,
          persistent: false
        });
      }
    }
    const res = resources[resourceId];
    this._track(consumerId, requestId, res, onChange);
    if (res) {
      return res.getData();
    }
    return undefined;
  }
  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }
  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }
  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    const request = consumer[requestId] || {};
    const oldResource = request.resourceId && this._resources[request.resourceId];
    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }
    if (resource) {
      consumer[requestId] = request;
      request.onChange = onChange;
      request.resourceId = resource.id;
      resource.subscribe(request);
    }
  }
  _prune() {
    this._pruneRequest = null;
    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];
      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }
}
exports.default = ResourceManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./resource":"node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _project = _interopRequireDefault(require("../project/project"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
var _default = {
  name: 'project32',
  dependencies: [_project.default],
  vs
};
exports.default = _default;
},{"../project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@luma.gl/core");
var _default = {
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
    'vs:DECKGL_FILTER_COLOR': "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
    'fs:#decl': "\nuniform bool picking_uAttribute;\n  ",
    'fs:DECKGL_FILTER_COLOR': {
      order: 99,
      injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
    }
  },
  ..._core.picking
};
exports.default = _default;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProgramManager = createProgramManager;
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _core.gouraudLighting;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _core.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.default;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.default;
  }
});
Object.defineProperty(exports, "project32", {
  enumerable: true,
  get: function () {
    return _project2.default;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function () {
    return _shadow.default;
  }
});
var _core = require("@luma.gl/core");
var _project = _interopRequireDefault(require("./project/project"));
var _project2 = _interopRequireDefault(require("./project32/project32"));
var _shadow = _interopRequireDefault(require("./shadow/shadow"));
var _picking = _interopRequireDefault(require("./picking/picking"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_MODULES = [_project.default];
const SHADER_HOOKS = ['vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)', 'vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)', 'vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)', 'fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)'];
function createProgramManager(gl) {
  const programManager = _core.ProgramManager.getDefaultProgramManager(gl);
  for (const shaderModule of DEFAULT_MODULES) {
    programManager.addDefaultModule(shaderModule);
  }
  for (const shaderHook of SHADER_HOOKS) {
    programManager.addShaderHook(shaderHook);
  }
  return programManager;
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","./project32/project32":"node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js","./shadow/shadow":"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js","./picking/picking":"node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _constants = require("../lifecycle/constants");
var _log = _interopRequireDefault(require("../utils/log"));
var _debug = _interopRequireDefault(require("../debug"));
var _flatten = require("../utils/flatten");
var _stats = require("@probe.gl/stats");
var _resourceManager = _interopRequireDefault(require("./resource/resource-manager"));
var _viewport2 = _interopRequireDefault(require("../viewports/viewport"));
var _shaderlib = require("../shaderlib");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_SET_LAYERS = 'layerManager.setLayers';
const TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';
class LayerManager {
  constructor(gl, {
    deck,
    stats,
    viewport: _viewport,
    timeline
  } = {}) {
    (0, _defineProperty2.default)(this, "layers", void 0);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "resourceManager", void 0);
    (0, _defineProperty2.default)(this, "_lastRenderedLayers", []);
    (0, _defineProperty2.default)(this, "_needsRedraw", false);
    (0, _defineProperty2.default)(this, "_needsUpdate", false);
    (0, _defineProperty2.default)(this, "_nextLayers", null);
    (0, _defineProperty2.default)(this, "_debug", false);
    (0, _defineProperty2.default)(this, "activateViewport", viewport => {
      (0, _debug.default)(TRACE_ACTIVATE_VIEWPORT, this, viewport);
      if (viewport) {
        this.context.viewport = viewport;
      }
    });
    this.layers = [];
    this.resourceManager = new _resourceManager.default({
      gl,
      protocol: 'deck://'
    });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl,
      deck,
      programManager: gl && (0, _shaderlib.createProgramManager)(gl),
      stats: stats || new _stats.Stats({
        id: 'deck.gl'
      }),
      viewport: _viewport || new _viewport2.default({
        id: 'DEFAULT-INITIAL-VIEWPORT'
      }),
      timeline: timeline || new _core.Timeline(),
      resourceManager: this.resourceManager,
      onError: undefined
    };
    Object.seal(this);
  }
  finalize() {
    this.resourceManager.finalize();
    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }
    return redraw;
  }
  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return 'layers changed';
    }
    return this._needsUpdate;
  }
  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }
  getLayers({
    layerIds
  } = {}) {
    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;
  }
  setProps(props) {
    if ('debug' in props) {
      this._debug = props.debug;
    }
    if ('userData' in props) {
      this.context.userData = props.userData;
    }
    if ('layers' in props) {
      this._nextLayers = props.layers;
    }
    if ('onError' in props) {
      this.context.onError = props.onError;
    }
  }
  setLayers(newLayers, reason) {
    (0, _debug.default)(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = (0, _flatten.flatten)(newLayers, Boolean);
    for (const layer of flatLayers) {
      layer.context = this.context;
    }
    this._updateLayers(this.layers, flatLayers);
  }
  updateLayers() {
    const reason = this.needsUpdate();
    if (reason) {
      this.setNeedsRedraw("updating layers: ".concat(reason));
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }
    this._nextLayers = null;
  }
  _handleError(stage, error, layer) {
    layer.raiseError(error, "".concat(stage, " of ").concat(layer));
  }
  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};
    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        _log.default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }
    const generatedLayers = [];
    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
    this._finalizeOldLayers(oldLayerMap);
    let needsUpdate = false;
    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = "Uniform transition in ".concat(layer);
        break;
      }
    }
    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }
  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];
      if (oldLayer === null) {
        _log.default.warn("Multiple new layers with same id ".concat(newLayer.id))();
      }
      oldLayerMap[newLayer.id] = null;
      let sublayers = null;
      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }
        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);
          this._updateLayer(newLayer);
        }
        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err) {
        this._handleError('matching', err, newLayer);
      }
      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }
  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];
      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }
  _initializeLayer(layer) {
    try {
      layer._initialize();
      layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError('initialization', err, layer);
    }
  }
  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);
    newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
    }
  }
  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError('update', err, layer);
    }
  }
  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
    layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
    try {
      layer._finalize();
      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError('finalization', err, layer);
    }
  }
}
exports.default = LayerManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","./resource/resource-manager":"node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../shaderlib":"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepEqual = deepEqual;
function deepEqual(a, b, depth) {
  if (a === b) {
    return true;
  }
  if (!depth || !a || !b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(b)) {
    return false;
  }
  if (typeof a === 'object' && typeof b === 'object') {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }
      if (!deepEqual(a[key], b[key], depth - 1)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/view-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deepEqual = require("../utils/deep-equal");
var _log = _interopRequireDefault(require("../utils/log"));
var _flatten = require("../utils/flatten");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ViewManager {
  constructor(props) {
    (0, _defineProperty2.default)(this, "width", void 0);
    (0, _defineProperty2.default)(this, "height", void 0);
    (0, _defineProperty2.default)(this, "views", void 0);
    (0, _defineProperty2.default)(this, "viewState", void 0);
    (0, _defineProperty2.default)(this, "controllers", void 0);
    (0, _defineProperty2.default)(this, "timeline", void 0);
    (0, _defineProperty2.default)(this, "_viewports", void 0);
    (0, _defineProperty2.default)(this, "_viewportMap", void 0);
    (0, _defineProperty2.default)(this, "_isUpdating", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "_needsUpdate", void 0);
    (0, _defineProperty2.default)(this, "_eventManager", void 0);
    (0, _defineProperty2.default)(this, "_eventCallbacks", void 0);
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'First render';
    this._needsUpdate = 'Initialize';
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }
  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];
      if (controller) {
        controller.finalize();
      }
    }
    this.controllers = {};
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }
  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];
      if (controller) {
        controller.updateTransition();
      }
    }
  }
  getViewports(rect) {
    if (rect) {
      return this._viewports.filter(viewport => viewport.containsPixel(rect));
    }
    return this._viewports;
  }
  getViews() {
    const viewMap = {};
    this.views.forEach(view => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }
  getView(viewId) {
    return this.views.find(view => view.id === viewId);
  }
  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === 'string' ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }
  getViewport(viewId) {
    return this._viewportMap[viewId];
  }
  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = {
      x: xyz[0],
      y: xyz[1]
    };
    for (let i = viewports.length - 1; i >= 0; --i) {
      const viewport = viewports[i];
      if (viewport.containsPixel(pixel)) {
        const p = xyz.slice();
        p[0] -= viewport.x;
        p[1] -= viewport.y;
        return viewport.unproject(p, opts);
      }
    }
    return null;
  }
  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }
    if (props.viewState) {
      this._setViewState(props.viewState);
    }
    if ('width' in props || 'height' in props) {
      this._setSize(props.width, props.height);
    }
    if (!this._isUpdating) {
      this._update();
    }
  }
  _update() {
    this._isUpdating = true;
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this._rebuildViewports();
    }
    this._isUpdating = false;
  }
  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate('Size changed');
    }
  }
  _setViews(views) {
    views = (0, _flatten.flatten)(views, Boolean);
    const viewsChanged = this._diffViews(views, this.views);
    if (viewsChanged) {
      this.setNeedsUpdate('views changed');
    }
    this.views = views;
  }
  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !(0, _deepEqual.deepEqual)(viewState, this.viewState, 3);
      if (viewStateChanged) {
        this.setNeedsUpdate('viewState changed');
      }
      this.viewState = viewState;
    } else {
      _log.default.warn('missing `viewState` or `initialViewState`')();
    }
  }
  _onViewStateChange(viewId, event) {
    if (this._eventCallbacks.onViewStateChange) {
      this._eventCallbacks.onViewStateChange({
        ...event,
        viewId
      });
    }
  }
  _createController(view, props) {
    const Controller = props.type;
    const controller = new Controller({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, props.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: viewState => {
        var _this$getView;
        return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
      }
    });
    return controller;
  }
  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;
    if (controllerProps) {
      const resolvedProps = {
        ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };
      if (!controller) {
        controller = this._createController(view, resolvedProps);
      }
      if (controller) {
        controller.setProps(resolvedProps);
      }
      return controller;
    }
    return null;
  }
  _rebuildViewports() {
    const {
      views
    } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;
    for (let i = views.length; i--;) {
      const view = views[i];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({
        viewState,
        width: this.width,
        height: this.height
      });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);
      if (hasController && !oldController) {
        invalidateControllers = true;
      }
      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }
      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
      this._viewports.unshift(viewport);
    }
    for (const id in oldControllers) {
      const oldController = oldControllers[id];
      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {};
    this._viewports.forEach(viewport => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }
  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }
    return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
  }
}
exports.default = ViewManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js"}],"node_modules/@deck.gl/core/dist/esm/utils/positions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPosition = getPosition;
exports.parsePosition = parsePosition;
const PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case 'number':
      return {
        position: value,
        relative: false
      };
    case 'string':
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);
      if (match && match.length >= 3) {
        const relative = match[2] === '%';
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'deck.gl: assertion failed.');
  }
}
},{}],"node_modules/@deck.gl/core/dist/esm/views/view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _positions = require("../utils/positions");
var _deepEqual = require("../utils/deep-equal");
var _assert = _interopRequireDefault(require("../utils/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class View {
  constructor(props) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "viewportInstance", void 0);
    (0, _defineProperty2.default)(this, "_x", void 0);
    (0, _defineProperty2.default)(this, "_y", void 0);
    (0, _defineProperty2.default)(this, "_width", void 0);
    (0, _defineProperty2.default)(this, "_height", void 0);
    (0, _defineProperty2.default)(this, "_padding", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    const {
      id,
      x = 0,
      y = 0,
      width = '100%',
      height = '100%',
      padding = null,
      viewportInstance
    } = props || {};
    (0, _assert.default)(!viewportInstance || viewportInstance instanceof _viewport.default);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || 'view';
    this.props = {
      ...props,
      id: this.id
    };
    this._x = (0, _positions.parsePosition)(x);
    this._y = (0, _positions.parsePosition)(y);
    this._width = (0, _positions.parsePosition)(width);
    this._height = (0, _positions.parsePosition)(height);
    this._padding = padding && {
      left: (0, _positions.parsePosition)(padding.left || 0),
      right: (0, _positions.parsePosition)(padding.right || 0),
      top: (0, _positions.parsePosition)(padding.top || 0),
      bottom: (0, _positions.parsePosition)(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }
  equals(view) {
    if (this === view) {
      return true;
    }
    if (this.viewportInstance) {
      return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
    }
    return this.ViewportType === view.ViewportType && (0, _deepEqual.deepEqual)(this.props, view.props, 2);
  }
  makeViewport({
    width,
    height,
    viewState
  }) {
    if (this.viewportInstance) {
      return this.viewportInstance;
    }
    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({
      width,
      height
    });
    return new this.ViewportType({
      ...viewState,
      ...this.props,
      ...viewportDimensions
    });
  }
  getViewStateId() {
    const {
      viewState
    } = this.props;
    if (typeof viewState === 'string') {
      return viewState;
    }
    return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
  }
  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === 'object') {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }
      const newViewState = {
        ...viewState
      };
      for (const key in this.props.viewState) {
        if (key !== 'id') {
          newViewState[key] = this.props.viewState[key];
        }
      }
      return newViewState;
    }
    return viewState;
  }
  getDimensions({
    width,
    height
  }) {
    const dimensions = {
      x: (0, _positions.getPosition)(this._x, width),
      y: (0, _positions.getPosition)(this._y, height),
      width: (0, _positions.getPosition)(this._width, width),
      height: (0, _positions.getPosition)(this._height, height)
    };
    if (this._padding) {
      dimensions.padding = {
        left: (0, _positions.getPosition)(this._padding.left, width),
        top: (0, _positions.getPosition)(this._padding.top, height),
        right: (0, _positions.getPosition)(this._padding.right, width),
        bottom: (0, _positions.getPosition)(this._padding.bottom, height)
      };
    }
    return dimensions;
  }
  get controller() {
    const opts = this.props.controller;
    if (!opts) {
      return null;
    }
    if (opts === true) {
      return {
        type: this.ControllerType
      };
    }
    if (typeof opts === 'function') {
      return {
        type: opts
      };
    }
    return {
      type: this.ControllerType,
      ...opts
    };
  }
}
exports.default = View;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../utils/positions":"node_modules/@deck.gl/core/dist/esm/utils/positions.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Transition {
  constructor(timeline) {
    (0, _defineProperty2.default)(this, "_inProgress", void 0);
    (0, _defineProperty2.default)(this, "_handle", void 0);
    (0, _defineProperty2.default)(this, "_timeline", void 0);
    (0, _defineProperty2.default)(this, "time", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    this._inProgress = false;
    this._handle = null;
    this._timeline = timeline;
    this.time = 0;
    this.settings = {
      duration: 0
    };
  }
  get inProgress() {
    return this._inProgress;
  }
  start(settings) {
    var _this$settings$onStar, _this$settings;
    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
  }
  end() {
    if (this._inProgress) {
      var _this$settings$onEnd, _this$settings2;
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
    }
  }
  cancel() {
    if (this._inProgress) {
      var _this$settings$onInte, _this$settings3;
      (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);
      this._timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }
  update() {
    var _this$settings$onUpda, _this$settings4;
    if (!this._inProgress) {
      return false;
    }
    if (this._handle === null) {
      const {
        _timeline: timeline,
        settings
      } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }
    this.time = this._timeline.getTime(this._handle);
    this._onUpdate();
    (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);
    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }
    return true;
  }
  _onUpdate() {}
}
exports.default = Transition;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_EVENTS = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transition = _interopRequireDefault(require("../transitions/transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const noop = () => {};
const TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
exports.TRANSITION_EVENTS = TRANSITION_EVENTS;
const DEFAULT_EASING = t => t;
const DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
class TransitionManager {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "getControllerState", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "propsInTransition", void 0);
    (0, _defineProperty2.default)(this, "transition", void 0);
    (0, _defineProperty2.default)(this, "onViewStateChange", void 0);
    (0, _defineProperty2.default)(this, "onStateChange", void 0);
    (0, _defineProperty2.default)(this, "_onTransitionUpdate", transition => {
      const {
        time,
        settings: {
          interpolator,
          startProps,
          endProps,
          duration,
          easing
        }
      } = transition;
      const t = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    });
    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new _transition.default(opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop;
    this.onStateChange = opts.onStateChange || noop;
  }
  finalize() {
    this.transition.cancel();
  }
  getViewportInTransition() {
    return this.propsInTransition;
  }
  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;
    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }
    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;
      if (this.transition.inProgress) {
        const {
          interruption,
          endProps
        } = this.transition.settings;
        startProps = {
          ...currentProps,
          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)
        };
      }
      this._triggerTransition(startProps, nextProps);
      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }
    return transitionTriggered;
  }
  updateTransition() {
    this.transition.update();
  }
  _isTransitionEnabled(props) {
    const {
      transitionDuration,
      transitionInterpolator
    } = props;
    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);
  }
  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }
    return false;
  }
  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
    }
    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }
    return true;
  }
  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
    if (duration === 0) {
      return;
    }
    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({
      inTransition: true
    });
    this.updateTransition();
  }
  _onTransitionEnd(callback) {
    return transition => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback === null || callback === void 0 ? void 0 : callback(transition);
    };
  }
}
exports.default = TransitionManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../transitions/transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _assert = _interopRequireDefault(require("../utils/assert"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class TransitionInterpolator {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "_propsToCompare", void 0);
    (0, _defineProperty2.default)(this, "_propsToExtract", void 0);
    (0, _defineProperty2.default)(this, "_requiredProps", void 0);
    const {
      compare,
      extract,
      required
    } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }
  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !(0, _core.equals)(currentProps[key], nextProps[key])) {
        return false;
      }
    }
    return true;
  }
  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};
    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }
    this._checkRequiredProps(startViewStateProps);
    this._checkRequiredProps(endViewStateProps);
    return {
      start: startViewStateProps,
      end: endViewStateProps
    };
  }
  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }
  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }
    this._requiredProps.forEach(propName => {
      const value = props[propName];
      (0, _assert.default)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
    });
  }
}
exports.default = TransitionInterpolator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
const DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];
class LinearInterpolator extends _transitionInterpolator.default {
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);
    (0, _defineProperty2.default)(this, "opts", void 0);
    this.opts = normalizedOpts;
  }
  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const {
      makeViewport,
      around
    } = this.opts;
    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }
    return result;
  }
  interpolateProps(startProps, endProps, t) {
    const propsInTransition = {};
    for (const key of this._propsToExtract) {
      propsInTransition[key] = (0, _core.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }
    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({
        ...endProps,
        ...propsInTransition
      });
      Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, (0, _core.lerp)(startProps.around, endProps.around, t)));
    }
    return propsInTransition;
  }
}
exports.default = LinearInterpolator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transitionManager = _interopRequireDefault(require("./transition-manager"));
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
const DEFAULT_INERTIA = 300;
const INERTIA_EASING = t => 1 - (1 - t) * (1 - t);
const EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown']
};
const pinchEventWorkaround = {};
class Controller {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "state", {});
    (0, _defineProperty2.default)(this, "transitionManager", void 0);
    (0, _defineProperty2.default)(this, "eventManager", void 0);
    (0, _defineProperty2.default)(this, "onViewStateChange", void 0);
    (0, _defineProperty2.default)(this, "onStateChange", void 0);
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    (0, _defineProperty2.default)(this, "_controllerState", void 0);
    (0, _defineProperty2.default)(this, "_events", {});
    (0, _defineProperty2.default)(this, "_interactionState", {
      isDragging: false
    });
    (0, _defineProperty2.default)(this, "_customEvents", []);
    (0, _defineProperty2.default)(this, "_eventStartBlocked", null);
    (0, _defineProperty2.default)(this, "_panMove", false);
    (0, _defineProperty2.default)(this, "invertPan", false);
    (0, _defineProperty2.default)(this, "dragMode", 'rotate');
    (0, _defineProperty2.default)(this, "inertia", 0);
    (0, _defineProperty2.default)(this, "scrollZoom", true);
    (0, _defineProperty2.default)(this, "dragPan", true);
    (0, _defineProperty2.default)(this, "dragRotate", true);
    (0, _defineProperty2.default)(this, "doubleClickZoom", true);
    (0, _defineProperty2.default)(this, "touchZoom", true);
    (0, _defineProperty2.default)(this, "touchRotate", false);
    (0, _defineProperty2.default)(this, "keyboard", true);
    this.transitionManager = new _transitionManager.default({
      ...opts,
      getControllerState: props => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;
    this.onViewStateChange = opts.onViewStateChange || (() => {});
    this.onStateChange = opts.onStateChange || (() => {});
    this.makeViewport = opts.makeViewport;
  }
  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    if (this.props) {
      this.setProps(this.props);
    }
  }
  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        var _this$eventManager;
        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
      }
    }
    this.transitionManager.finalize();
  }
  handleEvent(event) {
    this._controllerState = undefined;
    const eventStartBlocked = this._eventStartBlocked;
    switch (event.type) {
      case 'panstart':
        return eventStartBlocked ? false : this._onPanStart(event);
      case 'panmove':
        return this._onPan(event);
      case 'panend':
        return this._onPanEnd(event);
      case 'pinchstart':
        return eventStartBlocked ? false : this._onPinchStart(event);
      case 'pinchmove':
        return this._onPinch(event);
      case 'pinchend':
        return this._onPinchEnd(event);
      case 'tripanstart':
        return eventStartBlocked ? false : this._onTriplePanStart(event);
      case 'tripanmove':
        return this._onTriplePan(event);
      case 'tripanend':
        return this._onTriplePanEnd(event);
      case 'doubletap':
        return this._onDoubleTap(event);
      case 'wheel':
        return this._onWheel(event);
      case 'keydown':
        return this._onKeyDown(event);
      default:
        return false;
    }
  }
  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }
  getCenter(event) {
    const {
      x,
      y
    } = this.props;
    const {
      offsetCenter
    } = event;
    return [offsetCenter.x - x, offsetCenter.y - y];
  }
  isPointInBounds(pos, event) {
    const {
      width,
      height
    } = this.props;
    if (event && event.handled) {
      return false;
    }
    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
    if (inside && event) {
      event.stopPropagation();
    }
    return inside;
  }
  isFunctionKeyPressed(event) {
    const {
      srcEvent
    } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || false;
  }
  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }
  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }
    this.props = props;
    if (!('transitionInterpolator' in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }
    this.transitionManager.processViewStateChange(props);
    const {
      inertia
    } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const {
      scrollZoom = true,
      dragPan = true,
      dragRotate = true,
      doubleClickZoom = true,
      touchZoom = true,
      touchRotate = false,
      keyboard = true
    } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach(eventName => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;
          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }
  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = {
      ...newControllerState.getViewportProps(),
      ...extraProps
    };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();
    this._setInteractionState(interactionState);
    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();
      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState,
          interactionState: this._interactionState,
          oldViewState
        });
      }
    }
  }
  _onTransition(params) {
    this.onViewStateChange({
      ...params,
      interactionState: this._interactionState
    });
  }
  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }
  _onPanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
    if (this.invertPan || this.dragMode === 'pan') {
      alternateMode = !alternateMode;
    }
    const newControllerState = this.controllerState[alternateMode ? 'panStart' : 'rotateStart']({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }
  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }
  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }
  _onPanMoveEnd(event) {
    const {
      inertia
    } = this;
    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.pan({
        pos: endPos
      }).panEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }
    return true;
  }
  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }
    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onPanRotateEnd(event) {
    const {
      inertia
    } = this;
    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      }).rotateEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }
    event.srcEvent.preventDefault();
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const {
      speed = 0.01,
      smooth = false
    } = this.scrollZoom === true ? {} : this.scrollZoom;
    const {
      delta
    } = event;
    let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
    if (delta < 0 && scale !== 0) {
      scale = 1 / scale;
    }
    const newControllerState = this.controllerState.zoom({
      pos,
      scale
    });
    this.updateViewport(newControllerState, {
      ...this._getTransitionProps({
        around: pos
      }),
      transitionDuration: smooth ? 250 : 1
    }, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }
  _onTriplePanStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.rotateStart({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onTriplePan(event) {
    if (!this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }
  _onTriplePanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const {
      inertia
    } = this;
    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }
    return true;
  }
  _onPinchStart(event) {
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const newControllerState = this.controllerState.zoomStart({
      pos
    }).rotateStart({
      pos
    });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }
  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }
    if (!this.isDragging()) {
      return false;
    }
    let newControllerState = this.controllerState;
    if (this.touchZoom) {
      const {
        scale
      } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({
        pos,
        scale
      });
    }
    if (this.touchRotate) {
      const {
        rotation
      } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }
  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }
    const {
      inertia
    } = this;
    const {
      _lastPinchEvent
    } = pinchEventWorkaround;
    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z = Math.log2(event.scale);
      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
      const endScale = Math.pow(2, z + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({
        pos,
        scale: endScale
      }).zoomEnd();
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }
    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }
  _onDoubleTap(event) {
    if (!this.doubleClickZoom) {
      return false;
    }
    const pos = this.getCenter(event);
    if (!this.isPointInBounds(pos, event)) {
      return false;
    }
    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({
      pos,
      scale: isZoomOut ? 0.5 : 2
    });
    this.updateViewport(newControllerState, this._getTransitionProps({
      around: pos
    }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }
  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }
    const funcKey = this.isFunctionKeyPressed(event);
    const {
      zoomSpeed,
      moveSpeed,
      rotateSpeedX,
      rotateSpeedY
    } = this.keyboard === true ? {} : this.keyboard;
    const {
      controllerState
    } = this;
    let newControllerState;
    const interactionState = {};
    switch (event.srcEvent.code) {
      case 'Minus':
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case 'Equal':
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;
      case 'ArrowLeft':
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case 'ArrowRight':
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case 'ArrowUp':
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      case 'ArrowDown':
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }
        break;
      default:
        return false;
    }
    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }
  _getTransitionProps(opts) {
    const {
      transition
    } = this;
    if (!transition || !transition.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }
    return opts ? {
      ...transition,
      transitionInterpolator: new _linearInterpolator.default({
        ...opts,
        ...transition.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition;
  }
}
exports.default = Controller;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-manager":"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ViewState {
  constructor(props, state) {
    (0, _defineProperty2.default)(this, "_viewportProps", void 0);
    (0, _defineProperty2.default)(this, "_state", void 0);
    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
exports.default = ViewState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MapState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _viewState = _interopRequireDefault(require("./view-state"));
var _webMercator = require("@math.gl/web-mercator");
var _assert = _interopRequireDefault(require("../utils/assert"));
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const PITCH_MOUSE_THRESHOLD = 5;
const PITCH_ACCEL = 1.2;
class MapState extends _viewState.default {
  constructor(options) {
    const {
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing = 0,
      pitch = 0,
      altitude = 1.5,
      position = [0, 0, 0],
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom,
      normalize = true
    } = options;
    (0, _assert.default)(Number.isFinite(longitude));
    (0, _assert.default)(Number.isFinite(latitude));
    (0, _assert.default)(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    this.makeViewport = options.makeViewport;
  }
  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }
  pan({
    pos,
    startPos
  }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
    if (!startPanLngLat) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();
    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {
      return this;
    }
    let newRotation;
    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomLngLat
    } = this.getState();
    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomLngLat) {
      return this;
    }
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale);
    zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({
      ...this.getViewportProps(),
      zoom
    });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }
  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }
  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }
  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }
  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }
  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const {
      maxPitch,
      minPitch,
      pitch
    } = props;
    props.pitch = (0, _core.clamp)(pitch, minPitch, maxPitch);
    const {
      normalize = true
    } = props;
    if (normalize) {
      Object.assign(props, (0, _webMercator.normalizeViewportProps)(props));
    }
    return props;
  }
  _zoomFromCenter(scale) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale
    });
  }
  _panFromCenter(offset) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const {
      width,
      height
    } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;
    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }
    deltaScaleY = (0, _core.clamp)(deltaScaleY, -1, 1);
    const {
      minPitch,
      maxPitch
    } = this.getViewportProps();
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;
    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }
    return {
      pitch,
      bearing
    };
  }
}
exports.MapState = MapState;
class MapController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", MapState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default({
        transitionProps: {
          compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch', 'position'],
          required: ['longitude', 'latitude', 'zoom']
        }
      })
    });
    (0, _defineProperty2.default)(this, "dragMode", 'pan');
  }
  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;
    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }
}
exports.default = MapController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/map-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _webMercatorViewport = _interopRequireDefault(require("../viewports/web-mercator-viewport"));
var _mapController = _interopRequireDefault(require("../controllers/map-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class MapView extends _view.default {
  get ViewportType() {
    return _webMercatorViewport.default;
  }
  get ControllerType() {
    return _mapController.default;
  }
}
exports.default = MapView;
(0, _defineProperty2.default)(MapView, "displayName", 'MapView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","../controllers/map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js"}],"node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deepEqual = require("../utils/deep-equal");
var _lightingEffect = _interopRequireDefault(require("../effects/lighting/lighting-effect"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_LIGHTING_EFFECT = new _lightingEffect.default();
function compareEffects(e1, e2) {
  var _e1$order, _e2$order;
  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
  return o1 - o2;
}
class EffectManager {
  constructor() {
    (0, _defineProperty2.default)(this, "effects", void 0);
    (0, _defineProperty2.default)(this, "_resolvedEffects", []);
    (0, _defineProperty2.default)(this, "_defaultEffects", []);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    this.effects = [];
    this._needsRedraw = 'Initial render';
    this._setEffects([]);
  }
  addDefaultEffect(effect) {
    const defaultEffects = this._defaultEffects;
    if (!defaultEffects.find(e => e.id === effect.id)) {
      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);
      if (index < 0) {
        defaultEffects.push(effect);
      } else {
        defaultEffects.splice(index, 0, effect);
      }
      this._setEffects(this.effects);
    }
  }
  setProps(props) {
    if ('effects' in props) {
      if (!(0, _deepEqual.deepEqual)(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(effects) {
    const oldEffectsMap = {};
    for (const effect of this.effects) {
      oldEffectsMap[effect.id] = effect;
    }
    const nextEffects = [];
    for (const effect of effects) {
      const oldEffect = oldEffectsMap[effect.id];
      if (oldEffect && oldEffect !== effect) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect.props);
          nextEffects.push(oldEffect);
        } else {
          oldEffect.cleanup();
          nextEffects.push(effect);
        }
      } else {
        nextEffects.push(effect);
      }
      delete oldEffectsMap[effect.id];
    }
    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup();
    }
    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);
    if (!effects.some(effect => effect instanceof _lightingEffect.default)) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
    this._needsRedraw = 'effects changed';
  }
  finalize() {
    for (const effect of this._resolvedEffects) {
      effect.cleanup();
    }
    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }
}
exports.default = EffectManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../effects/lighting/lighting-effect":"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js"}],"node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _layersPass = _interopRequireDefault(require("./layers-pass"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class DrawLayersPass extends _layersPass.default {
  shouldDrawLayer(layer) {
    const {
      operation
    } = layer.props;
    return operation.includes('draw') || operation.includes('terrain');
  }
}
exports.default = DrawLayersPass;
},{"./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"}],"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _debug = _interopRequireDefault(require("../debug"));
var _drawLayersPass = _interopRequireDefault(require("../passes/draw-layers-pass"));
var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));
var _core = require("@luma.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';
class DeckRenderer {
  constructor(gl) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "layerFilter", void 0);
    (0, _defineProperty2.default)(this, "drawPickingColors", void 0);
    (0, _defineProperty2.default)(this, "drawLayersPass", void 0);
    (0, _defineProperty2.default)(this, "pickLayersPass", void 0);
    (0, _defineProperty2.default)(this, "renderCount", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "renderBuffers", void 0);
    (0, _defineProperty2.default)(this, "lastPostProcessEffect", void 0);
    this.gl = gl;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new _drawLayersPass.default(gl);
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.renderCount = 0;
    this._needsRedraw = 'Initial render';
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }
  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = 'layerFilter changed';
    }
    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = 'drawPickingColors changed';
    }
  }
  renderLayers(opts) {
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts,
      target: opts.target || _core.Framebuffer.getDefaultFramebuffer(this.gl)
    };
    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }
    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    const renderStats = layerPass.render({
      ...renderOpts,
      target: outputBuffer
    });
    if (renderOpts.effects) {
      this._postRender(renderOpts.effects, renderOpts);
    }
    this.renderCount++;
    (0, _debug.default)(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    return redraw;
  }
  finalize() {
    const {
      renderBuffers
    } = this;
    for (const buffer of renderBuffers) {
      buffer.delete();
    }
    renderBuffers.length = 0;
  }
  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};
    for (const effect of effects) {
      opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
      if (effect.postRender) {
        this.lastPostProcessEffect = effect.id;
      }
    }
    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers
    } = this;
    if (renderBuffers.length === 0) {
      renderBuffers.push(new _core.Framebuffer(this.gl), new _core.Framebuffer(this.gl));
    }
    for (const buffer of renderBuffers) {
      buffer.resize();
    }
  }
  _postRender(effects, opts) {
    const {
      renderBuffers
    } = this;
    const params = {
      ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1],
      target: null
    };
    for (const effect of effects) {
      if (effect.postRender) {
        if (effect.id === this.lastPostProcessEffect) {
          params.target = opts.target;
          effect.postRender(this.gl, params);
          break;
        }
        const buffer = effect.postRender(this.gl, params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }
}
exports.default = DeckRenderer;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../passes/draw-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js","../passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClosestObject = getClosestObject;
exports.getUniqueObjects = getUniqueObjects;
var _log = _interopRequireDefault(require("../../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({
  pickedColors,
  decodePickingColor,
  deviceX,
  deviceY,
  deviceRadius,
  deviceRect
}) {
  const {
    x,
    y,
    width,
    height
  } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i = 0;
  for (let row = 0; row < height; row++) {
    const dy = row + y - deviceY;
    const dy2 = dy * dy;
    if (dy2 > minSquareDistanceToCenter) {
      i += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const dx = col + x - deviceX;
          const d2 = dx * dx + dy2;
          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }
        i += 4;
      }
    }
  }
  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);
    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return {
        ...pickedObject,
        pickedColor,
        pickedX: x + dx,
        pickedY: y + dy
      };
    }
    _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects({
  pickedColors,
  decodePickingColor
}) {
  const uniqueColors = new Map();
  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;
      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(',');
        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);
          if (pickedObject) {
            uniqueColors.set(colorKey, {
              ...pickedObject,
              color: pickedColor
            });
          } else {
            _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}
},{"../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmptyPickingInfo = getEmptyPickingInfo;
exports.getLayerPickingInfo = getLayerPickingInfo;
exports.processPickInfo = processPickInfo;
function getEmptyPickingInfo({
  pickInfo,
  viewports,
  pixelRatio,
  x,
  y,
  z
}) {
  let pickedViewport = viewports[0];
  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
      x,
      y
    });
  }
  let coordinate;
  if (pickedViewport) {
    const point = [x - pickedViewport.x, y - pickedViewport.y];
    if (z !== undefined) {
      point[2] = z;
    }
    coordinate = pickedViewport.unproject(point);
  }
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    devicePixel: pickInfo && 'pickedX' in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : undefined,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const {
    pickInfo,
    lastPickedInfo,
    mode,
    layers
  } = opts;
  const {
    pickedColor,
    pickedLayer,
    pickedObjectIndex
  } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === 'hover') {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  const baseInfo = getEmptyPickingInfo(opts);
  const infos = new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(layer => {
    let info = {
      ...baseInfo
    };
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });
    const rootLayer = info.layer;
    if (layer === pickedLayer && mode === 'hover') {
      lastPickedInfo.info = info;
    }
    infos.set(rootLayer.id, info);
    if (mode === 'hover') {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({
  layer,
  info,
  mode
}) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];
    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }
  return viewports[0];
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));
var _queryObject = require("./picking/query-object");
var _pickInfo = require("./picking/pick-info");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class DeckPicker {
  constructor(gl) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "pickingFBO", void 0);
    (0, _defineProperty2.default)(this, "depthFBO", void 0);
    (0, _defineProperty2.default)(this, "pickLayersPass", void 0);
    (0, _defineProperty2.default)(this, "layerFilter", void 0);
    (0, _defineProperty2.default)(this, "lastPickedInfo", void 0);
    (0, _defineProperty2.default)(this, "_pickable", true);
    this.gl = gl;
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(props) {
    if ('layerFilter' in props) {
      this.layerFilter = props.layerFilter;
    }
    if ('_pickable' in props) {
      this._pickable = props._pickable;
    }
  }
  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.delete();
    }
    if (this.depthFBO) {
      this.depthFBO.color.delete();
      this.depthFBO.delete();
    }
  }
  pickObject(opts) {
    return this._pickClosestObject(opts);
  }
  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }
  getLastPickedObject({
    x,
    y,
    layers,
    viewports
  }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
    const info = {
      x,
      y,
      viewport,
      coordinate,
      layer
    };
    return {
      ...lastPickedInfo,
      ...info
    };
  }
  _resizeBuffer() {
    var _this$pickingFBO, _this$depthFBO;
    const {
      gl
    } = this;
    if (!this.pickingFBO) {
      this.pickingFBO = new _core.Framebuffer(gl);
      if (_core.Framebuffer.isSupported(gl, {
        colorBufferFloat: true
      })) {
        const depthFBO = new _core.Framebuffer(gl);
        depthFBO.attach({
          [36064]: new _core.Texture2D(gl, {
            format: (0, _core.isWebGL2)(gl) ? 34836 : 6408,
            type: 5126
          })
        });
        this.depthFBO = depthFBO;
      }
    }
    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
  }
  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }
    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }
  _pickClosestObject({
    layers,
    views,
    viewports,
    x,
    y,
    radius = 0,
    depth = 1,
    mode = 'query',
    unproject3D,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);
    const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
    if (!pickableLayers) {
      return {
        result: [],
        emptyInfo: (0, _pickInfo.getEmptyPickingInfo)({
          viewports,
          x,
          y,
          pixelRatio
        })
      };
    }
    this._resizeBuffer();
    const devicePixelRange = (0, _core.cssToDevicePixels)(this.gl, [x, y], true);
    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
    const deviceRadius = Math.round(radius * pixelRatio);
    const {
      width,
      height
    } = this.pickingFBO;
    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });
    const cullRect = {
      x: x - radius,
      y: y - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = new Set();
    for (let i = 0; i < depth; i++) {
      let pickInfo;
      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: "picking:".concat(mode)
        });
        pickInfo = (0, _queryObject.getClosestObject)({
          ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }
      let z;
      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const {
          pickedColors: pickedColors2
        } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: "picking:".concat(mode, ":z")
        }, true);
        if (pickedColors2[3]) {
          z = pickedColors2[0];
        }
      }
      if (pickInfo.pickedLayer && i + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }
      infos = (0, _pickInfo.processPickInfo)({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x,
        y,
        z,
        pixelRatio
      });
      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }
      if (!pickInfo.pickedColor) {
        break;
      }
    }
    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }
    return {
      result,
      emptyInfo: infos.get(null)
    };
  }
  _pickVisibleObjects({
    layers,
    views,
    viewports,
    x,
    y,
    width = 1,
    height = 1,
    mode = 'query',
    maxObjects = null,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);
    if (!pickableLayers) {
      return [];
    }
    this._resizeBuffer();
    const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
    const leftTop = (0, _core.cssToDevicePixels)(this.gl, [x, y], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = (0, _core.cssToDevicePixels)(this.gl, [x + width, y + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };
    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: {
        x,
        y,
        width,
        height
      },
      effects,
      pass: "picking:".concat(mode)
    });
    const pickInfos = (0, _queryObject.getUniqueObjects)(pickedResult);
    const uniqueInfos = new Map();
    const isMaxObjects = Number.isFinite(maxObjects);
    for (let i = 0; i < pickInfos.length; i++) {
      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
        break;
      }
      const pickInfo = pickInfos[i];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x,
        y,
        pixelRatio
      };
      info = (0, _pickInfo.getLayerPickingInfo)({
        layer: pickInfo.pickedLayer,
        info,
        mode
      });
      if (!uniqueInfos.has(info.object)) {
        uniqueInfos.set(info.object, info);
      }
    }
    return Array.from(uniqueInfos.values());
  }
  _drawAndSample({
    layers,
    views,
    viewports,
    onViewportActive,
    deviceRect,
    cullRect,
    effects,
    pass
  }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {}
    };
    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
      }
    }
    const {
      decodePickingColor
    } = this.pickLayersPass.render(opts);
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    (0, _core.readPixelsToArray)(pickingFBO, {
      sourceX: x,
      sourceY: y,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return {
      pickedColors,
      decodePickingColor
    };
  }
  _getPickingRect({
    deviceX,
    deviceY,
    deviceRadius,
    deviceWidth,
    deviceHeight
  }) {
    const x = Math.max(0, deviceX - deviceRadius);
    const y = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
    if (width <= 0 || height <= 0) {
      return null;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
}
exports.default = DeckPicker;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","./picking/query-object":"node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js","./picking/pick-info":"node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js"}],"node_modules/@deck.gl/core/dist/esm/lib/tooltip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultStyle = {
  zIndex: '1',
  position: 'absolute',
  pointerEvents: 'none',
  color: '#a0a7b4',
  backgroundColor: '#29323c',
  padding: '10px',
  top: '0',
  left: '0',
  display: 'none'
};
class Tooltip {
  constructor(canvas) {
    (0, _defineProperty2.default)(this, "el", null);
    (0, _defineProperty2.default)(this, "isVisible", false);
    const canvasParent = canvas.parentElement;
    if (canvasParent) {
      this.el = document.createElement('div');
      this.el.className = 'deck-tooltip';
      Object.assign(this.el.style, defaultStyle);
      canvasParent.appendChild(this.el);
    }
  }
  setTooltip(displayInfo, x, y) {
    const el = this.el;
    if (!el) {
      return;
    }
    if (typeof displayInfo === 'string') {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = 'none';
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }
      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }
      if (displayInfo.className) {
        el.className = displayInfo.className;
      }
      Object.assign(el.style, displayInfo.style);
    }
    this.isVisible = true;
    el.style.display = 'block';
    el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
  }
  remove() {
    if (this.el) {
      this.el.remove();
      this.el = null;
    }
  }
}
exports.default = Tooltip;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/hammerjs/hammer.js":[function(require,module,exports) {
var define;
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
  'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }
    return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
    var i;
    if (!obj) {
      return;
    }
    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;
      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);
      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }
      return method.apply(this, arguments);
    };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  } else {
    assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }
      i++;
    }
    return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
    var baseP = base.prototype,
      childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;
    if (properties) {
      assign(childP, properties);
    }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
    return val1 === undefined ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;
      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          return i;
        }
        i++;
      }
      return -1;
    }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;
    while (i < src.length) {
      var val = key ? src[i][key] : src[i];
      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }
      values[i] = val;
      i++;
    }
    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }
    return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;
      if (prop in obj) {
        return prop;
      }
      i++;
    }
    return undefined;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
    return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }
  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };
    this.init();
  }
  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function () {},
    /**
     * bind the events
     */
    init: function () {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },
    /**
     * unbind the events
     */
    destroy: function () {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;
    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }
    return new Type(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;
    if (isFirst) {
      manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }
    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }
    input.target = target;
  }
  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};
    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }
    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
      deltaTime = input.timeStamp - last.timeStamp,
      velocity,
      velocityX,
      velocityY,
      direction;
    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }
    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }
    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }
    var x = 0,
      y = 0,
      i = 0;
    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }
    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }
    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
      y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
      y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
  }
  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type];

      // on start we want to have the left mouse button down
      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      }

      // mouse must be down
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = this.manager.session.pointerEvents = [];
  }
  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType == INPUT_TYPE_TOUCH;

      // get index of the event in the store
      var storeIndex = inArray(store, ev.pointerId, 'pointerId');

      // start and mouse must be down
      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      }

      // it not found, so the pointer hasn't been down (so it's probably a hover)
      if (storeIndex < 0) {
        return;
      }

      // update the event in the store
      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });
      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }
  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

      // should we handle the touch events?
      if (type === INPUT_START) {
        this.started = true;
      }
      if (!this.started) {
        return;
      }
      var touches = normalizeSingleTouches.call(this, ev, type);

      // when done, reset the started state
      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }
      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);
    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }
    return [all, changed];
  }
  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }
  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);
      if (!touches) {
        return;
      }
      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }
    var i,
      targetTouches,
      changedTouches = toArray(ev.changedTouches),
      changedTargetTouches = [],
      target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
      i = 0;
      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      }

      // cleanup removed touches
      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }
      i++;
    }
    if (!changedTargetTouches.length) {
      return;
    }
    return [
    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */

  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;
  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
    this.primaryTouch = null;
    this.lastTouches = [];
  }
  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
        return;
      }

      // when we're in a touch event, record touches to  de-dupe synthetic mouse event
      if (isTouch) {
        recordTouches.call(this, inputEvent, inputData);
      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
        return;
      }
      this.callback(manager, inputEvent, inputData);
    },
    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });
  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }
  function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];
    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      this.lastTouches.push(lastTouch);
      var lts = this.lastTouches;
      var removeLastTouch = function () {
        var i = lts.indexOf(lastTouch);
        if (i > -1) {
          lts.splice(i, 1);
        }
      };
      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }
  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX,
      y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x),
        dy = Math.abs(y - t.y);
      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }
    return false;
  }
  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }
  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function (value) {
      // find out the touch-action by the event handlers
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }
      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }
      this.actions = value.toLowerCase().trim();
    },
    /**
     * just re-set the touchAction value
     */
    update: function () {
      this.set(this.manager.options.touchAction);
    },
    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function () {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },
    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function (input) {
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection;

      // if the touch action did prevented once this session
      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }
      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
      if (hasNone) {
        //do not prevent defaults if this is a tap gesture

        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;
        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }
      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }
      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    },
    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function (srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }
    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }
    return TOUCH_ACTION_AUTO;
  }
  function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
      return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
      // If css.supports is not supported but there is native touch-action assume it supports
      // all values. This is the case for IE 10 and 11.
      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }
  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},
    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function (options) {
      assign(this.options, options);

      // also update the touchAction, in case something changed about the directions/enabled state
      this.manager && this.manager.touchAction.update();
      return this;
    },
    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }
      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }
      return this;
    },
    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },
    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }
      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }
      return this;
    },
    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);
      if (index > -1) {
        this.requireFail.splice(index, 1);
      }
      return this;
    },
    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function () {
      return this.requireFail.length > 0;
    },
    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function (otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },
    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function (input) {
      var self = this;
      var state = this.state;
      function emit(event) {
        self.manager.emit(event, input);
      }

      // 'panstart' and 'panmove'
      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      }

      // panend and pancancel
      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    },
    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function (input) {
      if (this.canEmit()) {
        return this.emit(input);
      }
      // it's failing anyway
      this.state = STATE_FAILED;
    },
    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function () {
      var i = 0;
      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }
        i++;
      }
      return true;
    },
    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign({}, inputData);

      // is is enabled and allow recognizing?
      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      }

      // reset when we've reached the end
      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }
      this.state = this.process(inputDataClone);

      // the recognizer has recognized a gesture
      // so trigger an event
      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },
    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function (inputData) {},
    // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function () {},
    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function () {}
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }
    return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }
    return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
      return manager.get(otherRecognizer);
    }
    return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }
  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },
    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function (input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },
    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function (input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input);

      // on cancel input and we've recognized before, return STATE_CANCELLED
      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }
        return state | STATE_CHANGED;
      }
      return STATE_FAILED;
    }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }
  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function () {
      var direction = this.options.direction;
      var actions = [];
      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }
      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }
      return actions;
    },
    directionTest: function (input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY;

      // lock to axis?
      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }
      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function (input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    },
    emit: function (input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);
      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }
      this._super.emit.call(this, input);
    }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function (input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }
      this._super.emit.call(this, input);
    }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }
  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function () {
      return [TOUCH_ACTION_AUTO];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input;

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }
      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function (input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }
      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }
  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function () {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function (input) {
      var direction = this.options.direction;
      var velocity;
      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }
      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function (input) {
      var direction = directionStr(input.offsetDirection);
      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }
      this.manager.emit(this.options.event, input);
    }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }
  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function () {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();
      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      }

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }
        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;
        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }
        this._input = input;

        // if tap count matches we have recognized it,
        // else it has began recognizing...
        var tapCount = this.count % options.taps;
        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }
      return STATE_FAILED;
    },
    failTimeout: function () {
      this._timer = setTimeoutContext(function () {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function () {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.7';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,
    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,
    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,
    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,
    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,
    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
    [RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ['rotate']], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],
    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',
      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',
      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',
      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',
      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',
      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }
  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function (options) {
      assign(this.options, options);

      // Options that need a little more setup
      if (options.touchAction) {
        this.touchAction.update();
      }
      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }
      return this;
    },
    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function (force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },
    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      var session = this.session;
      if (session.stopped) {
        return;
      }

      // run the touch-action polyfill
      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers;

      // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`
      var curRecognizer = session.curRecognizer;

      // reset when the last recognizer is recognized
      // or when we're in a new session
      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }
      var i = 0;
      while (i < recognizers.length) {
        recognizer = recognizers[i];

        // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.
        if (session.stopped !== FORCED_STOP && (
        // 1
        !curRecognizer || recognizer == curRecognizer ||
        // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        }

        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer
        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }
        i++;
      }
    },
    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function (recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }
      var recognizers = this.recognizers;
      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }
      return null;
    },
    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function (recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      }

      // remove existing
      var existing = this.get(recognizer.options.event);
      if (existing) {
        this.remove(existing);
      }
      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },
    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function (recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }
      recognizer = this.get(recognizer);

      // let's make sure this recognizer exists
      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);
        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }
      return this;
    },
    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function (events, handler) {
      if (events === undefined) {
        return;
      }
      if (handler === undefined) {
        return;
      }
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },
    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function (events, handler) {
      if (events === undefined) {
        return;
      }
      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },
    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function (event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      }

      // no handlers, so skip it all
      var handlers = this.handlers[event] && this.handlers[event].slice();
      if (!handlers || !handlers.length) {
        return;
      }
      data.type = event;
      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };
      var i = 0;
      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },
    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function () {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
      return;
    }
    var prop;
    each(manager.options.cssProps, function (value, name) {
      prop = prefixed(element.style, name);
      if (add) {
        manager.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = manager.oldCssProps[prop] || '';
      }
    });
    if (!add) {
      manager.oldCssProps = {};
    }
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }
  assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line
  freeGlobal.Hammer = Hammer;
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return Hammer;
    });
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }
})(window, document, 'Hammer');
},{}],"node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enhanceMouseInput = enhanceMouseInput;
exports.enhancePointerEventInput = enhancePointerEventInput;
/**
 * This file contains overrides the default
 * hammer.js functions to add our own utility
 */
/* eslint-disable */
/* Hammer.js constants */
const INPUT_START = 1;
const INPUT_MOVE = 2;
const INPUT_END = 4;
const MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
/**
 * Helper function that returns true if any element in an array meets given criteria.
 * Because older browsers do not support `Array.prototype.some`
 * @params array {Array}
 * @params predict {Function}
 */
function some(array, predict) {
  for (let i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }
  return false;
}
/* eslint-disable no-invalid-this */
function enhancePointerEventInput(PointerEventInput) {
  const oldHandler = PointerEventInput.prototype.handler;
  // overrides PointerEventInput.handler to accept right mouse button
  PointerEventInput.prototype.handler = function handler(ev) {
    const store = this.store;
    // Allow non-left mouse buttons through
    if (ev.button > 0 && ev.type === 'pointerdown') {
      if (!some(store, e => e.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
// overrides MouseInput.handler to accept right mouse button
function enhanceMouseInput(MouseInput) {
  MouseInput.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    // on start we want to have the mouse button down
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }
    // mouse must be down
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: 'mouse',
      srcEvent: ev
    });
  };
}
},{}],"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Manager = void 0;
var hammerjs = _interopRequireWildcard(require("hammerjs"));
var _hammerOverrides = require("./hammer-overrides");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
(0, _hammerOverrides.enhancePointerEventInput)(hammerjs.PointerEventInput);
(0, _hammerOverrides.enhanceMouseInput)(hammerjs.MouseInput);
const Manager = hammerjs.Manager;
exports.Manager = Manager;
var _default = hammerjs;
exports.default = _default;
},{"hammerjs":"node_modules/hammerjs/hammer.js","./hammer-overrides":"node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js"}],"node_modules/mjolnir.js/dist/esm/inputs/input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
class Input {
  constructor(element, callback, options) {
    this.element = element;
    this.callback = callback;
    this.options = {
      enable: true,
      ...options
    };
  }
}
exports.default = Input;
},{}],"node_modules/mjolnir.js/dist/esm/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZERS = exports.INPUT_EVENT_TYPES = exports.GESTURE_EVENT_ALIASES = exports.EVENT_RECOGNIZER_MAP = exports.BASIC_EVENT_ALIASES = void 0;
var _hammer = _interopRequireDefault(require("./utils/hammer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// This module contains constants that must be conditionally required
// due to `window`/`document` references downstream.
const RECOGNIZERS = _hammer.default ? [[_hammer.default.Pan, {
  event: 'tripan',
  pointers: 3,
  threshold: 0,
  enable: false
}], [_hammer.default.Rotate, {
  enable: false
}], [_hammer.default.Pinch, {
  enable: false
}], [_hammer.default.Swipe, {
  enable: false
}], [_hammer.default.Pan, {
  threshold: 0,
  enable: false
}], [_hammer.default.Press, {
  enable: false
}], [_hammer.default.Tap, {
  event: 'doubletap',
  taps: 2,
  enable: false
}],
// TODO - rename to 'tap' and 'singletap' in the next major release
[_hammer.default.Tap, {
  event: 'anytap',
  enable: false
}], [_hammer.default.Tap, {
  enable: false
}]] : null;
// Recognize the following gestures even if a given recognizer succeeds
exports.RECOGNIZERS = RECOGNIZERS;
const RECOGNIZER_COMPATIBLE_MAP = {
  tripan: ['rotate', 'pinch', 'pan'],
  rotate: ['pinch'],
  pinch: ['pan'],
  pan: ['press', 'doubletap', 'anytap', 'tap'],
  doubletap: ['anytap'],
  anytap: ['tap']
};
// Recognize the folling gestures only if a given recognizer fails
exports.RECOGNIZER_COMPATIBLE_MAP = RECOGNIZER_COMPATIBLE_MAP;
const RECOGNIZER_FALLBACK_MAP = {
  doubletap: ['tap']
};
/**
 * Only one set of basic input events will be fired by Hammer.js:
 * either pointer, touch, or mouse, depending on system support.
 * In order to enable an application to be agnostic of system support,
 * alias basic input events into "classes" of events: down, move, and up.
 * See `_onBasicInput()` for usage of these aliases.
 */
exports.RECOGNIZER_FALLBACK_MAP = RECOGNIZER_FALLBACK_MAP;
const BASIC_EVENT_ALIASES = {
  pointerdown: 'pointerdown',
  pointermove: 'pointermove',
  pointerup: 'pointerup',
  touchstart: 'pointerdown',
  touchmove: 'pointermove',
  touchend: 'pointerup',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup'
};
exports.BASIC_EVENT_ALIASES = BASIC_EVENT_ALIASES;
const INPUT_EVENT_TYPES = {
  KEY_EVENTS: ['keydown', 'keyup'],
  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
  WHEEL_EVENTS: [
  // Chrome, Safari
  'wheel',
  // IE
  'mousewheel']
};
/**
 * "Gestural" events are those that have semantic meaning beyond the basic input event,
 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
 * Hammer.js handles these with its Recognizer system;
 * this block maps event names to the Recognizers required to detect the events.
 */
exports.INPUT_EVENT_TYPES = INPUT_EVENT_TYPES;
const EVENT_RECOGNIZER_MAP = {
  tap: 'tap',
  anytap: 'anytap',
  doubletap: 'doubletap',
  press: 'press',
  pinch: 'pinch',
  pinchin: 'pinch',
  pinchout: 'pinch',
  pinchstart: 'pinch',
  pinchmove: 'pinch',
  pinchend: 'pinch',
  pinchcancel: 'pinch',
  rotate: 'rotate',
  rotatestart: 'rotate',
  rotatemove: 'rotate',
  rotateend: 'rotate',
  rotatecancel: 'rotate',
  tripan: 'tripan',
  tripanstart: 'tripan',
  tripanmove: 'tripan',
  tripanup: 'tripan',
  tripandown: 'tripan',
  tripanleft: 'tripan',
  tripanright: 'tripan',
  tripanend: 'tripan',
  tripancancel: 'tripan',
  pan: 'pan',
  panstart: 'pan',
  panmove: 'pan',
  panup: 'pan',
  pandown: 'pan',
  panleft: 'pan',
  panright: 'pan',
  panend: 'pan',
  pancancel: 'pan',
  swipe: 'swipe',
  swipeleft: 'swipe',
  swiperight: 'swipe',
  swipeup: 'swipe',
  swipedown: 'swipe'
};
/**
 * Map gestural events typically provided by browsers
 * that are not reported in 'hammer.input' events
 * to corresponding Hammer.js gestures.
 */
exports.EVENT_RECOGNIZER_MAP = EVENT_RECOGNIZER_MAP;
const GESTURE_EVENT_ALIASES = {
  click: 'tap',
  anyclick: 'anytap',
  dblclick: 'doubletap',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup',
  mouseover: 'pointerover',
  mouseout: 'pointerout',
  mouseleave: 'pointerleave'
};
exports.GESTURE_EVENT_ALIASES = GESTURE_EVENT_ALIASES;
},{"./utils/hammer":"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js"}],"node_modules/mjolnir.js/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.userAgent = exports.passiveSupported = exports.global = exports.document = void 0;
// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global'
/* global window, global, document, navigator */
const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
exports.userAgent = userAgent;
const window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
const global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
const document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;
/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */
let passiveSupported = false;
/* eslint-disable accessor-pairs, no-empty */
exports.passiveSupported = passiveSupported;
try {
  const options = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      exports.passiveSupported = passiveSupported = true;
      return true;
    }
  };
  window_.addEventListener('test', null, options);
  window_.removeEventListener('test', null);
} catch (err) {
  exports.passiveSupported = passiveSupported = false;
}
},{}],"node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
var _constants = require("../constants");
var _globals = require("../utils/globals");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const firefox = _globals.userAgent.indexOf('firefox') !== -1;
const {
  WHEEL_EVENTS: WHEEL_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const EVENT_TYPE = 'wheel';
// Constants for normalizing input delta
const WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const WHEEL_DELTA_PER_LINE = 40;
// Slow down zoom if shift key is held for more precise zooming
const SHIFT_MULTIPLIER = 0.25;
class WheelInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    /* eslint-disable complexity, max-statements */
    this.handleEvent = event => {
      if (!this.options.enable) {
        return;
      }
      let value = event.deltaY;
      if (_globals.window.WheelEvent) {
        // Firefox doubles the values on retina screens...
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }
        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }
      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }
      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        delta: -value,
        srcEvent: event,
        pointerType: 'mouse',
        target: event.target
      });
    };
    this.events = (this.options.events || []).concat(WHEEL_EVENTS);
    this.events.forEach(event => element.addEventListener(event, this.handleEvent, _globals.passiveSupported ? {
      passive: false
    } : false));
  }
  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
}
exports.default = WheelInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js","../constants":"node_modules/mjolnir.js/dist/esm/constants.js","../utils/globals":"node_modules/mjolnir.js/dist/esm/utils/globals.js"}],"node_modules/mjolnir.js/dist/esm/inputs/move-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
var _constants = require("../constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  MOUSE_EVENTS: MOUSE_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const MOVE_EVENT_TYPE = 'pointermove';
const OVER_EVENT_TYPE = 'pointerover';
const OUT_EVENT_TYPE = 'pointerout';
const ENTER_EVENT_TYPE = 'pointerenter';
const LEAVE_EVENT_TYPE = 'pointerleave';
/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */
class MoveInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = event => {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleEnterEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    };
    this.pressed = false;
    const {
      enable: enable
    } = this.options;
    this.enableMoveEvent = enable;
    this.enableLeaveEvent = enable;
    this.enableEnterEvent = enable;
    this.enableOutEvent = enable;
    this.enableOverEvent = enable;
    this.events = (this.options.events || []).concat(MOUSE_EVENTS);
    this.events.forEach(event => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === MOVE_EVENT_TYPE) {
      this.enableMoveEvent = enabled;
    }
    if (eventType === OVER_EVENT_TYPE) {
      this.enableOverEvent = enabled;
    }
    if (eventType === OUT_EVENT_TYPE) {
      this.enableOutEvent = enabled;
    }
    if (eventType === ENTER_EVENT_TYPE) {
      this.enableEnterEvent = enabled;
    }
    if (eventType === LEAVE_EVENT_TYPE) {
      this.enableLeaveEvent = enabled;
    }
  }
  handleOverEvent(event) {
    if (this.enableOverEvent) {
      if (event.type === 'mouseover') {
        this._emit(OVER_EVENT_TYPE, event);
      }
    }
  }
  handleOutEvent(event) {
    if (this.enableOutEvent) {
      if (event.type === 'mouseout') {
        this._emit(OUT_EVENT_TYPE, event);
      }
    }
  }
  handleEnterEvent(event) {
    if (this.enableEnterEvent) {
      if (event.type === 'mouseenter') {
        this._emit(ENTER_EVENT_TYPE, event);
      }
    }
  }
  handleLeaveEvent(event) {
    if (this.enableLeaveEvent) {
      if (event.type === 'mouseleave') {
        this._emit(LEAVE_EVENT_TYPE, event);
      }
    }
  }
  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case 'mousedown':
          if (event.button >= 0) {
            // Button is down
            this.pressed = true;
          }
          break;
        case 'mousemove':
          // Move events use `which` to track the button being pressed
          if (event.which === 0) {
            // Button is not down
            this.pressed = false;
          }
          if (!this.pressed) {
            // Drag events are emitted by hammer already
            // we just need to emit the move event on hover
            this._emit(MOVE_EVENT_TYPE, event);
          }
          break;
        case 'mouseup':
          this.pressed = false;
          break;
        default:
      }
    }
  }
  _emit(type, event) {
    this.callback({
      type: type,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: 'mouse',
      target: event.target
    });
  }
}
exports.default = MoveInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js","../constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/inputs/key-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
var _constants = require("../constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  KEY_EVENTS: KEY_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const DOWN_EVENT_TYPE = 'keydown';
const UP_EVENT_TYPE = 'keyup';
class KeyInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = event => {
      // Ignore if focused on text input
      const targetElement = event.target || event.srcElement;
      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {
        return;
      }
      if (this.enableDownEvent && event.type === 'keydown') {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
      if (this.enableUpEvent && event.type === 'keyup') {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    };
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = (this.options.events || []).concat(KEY_EVENTS);
    element.tabIndex = this.options.tabIndex || 0;
    element.style.outline = 'none';
    this.events.forEach(event => element.addEventListener(event, this.handleEvent));
  }
  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === DOWN_EVENT_TYPE) {
      this.enableDownEvent = enabled;
    }
    if (eventType === UP_EVENT_TYPE) {
      this.enableUpEvent = enabled;
    }
  }
}
exports.default = KeyInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js","../constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _input = _interopRequireDefault(require("./input"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EVENT_TYPE = 'contextmenu';
class ContextmenuInput extends _input.default {
  constructor(element, callback, options) {
    super(element, callback, options);
    this.handleEvent = event => {
      if (!this.options.enable) {
        return;
      }
      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: 'mouse',
        target: event.target
      });
    };
    element.addEventListener('contextmenu', this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener('contextmenu', this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }
}
exports.default = ContextmenuInput;
},{"./input":"node_modules/mjolnir.js/dist/esm/inputs/input.js"}],"node_modules/mjolnir.js/dist/esm/utils/event-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsetPosition = getOffsetPosition;
exports.whichButtons = whichButtons;
/* Constants */
const DOWN_EVENT = 1;
const MOVE_EVENT = 2;
const UP_EVENT = 4;
const MOUSE_EVENTS = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
const MOUSE_EVENT_WHICH_LEFT = 1;
const MOUSE_EVENT_WHICH_MIDDLE = 2;
const MOUSE_EVENT_WHICH_RIGHT = 3;
// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
const MOUSE_EVENT_BUTTON_LEFT = 0;
const MOUSE_EVENT_BUTTON_MIDDLE = 1;
const MOUSE_EVENT_BUTTON_RIGHT = 2;
// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
const MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
 * Extract the involved mouse button
 */
function whichButtons(event) {
  const eventType = MOUSE_EVENTS[event.srcEvent.type];
  if (!eventType) {
    // Not a mouse evet
    return null;
  }
  const {
    buttons: buttons,
    button: button,
    which: which
  } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (
  // button is up, need to find out which one was pressed before
  eventType === UP_EVENT ||
  // moving but does not support `buttons` API
  eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return {
    leftButton: leftButton,
    middleButton: middleButton,
    rightButton: rightButton
  };
}
/**
 * Calculate event position relative to the root element
 */
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  // `center` is a hammer.js event property
  if (!center) {
    // Not a gestural event
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  // Fix scale for map affected by a CSS transform.
  // See https://stackoverflow.com/a/26893663/3528533
  const scaleX = rect.width / rootElement.offsetWidth || 1;
  const scaleY = rect.height / rootElement.offsetHeight || 1;
  // Calculate center relative to the root element
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return {
    center: center,
    offsetCenter: offsetCenter
  };
}
},{}],"node_modules/mjolnir.js/dist/esm/utils/event-registrar.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _eventUtils = require("./event-utils");
const DEFAULT_OPTIONS = {
  srcElement: 'root',
  priority: 0
};
class EventRegistrar {
  constructor(eventManager) {
    /**
     * Handles hammerjs event
     */
    this.handleEvent = event => {
      if (this.isEmpty()) {
        return;
      }
      const mjolnirEvent = this._normalizeEvent(event);
      let target = event.srcEvent.target;
      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);
        if (mjolnirEvent.handled) {
          return;
        }
        target = target.parentNode;
      }
      this._emit(mjolnirEvent, 'root');
    };
    this.eventManager = eventManager;
    this.handlers = [];
    // Element -> handler map
    this.handlersByElement = new Map();
    this._active = false;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(type, handler, options, once = false, passive = false) {
    const {
      handlers: handlers,
      handlersByElement: handlersByElement
    } = this;
    let opts = DEFAULT_OPTIONS;
    if (typeof options === 'string' || options && options.addEventListener) {
      // is DOM element, backward compatibility
      // @ts-ignore
      opts = {
        ...DEFAULT_OPTIONS,
        srcElement: options
      };
    } else if (options) {
      opts = {
        ...DEFAULT_OPTIONS,
        ...options
      };
    }
    let entries = handlersByElement.get(opts.srcElement);
    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }
    const entry = {
      type: type,
      handler: handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };
    if (once) {
      entry.once = true;
    }
    if (passive) {
      entry.passive = true;
    }
    handlers.push(entry);
    this._active = this._active || !entry.passive;
    // Sort handlers by descending priority
    // Handlers with the same priority are excuted in the order of registration
    let insertPosition = entries.length - 1;
    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }
      insertPosition--;
    }
    entries.splice(insertPosition + 1, 0, entry);
  }
  remove(type, handler) {
    const {
      handlers: handlers,
      handlersByElement: handlersByElement
    } = this;
    for (let i = handlers.length - 1; i >= 0; i--) {
      const entry = handlers[i];
      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);
        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }
    this._active = handlers.some(entry => !entry.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);
    if (entries) {
      let immediatePropagationStopped = false;
      // Prevents the current event from bubbling up
      const stopPropagation = () => {
        event.handled = true;
      };
      // Prevent any remaining listeners from being called
      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };
      const entriesToRemove = [];
      for (let i = 0; i < entries.length; i++) {
        const {
          type: type,
          handler: handler,
          once: once
        } = entries[i];
        handler({
          ...event,
          // @ts-ignore
          type: type,
          stopPropagation: stopPropagation,
          stopImmediatePropagation: stopImmediatePropagation
        });
        if (once) {
          entriesToRemove.push(entries[i]);
        }
        if (immediatePropagationStopped) {
          break;
        }
      }
      for (let i = 0; i < entriesToRemove.length; i++) {
        const {
          type: type,
          handler: handler
        } = entriesToRemove[i];
        this.remove(type, handler);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(event) {
    const rootElement = this.eventManager.getElement();
    return {
      ...event,
      ...(0, _eventUtils.whichButtons)(event),
      ...(0, _eventUtils.getOffsetPosition)(event, rootElement),
      preventDefault: () => {
        event.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: false,
      rootElement: rootElement
    };
  }
}
exports.default = EventRegistrar;
},{"./event-utils":"node_modules/mjolnir.js/dist/esm/utils/event-utils.js"}],"node_modules/mjolnir.js/dist/esm/event-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _hammer = require("./utils/hammer");
var _wheelInput = _interopRequireDefault(require("./inputs/wheel-input"));
var _moveInput = _interopRequireDefault(require("./inputs/move-input"));
var _keyInput = _interopRequireDefault(require("./inputs/key-input"));
var _contextmenuInput = _interopRequireDefault(require("./inputs/contextmenu-input"));
var _eventRegistrar = _interopRequireDefault(require("./utils/event-registrar"));
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_OPTIONS = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: _hammer.Manager,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: 'none',
  tabIndex: 0
};
// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.
class EventManager {
  constructor(element = null, options) {
    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */
    this._onBasicInput = event => {
      const {
        srcEvent: srcEvent
      } = event;
      const alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    };
    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */
    this._onOtherEvent = event => {
      // console.log('onotherevent', event.type, event)
      this.manager.emit(event.type, event);
    };
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    this.events = new Map();
    this.setElement(element);
    // Register all passed events.
    const {
      events: events
    } = this.options;
    if (events) {
      this.on(events);
    }
  }
  getElement() {
    return this.element;
  }
  setElement(element) {
    if (this.element) {
      // unregister all events
      this.destroy();
    }
    this.element = element;
    if (!element) {
      return;
    }
    const {
      options: options
    } = this;
    const ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || _constants.RECOGNIZERS
    }).on('hammer.input', this._onBasicInput);
    if (!options.recognizers) {
      // Set default recognize withs
      // http://hammerjs.github.io/recognize-with/
      Object.keys(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(name => {
        const recognizer = this.manager.get(name);
        if (recognizer) {
          _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }
    // Set recognizer options
    for (const recognizerName in options.recognizerOptions) {
      const recognizer = this.manager.get(recognizerName);
      if (recognizer) {
        const recognizerOption = options.recognizerOptions[recognizerName];
        // `enable` is managed by the event registrations
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }
    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this.wheelInput = new _wheelInput.default(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new _moveInput.default(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new _keyInput.default(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new _contextmenuInput.default(element, this._onOtherEvent, {
      enable: false
    });
    // Register all existing events
    for (const [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        // Enable recognizer for this event.
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }
  // Tear down internal event management implementations.
  destroy() {
    if (this.element) {
      // wheelInput etc. are created in setElement() and therefore
      // cannot exist if there is no element
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }
  /** Register an event handler function to be called on `event` */
  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }
  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }
  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }
  off(event, handler) {
    this._removeEventHandler(event, handler);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(name, enabled) {
    const {
      manager: manager
    } = this;
    if (!manager) {
      return;
    }
    const recognizer = manager.get(name);
    // @ts-ignore
    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({
        enable: enabled
      });
      const fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];
      if (fallbackRecognizers && !this.options.recognizers) {
        // Set default require failures
        // http://hammerjs.github.io/require-failure/
        fallbackRecognizers.forEach(otherName => {
          const otherRecognizer = manager.get(otherName);
          if (enabled) {
            // Wait for this recognizer to fail
            otherRecognizer.requireFailure(name);
            /**
             * This seems to be a bug in hammerjs:
             * requireFailure() adds both ways
             * dropRequireFailure() only drops one way
             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
               recognizer-constructor.js#L136
             */
            recognizer.dropRequireFailure(otherName);
          } else {
            // Do not wait for this recognizer to fail
            otherRecognizer.dropRequireFailure(name);
          }
        });
      }
    }
    this.wheelInput.enableEventType(name, enabled);
    this.moveInput.enableEventType(name, enabled);
    this.keyInput.enableEventType(name, enabled);
    this.contextmenuInput.enableEventType(name, enabled);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== 'string') {
      // @ts-ignore
      opts = handler;
      // If `event` is a map, call `on()` for each entry.
      for (const eventName in event) {
        this._addEventHandler(eventName, event[eventName], opts, once, passive);
      }
      return;
    }
    const {
      manager: manager,
      events: events
    } = this;
    // Alias to a recognized gesture as necessary.
    const eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
    let eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      eventRegistrar = new _eventRegistrar.default(this);
      events.set(eventAlias, eventRegistrar);
      // Enable recognizer for this event.
      eventRegistrar.recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Listen to the event
      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
    eventRegistrar.add(event, handler, opts, once, passive);
    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(event, handler) {
    if (typeof event !== 'string') {
      // If `event` is a map, call `off()` for each entry.
      for (const eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }
      return;
    }
    const {
      events: events
    } = this;
    // Alias to a recognized gesture as necessary.
    const eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
    const eventRegistrar = events.get(eventAlias);
    if (!eventRegistrar) {
      return;
    }
    eventRegistrar.remove(event, handler);
    if (eventRegistrar.isEmpty()) {
      const {
        recognizerName: recognizerName
      } = eventRegistrar;
      // Disable recognizer if no more handlers are attached to its events
      let isRecognizerUsed = false;
      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }
      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }
}
exports.default = EventManager;
},{"./utils/hammer":"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js","./inputs/wheel-input":"node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js","./inputs/move-input":"node_modules/mjolnir.js/dist/esm/inputs/move-input.js","./inputs/key-input":"node_modules/mjolnir.js/dist/esm/inputs/key-input.js","./inputs/contextmenu-input":"node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js","./utils/event-registrar":"node_modules/mjolnir.js/dist/esm/utils/event-registrar.js","./constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EventManager", {
  enumerable: true,
  get: function () {
    return _eventManager.default;
  }
});
var _eventManager = _interopRequireDefault(require("./event-manager"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./event-manager":"node_modules/mjolnir.js/dist/esm/event-manager.js"}],"node_modules/@deck.gl/core/dist/esm/lib/deck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layerManager = _interopRequireDefault(require("./layer-manager"));
var _viewManager = _interopRequireDefault(require("./view-manager"));
var _mapView = _interopRequireDefault(require("../views/map-view"));
var _effectManager = _interopRequireDefault(require("./effect-manager"));
var _deckRenderer = _interopRequireDefault(require("./deck-renderer"));
var _deckPicker = _interopRequireDefault(require("./deck-picker"));
var _tooltip = _interopRequireDefault(require("./tooltip"));
var _log = _interopRequireDefault(require("../utils/log"));
var _deepEqual = require("../utils/deep-equal");
var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));
var _init = require("./init");
var _env = require("@probe.gl/env");
var _core = require("@luma.gl/core");
var _stats = require("@probe.gl/stats");
var _mjolnir = require("mjolnir.js");
var _assert = _interopRequireDefault(require("../utils/assert"));
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function noop() {}
const getCursor = ({
  isDragging
}) => isDragging ? 'grabbing' : 'grab';
const defaultProps = {
  id: '',
  width: '100%',
  height: '100%',
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: 'none',
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onInteractionStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLoad: noop,
  onError: error => _log.default.error(error.message)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
class Deck {
  constructor(props) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "width", 0);
    (0, _defineProperty2.default)(this, "height", 0);
    (0, _defineProperty2.default)(this, "userData", {});
    (0, _defineProperty2.default)(this, "canvas", null);
    (0, _defineProperty2.default)(this, "viewManager", null);
    (0, _defineProperty2.default)(this, "layerManager", null);
    (0, _defineProperty2.default)(this, "effectManager", null);
    (0, _defineProperty2.default)(this, "deckRenderer", null);
    (0, _defineProperty2.default)(this, "deckPicker", null);
    (0, _defineProperty2.default)(this, "eventManager", null);
    (0, _defineProperty2.default)(this, "tooltip", null);
    (0, _defineProperty2.default)(this, "metrics", void 0);
    (0, _defineProperty2.default)(this, "animationLoop", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "viewState", void 0);
    (0, _defineProperty2.default)(this, "cursorState", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "_pickRequest", void 0);
    (0, _defineProperty2.default)(this, "_lastPointerDownInfo", null);
    (0, _defineProperty2.default)(this, "_metricsCounter", void 0);
    (0, _defineProperty2.default)(this, "_onPointerMove", event => {
      const {
        _pickRequest
      } = this;
      if (event.type === 'pointerleave') {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;
        if (!pos) {
          return;
        }
        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }
      if (this.layerManager) {
        this.layerManager.context.mousePosition = {
          x: _pickRequest.x,
          y: _pickRequest.y
        };
      }
      _pickRequest.event = event;
    });
    (0, _defineProperty2.default)(this, "_onEvent", event => {
      const eventOptions = _constants.EVENTS[event.type];
      const pos = event.offsetCenter;
      if (!eventOptions || !pos || !this.layerManager) {
        return;
      }
      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const {
        layer
      } = info;
      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      const rootHandler = this.props[eventOptions.handler];
      let handled = false;
      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }
      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    });
    (0, _defineProperty2.default)(this, "_onPointerDown", event => {
      const pos = event.offsetCenter;
      const pickedInfo = this._pick('pickObject', 'pickObject Time', {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    });
    this.props = {
      ...defaultProps,
      ...props
    };
    props = this.props;
    this._needsRedraw = 'Initial render';
    this._pickRequest = {
      mode: 'hover',
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };
    if (props.viewState && props.initialViewState) {
      _log.default.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();
    }
    if ((0, _env.getBrowser)() === 'IE') {
      _log.default.warn('IE 11 is not supported')();
    }
    this.viewState = props.initialViewState;
    if (!props.gl) {
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }
    }
    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new _stats.Stats({
      id: 'deck.gl'
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);
    if (props._typedArrayManagerProps) {
      _typedArrayManager.default.setOptions(props._typedArrayManagerProps);
    }
    this.animationLoop.start();
  }
  finalize() {
    var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
    this.animationLoop.stop();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
    this.layerManager = null;
    (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
    this.viewManager = null;
    (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
    this.effectManager = null;
    (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
    this.deckRenderer = null;
    (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
    this.deckPicker = null;
    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
    this.eventManager = null;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
    this.tooltip = null;
    if (!this.props.canvas && !this.props.gl && this.canvas) {
      var _this$canvas$parentEl;
      (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
      this.canvas = null;
    }
  }
  setProps(props) {
    this.stats.get('setProps Time').timeStart();
    if ('onLayerHover' in props) {
      _log.default.removed('onLayerHover', 'onHover')();
    }
    if ('onLayerClick' in props) {
      _log.default.removed('onLayerClick', 'onClick')();
    }
    if (props.initialViewState && !(0, _deepEqual.deepEqual)(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }
    Object.assign(this.props, props);
    this._setCanvasSize(this.props);
    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop.setProps(resolvedProps);
    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
    }
    this.stats.get('setProps Time').timeEnd();
  }
  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    if (!this.layerManager) {
      return false;
    }
    if (this.props._animate) {
      return 'Deck._animate';
    }
    let redraw = this._needsRedraw;
    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }
    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }
  redraw(reason) {
    if (!this.layerManager) {
      return;
    }
    let redrawReason = this.needsRedraw({
      clearRedrawFlags: true
    });
    redrawReason = reason || redrawReason;
    if (!redrawReason) {
      return;
    }
    this.stats.get('Redraw Count').incrementCount();
    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }
  get isInitialized() {
    return this.viewManager !== null;
  }
  getViews() {
    (0, _assert.default)(this.viewManager);
    return this.viewManager.views;
  }
  getViewports(rect) {
    (0, _assert.default)(this.viewManager);
    return this.viewManager.getViewports(rect);
  }
  pickObject(opts) {
    const infos = this._pick('pickObject', 'pickObject Time', opts).result;
    return infos.length ? infos[0] : null;
  }
  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;
  }
  pickObjects(opts) {
    return this._pick('pickObjects', 'pickObjects Time', opts);
  }
  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({
        resourceId: id,
        data: resources[id],
        forceUpdate
      });
    }
  }
  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }
  _addDefaultEffect(effect) {
    this.effectManager.addDefaultEffect(effect);
  }
  _pick(method, statKey, opts) {
    (0, _assert.default)(this.deckPicker);
    const {
      stats
    } = this;
    stats.get('Pick Count').incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }
  _createCanvas(props) {
    let canvas = props.canvas;
    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
      (0, _assert.default)(canvas);
    }
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = props.id || 'deckgl-overlay';
      const parent = props.parent || document.body;
      parent.appendChild(canvas);
    }
    Object.assign(canvas.style, props.style);
    return canvas;
  }
  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }
    const {
      width,
      height
    } = props;
    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
      this.canvas.style.width = cssWidth;
    }
    if (height || height === 0) {
      var _props$style;
      const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
      this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || 'absolute';
      this.canvas.style.height = cssHeight;
    }
  }
  _updateCanvasSize() {
    const {
      canvas
    } = this;
    if (!canvas) {
      return;
    }
    const newWidth = canvas.clientWidth || canvas.width;
    const newHeight = canvas.clientHeight || canvas.height;
    if (newWidth !== this.width || newHeight !== this.height) {
      var _this$viewManager2;
      this.width = newWidth;
      this.height = newHeight;
      (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
        width: newWidth,
        height: newHeight
      });
      this.props.onResize({
        width: newWidth,
        height: newHeight
      });
    }
  }
  _createAnimationLoop(props) {
    const {
      width,
      height,
      gl,
      glOptions,
      debug,
      onError,
      onBeforeRender,
      onAfterRender,
      useDevicePixels
    } = props;
    return new _core.AnimationLoop({
      width,
      height,
      useDevicePixels,
      autoResizeViewport: false,
      gl,
      onCreateContext: opts => (0, _core.createGLContext)({
        ...glOptions,
        ...opts,
        canvas: this.canvas,
        debug,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: context => this._setGLContext(context.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender,
      onAfterRender,
      onError
    });
  }
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  _getViews() {
    let views = this.props.views || [new _mapView.default({
      id: 'default-view'
    })];
    views = Array.isArray(views) ? views : [views];
    if (views.length && this.props.controller) {
      views[0].props.controller = this.props.controller;
    }
    return views;
  }
  _onContextLost() {
    const {
      onError
    } = this.props;
    if (this.animationLoop && onError) {
      onError(new Error('WebGL context is lost'));
    }
  }
  _pickAndCallback() {
    const {
      _pickRequest
    } = this;
    if (_pickRequest.event) {
      const {
        result,
        emptyInfo
      } = this._pick('pickObject', 'pickObject Time', _pickRequest);
      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;
      for (const info of result) {
        var _info$layer;
        pickedInfo = info;
        handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
      }
      if (!handled && this.props.onHover) {
        this.props.onHover(pickedInfo, _pickRequest.event);
      }
      if (this.props.getTooltip && this.tooltip) {
        const displayInfo = this.props.getTooltip(pickedInfo);
        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
      }
      _pickRequest.event = null;
    }
  }
  _updateCursor() {
    const container = this.props.parent || this.canvas;
    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }
  _setGLContext(gl) {
    if (this.layerManager) {
      return;
    }
    if (!this.canvas) {
      this.canvas = gl.canvas;
      (0, _core.instrumentGLContext)(gl, {
        enable: true,
        copyState: true
      });
    }
    this.tooltip = new _tooltip.default(this.canvas);
    (0, _core.setParameters)(gl, {
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthTest: true,
      depthFunc: 515
    });
    this.props.onWebGLInitialized(gl);
    const timeline = new _core.Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new _mjolnir.EventManager(this.props.parent || gl.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const eventType in _constants.EVENTS) {
      this.eventManager.on(eventType, this._onEvent);
    }
    this.viewManager = new _viewManager.default({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new _layerManager.default(gl, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new _effectManager.default();
    this.deckRenderer = new _deckRenderer.default(gl);
    this.deckPicker = new _deckPicker.default(gl);
    this.setProps(this.props);
    this._updateCanvasSize();
    this.props.onLoad();
  }
  _drawLayers(redrawReason, renderOptions) {
    const {
      gl
    } = this.layerManager.context;
    (0, _core.setParameters)(gl, this.props.parameters);
    this.props.onBeforeRender({
      gl
    });
    this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: 'screen',
      effects: this.effectManager.getEffects(),
      ...renderOptions
    });
    this.props.onAfterRender({
      gl
    });
  }
  _onRenderFrame(animationProps) {
    this._getFrameStats();
    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();
      this.stats.reset();
      _log.default.table(4, this.metrics)();
      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }
    this._updateCanvasSize();
    this._updateCursor();
    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
      this.tooltip.setTooltip(null);
    }
    this.layerManager.updateLayers();
    this._pickAndCallback();
    this.redraw();
    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }
  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;
    if (this.viewState) {
      this.viewState = {
        ...this.viewState,
        [params.viewId]: viewState
      };
      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({
            viewState: this.viewState
          });
        }
      }
    }
  }
  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }
  _getFrameStats() {
    const {
      stats
    } = this;
    stats.get('frameRate').timeEnd();
    stats.get('frameRate').timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);
    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);
  }
  _getMetrics() {
    const {
      metrics,
      stats
    } = this;
    metrics.fps = stats.get('frameRate').getHz();
    metrics.setPropsTime = stats.get('setProps Time').time;
    metrics.updateAttributesTime = stats.get('Update Attributes').time;
    metrics.framesRedrawn = stats.get('Redraw Count').count;
    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;
    metrics.pickCount = stats.get('Pick Count').count;
    metrics.gpuTime = stats.get('GPU Time').time;
    metrics.cpuTime = stats.get('CPU Time').time;
    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();
    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();
    const memoryStats = _core.lumaStats.get('Memory Usage');
    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;
    metrics.textureMemory = memoryStats.get('Texture Memory').count;
    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;
    metrics.gpuMemory = memoryStats.get('GPU Memory').count;
  }
}
exports.default = Deck;
(0, _defineProperty2.default)(Deck, "defaultProps", defaultProps);
(0, _defineProperty2.default)(Deck, "VERSION", _init.VERSION);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./view-manager":"node_modules/@deck.gl/core/dist/esm/lib/view-manager.js","../views/map-view":"node_modules/@deck.gl/core/dist/esm/views/map-view.js","./effect-manager":"node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js","./deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./deck-picker":"node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js","./tooltip":"node_modules/@deck.gl/core/dist/esm/lib/tooltip.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","./init":"node_modules/@deck.gl/core/dist/esm/lib/init.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","mjolnir.js":"node_modules/mjolnir.js/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class ShaderAttribute {
  constructor(dataColumn, opts) {
    (0, _defineProperty2.default)(this, "opts", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    this.opts = opts;
    this.source = dataColumn;
  }
  get value() {
    return this.source.value;
  }
  getValue() {
    const buffer = this.source.getBuffer();
    const accessor = this.getAccessor();
    if (buffer) {
      return [buffer, accessor];
    }
    const {
      value
    } = this.source;
    const {
      size
    } = accessor;
    let constantValue = value;
    if (value && value.length !== size) {
      constantValue = new Float32Array(size);
      const index = accessor.elementOffset || 0;
      for (let i = 0; i < size; ++i) {
        constantValue[i] = value[index + i];
      }
    }
    return constantValue;
  }
  getAccessor() {
    return {
      ...this.source.getAccessor(),
      ...this.opts
    };
  }
}
exports.default = ShaderAttribute;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;
function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error('Unknown GL type');
  }
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _shaderAttribute = _interopRequireDefault(require("./shader-attribute"));
var _glUtils = require("./gl-utils");
var _typedArrayManager = _interopRequireDefault(require("../../utils/typed-array-manager"));
var _mathUtils = require("../../utils/math-utils");
var _log = _interopRequireDefault(require("../../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    _log.default.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();
  }
  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return {
    ...shaderAttributeOptions,
    offset,
    stride
  };
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: {
      ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}
class DataColumn {
  constructor(gl, opts, state) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "size", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    (0, _defineProperty2.default)(this, "value", void 0);
    (0, _defineProperty2.default)(this, "doublePrecision", void 0);
    (0, _defineProperty2.default)(this, "_buffer", void 0);
    (0, _defineProperty2.default)(this, "state", void 0);
    this.gl = gl;
    this.id = opts.id || '';
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === 5130;
    let {
      defaultValue
    } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;
    if (doublePrecision) {
      bufferType = 5126;
    } else if (!logicalType && opts.isIndexed) {
      bufferType = gl && (0, _core.hasFeature)(gl, _core.FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    } else {
      bufferType = logicalType || 5126;
    }
    let defaultType = (0, _glUtils.glArrayFromType)(logicalType || bufferType || 5126);
    this.doublePrecision = doublePrecision;
    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }
    this.value = null;
    this.settings = {
      ...opts,
      defaultType,
      defaultValue: defaultValue,
      logicalType,
      type: bufferType,
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = {
      ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
    this._buffer = null;
  }
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed,
        type
      } = this.settings;
      this._buffer = new _core.Buffer(this.gl, {
        id: this.id,
        target: isIndexed ? 34963 : 34962,
        accessor: {
          type
        }
      });
    }
    return this._buffer;
  }
  get byteOffset() {
    const accessor = this.getAccessor();
    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }
    return 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(n) {
    this.state.numInstances = n;
  }
  delete() {
    if (this._buffer) {
      this._buffer.delete();
      this._buffer = null;
    }
    _typedArrayManager.default.release(this.state.allocatedValue);
  }
  getShaderAttributes(id, options) {
    if (this.doublePrecision) {
      const shaderAttributes = {};
      const isBuffer64Bit = this.value instanceof Float64Array;
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
      shaderAttributes[id] = new _shaderAttribute.default(this, doubleShaderAttributeDefs.high);
      shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new _shaderAttribute.default(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
      return shaderAttributes;
    }
    if (options) {
      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
      return {
        [id]: new _shaderAttribute.default(this, shaderAttributeDef)
      };
    }
    return {
      [id]: this
    };
  }
  getBuffer() {
    if (this.state.constant) {
      return null;
    }
    return this.state.externalBuffer || this._buffer;
  }
  getValue() {
    if (this.state.constant) {
      return this.value;
    }
    return [this.getBuffer(), this.getAccessor()];
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }
    let result = null;
    if (this.state.constant && this.value) {
      const min = Array.from(this.value);
      result = [min, min];
    } else {
      const {
        value,
        numInstances,
        size
      } = this;
      const len = numInstances * size;
      if (value && len && value.length >= len) {
        const min = new Array(size).fill(Infinity);
        const max = new Array(size).fill(-Infinity);
        for (let i = 0; i < len;) {
          for (let j = 0; j < size; j++) {
            const v = value[i++];
            if (v < min[j]) min[j] = v;
            if (v > max[j]) max[j] = v;
          }
        }
        result = [min, max];
      }
    }
    this.state.bounds = result;
    return result;
  }
  setData(data) {
    const {
      state
    } = this;
    let opts;
    if (ArrayBuffer.isView(data)) {
      opts = {
        value: data
      };
    } else if (data instanceof _core.Buffer) {
      opts = {
        buffer: data
      };
    } else {
      opts = data;
    }
    const accessor = {
      ...this.settings,
      ...opts
    };
    state.bufferAccessor = accessor;
    state.bounds = null;
    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);
      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }
      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
      if (!hasChanged) {
        return false;
      }
      state.externalBuffer = null;
      state.constant = true;
      this.value = value;
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value || null;
      const isBuffer64Bit = opts.value instanceof Float64Array;
      accessor.type = opts.type || buffer.accessor.type;
      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
      accessor.stride = getStride(accessor);
    } else if (opts.value) {
      this._checkExternalBuffer(opts);
      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
      const {
        buffer,
        byteOffset
      } = this;
      if (this.doublePrecision && value instanceof Float64Array) {
        value = (0, _mathUtils.toDoublePrecisionArray)(value, accessor);
      }
      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
      if (buffer.byteLength < requiredBufferSize) {
        buffer.reallocate(requiredBufferSize);
      }
      buffer.setAccessor(null);
      buffer.subData({
        data: value,
        offset: byteOffset
      });
      accessor.type = opts.type || buffer.accessor.type;
    }
    return true;
  }
  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const {
      startOffset = 0,
      endOffset
    } = opts;
    this.buffer.subData({
      data: this.doublePrecision && value instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(value, {
        size: this.size,
        startIndex: startOffset,
        endIndex: endOffset
      }) : value.subarray(startOffset, endOffset),
      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
    });
  }
  allocate(numInstances, copy = false) {
    const {
      state
    } = this;
    const oldValue = state.allocatedValue;
    const value = _typedArrayManager.default.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy
    });
    this.value = value;
    const {
      buffer,
      byteOffset
    } = this;
    if (buffer.byteLength < value.byteLength + byteOffset) {
      buffer.reallocate(value.byteLength + byteOffset);
      if (copy && oldValue) {
        buffer.subData({
          data: oldValue instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(oldValue, this) : oldValue,
          offset: byteOffset
        });
      }
    }
    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    state.bufferAccessor = this.settings;
    return true;
  }
  _checkExternalBuffer(opts) {
    const {
      value
    } = opts;
    if (!ArrayBuffer.isView(value)) {
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    }
    const ArrayType = this.settings.defaultType;
    let illegalArrayType = false;
    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }
    if (illegalArrayType) {
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
    }
    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {
      _log.default.warn("Attribute ".concat(this.id, " is normalized"))();
    }
  }
  normalizeConstant(value) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);
      case 5122:
        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);
      case 5121:
        return new Float32Array(value).map(x => x / 255);
      case 5123:
        return new Float32Array(value).map(x => x / 65535);
      default:
        return value;
    }
  }
  _normalizeValue(value, out, start) {
    const {
      defaultValue,
      size
    } = this.settings;
    if (Number.isFinite(value)) {
      out[start] = value;
      return out;
    }
    if (!value) {
      let i = size;
      while (--i >= 0) {
        out[start + i] = defaultValue[i];
      }
      return out;
    }
    switch (size) {
      case 4:
        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
      case 3:
        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
      case 2:
        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
      case 1:
        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;
      default:
        let i = size;
        while (--i >= 0) {
          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }
    }
    return out;
  }
  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }
    const {
      size
    } = this;
    for (let i = 0; i < size; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }
    return true;
  }
}
exports.default = DataColumn;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./shader-attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js","./gl-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js","../../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","../../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIterable = createIterable;
exports.getAccessorFromBuffer = getAccessorFromBuffer;
exports.isAsyncIterable = isAsyncIterable;
const EMPTY_ARRAY = [];
const placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === 'function') {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return {
    iterable,
    objectInfo
  };
}
function isAsyncIterable(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const {
    size,
    stride,
    offset,
    startIndices,
    nested
  } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, {
    index,
    target
  }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;
      for (let j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }
      return target;
    }
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);
        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;
      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        for (let j = 0; j < size; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }
    return result;
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/range.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FULL = exports.EMPTY = void 0;
exports.add = add;
const EMPTY = [];
exports.EMPTY = EMPTY;
const FULL = [[0, Infinity]];
exports.FULL = FULL;
function add(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range[0] < 0) {
    range[0] = 0;
  }
  if (range[0] >= range[1]) {
    return rangeList;
  }
  const newRangeList = [];
  const len = rangeList.length;
  let insertPosition = 0;
  for (let i = 0; i < len; i++) {
    const range0 = rangeList[i];
    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padArray = padArray;
function padArrayChunk(options) {
  const {
    source,
    target,
    start = 0,
    size,
    getData
  } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start;
  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }
  target.set(source, start);
  if (!getData) {
    return;
  }
  let i = sourceLength;
  while (i < targetLength) {
    const datum = getData(i, source);
    for (let j = 0; j < size; j++) {
      target[start + i] = datum[j] || 0;
      i++;
    }
  }
}
function padArray({
  source,
  target,
  size,
  getData,
  sourceStartIndices,
  targetStartIndices
}) {
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      size,
      getData
    });
    return target;
  }
  let sourceIndex = 0;
  let targetIndex = 0;
  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));
  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size;
    const nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }
  return target;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cycleBuffers = cycleBuffers;
exports.getAttributeBufferLength = getAttributeBufferLength;
exports.getAttributeTypeFromSize = getAttributeTypeFromSize;
exports.getSourceBufferAttribute = getSourceBufferAttribute;
exports.normalizeTransitionSettings = normalizeTransitionSettings;
exports.padBuffer = padBuffer;
var _arrayUtils = require("../../utils/array-utils");
const DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: t => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = {
      type: 'interpolation',
      duration: userSettings
    };
  }
  const type = userSettings.type || 'interpolation';
  return {
    ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}
function getSourceBufferAttribute(gl, attribute) {
  const buffer = attribute.getBuffer();
  if (buffer) {
    return [buffer, {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }
  return attribute.value;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return 'float';
    case 2:
      return 'vec2';
    case 3:
      return 'vec3';
    case 4:
      return 'vec4';
    default:
      throw new Error("No defined attribute type for size \"".concat(size, "\""));
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const {
    doublePrecision,
    settings,
    value,
    size
  } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}
function padBuffer({
  buffer,
  numInstances,
  attribute,
  fromLength,
  fromStartIndices,
  getData = x => x
}) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const toLength = getAttributeBufferLength(attribute, numInstances);
  const isConstant = attribute.isConstant;
  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }
  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });
  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;
    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }
  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);
  const source = buffer.getData({
    length: fromLength
  });
  const data = new Float32Array(toLength);
  (0, _arrayUtils.padArray)({
    source,
    target: data,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (buffer.byteLength < data.byteLength + byteOffset) {
    buffer.reallocate(data.byteLength + byteOffset);
  }
  buffer.subData({
    data,
    offset: byteOffset
  });
}
},{"../../utils/array-utils":"node_modules/@deck.gl/core/dist/esm/utils/array-utils.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _dataColumn = _interopRequireDefault(require("./data-column"));
var _assert = _interopRequireDefault(require("../../utils/assert"));
var _iterableUtils = require("../../utils/iterable-utils");
var _flatten = require("../../utils/flatten");
var range = _interopRequireWildcard(require("../../utils/range"));
var _attributeTransitionUtils = require("./attribute-transition-utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Attribute extends _dataColumn.default {
  constructor(gl, opts) {
    super(gl, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      updateRanges: range.FULL
    });
    (0, _defineProperty2.default)(this, "constant", false);
    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);
    Object.seal(this.settings);
    Object.seal(this.state);
    this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(layout) {
    this.state.startIndices = layout;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw({
    clearChangedFlags = false
  } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }
  getUpdateTriggers() {
    const {
      accessor
    } = this.settings;
    return [this.id].concat(typeof accessor !== 'function' && accessor || []);
  }
  supportsTransition() {
    return Boolean(this.settings.transition);
  }
  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }
    const {
      accessor
    } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];
    return (0, _attributeTransitionUtils.normalizeTransitionSettings)(userSettings, layerSettings);
  }
  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);
    if (dataRange) {
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange;
      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = range.FULL;
    }
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = range.EMPTY;
  }
  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }
  allocate(numInstances) {
    const {
      state,
      settings
    } = this;
    if (settings.noAlloc) {
      return false;
    }
    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== range.FULL);
      return true;
    }
    return false;
  }
  updateBuffer({
    numInstances,
    data,
    props,
    context
  }) {
    if (!this.needsUpdate()) {
      return false;
    }
    const {
      state: {
        updateRanges
      },
      settings: {
        update,
        noAlloc
      }
    } = this;
    let updated = true;
    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, {
          data,
          startRow,
          endRow,
          props,
          numInstances
        });
      }
      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({
            startOffset,
            endOffset
          });
        }
      }
      this._checkAttributeArray();
    } else {
      updated = false;
    }
    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }
  setConstantValue(value) {
    if (value === undefined || typeof value === 'function') {
      return false;
    }
    const hasChanged = this.setData({
      constant: true,
      value
    });
    if (hasChanged) {
      this.setNeedsRedraw();
    }
    this.clearNeedsUpdate();
    return true;
  }
  setExternalBuffer(buffer) {
    const {
      state
    } = this;
    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }
    this.clearNeedsUpdate();
    if (state.lastExternalBuffer === buffer) {
      return true;
    }
    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }
  setBinaryValue(buffer, startIndices = null) {
    const {
      state,
      settings
    } = this;
    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }
    if (settings.noAlloc) {
      return false;
    }
    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }
    state.binaryValue = buffer;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;
    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer)) {
        buffer = {
          value: buffer
        };
      }
      const binaryValue = buffer;
      (0, _assert.default)(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = (0, _iterableUtils.getAccessorFromBuffer)(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices: startIndices,
        nested: needsNormalize
      });
      return false;
    }
    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }
  getVertexOffset(row) {
    const {
      startIndices
    } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }
  getShaderAttributes() {
    const shaderAttributeDefs = this.settings.shaderAttributes || {
      [this.id]: null
    };
    const shaderAttributes = {};
    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }
    return shaderAttributes;
  }
  _autoUpdater(attribute, {
    data,
    startRow,
    endRow,
    props,
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }
    const {
      settings,
      state,
      value,
      size,
      startIndices
    } = attribute;
    const {
      accessor,
      transform
    } = settings;
    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);
    (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
    let i = attribute.getVertexOffset(startRow);
    const {
      iterable,
      objectInfo
    } = (0, _iterableUtils.createIterable)(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);
      if (transform) {
        objectValue = transform.call(this, objectValue);
      }
      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i;
          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);
            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);
          (0, _flatten.fillArray)({
            target: value,
            source: objectInfo.target,
            start: i,
            count: numVertices
          });
        }
        i += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i);
        i += size;
      }
    }
  }
  _validateAttributeUpdaters() {
    const {
      settings
    } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';
    if (!hasUpdater) {
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
  }
  _checkAttributeArray() {
    const {
      value
    } = this;
    const limit = Math.min(4, this.size);
    if (value && value.length >= limit) {
      let valid = true;
      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);
        case 3:
          valid = valid && Number.isFinite(value[2]);
        case 2:
          valid = valid && Number.isFinite(value[1]);
        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;
        default:
          valid = false;
      }
      if (!valid) {
        throw new Error("Illegal attribute generated for ".concat(this.id));
      }
    }
  }
}
exports.default = Attribute;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./data-column":"node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js","../../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","../../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","../../utils/range":"node_modules/@deck.gl/core/dist/esm/utils/range.js","./attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _attribute = _interopRequireDefault(require("../lib/attribute/attribute"));
var _attributeTransitionUtils = require("../lib/attribute/attribute-transition-utils");
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GPUInterpolationTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "type", 'interpolation');
    (0, _defineProperty2.default)(this, "attributeInTransition", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    (0, _defineProperty2.default)(this, "attribute", void 0);
    (0, _defineProperty2.default)(this, "transition", void 0);
    (0, _defineProperty2.default)(this, "currentStartIndices", void 0);
    (0, _defineProperty2.default)(this, "currentLength", void 0);
    (0, _defineProperty2.default)(this, "transform", void 0);
    (0, _defineProperty2.default)(this, "buffers", void 0);
    this.gl = gl;
    this.transition = new _transition.default(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _attribute.default(gl, attribute.settings);
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.transform = getTransform(gl, attribute);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances) {
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }
    this.settings = transitionSettings;
    const {
      gl,
      buffers,
      attribute
    } = this;
    (0, _attributeTransitionUtils.cycleBuffers)(buffers);
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };
    for (const buffer of buffers) {
      (0, _attributeTransitionUtils.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0, _attributeTransitionUtils.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start(transitionSettings);
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aFrom: buffers[0],
        aTo: (0, _attributeTransitionUtils.getSourceBufferAttribute)(gl, attribute)
      },
      feedbackBuffers: {
        vCurrent: buffers[1]
      }
    });
  }
  update() {
    const updated = this.transition.update();
    if (updated) {
      const {
        duration,
        easing
      } = this.settings;
      const {
        time
      } = this.transition;
      let t = time / duration;
      if (easing) {
        t = easing(t);
      }
      this.transform.run({
        uniforms: {
          time: t
        }
      });
    }
    return updated;
  }
  cancel() {
    this.transition.cancel();
    this.transform.delete();
    for (const buffer of this.buffers) {
      buffer.delete();
    }
    this.buffers.length = 0;
  }
}
exports.default = GPUInterpolationTransition;
const vs = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
function getTransform(gl, attribute) {
  const attributeType = (0, _attributeTransitionUtils.getAttributeTypeFromSize)(attribute.size);
  return new _core.Transform(gl, {
    vs,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vCurrent']
  });
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/attribute/attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","../lib/attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _attributeTransitionUtils = require("../lib/attribute/attribute-transition-utils");
var _attribute = _interopRequireDefault(require("../lib/attribute/attribute"));
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GPUSpringTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "type", 'spring');
    (0, _defineProperty2.default)(this, "attributeInTransition", void 0);
    (0, _defineProperty2.default)(this, "settings", void 0);
    (0, _defineProperty2.default)(this, "attribute", void 0);
    (0, _defineProperty2.default)(this, "transition", void 0);
    (0, _defineProperty2.default)(this, "currentStartIndices", void 0);
    (0, _defineProperty2.default)(this, "currentLength", void 0);
    (0, _defineProperty2.default)(this, "texture", void 0);
    (0, _defineProperty2.default)(this, "framebuffer", void 0);
    (0, _defineProperty2.default)(this, "transform", void 0);
    (0, _defineProperty2.default)(this, "buffers", void 0);
    this.gl = gl;
    this.type = 'spring';
    this.transition = new _transition.default(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _attribute.default(gl, {
      ...attribute.settings,
      normalized: false
    });
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.texture = getTexture(gl);
    this.framebuffer = getFramebuffer(gl, this.texture);
    this.transform = getTransform(gl, attribute, this.framebuffer);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(transitionSettings, numInstances) {
    const {
      gl,
      buffers,
      attribute
    } = this;
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };
    for (const buffer of buffers) {
      (0, _attributeTransitionUtils.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }
    this.settings = transitionSettings;
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0, _attributeTransitionUtils.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start({
      ...transitionSettings,
      duration: Infinity
    });
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aTo: (0, _attributeTransitionUtils.getSourceBufferAttribute)(gl, attribute)
      }
    });
  }
  update() {
    const {
      buffers,
      transform,
      framebuffer,
      transition
    } = this;
    const updated = transition.update();
    if (!updated) {
      return false;
    }
    const settings = this.settings;
    transform.update({
      sourceBuffers: {
        aPrev: buffers[0],
        aCur: buffers[1]
      },
      feedbackBuffers: {
        vNext: buffers[2]
      }
    });
    transform.run({
      framebuffer,
      discard: false,
      clearRenderTarget: true,
      uniforms: {
        stiffness: settings.stiffness,
        damping: settings.damping
      },
      parameters: {
        depthTest: false,
        blend: true,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    });
    (0, _attributeTransitionUtils.cycleBuffers)(buffers);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: this.attribute.value
    });
    const isTransitioning = (0, _core.readPixelsToArray)(framebuffer)[0] > 0;
    if (!isTransitioning) {
      transition.end();
    }
    return true;
  }
  cancel() {
    this.transition.cancel();
    this.transform.delete();
    for (const buffer of this.buffers) {
      buffer.delete();
    }
    this.buffers.length = 0;
    this.texture.delete();
    this.framebuffer.delete();
  }
}
exports.default = GPUSpringTransition;
function getTransform(gl, attribute, framebuffer) {
  const attributeType = (0, _attributeTransitionUtils.getAttributeTypeFromSize)(attribute.size);
  return new _core.Transform(gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vNext']
  });
}
function getTexture(gl) {
  return new _core.Texture2D(gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function getFramebuffer(gl, texture) {
  return new _core.Framebuffer(gl, {
    id: 'spring-transition-is-transitioning-framebuffer',
    width: 1,
    height: 1,
    attachments: {
      [36064]: texture
    }
  });
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","../lib/attribute/attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _gpuInterpolationTransition = _interopRequireDefault(require("../../transitions/gpu-interpolation-transition"));
var _gpuSpringTransition = _interopRequireDefault(require("../../transitions/gpu-spring-transition"));
var _log = _interopRequireDefault(require("../../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRANSITION_TYPES = {
  interpolation: _gpuInterpolationTransition.default,
  spring: _gpuSpringTransition.default
};
class AttributeTransitionManager {
  constructor(gl, {
    id,
    timeline
  }) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "isSupported", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "timeline", void 0);
    (0, _defineProperty2.default)(this, "transitions", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "numInstances", void 0);
    this.id = id;
    this.gl = gl;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
    this.isSupported = _core.Transform.isSupported(gl);
  }
  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }
  update({
    attributes,
    transitions,
    numInstances
  }) {
    this.numInstances = numInstances || 1;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings) continue;
      this._updateAttribute(attributeName, attribute, settings);
    }
    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];
      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }
  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }
  getAttributes() {
    const animatedAttributes = {};
    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];
      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }
    return animatedAttributes;
  }
  run() {
    if (!this.isSupported || this.numInstances === 0) {
      return false;
    }
    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();
      if (updated) {
        this.needsRedraw = true;
      }
    }
    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }
  _removeTransition(attributeName) {
    this.transitions[attributeName].cancel();
    delete this.transitions[attributeName];
  }
  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;
    if (isNew) {
      if (!this.isSupported) {
        _log.default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
        return;
      }
      if (transition) {
        this._removeTransition(attributeName);
      }
      const TransitionType = TRANSITION_TYPES[settings.type];
      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          gl: this.gl
        });
      } else {
        _log.default.error("unsupported transition type '".concat(settings.type, "'"))();
        isNew = false;
      }
    }
    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }
}
exports.default = AttributeTransitionManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../../transitions/gpu-interpolation-transition":"node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js","../../transitions/gpu-spring-transition":"node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _attribute = _interopRequireDefault(require("./attribute"));
var _log = _interopRequireDefault(require("../../utils/log"));
var _memoize = _interopRequireDefault(require("../../utils/memoize"));
var _mathUtils = require("../../utils/math-utils");
var _debug = _interopRequireDefault(require("../../debug"));
var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_INVALIDATE = 'attributeManager.invalidate';
const TRACE_UPDATE_START = 'attributeManager.updateStart';
const TRACE_UPDATE_END = 'attributeManager.updateEnd';
const TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';
const TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';
const TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';
class AttributeManager {
  constructor(gl, {
    id = 'attribute-manager',
    stats,
    timeline
  } = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "attributes", void 0);
    (0, _defineProperty2.default)(this, "updateTriggers", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "userData", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "attributeTransitionManager", void 0);
    (0, _defineProperty2.default)(this, "mergeBoundsMemoized", (0, _memoize.default)(_mathUtils.mergeBounds));
    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions"),
      timeline
    });
    Object.seal(this);
  }
  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }
    this.attributeTransitionManager.finalize();
  }
  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }
  setNeedsRedraw() {
    this.needsRedraw = true;
  }
  add(attributes) {
    this._add(attributes);
  }
  addInstanced(attributes) {
    this._add(attributes, {
      instanced: 1
    });
  }
  remove(attributeNameArray) {
    for (const name of attributeNameArray) {
      if (this.attributes[name] !== undefined) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }
  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
    (0, _debug.default)(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }
  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }
    (0, _debug.default)(TRACE_INVALIDATE, this, 'all');
  }
  update({
    data,
    numInstances,
    startIndices = null,
    transitions,
    props = {},
    buffers = {},
    context = {}
  }) {
    let updated = false;
    (0, _debug.default)(TRACE_UPDATE_START, this);
    if (this.stats) {
      this.stats.get('Update Attributes').timeStart();
    }
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;
      if (props[attributeName]) {
        _log.default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
      }
      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {
        updated = true;
        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }
      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }
    if (updated) {
      (0, _debug.default)(TRACE_UPDATE_END, this, numInstances);
    }
    if (this.stats) {
      this.stats.get('Update Attributes').timeEnd();
    }
    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }
  updateTransition() {
    const {
      attributeTransitionManager
    } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }
  getAttributes() {
    return this.attributes;
  }
  getBounds(attributeNames) {
    const bounds = attributeNames.map(attributeName => {
      var _this$attributes$attr;
      return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
    });
    return this.mergeBoundsMemoized(bounds);
  }
  getChangedAttributes(opts = {
    clearChangedFlags: false
  }) {
    const {
      attributes,
      attributeTransitionManager
    } = this;
    const changedAttributes = {
      ...attributeTransitionManager.getAttributes()
    };
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }
    return changedAttributes;
  }
  getShaderAttributes(attributes, excludeAttributes = {}) {
    if (!attributes) {
      attributes = this.getAttributes();
    }
    const shaderAttributes = {};
    for (const attributeName in attributes) {
      if (!excludeAttributes[attributeName]) {
        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
      }
    }
    return shaderAttributes;
  }
  _add(attributes, extraProps = {}) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
    }
    this._mapUpdateTriggersToAttributes();
  }
  _createAttribute(name, attribute, extraProps) {
    const props = {
      ...attribute,
      id: name,
      size: attribute.isIndexed && 1 || attribute.size || 1,
      divisor: extraProps.instanced ? 1 : attribute.divisor || 0
    };
    return new _attribute.default(this.gl, props);
  }
  _mapUpdateTriggersToAttributes() {
    const triggers = {};
    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach(triggerName => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }
        triggers[triggerName].push(attributeName);
      });
    }
    this.updateTriggers = triggers;
  }
  _invalidateTrigger(triggerName, dataRange) {
    const {
      attributes,
      updateTriggers
    } = this;
    const invalidatedAttributes = updateTriggers[triggerName];
    if (invalidatedAttributes) {
      invalidatedAttributes.forEach(name => {
        const attribute = attributes[name];
        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }
    return invalidatedAttributes;
  }
  _updateAttribute(opts) {
    const {
      attribute,
      numInstances
    } = opts;
    (0, _debug.default)(TRACE_ATTRIBUTE_UPDATE_START, attribute);
    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }
    if (attribute.allocate(numInstances)) {
      (0, _debug.default)(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }
    const updated = attribute.updateBuffer(opts);
    if (updated) {
      this.needsRedraw = true;
      (0, _debug.default)(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }
}
exports.default = AttributeManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","../../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","./attribute-transition-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@math.gl/core");
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class CPUInterpolationTransition extends _transition.default {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time,
      settings: {
        fromValue,
        toValue,
        duration,
        easing
      }
    } = this;
    const t = easing(time / duration);
    this._value = (0, _core.lerp)(fromValue, toValue, t);
  }
}
exports.default = CPUInterpolationTransition;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _transition = _interopRequireDefault(require("./transition"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EPSILON = 1e-5;
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];
    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;
    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value2);
}
class CPUSpringTransition extends _transition.default {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue,
      toValue,
      damping,
      stiffness
    } = this.settings;
    const {
      _prevValue = fromValue,
      _currValue = fromValue
    } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance(nextValue, toValue);
    const velocity = distance(nextValue, _currValue);
    if (delta < EPSILON && velocity < EPSILON) {
      nextValue = toValue;
      this.end();
    }
    this._prevValue = _currValue;
    this._currValue = nextValue;
  }
}
exports.default = CPUSpringTransition;
},{"./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _attributeTransitionUtils = require("./attribute/attribute-transition-utils");
var _cpuInterpolationTransition = _interopRequireDefault(require("../transitions/cpu-interpolation-transition"));
var _cpuSpringTransition = _interopRequireDefault(require("../transitions/cpu-spring-transition"));
var _log = _interopRequireDefault(require("../utils/log"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRANSITION_TYPES = {
  interpolation: _cpuInterpolationTransition.default,
  spring: _cpuSpringTransition.default
};
class UniformTransitionManager {
  constructor(timeline) {
    this.transitions = new Map();
    this.timeline = timeline;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(key, fromValue, toValue, settings) {
    const {
      transitions
    } = this;
    if (transitions.has(key)) {
      const transition = transitions.get(key);
      const {
        value = transition.settings.fromValue
      } = transition;
      fromValue = value;
      this.remove(key);
    }
    settings = (0, _attributeTransitionUtils.normalizeTransitionSettings)(settings);
    if (!settings) {
      return;
    }
    const TransitionType = TRANSITION_TYPES[settings.type];
    if (!TransitionType) {
      _log.default.error("unsupported transition type '".concat(settings.type, "'"))();
      return;
    }
    const transition = new TransitionType(this.timeline);
    transition.start({
      ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }
  remove(key) {
    const {
      transitions
    } = this;
    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }
  update() {
    const propsInTransition = {};
    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;
      if (!transition.inProgress) {
        this.remove(key);
      }
    }
    return propsInTransition;
  }
  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }
}
exports.default = UniformTransitionManager;
},{"./attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","../transitions/cpu-interpolation-transition":"node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js","../transitions/cpu-spring-transition":"node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareProps = compareProps;
exports.diffProps = diffProps;
exports.validateProps = validateProps;
var _constants = require("./constants");
function validateProps(props) {
  const propTypes = props[_constants.PROP_TYPES_SYMBOL];
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      validate
    } = propType;
    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[_constants.PROP_TYPES_SYMBOL],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }
  const result = {};
  const propTypes = props[_constants.PROP_TYPES_SYMBOL];
  let changed = false;
  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === 'number' || type === 'color' || type === 'array';
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }
  return changed ? result : false;
}
function compareProps({
  newProps,
  oldProps,
  ignoreProps = {},
  propTypes = {},
  triggerName = 'props'
}) {
  if (oldProps === newProps) {
    return false;
  }
  if (typeof newProps !== 'object' || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  if (typeof oldProps !== 'object' || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }
      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }
  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }
      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
  }
  return false;
}
function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;
  if (equal && !equal(newProp, oldProp, propType)) {
    return 'changed deeply';
  }
  if (!equal) {
    equal = newProp && oldProp && newProp.equals;
    if (equal && !equal.call(newProp, oldProp)) {
      return 'changed deeply';
    }
  }
  if (!equal && oldProp !== newProp) {
    return 'changed shallowly';
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }
  let dataChanged = false;
  const {
    dataComparator,
    _dataDiff
  } = props;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = 'Data comparator detected a change';
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = 'A new data container was supplied';
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return {
      all: true
    };
  }
  if ('all' in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, 'all');
    if (diffReason) {
      return {
        all: true
      };
    }
  }
  const reason = {};
  let changed = false;
  for (const triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }
  return changed ? reason : false;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }
  const oldExtensions = oldProps.extensions;
  const {
    extensions
  } = props;
  if (extensions === oldExtensions) {
    return false;
  }
  if (!oldExtensions || !extensions) {
    return true;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}
},{"./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/utils/count.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.count = count;
const ERR_NOT_OBJECT = 'count(): argument not an object';
const ERR_NOT_CONTAINER = 'count(): argument not a container';
function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === 'function') {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value) {
  return value !== null && typeof value === 'object' && value.constructor === Object;
}
function isObject(value) {
  return value !== null && typeof value === 'object';
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeShaders = mergeShaders;
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }
  const result = {
    ...target,
    ...source
  };
  if ('defines' in source) {
    result.defines = {
      ...target.defines,
      ...source.defines
    };
  }
  if ('modules' in source) {
    result.modules = (target.modules || []).concat(source.modules);
    if (source.modules.some(module => module.name === 'project64')) {
      const index = result.modules.findIndex(module => module.name === 'project32');
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ('inject' in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = {
        ...target.inject
      };
      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || '') + source.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/texture.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTexture = createTexture;
exports.destroyTexture = destroyTexture;
var _core = require("@luma.gl/core");
const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
const internalTextures = {};
function createTexture(gl, image, parameters) {
  if (image instanceof _core.Texture2D) {
    return image;
  } else if (image.constructor && image.constructor.name !== 'Object') {
    image = {
      data: image
    };
  }
  let specialTextureParameters = null;
  if (image.compressed) {
    specialTextureParameters = {
      [10241]: image.data.length > 1 ? 9985 : 9729
    };
  }
  const texture = new _core.Texture2D(gl, {
    ...image,
    parameters: {
      ...DEFAULT_TEXTURE_PARAMETERS,
      ...specialTextureParameters,
      ...parameters
    }
  });
  internalTextures[texture.id] = true;
  return texture;
}
function destroyTexture(texture) {
  if (!texture || !(texture instanceof _core.Texture2D)) {
    return;
  }
  if (internalTextures[texture.id]) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;
var _texture = require("../utils/texture");
var _deepEqual = require("../utils/deep-equal");
const TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },
    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
    },
    equal(value1, value2, propType) {
      return (0, _deepEqual.deepEqual)(value1, value2, 1);
    }
  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf(value);
      return valueType === 'function' || valueType === getTypeOf(propType.value);
    },
    equal(value1, value2, propType) {
      if (typeof value2 === 'function') {
        return true;
      }
      return (0, _deepEqual.deepEqual)(value1, value2, 1);
    }
  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },
    equal(value1, value2, propType) {
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? (0, _deepEqual.deepEqual)(value1, value2, depth) : value1 === value2;
    }
  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? (0, _deepEqual.deepEqual)(value1, value2, depth) : value1 === value2;
    }
  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === 'function';
    },
    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }
  },
  data: {
    transform: (value, propType, component) => {
      const {
        dataTransform
      } = component.props;
      return dataTransform && value ? dataTransform(value) : value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;
      if (!context || !context.gl) {
        return null;
      }
      return (0, _texture.createTexture)(context.gl, value, {
        ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: value => {
      (0, _texture.destroyTexture)(value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  const defaultProps = {};
  const deprecatedProps = {};
  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps[propName] = propType.value;
    }
  }
  return {
    propTypes,
    defaultProps,
    deprecatedProps
  };
}
function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      return normalizePropDefinition(name, propDef);
    case 'array':
      return normalizePropDefinition(name, {
        type: 'array',
        value: propDef,
        compare: false
      });
    case 'boolean':
      return normalizePropDefinition(name, {
        type: 'boolean',
        value: propDef
      });
    case 'number':
      return normalizePropDefinition(name, {
        type: 'number',
        value: propDef
      });
    case 'function':
      return normalizePropDefinition(name, {
        type: 'function',
        value: propDef,
        compare: true
      });
    default:
      return {
        name,
        type: 'unknown',
        value: propDef
      };
  }
}
function normalizePropDefinition(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name,
        type: 'object',
        value: propDef
      };
    }
    return {
      name,
      type: getTypeOf(propDef.value),
      ...propDef
    };
  }
  return {
    name,
    ...TYPE_DEFINITIONS[propDef.type],
    ...propDef
  };
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}
function getTypeOf(value) {
  if (isArray(value)) {
    return 'array';
  }
  if (value === null) {
    return 'null';
  }
  return typeof value;
}
},{"../utils/texture":"node_modules/@deck.gl/core/dist/esm/utils/texture.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProps = createProps;
var _log = _interopRequireDefault(require("../utils/log"));
var _iterableUtils = require("../utils/iterable-utils");
var _propTypes = require("./prop-types");
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createProps(component, propObjects) {
  let extensions;
  for (let i = propObjects.length - 1; i >= 0; i--) {
    const props = propObjects[i];
    if ('extensions' in props) {
      extensions = props.extensions;
    }
  }
  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[_constants.COMPONENT_SYMBOL] = component;
  propsInstance[_constants.ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[_constants.ASYNC_RESOLVED_SYMBOL] = {};
  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];
    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
const MergedDefaultPropsCacheKey = '_mergedDefaultProps';
function getPropsPrototype(componentClass, extensions) {
  let cacheKey = MergedDefaultPropsCacheKey;
  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;
      if (ExtensionClass) {
        cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
      }
    }
  }
  const defaultProps = getOwnProperty(componentClass, cacheKey);
  if (!defaultProps) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }
  return defaultProps;
}
function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;
  if (!parent) {
    return null;
  }
  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
  const componentPropDefs = (0, _propTypes.parsePropTypes)(componentDefaultProps);
  const defaultProps = Object.assign(Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[_constants.PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[_constants.DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);
    if (extensionDefaultProps) {
      Object.assign(defaultProps, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[_constants.PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[_constants.DEPRECATED_PROPS_SYMBOL]);
    }
  }
  createPropsPrototype(defaultProps, componentClass);
  addAsyncPropsToPropPrototype(defaultProps, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);
  defaultProps[_constants.PROP_TYPES_SYMBOL] = propTypes;
  defaultProps[_constants.DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
  if (extensions.length === 0 && !hasOwnProperty(componentClass, '_propTypes')) {
    componentClass._propTypes = propTypes;
  }
  return defaultProps;
}
function createPropsPrototype(defaultProps, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps, {
    id: {
      writable: true,
      value: id
    }
  });
}
function addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps, propName, {
      enumerable: false,
      set(newValue) {
        const nameStr = "".concat(this.id, ": ").concat(propName);
        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }
        _log.default.deprecated(nameStr, deprecatedProps[propName].join('/'))();
      }
    });
  }
}
function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
  const defaultValues = {};
  const descriptors = {};
  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      name,
      value
    } = propType;
    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }
  defaultProps[_constants.ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps[_constants.ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps, descriptors);
}
function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,
    set(newValue) {
      if (typeof newValue === 'string' || newValue instanceof Promise || (0, _iterableUtils.isAsyncIterable)(newValue)) {
        this[_constants.ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[_constants.ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },
    get() {
      if (this[_constants.ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[_constants.ASYNC_RESOLVED_SYMBOL]) {
          const value = this[_constants.ASYNC_RESOLVED_SYMBOL][name];
          return value || this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
        }
        if (name in this[_constants.ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[_constants.COMPONENT_SYMBOL] && this[_constants.COMPONENT_SYMBOL].internalState;
          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }
      return this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
    }
  };
}
function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  const componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');
  if (!componentName) {
    _log.default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
  }
  return componentName || componentClass.name;
}
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./prop-types":"node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/component.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _constants = require("./constants");
var _createProps = require("./create-props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
let counter = 0;
class Component {
  constructor(...propObjects) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "count", void 0);
    this.props = (0, _createProps.createProps)(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }
  clone(newProps) {
    const {
      props
    } = this;
    const asyncProps = {};
    for (const key in props[_constants.ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[_constants.ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[_constants.ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[_constants.ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[_constants.ASYNC_ORIGINAL_SYMBOL][key];
      }
    }
    return new this.constructor({
      ...props,
      ...asyncProps,
      ...newProps
    });
  }
}
exports.default = Component;
(0, _defineProperty2.default)(Component, "componentName", 'Component');
(0, _defineProperty2.default)(Component, "defaultProps", {});
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","./create-props":"node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _iterableUtils = require("../utils/iterable-utils");
var _constants = require("./constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const EMPTY_PROPS = Object.freeze({});
class ComponentState {
  constructor(component) {
    (0, _defineProperty2.default)(this, "component", void 0);
    (0, _defineProperty2.default)(this, "onAsyncPropUpdated", void 0);
    (0, _defineProperty2.default)(this, "asyncProps", void 0);
    (0, _defineProperty2.default)(this, "oldProps", void 0);
    (0, _defineProperty2.default)(this, "oldAsyncProps", void 0);
    this.component = component;
    this.asyncProps = {};
    this.onAsyncPropUpdated = () => {};
    this.oldProps = null;
    this.oldAsyncProps = null;
  }
  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }
  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }
  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }
  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }
  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }
    return false;
  }
  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }
  setAsyncProps(props) {
    this.component = props[_constants.COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[_constants.ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[_constants.ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[_constants.ASYNC_DEFAULTS_SYMBOL] || {};
    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
      resolvedValues[propName] = this.getAsyncProp(propName);
    }
    for (const propName in originalValues) {
      const value = originalValues[propName];
      this._createAsyncPropData(propName, defaultValues[propName]);
      this._updateAsyncProp(propName, value);
    }
  }
  _fetch(propName, url) {
    return null;
  }
  _onResolve(propName, value) {}
  _onError(propName, error) {}
  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }
    if (typeof value === 'string') {
      value = this._fetch(propName, value);
    }
    if (value instanceof Promise) {
      this._watchPromise(propName, value);
      return;
    }
    if ((0, _iterableUtils.isAsyncIterable)(value)) {
      this._resolveAsyncIterable(propName, value);
      return;
    }
    this._setPropValue(propName, value);
  }
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }
  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];
    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }
    asyncProp.lastValue = value;
    return true;
  }
  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }
  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {
      this._freezeAsyncOldProps();
      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }
  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];
    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then(data => {
        if (!this.component) {
          return;
        }
        data = this._postProcessValue(asyncProp, data);
        this._setAsyncPropValue(propName, data, loadCount);
        this._onResolve(propName, data);
      }).catch(error => {
        this._onError(propName, error);
      });
    }
  }
  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== 'data') {
      this._setPropValue(propName, iterable);
      return;
    }
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      return;
    }
    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count = 0;
    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }
      const {
        dataTransform
      } = this.component.props;
      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }
      Object.defineProperty(data, '__diff', {
        enumerable: false,
        value: [{
          startRow: count,
          endRow: data.length
        }]
      });
      count = data.length;
      this._setAsyncPropValue(propName, data, loadCount);
    }
    this._onResolve(propName, data);
  }
  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;
    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }
      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }
    return value;
  }
  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];
    if (!asyncProp) {
      const propTypes = this.component && this.component.props[_constants.PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
exports.default = ComponentState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _componentState = _interopRequireDefault(require("../lifecycle/component-state"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LayerState extends _componentState.default {
  constructor({
    attributeManager,
    layer
  }) {
    super(layer);
    (0, _defineProperty2.default)(this, "attributeManager", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "needsUpdate", void 0);
    (0, _defineProperty2.default)(this, "subLayers", void 0);
    (0, _defineProperty2.default)(this, "usesPickingColorCache", void 0);
    (0, _defineProperty2.default)(this, "hasPickingBuffer", void 0);
    (0, _defineProperty2.default)(this, "changeFlags", void 0);
    (0, _defineProperty2.default)(this, "viewport", void 0);
    (0, _defineProperty2.default)(this, "uniformTransitions", void 0);
    (0, _defineProperty2.default)(this, "propsInTransition", void 0);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }
  get layer() {
    return this.component;
  }
  _fetch(propName, url) {
    const layer = this.layer;
    const fetch = layer === null || layer === void 0 ? void 0 : layer.props.fetch;
    if (fetch) {
      return fetch(url, {
        propName,
        layer
      });
    }
    return super._fetch(propName, url);
  }
  _onResolve(propName, value) {
    const layer = this.layer;
    if (layer) {
      const onDataLoad = layer.props.onDataLoad;
      if (propName === 'data' && onDataLoad) {
        onDataLoad(value, {
          propName,
          layer
        });
      }
    }
  }
  _onError(propName, error) {
    const layer = this.layer;
    if (layer) {
      layer.raiseError(error, "loading ".concat(propName, " of ").concat(this.layer));
    }
  }
}
exports.default = LayerState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../lifecycle/component-state":"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _constants = require("./constants");
var _attributeManager = _interopRequireDefault(require("./attribute/attribute-manager"));
var _uniformTransitionManager = _interopRequireDefault(require("./uniform-transition-manager"));
var _props = require("../lifecycle/props");
var _constants2 = require("../lifecycle/constants");
var _count = require("../utils/count");
var _log = _interopRequireDefault(require("../utils/log"));
var _debug = _interopRequireDefault(require("../debug"));
var _core = require("@luma.gl/core");
var _assert = _interopRequireDefault(require("../utils/assert"));
var _memoize = _interopRequireDefault(require("../utils/memoize"));
var _shader = require("../utils/shader");
var _projectFunctions = require("../shaderlib/project/project-functions");
var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));
var _component = _interopRequireDefault(require("../lifecycle/component"));
var _layerState = _interopRequireDefault(require("./layer-state"));
var _webMercator = require("@math.gl/web-mercator");
var _core2 = require("@loaders.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_CHANGE_FLAG = 'layer.changeFlag';
const TRACE_INITIALIZE = 'layer.initialize';
const TRACE_UPDATE = 'layer.update';
const TRACE_FINALIZE = 'layer.finalize';
const TRACE_MATCHED = 'layer.matched';
const MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const EMPTY_ARRAY = Object.freeze([]);
const areViewportsEqual = (0, _memoize.default)(({
  oldViewport,
  viewport
}) => {
  return oldViewport.equals(viewport);
});
let pickingColorCache = new Uint8ClampedArray(0);
const defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: {
    type: 'function',
    value: null,
    optional: true
  },
  _dataDiff: {
    type: 'function',
    value: data => data && data.__diff,
    optional: true
  },
  dataTransform: {
    type: 'function',
    value: null,
    optional: true
  },
  onDataLoad: {
    type: 'function',
    value: null,
    optional: true
  },
  onError: {
    type: 'function',
    value: null,
    optional: true
  },
  fetch: {
    type: 'function',
    value: (url, {
      propName,
      layer,
      loaders,
      loadOptions,
      signal
    }) => {
      const {
        resourceManager
      } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;
      if (signal) {
        var _loadOptions;
        loadOptions = {
          ...loadOptions,
          fetch: {
            ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),
            signal
          }
        };
      }
      let inResourceManager = resourceManager.contains(url);
      if (!inResourceManager && !loadOptions) {
        resourceManager.add({
          resourceId: url,
          data: (0, _core2.load)(url, loaders),
          persistent: false
        });
        inResourceManager = true;
      }
      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: data => {
            var _layer$internalState;
            return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
          },
          consumerId: layer.id,
          requestId: propName
        });
      }
      return (0, _core2.load)(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  operation: 'draw',
  onHover: {
    type: 'function',
    value: null,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    optional: true
  },
  coordinateSystem: _constants.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: 'XYZ',
  colorFormat: 'RGBA',
  parameters: {
    type: 'object',
    value: {},
    optional: true,
    compare: 2
  },
  loadOptions: {
    type: 'object',
    value: null,
    optional: true,
    ignore: true
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: 'array',
    value: [],
    optional: true,
    ignore: true
  },
  getPolygonOffset: {
    type: 'function',
    value: ({
      layerIndex
    }) => [0, -layerIndex * 100]
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'accessor',
    value: [0, 0, 128, 128]
  }
};
class Layer extends _component.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "internalState", null);
    (0, _defineProperty2.default)(this, "lifecycle", _constants2.LIFECYCLE.NO_STATE);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "parent", null);
  }
  get root() {
    let layer = this;
    while (layer.parent) {
      layer = layer.parent;
    }
    return layer;
  }
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return "".concat(className, "({id: '").concat(this.props.id, "'})");
  }
  project(xyz) {
    (0, _assert.default)(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = (0, _projectFunctions.getWorldPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x, y, z] = (0, _webMercator.worldToPixels)(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x, y] : [x, y, z];
  }
  unproject(xy) {
    (0, _assert.default)(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }
  projectPosition(xyz, params) {
    (0, _assert.default)(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return (0, _projectFunctions.projectPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }
  get isComposite() {
    return false;
  }
  setState(partialState) {
    this.setChangeFlags({
      stateChanged: true
    });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }
  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }
  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }
  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem
    } = this.props;
    return coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT || coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN;
  }
  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }
    return false;
  }
  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }
    return false;
  }
  nullPickingColor() {
    return [0, 0, 0];
  }
  encodePickingColor(i, target = []) {
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }
  decodePickingColor(color) {
    (0, _assert.default)(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }
  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }
    if (this.state && this.state.numInstances !== undefined) {
      return this.state.numInstances;
    }
    return (0, _count.count)(this.props.data);
  }
  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }
    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }
    return null;
  }
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['positions', 'instancePositions']);
  }
  getShaders(shaders) {
    for (const extension of this.props.extensions) {
      shaders = (0, _shader.mergeShaders)(shaders, extension.getShaders.call(this, extension));
    }
    return shaders;
  }
  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }
  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const {
      dataChanged
    } = params.changeFlags;
    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }
    if (attributeManager) {
      const {
        props
      } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some(extension => extension.getNeedsPickingBuffer.call(this, extension));
      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const {
          pickingColors,
          instancePickingColors
        } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;
        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }
          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }
  finalizeState(context) {
    for (const model of this.getModels()) {
      model.delete();
    }
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.finalize();
    }
    if (this.context) {
      this.context.resourceManager.unsubscribe({
        consumerId: this.id
      });
    }
    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }
  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }
  getPickingInfo({
    info,
    mode,
    sourceLayer
  }) {
    const {
      index
    } = info;
    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }
    return info;
  }
  raiseError(error, message) {
    var _this$props$onError, _this$props;
    if (message) {
      error.message = "".concat(message, ": ").concat(error.message);
    }
    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {
      var _this$context, _this$context$onError;
      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);
    }
  }
  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    return this._getNeedsRedraw(opts);
  }
  needsUpdate() {
    if (!this.internalState) {
      return false;
    }
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }
  hasUniformTransition() {
    var _this$internalState;
    return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
  }
  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;
    if (!oldViewport || !areViewportsEqual({
      oldViewport,
      viewport
    })) {
      this.setChangeFlags({
        viewportChanged: true
      });
      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }
  invalidateAttribute(name = 'all') {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    if (name === 'all') {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name);
    }
  }
  updateAttributes(changedAttributes) {
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes);
    }
  }
  _updateAttributes() {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager) {
      return;
    }
    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({
      clearChangedFlags: true
    });
    this.updateAttributes(changedAttributes);
  }
  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }
  _updateUniformTransition() {
    const {
      uniformTransitions
    } = this.internalState;
    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);
      for (const key in propsInTransition) {
        Object.defineProperty(props, key, {
          value: propsInTransition[key]
        });
      }
      return props;
    }
    return this.props;
  }
  calculateInstancePickingColors(attribute, {
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }
    const cacheSize = Math.floor(pickingColorCache.length / 3);
    this.internalState.usesPickingColorCache = true;
    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        _log.default.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();
      }
      pickingColorCache = _typedArrayManager.default.allocate(pickingColorCache, numInstances, {
        size: 3,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 3);
      const pickingColor = [];
      for (let i = cacheSize; i < newCacheSize; i++) {
        this.encodePickingColor(i, pickingColor);
        pickingColorCache[i * 3 + 0] = pickingColor[0];
        pickingColorCache[i * 3 + 1] = pickingColor[1];
        pickingColorCache[i * 3 + 2] = pickingColor[2];
      }
    }
    attribute.value = pickingColorCache.subarray(0, numInstances * 3);
  }
  _setModelAttributes(model, changedAttributes) {
    const attributeManager = this.getAttributeManager();
    const excludeAttributes = model.userData.excludeAttributes || {};
    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
    model.setAttributes(shaderAttributes);
  }
  disablePickingIndex(objectIndex) {
    this._disablePickingIndex(objectIndex);
  }
  _disablePickingIndex(objectIndex) {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    const start = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.subData({
      data: new Uint8Array(end - start),
      offset: start
    });
  }
  restorePickingColors() {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    if (!colors) {
      return;
    }
    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }
    colors.updateSubBuffer({
      startOffset: 0
    });
  }
  _initialize() {
    (0, _assert.default)(!this.internalState);
    (0, _assert.default)(Number.isFinite(this.props.coordinateSystem));
    (0, _debug.default)(TRACE_INITIALIZE, this);
    const attributeManager = this._getAttributeManager();
    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateInstancePickingColors
        }
      });
    }
    this.internalState = new _layerState.default({
      attributeManager,
      layer: this
    });
    this._clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, 'attributeManager', {
      get: () => {
        _log.default.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new _uniformTransitionManager.default(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);
    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }
    this.setChangeFlags({
      dataChanged: 'init',
      propsChanged: 'init',
      viewportChanged: true,
      extensionsChanged: true
    });
    this._update();
  }
  _transferState(oldLayer) {
    (0, _debug.default)(TRACE_MATCHED, this, this === oldLayer);
    const {
      state,
      internalState
    } = oldLayer;
    if (this === oldLayer) {
      return;
    }
    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this._diffProps(this.props, this.internalState.getOldProps());
  }
  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    (0, _debug.default)(TRACE_UPDATE, this, stateNeedsUpdate);
    if (!stateNeedsUpdate) {
      return;
    }
    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;
    const propsInTransition = this._updateUniformTransition();
    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;
    try {
      const updateParams = this._getUpdateParams();
      const oldModels = this.getModels();
      if (context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {}
      }
      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }
      const modelChanged = this.getModels()[0] !== oldModels[0];
      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;
      this._clearChangeFlags();
      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }
  _finalize() {
    (0, _debug.default)(TRACE_FINALIZE, this);
    this.finalizeState(this.context);
    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }
  _drawLayer({
    moduleParameters = null,
    uniforms = {},
    parameters = {}
  }) {
    this._updateAttributeTransition();
    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    const opacity = this.props.opacity;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);
    try {
      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }
      const {
        getPolygonOffset
      } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      (0, _core.setParameters)(context.gl, {
        polygonOffset: offsets
      });
      (0, _core.withParameters)(context.gl, parameters, () => {
        const opts = {
          moduleParameters,
          uniforms,
          parameters,
          context
        };
        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }
        this.draw(opts);
      });
    } finally {
      this.props = currentProps;
    }
  }
  getChangeFlags() {
    var _this$internalState2;
    return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
  }
  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }
    const {
      changeFlags
    } = this.internalState;
    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;
        switch (key) {
          case 'dataChanged':
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];
            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }
          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }
        }
        if (flagChanged) {
          (0, _debug.default)(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }
    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }
  _diffProps(newProps, oldProps) {
    const changeFlags = (0, _props.diffProps)(newProps, oldProps);
    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }
    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        var _newProps$transitions;
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
      }
    }
    return this.setChangeFlags(changeFlags);
  }
  validateProps() {
    (0, _props.validateProps)(this.props);
  }
  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }
  _updateAutoHighlight(info) {
    const pickingModuleParameters = {
      pickingSelectedColor: info.picked ? info.color : null
    };
    const {
      highlightColor
    } = this.props;
    if (info.picked && typeof highlightColor === 'function') {
      pickingModuleParameters.pickingHighlightColor = highlightColor(info);
    }
    this.setModuleParameters(pickingModuleParameters);
    this.setNeedsRedraw();
  }
  _getAttributeManager() {
    const context = this.context;
    return new _attributeManager.default(context.gl, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }
  _postUpdate(updateParams, forceUpdate) {
    const {
      props,
      oldProps
    } = updateParams;
    this.setNeedsRedraw();
    this._updateAttributes();
    const {
      model
    } = this.state;
    model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight,
      highlightedObjectIndex,
      highlightColor
    } = props;
    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const parameters = {};
      if (!autoHighlight) {
        parameters.pickingSelectedColor = null;
      }
      if (Array.isArray(highlightColor)) {
        parameters.pickingHighlightColor = highlightColor;
      }
      if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }
      this.setModuleParameters(parameters);
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }
  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }
    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;
    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }
}
exports.default = Layer;
(0, _defineProperty2.default)(Layer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(Layer, "layerName", 'Layer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./uniform-transition-manager":"node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js","../lifecycle/props":"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../utils/count":"node_modules/@deck.gl/core/dist/esm/utils/count.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","../utils/shader":"node_modules/@deck.gl/core/dist/esm/utils/shader.js","../shaderlib/project/project-functions":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","../lifecycle/component":"node_modules/@deck.gl/core/dist/esm/lifecycle/component.js","./layer-state":"node_modules/@deck.gl/core/dist/esm/lib/layer-state.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _layer = _interopRequireDefault(require("./layer"));
var _debug = _interopRequireDefault(require("../debug"));
var _flatten = require("../utils/flatten");
var _constants = require("../lifecycle/constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';
class CompositeLayer extends _layer.default {
  get isComposite() {
    return true;
  }
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);
  }
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  initializeState(context) {}
  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }
  getPickingInfo({
    info
  }) {
    const {
      object
    } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
    if (!isDataWrapped) {
      return info;
    }
    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }
  filterSubLayer(context) {
    return true;
  }
  shouldRenderSubLayer(subLayerId, data) {
    return data && data.length;
  }
  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const {
      _subLayerProps: overridingProps
    } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }
  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }
  getSubLayerAccessor(accessor) {
    if (typeof accessor === 'function') {
      const objectInfo = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (x, i) => {
        if (x && x.__source) {
          objectInfo.index = x.__source.index;
          return accessor(x.__source.object, objectInfo);
        }
        return accessor(x, i);
      };
    }
    return accessor;
  }
  getSubLayerProps(sublayerProps = {}) {
    var _this$props$updateTri;
    const {
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation,
      _subLayerProps: overridingProps
    } = this.props;
    const newProps = {
      id: '',
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || 'sublayer';
    if (overridingSublayerProps) {
      const propTypes = this.props[_constants.PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];
        if (propType && propType.type === 'accessor') {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }
    Object.assign(newProps, sublayerProps, overridingSublayerProps);
    newProps.id = "".concat(this.props.id, "-").concat(sublayerId);
    newProps.updateTriggers = {
      all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };
    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);
      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }
    return newProps;
  }
  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }
  _getAttributeManager() {
    return null;
  }
  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();
    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = (0, _flatten.flatten)(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }
    (0, _debug.default)(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);
    for (const layer of subLayers) {
      layer.parent = this;
    }
  }
}
exports.default = CompositeLayer;
(0, _defineProperty2.default)(CompositeLayer, "layerName", 'CompositeLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _viewport = _interopRequireDefault(require("./viewport"));
var _constants = require("../lib/constants");
var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));
var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEGREES_TO_RADIANS = Math.PI / 180;
const RADIANS_TO_DEGREES = 180 / Math.PI;
const EARTH_RADIUS = 6370972;
const GLOBE_RADIUS = 256;
function getDistanceScales() {
  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]
  };
}
class GlobeViewport extends _viewport.default {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 2,
      resolution = 10
    } = opts;
    let {
      height,
      altitude = 1.5
    } = opts;
    height = height || 1;
    altitude = Math.max(0.75, altitude);
    const viewMatrix = new _core.Matrix4().lookAt({
      eye: [0, -altitude, 0],
      up: [0, 0, 1]
    });
    const scale = Math.pow(2, zoom);
    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);
    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);
    viewMatrix.scale(scale / height);
    const halfFov = Math.atan(0.5 / altitude);
    const relativeScale = GLOBE_RADIUS * 2 * scale / height;
    super({
      ...opts,
      height,
      viewMatrix,
      longitude,
      latitude,
      zoom,
      distanceScales: getDistanceScales(),
      fovyRadians: halfFov * 2,
      focalDistance: altitude,
      near: nearZMultiplier,
      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
    });
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "latitude", void 0);
    (0, _defineProperty2.default)(this, "resolution", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
    this.resolution = resolution;
  }
  get projectionMode() {
    return _constants.PROJECTION_MODE.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const left = this.unproject([0, this.height / 2], unprojectOption);
    const top = this.unproject([this.width / 2, 0], unprojectOption);
    const right = this.unproject([this.width, this.height / 2], unprojectOption);
    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
    if (right[0] < this.longitude) right[0] += 360;
    if (left[0] > this.longitude) left[0] -= 360;
    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
  }
  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const {
      pixelUnprojectionMatrix
    } = this;
    let coord;
    if (Number.isFinite(z)) {
      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);
    } else {
      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);
      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);
      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));
      const l0Sqr = vec3.sqrLen(coord0);
      const l1Sqr = vec3.sqrLen(coord1);
      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
      const dSqr = 4 * sSqr / lSqr;
      const r0 = Math.sqrt(l0Sqr - dSqr);
      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
      const t = (r0 - dr) / Math.sqrt(lSqr);
      coord = vec3.lerp([], coord0, coord1, t);
    }
    const [X, Y, Z] = this.unprojectPosition(coord);
    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }
    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }
  projectPosition(xyz) {
    const [lng, lat, Z = 0] = xyz;
    const lambda = lng * DEGREES_TO_RADIANS;
    const phi = lat * DEGREES_TO_RADIANS;
    const cosPhi = Math.cos(phi);
    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
  }
  unprojectPosition(xyz) {
    const [x, y, z] = xyz;
    const D = vec3.len(xyz);
    const phi = Math.asin(z / D);
    const lambda = Math.atan2(x, -y);
    const lng = lambda * RADIANS_TO_DEGREES;
    const lat = phi * RADIANS_TO_DEGREES;
    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
    return [lng, lat, Z];
  }
  projectFlat(xyz) {
    return xyz;
  }
  unprojectFlat(xyz) {
    return xyz;
  }
  panByPosition(coords, pixel) {
    const fromPosition = this.unproject(pixel);
    return {
      longitude: coords[0] - fromPosition[0] + this.longitude,
      latitude: coords[1] - fromPosition[1] + this.latitude
    };
  }
}
exports.default = GlobeViewport;
function transformVector(matrix, vector) {
  const result = vec4.transformMat4([], vector, matrix);
  vec4.scale(result, result, 1 / result[3]);
  return result;
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _core = require("@math.gl/core");
var _webMercator = require("@math.gl/web-mercator");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEGREES_TO_RADIANS = Math.PI / 180;
function getViewMatrix({
  height,
  focalDistance,
  orbitAxis,
  rotationX,
  rotationOrbit,
  zoom
}) {
  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];
  const eye = orbitAxis === 'Z' ? [0, -focalDistance, 0] : [0, 0, focalDistance];
  const viewMatrix = new _core.Matrix4().lookAt({
    eye,
    up
  });
  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);
  if (orbitAxis === 'Z') {
    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
  } else {
    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
  }
  const projectionScale = Math.pow(2, zoom) / height;
  viewMatrix.scale(projectionScale);
  return viewMatrix;
}
class OrbitViewport extends _viewport.default {
  constructor(props) {
    const {
      height,
      projectionMatrix,
      fovy = 50,
      orbitAxis = 'Z',
      target = [0, 0, 0],
      rotationX = 0,
      rotationOrbit = 0,
      zoom = 0
    } = props;
    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : (0, _webMercator.fovyToAltitude)(fovy);
    super({
      ...props,
      longitude: undefined,
      viewMatrix: getViewMatrix({
        height: height || 1,
        focalDistance,
        orbitAxis,
        rotationX,
        rotationOrbit,
        zoom
      }),
      fovy,
      focalDistance,
      position: target,
      zoom
    });
    (0, _defineProperty2.default)(this, "projectedCenter", void 0);
    this.projectedCenter = this.project(this.center);
  }
  unproject(xyz, {
    topLeft = true
  } = {}) {
    const [x, y, z = this.projectedCenter[2]] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const [X, Y, Z] = (0, _webMercator.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix);
    return [X, Y, Z];
  }
  panByPosition(coords, pixel) {
    const p0 = this.project(coords);
    const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
    return {
      target: this.unproject(nextCenter)
    };
  }
}
exports.default = OrbitViewport;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _core = require("@math.gl/core");
var _webMercator = require("@math.gl/web-mercator");
var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const viewMatrix = new _core.Matrix4().lookAt({
  eye: [0, 0, 1]
});
function getProjectionMatrix({
  width,
  height,
  near,
  far,
  padding
}) {
  let left = -width / 2;
  let right = width / 2;
  let bottom = -height / 2;
  let top = height / 2;
  if (padding) {
    const {
      left: l = 0,
      right: r = 0,
      top: t = 0,
      bottom: b = 0
    } = padding;
    const offsetX = (0, _core.clamp)((l + width - r) / 2, 0, width) - width / 2;
    const offsetY = (0, _core.clamp)((t + height - b) / 2, 0, height) - height / 2;
    left -= offsetX;
    right -= offsetX;
    bottom += offsetY;
    top += offsetY;
  }
  return new _core.Matrix4().ortho({
    left,
    right,
    bottom,
    top,
    near,
    far
  });
}
class OrthographicViewport extends _viewport.default {
  constructor(props) {
    const {
      width,
      height,
      near = 0.1,
      far = 1000,
      zoom = 0,
      target = [0, 0, 0],
      padding = null,
      flipY = true
    } = props;
    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
    const zoom_ = Math.min(zoomX, zoomY);
    const scale = Math.pow(2, zoom_);
    let distanceScales;
    if (zoomX !== zoomY) {
      const scaleX = Math.pow(2, zoomX);
      const scaleY = Math.pow(2, zoomY);
      distanceScales = {
        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],
        metersPerUnit: [scale / scaleX, scale / scaleY, 1]
      };
    }
    super({
      ...props,
      longitude: undefined,
      position: target,
      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),
      projectionMatrix: getProjectionMatrix({
        width: width || 1,
        height: height || 1,
        padding,
        near,
        far
      }),
      zoom: zoom_,
      distanceScales
    });
  }
  projectFlat([X, Y]) {
    const {
      unitsPerMeter
    } = this.distanceScales;
    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];
  }
  unprojectFlat([x, y]) {
    const {
      metersPerUnit
    } = this.distanceScales;
    return [x * metersPerUnit[0], y * metersPerUnit[1]];
  }
  panByPosition(coords, pixel) {
    const fromLocation = (0, _webMercator.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    return {
      target: this.unprojectFlat(newCenter)
    };
  }
}
exports.default = OrthographicViewport;
},{"../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _viewport = _interopRequireDefault(require("../viewports/viewport"));
var _webMercator = require("@math.gl/web-mercator");
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class FirstPersonViewport extends _viewport.default {
  constructor(props) {
    const {
      longitude,
      latitude,
      modelMatrix,
      bearing = 0,
      pitch = 0,
      up = [0, 0, 1]
    } = props;
    const spherical = new _core._SphericalCoordinates({
      bearing,
      pitch: pitch === -90 ? 0.0001 : 90 + pitch
    });
    const dir = spherical.toVector3().normalize();
    const center = modelMatrix ? new _core.Matrix4(modelMatrix).transformAsVector(dir) : dir;
    const zoom = Number.isFinite(latitude) ? (0, _webMercator.getMeterZoom)({
      latitude: latitude
    }) : 0;
    const scale = Math.pow(2, zoom);
    const viewMatrix = new _core.Matrix4().lookAt({
      eye: [0, 0, 0],
      center,
      up
    }).scale(scale);
    super({
      ...props,
      zoom,
      viewMatrix
    });
    (0, _defineProperty2.default)(this, "longitude", void 0);
    (0, _defineProperty2.default)(this, "latitude", void 0);
    this.latitude = latitude;
    this.longitude = longitude;
  }
}
exports.default = FirstPersonViewport;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _controller = _interopRequireDefault(require("./controller"));
var _viewState = _interopRequireDefault(require("./view-state"));
var _mathUtils = require("../utils/math-utils");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
var _core = require("@math.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const MOVEMENT_SPEED = 20;
class FirstPersonState extends _viewState.default {
  constructor(options) {
    const {
      width,
      height,
      position = [0, 0, 0],
      bearing = 0,
      pitch = 0,
      longitude = null,
      latitude = null,
      maxPitch = 90,
      minPitch = -90,
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition
    } = options;
    super({
      width,
      height,
      position,
      bearing,
      pitch,
      longitude,
      latitude,
      maxPitch,
      minPitch
    }, {
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition
    });
  }
  panStart() {
    return this;
  }
  pan() {
    return this;
  }
  panEnd() {
    return this;
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();
    const {
      width,
      height
    } = this.getViewportProps();
    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {
      return this;
    }
    let newRotation;
    if (pos) {
      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      newRotation = {
        bearing: startBearing - deltaScaleX * 180,
        pitch: startPitch - deltaScaleY * 90
      };
    } else {
      newRotation = {
        bearing: startBearing - deltaAngleX,
        pitch: startPitch - deltaAngleY
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startRotatePos: null,
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart() {
    return this._getUpdatedState({
      startZoomPosition: this.getViewportProps().position
    });
  }
  zoom({
    scale
  }) {
    let {
      startZoomPosition
    } = this.getState();
    if (!startZoomPosition) {
      startZoomPosition = this.getViewportProps().position;
    }
    const direction = this.getDirection();
    return this._move(direction, Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null
    });
  }
  moveLeft(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: Math.PI / 2
    }), speed);
  }
  moveRight(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: -Math.PI / 2
    }), speed);
  }
  moveUp(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction, speed);
  }
  moveDown(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.negate(), speed);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }
  zoomIn(speed = 2) {
    return this.zoom({
      scale: speed
    });
  }
  zoomOut(speed = 2) {
    return this.zoom({
      scale: 1 / speed
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;
    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }
    if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }
    return props;
  }
  _move(direction, speed, fromPosition = this.getViewportProps().position) {
    const delta = direction.scale(speed);
    return this._getUpdatedState({
      position: new _core.Vector3(fromPosition).add(delta)
    });
  }
  getDirection(use2D = false) {
    const spherical = new _core._SphericalCoordinates({
      bearing: this.getViewportProps().bearing,
      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
    });
    const direction = spherical.toVector3().normalize();
    return direction;
  }
  _getUpdatedState(newProps) {
    return new FirstPersonState({
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  applyConstraints(props) {
    const {
      pitch,
      maxPitch,
      minPitch,
      longitude,
      bearing
    } = props;
    props.pitch = (0, _core.clamp)(pitch, minPitch, maxPitch);
    if (longitude !== null && (longitude < -180 || longitude > 180)) {
      props.longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      props.bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
    }
    return props;
  }
}
class FirstPersonController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", FirstPersonState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default(['position', 'pitch', 'bearing'])
    });
  }
}
exports.default = FirstPersonController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/views/first-person-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _firstPersonViewport = _interopRequireDefault(require("../viewports/first-person-viewport"));
var _firstPersonController = _interopRequireDefault(require("../controllers/first-person-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class FirstPersonView extends _view.default {
  get ViewportType() {
    return _firstPersonViewport.default;
  }
  get ControllerType() {
    return _firstPersonController.default;
  }
}
exports.default = FirstPersonView;
(0, _defineProperty2.default)(FirstPersonView, "displayName", 'FirstPersonView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/first-person-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js","../controllers/first-person-controller":"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OrbitState = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _viewState = _interopRequireDefault(require("./view-state"));
var _mathUtils = require("../utils/math-utils");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrbitState extends _viewState.default {
  constructor(options) {
    const {
      width,
      height,
      rotationX = 0,
      rotationOrbit = 0,
      target = [0, 0, 0],
      zoom = 0,
      minRotationX = -90,
      maxRotationX = 90,
      minZoom = -Infinity,
      maxZoom = Infinity,
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    } = options;
    super({
      width,
      height,
      rotationX,
      rotationOrbit,
      target,
      zoom,
      minRotationX,
      maxRotationX,
      minZoom,
      maxZoom
    }, {
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    });
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    this.makeViewport = options.makeViewport;
  }
  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(pos)
    });
  }
  pan({
    pos,
    startPosition
  }) {
    const startPanPosition = this.getState().startPanPosition || startPosition;
    if (!startPanPosition) {
      return this;
    }
    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanPosition, pos);
    return this._getUpdatedState(newProps);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }
  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startRotationX: this.getViewportProps().rotationX,
      startRotationOrbit: this.getViewportProps().rotationOrbit
    });
  }
  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startRotationX,
      startRotationOrbit
    } = this.getState();
    const {
      width,
      height
    } = this.getViewportProps();
    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {
      return this;
    }
    let newRotation;
    if (pos) {
      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      if (startRotationX < -90 || startRotationX > 90) {
        deltaScaleX *= -1;
      }
      newRotation = {
        rotationX: startRotationX + deltaScaleY * 180,
        rotationOrbit: startRotationOrbit + deltaScaleX * 180
      };
    } else {
      newRotation = {
        rotationX: startRotationX + deltaAngleY,
        rotationOrbit: startRotationOrbit + deltaAngleX
      };
    }
    return this._getUpdatedState(newRotation);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }
  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = {
      ...this.getViewportProps()
    };
    const {
      rotationOrbit
    } = props;
    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
    }
    return props;
  }
  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomPosition
    } = this.getState();
    if (!startZoomPosition) {
      startZoom = this.getViewportProps().zoom;
      startZoomPosition = this._unproject(startPos) || this._unproject(pos);
    }
    if (!startZoomPosition) {
      return this;
    }
    const newZoom = this._calculateNewZoom({
      scale,
      startZoom
    });
    const zoomedViewport = this.makeViewport({
      ...this.getViewportProps(),
      zoom: newZoom
    });
    return this._getUpdatedState({
      zoom: newZoom,
      ...zoomedViewport.panByPosition(startZoomPosition, pos)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }
  zoomIn(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: speed
      })
    });
  }
  zoomOut(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: 1 / speed
      })
    });
  }
  moveLeft(speed = 50) {
    return this._panFromCenter([-speed, 0]);
  }
  moveRight(speed = 50) {
    return this._panFromCenter([speed, 0]);
  }
  moveUp(speed = 50) {
    return this._panFromCenter([0, -speed]);
  }
  moveDown(speed = 50) {
    return this._panFromCenter([0, speed]);
  }
  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit - speed
    });
  }
  rotateRight(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit + speed
    });
  }
  rotateUp(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX - speed
    });
  }
  rotateDown(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX + speed
    });
  }
  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }
  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }
    const zoom = startZoom + Math.log2(scale);
    return (0, _core.clamp)(zoom, minZoom, maxZoom);
  }
  _panFromCenter(offset) {
    const {
      width,
      height,
      target
    } = this.getViewportProps();
    return this.pan({
      startPosition: target,
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }
  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom,
      maxRotationX,
      minRotationX,
      rotationOrbit
    } = props;
    props.zoom = Array.isArray(zoom) ? [(0, _core.clamp)(zoom[0], minZoom, maxZoom), (0, _core.clamp)(zoom[1], minZoom, maxZoom)] : (0, _core.clamp)(zoom, minZoom, maxZoom);
    props.rotationX = (0, _core.clamp)(props.rotationX, minRotationX, maxRotationX);
    if (rotationOrbit < -180 || rotationOrbit > 180) {
      props.rotationOrbit = (0, _mathUtils.mod)(rotationOrbit + 180, 360) - 180;
    }
    return props;
  }
}
exports.OrbitState = OrbitState;
class OrbitController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", OrbitState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default({
        transitionProps: {
          compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],
          required: ['target', 'zoom']
        }
      })
    });
  }
}
exports.default = OrbitController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/orbit-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _orbitViewport = _interopRequireDefault(require("../viewports/orbit-viewport"));
var _orbitController = _interopRequireDefault(require("../controllers/orbit-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrbitView extends _view.default {
  constructor(props = {}) {
    super(props);
    this.props.orbitAxis = props.orbitAxis || 'Z';
  }
  get ViewportType() {
    return _orbitViewport.default;
  }
  get ControllerType() {
    return _orbitController.default;
  }
}
exports.default = OrbitView;
(0, _defineProperty2.default)(OrbitView, "displayName", 'OrbitView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/orbit-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js","../controllers/orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _orbitController = require("./orbit-controller");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrthographicState extends _orbitController.OrbitState {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "zoomAxis", void 0);
    this.zoomAxis = props.zoomAxis || 'all';
  }
  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }
    let deltaZoom = Math.log2(scale);
    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;
      switch (this.zoomAxis) {
        case 'X':
          newZoomX = (0, _core.clamp)(newZoomX + deltaZoom, minZoom, maxZoom);
          break;
        case 'Y':
          newZoomY = (0, _core.clamp)(newZoomY + deltaZoom, minZoom, maxZoom);
          break;
        default:
          let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z < minZoom) {
            deltaZoom += minZoom - z;
          }
          z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
          if (z > maxZoom) {
            deltaZoom += maxZoom - z;
          }
          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }
      return [newZoomX, newZoomY];
    }
    return (0, _core.clamp)(startZoom + deltaZoom, minZoom, maxZoom);
  }
}
class OrthographicController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", OrthographicState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default(['target', 'zoom'])
    });
    (0, _defineProperty2.default)(this, "dragMode", 'pan');
  }
  _onPanRotate() {
    return false;
  }
}
exports.default = OrthographicController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _orthographicViewport = _interopRequireDefault(require("../viewports/orthographic-viewport"));
var _orthographicController = _interopRequireDefault(require("../controllers/orthographic-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class OrthographicView extends _view.default {
  get ViewportType() {
    return _orthographicViewport.default;
  }
  get ControllerType() {
    return _orthographicController.default;
  }
}
exports.default = OrthographicView;
(0, _defineProperty2.default)(OrthographicView, "displayName", 'OrthographicView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/orthographic-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js","../controllers/orthographic-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _controller = _interopRequireDefault(require("./controller"));
var _mapController = require("./map-controller");
var _mathUtils = require("../utils/math-utils");
var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GlobeState extends _mapController.MapState {
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const {
      longitude,
      latitude
    } = props;
    if (longitude < -180 || longitude > 180) {
      props.longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
    }
    props.latitude = (0, _core.clamp)(latitude, -89, 89);
    return props;
  }
}
class GlobeController extends _controller.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "ControllerState", GlobeState);
    (0, _defineProperty2.default)(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _linearInterpolator.default(['longitude', 'latitude', 'zoom'])
    });
    (0, _defineProperty2.default)(this, "dragMode", 'pan');
  }
  setProps(props) {
    super.setProps(props);
    this.dragRotate = false;
    this.touchRotate = false;
  }
}
exports.default = GlobeController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/views/globe-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _view = _interopRequireDefault(require("./view"));
var _globeViewport = _interopRequireDefault(require("../viewports/globe-viewport"));
var _globeController = _interopRequireDefault(require("../controllers/globe-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class GlobeView extends _view.default {
  get ViewportType() {
    return _globeViewport.default;
  }
  get ControllerType() {
    return _globeController.default;
  }
}
exports.default = GlobeView;
(0, _defineProperty2.default)(GlobeView, "displayName", 'GlobeView');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/globe-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js","../controllers/globe-controller":"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deepEqual = require("../utils/deep-equal");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LayerExtension {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "opts", void 0);
    if (opts) {
      this.opts = opts;
    }
  }
  equals(extension) {
    if (this === extension) {
      return true;
    }
    return this.constructor === extension.constructor && (0, _deepEqual.deepEqual)(this.opts, extension.opts, 1);
  }
  getShaders(extension) {
    return null;
  }
  getSubLayerProps(extension) {
    const {
      defaultProps
    } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };
    for (const key in defaultProps) {
      if (key in this.props) {
        const propDef = defaultProps[key];
        const propValue = this.props[key];
        newProps[key] = propValue;
        if (propDef && propDef.type === 'accessor') {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];
          if (typeof propValue === 'function') {
            newProps[key] = this.getSubLayerAccessor(propValue);
          }
        }
      }
    }
    return newProps;
  }
  initializeState(context, extension) {}
  updateState(params, extension) {}
  onNeedsRedraw(extension) {}
  getNeedsPickingBuffer(extension) {
    return false;
  }
  draw(params, extension) {}
  finalizeState(context, extension) {}
}
exports.default = LayerExtension;
(0, _defineProperty2.default)(LayerExtension, "defaultProps", {});
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));
var _core = require("@math.gl/core");
var _webMercator = require("@math.gl/web-mercator");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];
const DEFAULT_OPTS = {
  speed: 1.2,
  curve: 1.414
};
class FlyToInterpolator extends _transitionInterpolator.default {
  constructor(opts = {}) {
    super({
      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
    });
    (0, _defineProperty2.default)(this, "opts", void 0);
    this.opts = {
      ...DEFAULT_OPTS,
      ...opts
    };
  }
  interpolateProps(startProps, endProps, t) {
    const viewport = (0, _webMercator.flyToViewport)(startProps, endProps, t, this.opts);
    for (const key of LINEARLY_INTERPOLATED_PROPS) {
      viewport[key] = (0, _core.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }
    return viewport;
  }
  getDuration(startProps, endProps) {
    let {
      transitionDuration
    } = endProps;
    if (transitionDuration === 'auto') {
      transitionDuration = (0, _webMercator.getFlyToDuration)(startProps, endProps, this.opts);
    }
    return transitionDuration;
  }
}
exports.default = FlyToInterpolator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/tesselator.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _iterableUtils = require("./iterable-utils");
var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));
var _assert = _interopRequireDefault(require("./assert"));
var _webgl = require("@luma.gl/webgl");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Tesselator {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "opts", void 0);
    (0, _defineProperty2.default)(this, "typedArrayManager", void 0);
    (0, _defineProperty2.default)(this, "indexStarts", [0]);
    (0, _defineProperty2.default)(this, "vertexStarts", [0]);
    (0, _defineProperty2.default)(this, "vertexCount", 0);
    (0, _defineProperty2.default)(this, "instanceCount", 0);
    (0, _defineProperty2.default)(this, "attributes", void 0);
    (0, _defineProperty2.default)(this, "_attributeDefs", void 0);
    (0, _defineProperty2.default)(this, "data", void 0);
    (0, _defineProperty2.default)(this, "getGeometry", void 0);
    (0, _defineProperty2.default)(this, "geometryBuffer", void 0);
    (0, _defineProperty2.default)(this, "buffers", void 0);
    (0, _defineProperty2.default)(this, "positionSize", void 0);
    (0, _defineProperty2.default)(this, "normalize", void 0);
    const {
      attributes = {}
    } = opts;
    this.typedArrayManager = _typedArrayManager.default;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }
  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const {
      data,
      buffers = {},
      getGeometry,
      geometryBuffer,
      positionFormat,
      dataChanged,
      normalize = true
    } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize;
    if (geometryBuffer) {
      (0, _assert.default)(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
      if (!normalize) {
        buffers.positions = geometryBuffer;
      }
    }
    this.geometryBuffer = buffers.positions;
    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }
  updatePartialGeometry({
    startRow,
    endRow
  }) {
    this._rebuildGeometry({
      startRow,
      endRow
    });
  }
  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    if (!ArrayBuffer.isView(value)) {
      return null;
    }
    return (0, _iterableUtils.getAccessorFromBuffer)(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }
  _allocate(instanceCount, copy) {
    const {
      attributes,
      buffers,
      _attributeDefs,
      typedArrayManager
    } = this;
    for (const name in _attributeDefs) {
      if (name in buffers) {
        typedArrayManager.release(attributes[name]);
        attributes[name] = null;
      } else {
        const def = _attributeDefs[name];
        def.copy = copy;
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }
  }
  _forEachGeometry(visitor, startRow, endRow) {
    const {
      data,
      getGeometry
    } = this;
    const {
      iterable,
      objectInfo
    } = (0, _iterableUtils.createIterable)(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
      visitor(geometry, objectInfo.index);
    }
  }
  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }
    let {
      indexStarts,
      vertexStarts,
      instanceCount
    } = this;
    const {
      data,
      geometryBuffer
    } = this;
    const {
      startRow = 0,
      endRow = Infinity
    } = dataRange || {};
    const normalizedData = {};
    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }
    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);
      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || 0;
      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof _webgl.Buffer) {
        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }
    this._allocate(instanceCount, Boolean(dataRange));
    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};
    this._forEachGeometry((geometry, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);
    this.vertexCount = indexStarts[indexStarts.length - 1];
  }
}
exports.default = Tesselator;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","./assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function () {
    return _ambientLight.AmbientLight;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function () {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function () {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function () {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "Controller", {
  enumerable: true,
  get: function () {
    return _controller.default;
  }
});
Object.defineProperty(exports, "Deck", {
  enumerable: true,
  get: function () {
    return _deck.default;
  }
});
Object.defineProperty(exports, "DeckRenderer", {
  enumerable: true,
  get: function () {
    return _deckRenderer.default;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function () {
    return _directionalLight.DirectionalLight;
  }
});
Object.defineProperty(exports, "FirstPersonController", {
  enumerable: true,
  get: function () {
    return _firstPersonController.default;
  }
});
Object.defineProperty(exports, "FirstPersonView", {
  enumerable: true,
  get: function () {
    return _firstPersonView.default;
  }
});
Object.defineProperty(exports, "FirstPersonViewport", {
  enumerable: true,
  get: function () {
    return _firstPersonViewport.default;
  }
});
Object.defineProperty(exports, "FlyToInterpolator", {
  enumerable: true,
  get: function () {
    return _flyToInterpolator.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _layer.default;
  }
});
Object.defineProperty(exports, "LayerExtension", {
  enumerable: true,
  get: function () {
    return _layerExtension.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function () {
    return _layerManager.default;
  }
});
Object.defineProperty(exports, "LightingEffect", {
  enumerable: true,
  get: function () {
    return _lightingEffect.default;
  }
});
Object.defineProperty(exports, "LinearInterpolator", {
  enumerable: true,
  get: function () {
    return _linearInterpolator.default;
  }
});
Object.defineProperty(exports, "MapController", {
  enumerable: true,
  get: function () {
    return _mapController.default;
  }
});
Object.defineProperty(exports, "MapView", {
  enumerable: true,
  get: function () {
    return _mapView.default;
  }
});
Object.defineProperty(exports, "OPERATION", {
  enumerable: true,
  get: function () {
    return _constants.OPERATION;
  }
});
Object.defineProperty(exports, "OrbitController", {
  enumerable: true,
  get: function () {
    return _orbitController.default;
  }
});
Object.defineProperty(exports, "OrbitView", {
  enumerable: true,
  get: function () {
    return _orbitView.default;
  }
});
Object.defineProperty(exports, "OrbitViewport", {
  enumerable: true,
  get: function () {
    return _orbitViewport.default;
  }
});
Object.defineProperty(exports, "OrthographicController", {
  enumerable: true,
  get: function () {
    return _orthographicController.default;
  }
});
Object.defineProperty(exports, "OrthographicView", {
  enumerable: true,
  get: function () {
    return _orthographicView.default;
  }
});
Object.defineProperty(exports, "OrthographicViewport", {
  enumerable: true,
  get: function () {
    return _orthographicViewport.default;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function () {
    return _pointLight.PointLight;
  }
});
Object.defineProperty(exports, "PostProcessEffect", {
  enumerable: true,
  get: function () {
    return _postProcessEffect.default;
  }
});
Object.defineProperty(exports, "TRANSITION_EVENTS", {
  enumerable: true,
  get: function () {
    return _transitionManager.TRANSITION_EVENTS;
  }
});
Object.defineProperty(exports, "Tesselator", {
  enumerable: true,
  get: function () {
    return _tesselator.default;
  }
});
Object.defineProperty(exports, "TransitionInterpolator", {
  enumerable: true,
  get: function () {
    return _transitionInterpolator.default;
  }
});
Object.defineProperty(exports, "UNIT", {
  enumerable: true,
  get: function () {
    return _constants.UNIT;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _init.VERSION;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function () {
    return _view.default;
  }
});
Object.defineProperty(exports, "Viewport", {
  enumerable: true,
  get: function () {
    return _viewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "_CameraLight", {
  enumerable: true,
  get: function () {
    return _cameraLight.default;
  }
});
Object.defineProperty(exports, "_GlobeController", {
  enumerable: true,
  get: function () {
    return _globeController.default;
  }
});
Object.defineProperty(exports, "_GlobeView", {
  enumerable: true,
  get: function () {
    return _globeView.default;
  }
});
Object.defineProperty(exports, "_GlobeViewport", {
  enumerable: true,
  get: function () {
    return _globeViewport.default;
  }
});
Object.defineProperty(exports, "_LayersPass", {
  enumerable: true,
  get: function () {
    return _layersPass.default;
  }
});
Object.defineProperty(exports, "_PickLayersPass", {
  enumerable: true,
  get: function () {
    return _pickLayersPass.default;
  }
});
Object.defineProperty(exports, "_SunLight", {
  enumerable: true,
  get: function () {
    return _sunLight.default;
  }
});
Object.defineProperty(exports, "_compareProps", {
  enumerable: true,
  get: function () {
    return _props.compareProps;
  }
});
Object.defineProperty(exports, "_count", {
  enumerable: true,
  get: function () {
    return _count.count;
  }
});
Object.defineProperty(exports, "_deepEqual", {
  enumerable: true,
  get: function () {
    return _deepEqual.deepEqual;
  }
});
Object.defineProperty(exports, "_fillArray", {
  enumerable: true,
  get: function () {
    return _flatten.fillArray;
  }
});
Object.defineProperty(exports, "_flatten", {
  enumerable: true,
  get: function () {
    return _flatten.flatten;
  }
});
Object.defineProperty(exports, "_memoize", {
  enumerable: true,
  get: function () {
    return _memoize.default;
  }
});
Object.defineProperty(exports, "_mergeShaders", {
  enumerable: true,
  get: function () {
    return _shader.mergeShaders;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "createIterable", {
  enumerable: true,
  get: function () {
    return _iterableUtils.createIterable;
  }
});
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _mathUtils.fp64LowPart;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _shaderlib.gouraudLighting;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _shaderlib.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shaderlib.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shaderlib.project;
  }
});
Object.defineProperty(exports, "project32", {
  enumerable: true,
  get: function () {
    return _shaderlib.project32;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function () {
    return _shaderlib.shadow;
  }
});
var _init = require("./lib/init");
var _constants = require("./lib/constants");
var _lightingEffect = _interopRequireDefault(require("./effects/lighting/lighting-effect"));
var _ambientLight = require("./effects/lighting/ambient-light");
var _directionalLight = require("./effects/lighting/directional-light");
var _pointLight = require("./effects/lighting/point-light");
var _cameraLight = _interopRequireDefault(require("./effects/lighting/camera-light"));
var _sunLight = _interopRequireDefault(require("./effects/lighting/sun-light"));
var _postProcessEffect = _interopRequireDefault(require("./effects/post-process-effect"));
var _layersPass = _interopRequireDefault(require("./passes/layers-pass"));
var _pickLayersPass = _interopRequireDefault(require("./passes/pick-layers-pass"));
var _deck = _interopRequireDefault(require("./lib/deck"));
var _layerManager = _interopRequireDefault(require("./lib/layer-manager"));
var _attributeManager = _interopRequireDefault(require("./lib/attribute/attribute-manager"));
var _layer = _interopRequireDefault(require("./lib/layer"));
var _compositeLayer = _interopRequireDefault(require("./lib/composite-layer"));
var _deckRenderer = _interopRequireDefault(require("./lib/deck-renderer"));
var _viewport = _interopRequireDefault(require("./viewports/viewport"));
var _webMercatorViewport = _interopRequireDefault(require("./viewports/web-mercator-viewport"));
var _globeViewport = _interopRequireDefault(require("./viewports/globe-viewport"));
var _orbitViewport = _interopRequireDefault(require("./viewports/orbit-viewport"));
var _orthographicViewport = _interopRequireDefault(require("./viewports/orthographic-viewport"));
var _firstPersonViewport = _interopRequireDefault(require("./viewports/first-person-viewport"));
var _shaderlib = require("./shaderlib");
var _view = _interopRequireDefault(require("./views/view"));
var _mapView = _interopRequireDefault(require("./views/map-view"));
var _firstPersonView = _interopRequireDefault(require("./views/first-person-view"));
var _orbitView = _interopRequireDefault(require("./views/orbit-view"));
var _orthographicView = _interopRequireDefault(require("./views/orthographic-view"));
var _globeView = _interopRequireDefault(require("./views/globe-view"));
var _controller = _interopRequireDefault(require("./controllers/controller"));
var _mapController = _interopRequireDefault(require("./controllers/map-controller"));
var _globeController = _interopRequireDefault(require("./controllers/globe-controller"));
var _firstPersonController = _interopRequireDefault(require("./controllers/first-person-controller"));
var _orbitController = _interopRequireDefault(require("./controllers/orbit-controller"));
var _orthographicController = _interopRequireDefault(require("./controllers/orthographic-controller"));
var _layerExtension = _interopRequireDefault(require("./lib/layer-extension"));
var _transitionManager = require("./controllers/transition-manager");
var _transitionInterpolator = _interopRequireDefault(require("./transitions/transition-interpolator"));
var _linearInterpolator = _interopRequireDefault(require("./transitions/linear-interpolator"));
var _flyToInterpolator = _interopRequireDefault(require("./transitions/fly-to-interpolator"));
var _log = _interopRequireDefault(require("./utils/log"));
var _assert = _interopRequireDefault(require("./utils/assert"));
var _iterableUtils = require("./utils/iterable-utils");
var _mathUtils = require("./utils/math-utils");
var _tesselator = _interopRequireDefault(require("./utils/tesselator"));
var _flatten = require("./utils/flatten");
var _count = require("./utils/count");
var _deepEqual = require("./utils/deep-equal");
var _memoize = _interopRequireDefault(require("./utils/memoize"));
var _shader = require("./utils/shader");
var _props = require("./lifecycle/props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/init":"node_modules/@deck.gl/core/dist/esm/lib/init.js","./lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./effects/lighting/lighting-effect":"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js","./effects/lighting/ambient-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js","./effects/lighting/directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","./effects/lighting/point-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","./effects/lighting/camera-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js","./effects/lighting/sun-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js","./effects/post-process-effect":"node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js","./passes/layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","./passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","./lib/deck":"node_modules/@deck.gl/core/dist/esm/lib/deck.js","./lib/layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./lib/attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./lib/layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","./lib/composite-layer":"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","./lib/deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","./viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","./viewports/globe-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js","./viewports/orbit-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js","./viewports/orthographic-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js","./viewports/first-person-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js","./shaderlib":"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js","./views/view":"node_modules/@deck.gl/core/dist/esm/views/view.js","./views/map-view":"node_modules/@deck.gl/core/dist/esm/views/map-view.js","./views/first-person-view":"node_modules/@deck.gl/core/dist/esm/views/first-person-view.js","./views/orbit-view":"node_modules/@deck.gl/core/dist/esm/views/orbit-view.js","./views/orthographic-view":"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js","./views/globe-view":"node_modules/@deck.gl/core/dist/esm/views/globe-view.js","./controllers/controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./controllers/map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","./controllers/globe-controller":"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js","./controllers/first-person-controller":"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js","./controllers/orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","./controllers/orthographic-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js","./lib/layer-extension":"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js","./controllers/transition-manager":"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","./transitions/transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","./transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transitions/fly-to-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js","./utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","./utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","./utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","./utils/tesselator":"node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","./utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","./utils/count":"node_modules/@deck.gl/core/dist/esm/utils/count.js","./utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","./utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","./utils/shader":"node_modules/@deck.gl/core/dist/esm/utils/shader.js","./lifecycle/props":"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js"}],"node_modules/@deck.gl/mapbox/dist/esm/deck-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addLayer = addLayer;
exports.drawLayer = drawLayer;
exports.getDeckInstance = getDeckInstance;
exports.getInterleavedProps = getInterleavedProps;
exports.getViewState = getViewState;
exports.removeLayer = removeLayer;
exports.updateLayer = updateLayer;
var _core = require("@deck.gl/core");
var _webMercator = require("@math.gl/web-mercator");
const TILE_SIZE = 512;
const DEGREES_TO_RADIANS = Math.PI / 180;
function getDeckInstance({
  map,
  gl,
  deck
}) {
  if (map.__deck) {
    return map.__deck;
  }
  const customRender = deck === null || deck === void 0 ? void 0 : deck.props._customRender;
  const onLoad = deck === null || deck === void 0 ? void 0 : deck.props.onLoad;
  const deckProps = getInterleavedProps({
    ...(deck === null || deck === void 0 ? void 0 : deck.props),
    _customRender: () => {
      map.triggerRepaint();
      customRender === null || customRender === void 0 ? void 0 : customRender('');
    }
  });
  let deckInstance;
  if (!deck || deck.props.gl === gl) {
    Object.assign(deckProps, {
      gl,
      width: null,
      height: null,
      touchAction: 'unset',
      viewState: getViewState(map)
    });
    if (deck !== null && deck !== void 0 && deck.isInitialized) {
      watchMapMove(deck, map);
    } else {
      deckProps.onLoad = () => {
        onLoad === null || onLoad === void 0 ? void 0 : onLoad();
        watchMapMove(deckInstance, map);
      };
    }
  }
  if (deck) {
    deckInstance = deck;
    deck.setProps(deckProps);
    deck.userData.isExternal = true;
  } else {
    deckInstance = new _core.Deck(deckProps);
    map.on('remove', () => {
      deckInstance.finalize();
      map.__deck = null;
    });
  }
  deckInstance.userData.mapboxLayers = new Set();
  map.__deck = deckInstance;
  map.on('render', () => {
    if (deckInstance.isInitialized) afterRender(deckInstance, map);
  });
  return deckInstance;
}
function watchMapMove(deck, map) {
  const _handleMapMove = () => {
    if (deck.isInitialized) {
      onMapMove(deck, map);
    } else {
      map.off('move', _handleMapMove);
    }
  };
  map.on('move', _handleMapMove);
}
function getInterleavedProps(currProps) {
  const useDevicePixels = 'useDevicePixels' in currProps ? currProps.useDevicePixels : true;
  const nextProps = {
    ...currProps,
    useDevicePixels,
    parameters: {
      depthMask: true,
      depthTest: true,
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthFunc: 515,
      blendEquation: 32774,
      ...currProps.parameters
    },
    views: currProps.views || [new _core.MapView({
      id: 'mapbox'
    })]
  };
  return nextProps;
}
function addLayer(deck, layer) {
  deck.userData.mapboxLayers.add(layer);
  updateLayers(deck);
}
function removeLayer(deck, layer) {
  deck.userData.mapboxLayers.delete(layer);
  updateLayers(deck);
}
function updateLayer(deck, layer) {
  updateLayers(deck);
}
function drawLayer(deck, map, layer) {
  let {
    currentViewport
  } = deck.userData;
  let clearStack = false;
  if (!currentViewport) {
    currentViewport = getViewport(deck, map, true);
    deck.userData.currentViewport = currentViewport;
    clearStack = true;
  }
  if (!deck.isInitialized) {
    return;
  }
  deck._drawLayers('mapbox-repaint', {
    viewports: [currentViewport],
    layerFilter: ({
      layer: deckLayer
    }) => layer.id === deckLayer.id,
    clearStack,
    clearCanvas: false
  });
}
function getViewState(map) {
  var _map$getTerrain;
  const {
    lng,
    lat
  } = map.getCenter();
  const viewState = {
    longitude: (lng + 540) % 360 - 180,
    latitude: lat,
    zoom: map.getZoom(),
    bearing: map.getBearing(),
    pitch: map.getPitch(),
    padding: map.getPadding(),
    repeat: map.getRenderWorldCopies()
  };
  if ((_map$getTerrain = map.getTerrain) !== null && _map$getTerrain !== void 0 && _map$getTerrain.call(map)) {
    centerCameraOnTerrain(map, viewState);
  }
  return viewState;
}
function centerCameraOnTerrain(map, viewState) {
  if (map.getFreeCameraOptions) {
    const {
      position
    } = map.getFreeCameraOptions();
    if (!position || position.z === undefined) {
      return;
    }
    const height = map.transform.height;
    const {
      longitude,
      latitude,
      pitch
    } = viewState;
    const cameraX = position.x * TILE_SIZE;
    const cameraY = (1 - position.y) * TILE_SIZE;
    const cameraZ = position.z * TILE_SIZE;
    const center = (0, _webMercator.lngLatToWorld)([longitude, latitude]);
    const dx = cameraX - center[0];
    const dy = cameraY - center[1];
    const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
    const pitchRadians = pitch * DEGREES_TO_RADIANS;
    const altitudePixels = 1.5 * height;
    const scale = pitchRadians < 0.001 ? altitudePixels * Math.cos(pitchRadians) / cameraZ : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
    viewState.zoom = Math.log2(scale);
    const cameraZFromSurface = altitudePixels * Math.cos(pitchRadians) / scale;
    const surfaceElevation = cameraZ - cameraZFromSurface;
    viewState.position = [0, 0, surfaceElevation / (0, _webMercator.unitsPerMeter)(latitude)];
  } else if (typeof map.transform.elevation === 'number') {
    viewState.position = [0, 0, map.transform.elevation];
  }
}
function getViewport(deck, map, useMapboxProjection = true) {
  return new _core.WebMercatorViewport({
    id: 'mapbox',
    x: 0,
    y: 0,
    width: deck.width,
    height: deck.height,
    ...getViewState(map),
    nearZMultiplier: useMapboxProjection ? 0.02 : 0.1
  });
}
function afterRender(deck, map) {
  const {
    mapboxLayers,
    isExternal
  } = deck.userData;
  if (isExternal) {
    const mapboxLayerIds = Array.from(mapboxLayers, layer => layer.id);
    const deckLayers = (0, _core._flatten)(deck.props.layers, Boolean);
    const hasNonMapboxLayers = deckLayers.some(layer => layer && !mapboxLayerIds.includes(layer.id));
    let viewports = deck.getViewports();
    const mapboxViewportIdx = viewports.findIndex(vp => vp.id === 'mapbox');
    const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
    if (hasNonMapboxLayers || hasNonMapboxViews) {
      if (mapboxViewportIdx >= 0) {
        viewports = viewports.slice();
        viewports[mapboxViewportIdx] = getViewport(deck, map, false);
      }
      deck._drawLayers('mapbox-repaint', {
        viewports,
        layerFilter: params => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== 'mapbox' || !mapboxLayerIds.includes(params.layer.id)),
        clearCanvas: false
      });
    }
  }
  deck.userData.currentViewport = null;
}
function onMapMove(deck, map) {
  deck.setProps({
    viewState: getViewState(map)
  });
  deck.needsRedraw({
    clearRedrawFlags: true
  });
}
function updateLayers(deck) {
  if (deck.userData.isExternal) {
    return;
  }
  const layers = [];
  deck.userData.mapboxLayers.forEach(deckLayer => {
    const LayerType = deckLayer.props.type;
    const layer = new LayerType(deckLayer.props);
    layers.push(layer);
  });
  deck.setProps({
    layers
  });
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/mapbox/dist/esm/mapbox-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _deckUtils = require("./deck-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class MapboxLayer {
  constructor(props) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "renderingMode", void 0);
    (0, _defineProperty2.default)(this, "map", void 0);
    (0, _defineProperty2.default)(this, "deck", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    if (!props.id) {
      throw new Error('Layer must have an unique id');
    }
    this.id = props.id;
    this.type = 'custom';
    this.renderingMode = props.renderingMode || '3d';
    this.map = null;
    this.deck = null;
    this.props = props;
  }
  onAdd(map, gl) {
    this.map = map;
    this.deck = (0, _deckUtils.getDeckInstance)({
      map,
      gl,
      deck: this.props.deck
    });
    (0, _deckUtils.addLayer)(this.deck, this);
  }
  onRemove() {
    if (this.deck) {
      (0, _deckUtils.removeLayer)(this.deck, this);
    }
  }
  setProps(props) {
    Object.assign(this.props, props, {
      id: this.id
    });
    if (this.deck) {
      (0, _deckUtils.updateLayer)(this.deck, this);
    }
  }
  render() {
    (0, _deckUtils.drawLayer)(this.deck, this.map, this);
  }
}
exports.default = MapboxLayer;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./deck-utils":"node_modules/@deck.gl/mapbox/dist/esm/deck-utils.js"}],"node_modules/@deck.gl/mapbox/dist/esm/resolve-layers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveLayers = resolveLayers;
var _core = require("@deck.gl/core");
var _mapboxLayer = _interopRequireDefault(require("./mapbox-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const UNDEFINED_BEFORE_ID = '__UNDEFINED__';
function resolveLayers(map, deck, oldLayers, newLayers) {
  if (!map || !deck || !map.style || !map.style._loaded) {
    return;
  }
  const layers = (0, _core._flatten)(newLayers, Boolean);
  if (oldLayers !== newLayers) {
    const prevLayers = (0, _core._flatten)(oldLayers, Boolean);
    const prevLayerIds = new Set(prevLayers.map(l => l.id));
    for (const layer of layers) {
      prevLayerIds.delete(layer.id);
    }
    for (const id of prevLayerIds) {
      if (map.getLayer(id)) {
        map.removeLayer(id);
      }
    }
  }
  for (const layer of layers) {
    const mapboxLayer = map.getLayer(layer.id);
    if (mapboxLayer) {
      mapboxLayer.implementation.setProps(layer.props);
    } else {
      map.addLayer(new _mapboxLayer.default({
        id: layer.id,
        deck
      }), layer.props.beforeId);
    }
  }
  const mapLayers = map.style._order;
  const layerGroups = {};
  for (const layer of layers) {
    let {
      beforeId
    } = layer.props;
    if (!beforeId || !mapLayers.includes(beforeId)) {
      beforeId = UNDEFINED_BEFORE_ID;
    }
    layerGroups[beforeId] = layerGroups[beforeId] || [];
    layerGroups[beforeId].push(layer.id);
  }
  for (const beforeId in layerGroups) {
    const layerGroup = layerGroups[beforeId];
    let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
    let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? undefined : beforeId;
    for (let i = layerGroup.length - 1; i >= 0; i--) {
      const layerId = layerGroup[i];
      const layerIndex = mapLayers.indexOf(layerId);
      if (layerIndex !== lastLayerIndex - 1) {
        map.moveLayer(layerId, lastLayerId);
        if (layerIndex > lastLayerIndex) {
          lastLayerIndex++;
        }
      }
      lastLayerIndex--;
      lastLayerId = layerId;
    }
  }
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./mapbox-layer":"node_modules/@deck.gl/mapbox/dist/esm/mapbox-layer.js"}],"node_modules/@deck.gl/mapbox/dist/esm/mapbox-overlay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _deckUtils = require("./deck-utils");
var _resolveLayers = require("./resolve-layers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class MapboxOverlay {
  constructor(props) {
    (0, _defineProperty2.default)(this, "_props", void 0);
    (0, _defineProperty2.default)(this, "_deck", void 0);
    (0, _defineProperty2.default)(this, "_map", void 0);
    (0, _defineProperty2.default)(this, "_container", void 0);
    (0, _defineProperty2.default)(this, "_interleaved", void 0);
    (0, _defineProperty2.default)(this, "_handleStyleChange", () => {
      (0, _resolveLayers.resolveLayers)(this._map, this._deck, this._props.layers, this._props.layers);
    });
    (0, _defineProperty2.default)(this, "_updateContainerSize", () => {
      if (this._map && this._container) {
        const {
          clientWidth,
          clientHeight
        } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: "".concat(clientWidth, "px"),
          height: "".concat(clientHeight, "px")
        });
      }
    });
    (0, _defineProperty2.default)(this, "_updateViewState", () => {
      const deck = this._deck;
      if (deck) {
        deck.setProps({
          viewState: (0, _deckUtils.getViewState)(this._map)
        });
        deck.redraw();
      }
    });
    (0, _defineProperty2.default)(this, "_handleMouseEvent", event => {
      const deck = this._deck;
      if (!deck) {
        return;
      }
      const mockEvent = {
        type: event.type,
        offsetCenter: event.point,
        srcEvent: event
      };
      switch (event.type) {
        case 'click':
          mockEvent.tapCount = 1;
          deck._onPointerDown(mockEvent);
          deck._onEvent(mockEvent);
          break;
        case 'dblclick':
          mockEvent.type = 'click';
          mockEvent.tapCount = 2;
          deck._onEvent(mockEvent);
          break;
        case 'mousemove':
          mockEvent.type = 'pointermove';
          deck._onPointerMove(mockEvent);
          break;
        case 'mouseout':
          mockEvent.type = 'pointerleave';
          deck._onPointerMove(mockEvent);
          break;
        default:
          return;
      }
    });
    const {
      interleaved = false,
      ...otherProps
    } = props;
    this._interleaved = interleaved;
    this._props = otherProps;
  }
  setProps(props) {
    if (this._interleaved && props.layers) {
      (0, _resolveLayers.resolveLayers)(this._map, this._deck, this._props.layers, props.layers);
    }
    Object.assign(this._props, props);
    if (this._deck) {
      this._deck.setProps(this._interleaved ? (0, _deckUtils.getInterleavedProps)(this._props) : this._props);
    }
  }
  onAdd(map) {
    this._map = map;
    return this._interleaved ? this._onAddInterleaved(map) : this._onAddOverlaid(map);
  }
  _onAddOverlaid(map) {
    const container = document.createElement('div');
    Object.assign(container.style, {
      position: 'absolute',
      left: 0,
      top: 0,
      pointerEvents: 'none'
    });
    this._container = container;
    this._deck = new _core.Deck({
      ...this._props,
      parent: container,
      viewState: (0, _deckUtils.getViewState)(map)
    });
    map.on('resize', this._updateContainerSize);
    map.on('render', this._updateViewState);
    map.on('mousemove', this._handleMouseEvent);
    map.on('mouseout', this._handleMouseEvent);
    map.on('click', this._handleMouseEvent);
    map.on('dblclick', this._handleMouseEvent);
    this._updateContainerSize();
    return container;
  }
  _onAddInterleaved(map) {
    this._deck = (0, _deckUtils.getDeckInstance)({
      map,
      gl: map.painter.context.gl,
      deck: new _core.Deck({
        ...this._props,
        gl: map.painter.context.gl
      })
    });
    map.on('styledata', this._handleStyleChange);
    (0, _resolveLayers.resolveLayers)(map, this._deck, [], this._props.layers);
    return document.createElement('div');
  }
  onRemove() {
    var _this$_deck;
    const map = this._map;
    if (map) {
      if (this._interleaved) {
        this._onRemoveInterleaved(map);
      } else {
        this._onRemoveOverlaid(map);
      }
    }
    (_this$_deck = this._deck) === null || _this$_deck === void 0 ? void 0 : _this$_deck.finalize();
    this._deck = undefined;
    this._map = undefined;
    this._container = undefined;
  }
  _onRemoveOverlaid(map) {
    map.off('resize', this._updateContainerSize);
    map.off('render', this._updateViewState);
    map.off('mousemove', this._handleMouseEvent);
    map.off('mouseout', this._handleMouseEvent);
    map.off('click', this._handleMouseEvent);
    map.off('dblclick', this._handleMouseEvent);
  }
  _onRemoveInterleaved(map) {
    map.off('styledata', this._handleStyleChange);
    (0, _resolveLayers.resolveLayers)(map, this._deck, this._props.layers, []);
  }
  getDefaultPosition() {
    return 'top-left';
  }
  pickObject(params) {
    (0, _core.assert)(this._deck);
    return this._deck.pickObject(params);
  }
  pickMultipleObjects(params) {
    (0, _core.assert)(this._deck);
    return this._deck.pickMultipleObjects(params);
  }
  pickObjects(params) {
    (0, _core.assert)(this._deck);
    return this._deck.pickObjects(params);
  }
  finalize() {
    if (this._map) {
      this._map.removeControl(this);
    }
  }
}
exports.default = MapboxOverlay;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./deck-utils":"node_modules/@deck.gl/mapbox/dist/esm/deck-utils.js","./resolve-layers":"node_modules/@deck.gl/mapbox/dist/esm/resolve-layers.js"}],"node_modules/@deck.gl/mapbox/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MapboxLayer", {
  enumerable: true,
  get: function () {
    return _mapboxLayer.default;
  }
});
Object.defineProperty(exports, "MapboxOverlay", {
  enumerable: true,
  get: function () {
    return _mapboxOverlay.default;
  }
});
var _mapboxLayer = _interopRequireDefault(require("./mapbox-layer"));
var _mapboxOverlay = _interopRequireDefault(require("./mapbox-overlay"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./mapbox-layer":"node_modules/@deck.gl/mapbox/dist/esm/mapbox-layer.js","./mapbox-overlay":"node_modules/@deck.gl/mapbox/dist/esm/mapbox-overlay.js"}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _arcLayerVertex = _interopRequireDefault(require("./arc-layer-vertex.glsl"));
var _arcLayerFragment = _interopRequireDefault(require("./arc-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  getSourcePosition: {
    type: 'accessor',
    value: x => x.sourcePosition
  },
  getTargetPosition: {
    type: 'accessor',
    value: x => x.targetPosition
  },
  getSourceColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getTargetColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  getHeight: {
    type: 'accessor',
    value: 1
  },
  getTilt: {
    type: 'accessor',
    value: 0
  },
  greatCircle: false,
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  }
};
class ArcLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['instanceSourcePositions', 'instanceTargetPositions']);
  }
  getShaders() {
    return super.getShaders({
      vs: _arcLayerVertex.default,
      fs: _arcLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getSourceColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getTargetColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: 'getHeight',
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: 'getTilt',
        defaultValue: 0
      }
    });
  }
  updateState(opts) {
    super.updateState(opts);
    if (opts.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      greatCircle,
      wrapLongitude
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      greatCircle,
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude
    }).draw();
  }
  _getModel(gl) {
    let positions = [];
    const NUM_SEGMENTS = 50;
    for (let i = 0; i < NUM_SEGMENTS; i++) {
      positions = positions.concat([i, 1, 0, i, -1, 0]);
    }
    const model = new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 5,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
    model.setUniforms({
      numSegments: NUM_SEGMENTS
    });
    return model;
  }
}
exports.default = ArcLayer;
(0, _defineProperty2.default)(ArcLayer, "layerName", 'ArcLayer');
(0, _defineProperty2.default)(ArcLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./arc-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js","./arc-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMesh;
var _core = require("@math.gl/core");
const DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
const DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;
  for (let u = 0; u < uCount; u++) {
    const ut = u / (uCount - 1);
    for (let v = 0; v < vCount; v++) {
      const vt = v / (vCount - 1);
      const p = interpolateQuad(bounds, ut, vt);
      positions[vertex * 3 + 0] = p[0];
      positions[vertex * 3 + 1] = p[1];
      positions[vertex * 3 + 2] = p[2] || 0;
      texCoords[vertex * 2 + 0] = ut;
      texCoords[vertex * 2 + 1] = 1 - vt;
      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i = 0; i < bounds.length; i++) {
    positions[i * 3 + 0] = bounds[i][0];
    positions[i * 3 + 1] = bounds[i][1];
    positions[i * 3 + 2] = bounds[i][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut, vt) {
  return (0, _core.lerp)((0, _core.lerp)(quad[0], quad[1], vt), (0, _core.lerp)(quad[3], quad[2], vt), ut);
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const packUVsIntoRGB = "\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n";
var _default = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat(packUVsIntoRGB, "\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive && !picking_uAttribute) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n");
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _webMercator = require("@math.gl/web-mercator");
var _createMesh = _interopRequireDefault(require("./create-mesh"));
var _bitmapLayerVertex = _interopRequireDefault(require("./bitmap-layer-vertex"));
var _bitmapLayerFragment = _interopRequireDefault(require("./bitmap-layer-fragment"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultProps = {
  image: {
    type: 'image',
    value: null,
    async: true
  },
  bounds: {
    type: 'array',
    value: [1, 0, 0, 1],
    compare: true
  },
  _imageCoordinateSystem: _core.COORDINATE_SYSTEM.DEFAULT,
  desaturate: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0
  },
  transparentColor: {
    type: 'color',
    value: [0, 0, 0, 0]
  },
  tintColor: {
    type: 'color',
    value: [255, 255, 255]
  },
  textureParameters: {
    type: 'object',
    ignore: true
  }
};
class BitmapLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _bitmapLayerVertex.default,
      fs: _bitmapLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(['instancePickingColors']);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: attribute => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        update: attribute => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: attribute => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({
        mesh,
        ...this._getCoordinateUniforms()
      });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const {
      image
    } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const {
      width,
      height
    } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];
    info.bitmap = {
      size: {
        width,
        height
      },
      uv,
      pixel
    };
    return info;
  }
  disablePickingIndex() {
    this.setState({
      disablePicking: true
    });
  }
  restorePickingColors() {
    this.setState({
      disablePicking: false
    });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const {
      bounds
    } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
    }
    return (0, _createMesh.default)(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel(gl) {
    if (!gl) {
      return null;
    }
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        vertexCount: 6
      }),
      isInstanced: false
    });
  }
  draw(opts) {
    const {
      uniforms,
      moduleParameters
    } = opts;
    const {
      model,
      coordinateConversion,
      bounds,
      disablePicking
    } = this.state;
    const {
      image,
      desaturate,
      transparentColor,
      tintColor
    } = this.props;
    if (moduleParameters.pickingActive && disablePicking) {
      return;
    }
    if (image && model) {
      model.setUniforms(uniforms).setUniforms({
        bitmapTexture: image,
        desaturate,
        transparentColor: transparentColor.map(x => x / 255),
        tintColor: tintColor.slice(0, 3).map(x => x / 255),
        coordinateConversion,
        bounds
      }).draw();
    }
  }
  _getCoordinateUniforms() {
    const {
      LNGLAT,
      CARTESIAN,
      DEFAULT
    } = _core.COORDINATE_SYSTEM;
    let {
      _imageCoordinateSystem: imageCoordinateSystem
    } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const {
        bounds
      } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error('_imageCoordinateSystem only supports rectangular bounds');
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return {
          coordinateConversion: -1,
          bounds
        };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = (0, _webMercator.lngLatToWorld)([bounds[0], bounds[1]]);
        const topRight = (0, _webMercator.lngLatToWorld)([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
}
exports.default = BitmapLayer;
(0, _defineProperty2.default)(BitmapLayer, "layerName", 'BitmapLayer');
(0, _defineProperty2.default)(BitmapLayer, "defaultProps", defaultProps);
function unpackUVsFromRGB(color) {
  const [u, v, fracUV] = color;
  const vFrac = (fracUV & 0xf0) / 256;
  const uFrac = (fracUV & 0x0f) / 16;
  return [(u + uFrac) / 256, (v + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","./create-mesh":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js","./bitmap-layer-vertex":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js","./bitmap-layer-fragment":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js"}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildMapping = buildMapping;
exports.default = void 0;
exports.getDiffIcons = getDiffIcons;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _core2 = require("@loaders.gl/core");
var _core3 = require("@deck.gl/core");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_CANVAS_WIDTH = 1024;
const DEFAULT_BUFFER = 4;
const noop = () => {};
const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return {
      data: imageData,
      width,
      height
    };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return {
    data: ctx.canvas,
    width,
    height
  };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, parameters) {
  const oldWidth = texture.width;
  const oldHeight = texture.height;
  const newTexture = new _core.Texture2D(texture.gl, {
    width,
    height,
    parameters
  });
  (0, _core.copyToTexture)(texture, newTexture, {
    targetY: 0,
    width: oldWidth,
    height: oldHeight
  });
  texture.delete();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const {
      icon,
      xOffset
    } = columns[i];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({
  icons,
  buffer,
  mapping = {},
  xOffset = 0,
  yOffset = 0,
  rowHeight = 0,
  canvasWidth
}) {
  let columns = [];
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const {
        height,
        width
      } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const {
    iterable,
    objectInfo
  } = (0, _core3.createIterable)(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error('Icon is missing.');
    }
    if (!icon.url) {
      throw new Error('Icon url is missing.');
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = {
        ...icon,
        source: object,
        sourceIndex: objectInfo.index
      };
    }
  }
  return icons;
}
class IconManager {
  constructor(gl, {
    onUpdate = noop,
    onError = noop
  }) {
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "onUpdate", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadOptions", null);
    (0, _defineProperty2.default)(this, "_texture", null);
    (0, _defineProperty2.default)(this, "_externalTexture", null);
    (0, _defineProperty2.default)(this, "_mapping", {});
    (0, _defineProperty2.default)(this, "_textureParameters", null);
    (0, _defineProperty2.default)(this, "_pendingCount", 0);
    (0, _defineProperty2.default)(this, "_autoPacking", false);
    (0, _defineProperty2.default)(this, "_xOffset", 0);
    (0, _defineProperty2.default)(this, "_yOffset", 0);
    (0, _defineProperty2.default)(this, "_rowHeight", 0);
    (0, _defineProperty2.default)(this, "_buffer", DEFAULT_BUFFER);
    (0, _defineProperty2.default)(this, "_canvasWidth", DEFAULT_CANVAS_WIDTH);
    (0, _defineProperty2.default)(this, "_canvasHeight", 0);
    (0, _defineProperty2.default)(this, "_canvas", null);
    this.gl = gl;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    var _this$_texture;
    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || {};
  }
  setProps({
    loadOptions,
    autoPacking,
    iconAtlas,
    iconMapping,
    textureParameters
  }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== undefined) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      var _this$_texture2;
      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._textureParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === 'undefined') {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const {
        mapping,
        xOffset,
        yOffset,
        rowHeight,
        canvasHeight
      } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = new _core.Texture2D(this.gl, {
          width: this._canvasWidth,
          height: this._canvasHeight,
          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement('canvas');
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext('2d', {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      (0, _core2.load)(icon.url, this._loadOptions).then(imageData => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const {
          x,
          y,
          width: maxWidth,
          height: maxHeight
        } = iconDef;
        const {
          data,
          width,
          height
        } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        this._texture.setSubImageData({
          data,
          x: x + (maxWidth - width) / 2,
          y: y + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch(error => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
}
exports.default = IconManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _iconLayerVertex = _interopRequireDefault(require("./icon-layer-vertex.glsl"));
var _iconLayerFragment = _interopRequireDefault(require("./icon-layer-fragment.glsl"));
var _iconManager = _interopRequireDefault(require("./icon-manager"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  iconAtlas: {
    type: 'image',
    value: null,
    async: true
  },
  iconMapping: {
    type: 'object',
    value: {},
    async: true
  },
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  billboard: true,
  sizeUnits: 'pixels',
  sizeMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  alphaCutoff: {
    type: 'number',
    value: 0.05,
    min: 0,
    max: 1
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getIcon: {
    type: 'accessor',
    value: x => x.icon
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  onIconError: {
    type: 'function',
    value: null,
    optional: true
  },
  textureParameters: {
    type: 'object',
    ignore: true
  }
};
class IconLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _iconLayerVertex.default,
      fs: _iconLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    this.state = {
      iconManager: new _iconManager.default(this.context.gl, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: 'getIcon',
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: 'getIcon',
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: 5121,
        accessor: 'getIcon',
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle'
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const attributeManager = this.getAttributeManager();
    const {
      iconAtlas,
      iconMapping,
      data,
      getIcon,
      textureParameters
    } = props;
    const {
      iconManager
    } = this.state;
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate('getIcon');
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({
    uniforms
  }) {
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      sizeUnits,
      billboard,
      alphaCutoff
    } = this.props;
    const {
      iconManager
    } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      this.state.model.setUniforms(uniforms).setUniforms({
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: _core.UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      }).draw();
    }
  }
  _getModel(gl) {
    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    var _this$getCurrentLayer;
    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      _core.log.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const {
      width,
      height,
      anchorX = width / 2,
      anchorY = height / 2
    } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const {
      x,
      y,
      width,
      height
    } = this.state.iconManager.getIconMapping(icon);
    return [x, y, width, height];
  }
}
exports.default = IconLayer;
(0, _defineProperty2.default)(IconLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(IconLayer, "layerName", 'IconLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./icon-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js","./icon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js","./icon-manager":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js"}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _lineLayerVertex = _interopRequireDefault(require("./line-layer-vertex.glsl"));
var _lineLayerFragment = _interopRequireDefault(require("./line-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  getSourcePosition: {
    type: 'accessor',
    value: x => x.sourcePosition
  },
  getTargetPosition: {
    type: 'accessor',
    value: x => x.targetPosition
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  }
};
class LineLayer extends _core.Layer {
  getBounds() {
    var _this$getAttributeMan;
    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['instanceSourcePositions', 'instanceTargetPositions']);
  }
  getShaders() {
    return super.getShaders({
      vs: _lineLayerVertex.default,
      fs: _lineLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      wrapLongitude
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    }).draw();
    if (wrapLongitude) {
      this.state.model.setUniforms({
        useShortestPath: -1
      }).draw();
    }
  }
  _getModel(gl) {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 5,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = LineLayer;
(0, _defineProperty2.default)(LineLayer, "layerName", 'LineLayer');
(0, _defineProperty2.default)(LineLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./line-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js","./line-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _pointCloudLayerVertex = _interopRequireDefault(require("./point-cloud-layer-vertex.glsl"));
var _pointCloudLayerFragment = _interopRequireDefault(require("./point-cloud-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_NORMAL = [0, 0, 1];
const defaultProps = {
  sizeUnits: 'pixels',
  pointSize: {
    type: 'number',
    min: 0,
    value: 10
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getNormal: {
    type: 'accessor',
    value: DEFAULT_NORMAL
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: true,
  radiusPixels: {
    deprecatedFor: 'pointSize'
  }
};
function normalizeData(data) {
  const {
    header,
    attributes
  } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    attributes.instanceColors = attributes.COLOR_0;
  }
}
class PointCloudLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _pointCloudLayerVertex.default,
      fs: _pointCloudLayerFragment.default,
      modules: [_core.project32, _core.gouraudLighting, _core.picking]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: 'getNormal',
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      }
    });
  }
  updateState(params) {
    const {
      changeFlags,
      props
    } = params;
    super.updateState(params);
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }
  draw({
    uniforms
  }) {
    const {
      pointSize,
      sizeUnits
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      sizeUnits: _core.UNIT[sizeUnits],
      radiusPixels: pointSize
    }).draw();
  }
  _getModel(gl) {
    const positions = [];
    for (let i = 0; i < 3; i++) {
      const angle = i / 3 * Math.PI * 2;
      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
    }
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = PointCloudLayer;
(0, _defineProperty2.default)(PointCloudLayer, "layerName", 'PointCloudLayer');
(0, _defineProperty2.default)(PointCloudLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./point-cloud-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js","./point-cloud-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _scatterplotLayerVertex = _interopRequireDefault(require("./scatterplot-layer-vertex.glsl"));
var _scatterplotLayerFragment = _interopRequireDefault(require("./scatterplot-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  radiusUnits: 'meters',
  radiusScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  radiusMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  lineWidthUnits: 'meters',
  lineWidthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  lineWidthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  lineWidthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getRadius: {
    type: 'accessor',
    value: 1
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  strokeWidth: {
    deprecatedFor: 'getLineWidth'
  },
  outline: {
    deprecatedFor: 'stroked'
  },
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};
class ScatterplotLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _scatterplotLayerVertex.default,
      fs: _scatterplotLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: 'getRadius',
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      radiusUnits,
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      stroked,
      filled,
      billboard,
      antialiasing,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      stroked: stroked ? 1 : 0,
      filled,
      billboard,
      antialiasing,
      radiusUnits: _core.UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: _core.UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 3,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = ScatterplotLayer;
(0, _defineProperty2.default)(ScatterplotLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(ScatterplotLayer, "layerName", 'ScatterplotLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./scatterplot-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js","./scatterplot-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js"}],"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WINDING = void 0;
exports.forEachSegmentInPolygon = forEachSegmentInPolygon;
exports.forEachSegmentInPolygonPoints = forEachSegmentInPolygonPoints;
exports.getPolygonSignedArea = getPolygonSignedArea;
exports.getPolygonSignedAreaPoints = getPolygonSignedAreaPoints;
exports.getPolygonWindingDirection = getPolygonWindingDirection;
exports.getPolygonWindingDirectionPoints = getPolygonWindingDirectionPoints;
exports.modifyPolygonWindingDirection = modifyPolygonWindingDirection;
exports.modifyPolygonWindingDirectionPoints = modifyPolygonWindingDirectionPoints;
var _core = require("@math.gl/core");
const WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
exports.WINDING = WINDING;
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
function getPolygonSignedArea(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  const dim = options.size || 2;
  let area = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);
    j = i;
  }
  return area / 2;
}
function forEachSegmentInPolygon(points, visitor, options = {}) {
  const {
    start = 0,
    end = points.length,
    size = 2,
    isClosed
  } = options;
  const numPoints = (end - start) / size;
  for (let i = 0; i < numPoints - 1; ++i) {
    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);
  }
  const endPointIndex = start + (numPoints - 1) * size;
  const isClosedEx = isClosed || (0, _core.equals)(points[start], points[endPointIndex]) && (0, _core.equals)(points[start + 1], points[endPointIndex + 1]);
  if (!isClosedEx) {
    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);
  }
}
function reversePolygon(points, options) {
  const {
    start = 0,
    end = points.length,
    size = 2
  } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start + i * size;
    const b2 = start + (numPoints - 1 - i) * size;
    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}
function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {
  const currentDirection = getPolygonWindingDirectionPoints(points, options);
  if (currentDirection !== direction) {
    points.reverse();
    return true;
  }
  return false;
}
function getPolygonWindingDirectionPoints(points, options = {}) {
  return Math.sign(getPolygonSignedAreaPoints(points, options));
}
function getPolygonSignedAreaPoints(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  let area = 0;
  for (let i = start, j = end - 1; i < end; ++i) {
    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);
    j = i;
  }
  return area / 2;
}
function forEachSegmentInPolygonPoints(points, visitor, options = {}) {
  const {
    start = 0,
    end = points.length,
    isClosed
  } = options;
  for (let i = start; i < end - 1; ++i) {
    visitor(points[i], points[i + 1], i, i + 1);
  }
  const isClosedEx = isClosed || (0, _core.equals)(points[end - 1], points[0]);
  if (!isClosedEx) {
    visitor(points[end - 1], points[0], end - 1, 0);
  }
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@math.gl/polygon/dist/esm/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@math.gl/core");
var _polygonUtils = require("./polygon-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Polygon {
  constructor(points, options = {}) {
    (0, _defineProperty2.default)(this, "points", void 0);
    (0, _defineProperty2.default)(this, "isFlatArray", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    this.points = points;
    this.isFlatArray = !(0, _core.isArray)(points[0]);
    this.options = {
      start: options.start || 0,
      end: options.end || points.length,
      size: options.size || 2,
      isClosed: options.isClosed
    };
    Object.freeze(this);
  }
  getSignedArea() {
    if (this.isFlatArray) return (0, _polygonUtils.getPolygonSignedArea)(this.points, this.options);
    return (0, _polygonUtils.getPolygonSignedAreaPoints)(this.points, this.options);
  }
  getArea() {
    return Math.abs(this.getSignedArea());
  }
  getWindingDirection() {
    return Math.sign(this.getSignedArea());
  }
  forEachSegment(visitor) {
    if (this.isFlatArray) {
      (0, _polygonUtils.forEachSegmentInPolygon)(this.points, (x1, y1, x2, y2, i1, i2) => {
        visitor([x1, y1], [x2, y2], i1, i2);
      }, this.options);
    } else {
      (0, _polygonUtils.forEachSegmentInPolygonPoints)(this.points, visitor, this.options);
    }
  }
  modifyWindingDirection(direction) {
    if (this.isFlatArray) {
      return (0, _polygonUtils.modifyPolygonWindingDirection)(this.points, direction, this.options);
    }
    return (0, _polygonUtils.modifyPolygonWindingDirectionPoints)(this.points, direction, this.options);
  }
}
exports.default = Polygon;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"}],"node_modules/@math.gl/polygon/dist/esm/earcut.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.earcut = earcut;
var _polygonUtils = require("./polygon-utils");
function earcut(positions, holeIndices, dim = 2, areas) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  let invSize;
  let maxX;
  let maxY;
  let minX;
  let minY;
  let x;
  let y;
  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);
  if (positions.length > 80 * dim) {
    minX = maxX = positions[0];
    minY = maxY = positions[1];
    for (let i = dim; i < outerLen; i += dim) {
      x = positions[i];
      y = positions[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise, area) {
  let i;
  let last;
  if (area === undefined) {
    area = (0, _polygonUtils.getPolygonSignedArea)(data, {
      start,
      end,
      size: dim
    });
  }
  if (clockwise === area < 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start;
  let again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  let prev;
  let next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev;
  const b = ear;
  const c = ear.next;
  if (area(a, b, c) >= 0) return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev;
  const b = ear;
  const c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
  const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
  const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
  const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize);
  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ;
  let n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev;
    const b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
  const queue = [];
  let i;
  let len;
  let start;
  let end;
  let list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  if (hx === qx) return m;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  let tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let e;
  let i;
  let inSize = 1;
  let numMerges;
  let p;
  let pSize;
  let q;
  let qSize;
  let tail;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00ff00ff;
  x = (x | x << 4) & 0x0f0f0f0f;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00ff00ff;
  y = (y | y << 4) & 0x0f0f0f0f;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start;
  let leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a;
  let inside = false;
  const px = (a.x + b.x) / 2;
  const py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y);
  const b2 = new Node(b.i, b.x, b.y);
  const an = a.next;
  const bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
},{"./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"}],"node_modules/@math.gl/polygon/dist/esm/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.getPointAtIndex = getPointAtIndex;
exports.push = push;
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}
},{}],"node_modules/@math.gl/polygon/dist/esm/lineclip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bitCode = bitCode;
exports.clipPolygon = clipPolygon;
exports.clipPolyline = clipPolyline;
exports.intersect = intersect;
var _utils = require("./utils");
function clipPolyline(positions, bbox, options) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  const result = [];
  let part = [];
  let a;
  let b;
  let codeA = -1;
  let codeB;
  let lastCode;
  for (let i = 1; i < numPoints; i++) {
    a = (0, _utils.getPointAtIndex)(positions, i - 1, size, startIndex, a);
    b = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, b);
    if (codeA < 0) {
      codeA = bitCode(a, bbox);
    }
    codeB = lastCode = bitCode(b, bbox);
    while (true) {
      if (!(codeA | codeB)) {
        (0, _utils.push)(part, a);
        if (codeB !== lastCode) {
          (0, _utils.push)(part, b);
          if (i < numPoints - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === numPoints - 1) {
          (0, _utils.push)(part, b);
        }
        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        intersect(a, b, codeA, bbox, a);
        codeA = bitCode(a, bbox);
      } else {
        intersect(a, b, codeB, bbox, b);
        codeB = bitCode(b, bbox);
      }
    }
    codeA = lastCode;
  }
  if (part.length) result.push(part);
  return result;
}
function clipPolygon(positions, bbox, options) {
  const {
    size = 2,
    endIndex = positions.length
  } = options || {};
  let {
    startIndex = 0
  } = options || {};
  let numPoints = (endIndex - startIndex) / size;
  let result;
  let p;
  let prev;
  let inside;
  let prevInside;
  for (let edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = (0, _utils.getPointAtIndex)(positions, numPoints - 1, size, startIndex, prev);
    prevInside = !(bitCode(prev, bbox) & edge);
    for (let i = 0; i < numPoints; i++) {
      p = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, p);
      inside = !(bitCode(p, bbox) & edge);
      if (inside !== prevInside) (0, _utils.push)(result, intersect(prev, p, edge, bbox));
      if (inside) (0, _utils.push)(result, p);
      (0, _utils.copy)(prev, p);
      prevInside = inside;
    }
    positions = result;
    startIndex = 0;
    numPoints = result.length / size;
    if (!numPoints) break;
  }
  return result;
}
function intersect(a, b, edge, bbox, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
  }
  return out;
}
function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;
  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;
  return code;
}
},{"./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutPolygonByGrid = cutPolygonByGrid;
exports.cutPolylineByGrid = cutPolylineByGrid;
var _lineclip = require("./lineclip");
var _utils = require("./utils");
function cutPolylineByGrid(positions, options) {
  const {
    size = 2,
    broken = false,
    gridResolution = 10,
    gridOffset = [0, 0],
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a, gridResolution, gridOffset, []);
  const scratchPoint = [];
  (0, _utils.push)(part, a);
  for (let i = 1; i < numPoints; i++) {
    b = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, b);
    codeB = (0, _lineclip.bitCode)(b, cell);
    while (codeB) {
      (0, _lineclip.intersect)(a, b, codeB, cell, scratchPoint);
      const codeAlt = (0, _lineclip.bitCode)(scratchPoint, cell);
      if (codeAlt) {
        (0, _lineclip.intersect)(a, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      (0, _utils.push)(part, scratchPoint);
      (0, _utils.copy)(a, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        (0, _utils.push)(part, a);
      }
      codeB = (0, _lineclip.bitCode)(b, cell);
    }
    (0, _utils.push)(part, b);
    (0, _utils.copy)(a, b);
  }
  return broken ? result : result[0];
}
const TYPE_INSIDE = 0;
const TYPE_BORDER = 1;
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const {
    size = 2,
    gridResolution = 10,
    gridOffset = [0, 0],
    edgeTypes = false
  } = options || {};
  const result = [];
  const queue = [{
    pos: positions,
    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
    holes: holeIndices || []
  }];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const {
      pos,
      types,
      holes
    } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = (0, _lineclip.bitCode)(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = {
        pos: parts[0].pos,
        types: parts[0].types,
        holes: []
      };
      const polygonHigh = {
        pos: parts[1].pos,
        types: parts[1].types,
        holes: []
      };
      queue.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = {
        positions: pos
      };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = (0, _utils.getPointAtIndex)(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];
    if (side && prevSide && prevSide !== side) {
      (0, _lineclip.intersect)(prev, p, edge, bbox, scratchPoint);
      (0, _utils.push)(resultLow, scratchPoint) && typesLow.push(prevType);
      (0, _utils.push)(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      (0, _utils.push)(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      (0, _utils.push)(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    (0, _utils.copy)(prev, p);
    prevSide = side;
    prevType = type;
  }
  return [lowPointCount ? {
    pos: resultLow,
    types: edgeTypes && typesLow
  } : null, highPointCount ? {
    pos: resultHigh,
    types: edgeTypes && typesHigh
  } : null];
}
function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    minX = x < minX ? x : minX;
    maxX = x > maxX ? x : maxX;
    minY = y < minY ? y : minY;
    maxY = y > maxY ? y : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
},{"./lineclip":"node_modules/@math.gl/polygon/dist/esm/lineclip.js","./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutPolygonByMercatorBounds = cutPolygonByMercatorBounds;
exports.cutPolylineByMercatorBounds = cutPolylineByMercatorBounds;
var _cutByGrid = require("./cut-by-grid");
var _utils = require("./utils");
const DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length,
    normalize = true
  } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = (0, _cutByGrid.cutPolylineByGrid)(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const {
    size = 2,
    normalize = true,
    edgeTypes = false
  } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = (0, _cutByGrid.cutPolygonByGrid)(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    (0, _utils.push)(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    (0, _utils.push)(positions, p);
    p[0] = firstLng;
    (0, _utils.push)(positions, p);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}
},{"./cut-by-grid":"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "WINDING", {
  enumerable: true,
  get: function () {
    return _polygonUtils.WINDING;
  }
});
Object.defineProperty(exports, "_Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "clipPolygon", {
  enumerable: true,
  get: function () {
    return _lineclip.clipPolygon;
  }
});
Object.defineProperty(exports, "clipPolyline", {
  enumerable: true,
  get: function () {
    return _lineclip.clipPolyline;
  }
});
Object.defineProperty(exports, "cutPolygonByGrid", {
  enumerable: true,
  get: function () {
    return _cutByGrid.cutPolygonByGrid;
  }
});
Object.defineProperty(exports, "cutPolygonByMercatorBounds", {
  enumerable: true,
  get: function () {
    return _cutByMercatorBounds.cutPolygonByMercatorBounds;
  }
});
Object.defineProperty(exports, "cutPolylineByGrid", {
  enumerable: true,
  get: function () {
    return _cutByGrid.cutPolylineByGrid;
  }
});
Object.defineProperty(exports, "cutPolylineByMercatorBounds", {
  enumerable: true,
  get: function () {
    return _cutByMercatorBounds.cutPolylineByMercatorBounds;
  }
});
Object.defineProperty(exports, "earcut", {
  enumerable: true,
  get: function () {
    return _earcut.earcut;
  }
});
Object.defineProperty(exports, "forEachSegmentInPolygon", {
  enumerable: true,
  get: function () {
    return _polygonUtils.forEachSegmentInPolygon;
  }
});
Object.defineProperty(exports, "getPolygonSignedArea", {
  enumerable: true,
  get: function () {
    return _polygonUtils.getPolygonSignedArea;
  }
});
Object.defineProperty(exports, "getPolygonWindingDirection", {
  enumerable: true,
  get: function () {
    return _polygonUtils.getPolygonWindingDirection;
  }
});
Object.defineProperty(exports, "modifyPolygonWindingDirection", {
  enumerable: true,
  get: function () {
    return _polygonUtils.modifyPolygonWindingDirection;
  }
});
var _polygon = _interopRequireDefault(require("./polygon"));
var _polygonUtils = require("./polygon-utils");
var _earcut = require("./earcut");
var _lineclip = require("./lineclip");
var _cutByGrid = require("./cut-by-grid");
var _cutByMercatorBounds = require("./cut-by-mercator-bounds");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./polygon":"node_modules/@math.gl/polygon/dist/esm/polygon.js","./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","./earcut":"node_modules/@math.gl/polygon/dist/esm/earcut.js","./lineclip":"node_modules/@math.gl/polygon/dist/esm/lineclip.js","./cut-by-grid":"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","./cut-by-mercator-bounds":"node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _polygon = require("@math.gl/polygon");
class ColumnGeometry extends _core2.Geometry {
  constructor(props) {
    const {
      id = (0, _core2.uid)('column-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateColumn(props);
    super({
      ...props,
      id,
      indices,
      attributes
    });
  }
}
exports.default = ColumnGeometry;
function tesselateColumn(props) {
  const {
    radius,
    height = 1,
    nradial = 10
  } = props;
  let {
    vertices
  } = props;
  if (vertices) {
    _core.log.assert(vertices.length >= nradial);
    vertices = vertices.flatMap(v => [v[0], v[1]]);
    (0, _polygon.modifyPolygonWindingDirection)(vertices, _polygon.WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i = 0;
  if (isExtruded) {
    for (let j = 0; j < vertsAroundEdge; j++) {
      const a = j * stepAngle;
      const vertexIndex = j % nradial;
      const sin = Math.sin(a);
      const cos = Math.cos(a);
      for (let k = 0; k < 2; k++) {
        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
        positions[i + 2] = (1 / 2 - k) * height;
        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;
        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
        i += 3;
      }
    }
    positions[i + 0] = positions[i - 3];
    positions[i + 1] = positions[i - 2];
    positions[i + 2] = positions[i - 1];
    i += 3;
  }
  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
    const a = v * stepAngle;
    const vertexIndex = (v + nradial) % nradial;
    const sin = Math.sin(a);
    const cos = Math.cos(a);
    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j = 0; j < nradial; j++) {
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 2;
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      }
    }
  };
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool stroked;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (stroked) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n    if (isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _columnGeometry = _interopRequireDefault(require("./column-geometry"));
var _columnLayerVertex = _interopRequireDefault(require("./column-layer-vertex.glsl"));
var _columnLayerFragment = _interopRequireDefault(require("./column-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  diskResolution: {
    type: 'number',
    min: 4,
    value: 20
  },
  vertices: null,
  radius: {
    type: 'number',
    min: 0,
    value: 1000
  },
  angle: {
    type: 'number',
    value: 0
  },
  offset: {
    type: 'array',
    value: [0, 0]
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusUnits: 'meters',
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: true,
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};
class ColumnLayer extends _core.Layer {
  getShaders() {
    const {
      gl
    } = this.context;
    const transpileToGLSL100 = !(0, _core2.isWebGL2)(gl);
    const defines = {};
    const useDerivatives = this.props.flatShading && (0, _core2.hasFeature)(gl, _core2.FEATURES.GLSL_DERIVATIVES);
    if (useDerivatives) {
      defines.FLAT_SHADING = 1;
    }
    return super.getShaders({
      vs: _columnLayerVertex.default,
      fs: _columnLayerFragment.default,
      defines,
      transpileToGLSL100,
      modules: [_core.project32, useDerivatives ? _core.phongLighting : _core.gouraudLighting, _core.picking]
    });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: 'getElevation'
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getLineWidth',
        transition: true
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
    if (regenerateModels) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }
  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry = new _columnGeometry.default({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;
    if (vertices) {
      for (let i = 0; i < diskResolution; i++) {
        const p = vertices[i];
        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
        meanVertexDistance += d / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry;
  }
  _getModel(gl) {
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      isInstanced: true
    });
  }
  _updateGeometry({
    diskResolution,
    vertices,
    extruded,
    stroked
  }) {
    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3,
      wireframeVertexCount: geometry.indices.value.length
    });
    this.state.model.setProps({
      geometry
    });
  }
  draw({
    uniforms
  }) {
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      radiusUnits,
      elevationScale,
      extruded,
      filled,
      stroked,
      wireframe,
      offset,
      coverage,
      radius,
      angle
    } = this.props;
    const {
      model,
      fillVertexCount,
      wireframeVertexCount,
      edgeDistance
    } = this.state;
    model.setUniforms(uniforms).setUniforms({
      radius,
      angle: angle / 180 * Math.PI,
      offset,
      extruded,
      stroked,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: _core.UNIT[radiusUnits],
      widthUnits: _core.UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    });
    if (extruded && wireframe) {
      model.setProps({
        isIndexed: true
      });
      model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({
        isStroke: true
      }).draw();
    }
    if (filled) {
      model.setProps({
        isIndexed: false
      });
      model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({
        isStroke: false
      }).draw();
    }
    if (!extruded && stroked) {
      model.setProps({
        isIndexed: false
      });
      model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({
        isStroke: true
      }).draw();
    }
  }
}
exports.default = ColumnLayer;
(0, _defineProperty2.default)(ColumnLayer, "layerName", 'ColumnLayer');
(0, _defineProperty2.default)(ColumnLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./column-geometry":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js","./column-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js","./column-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@luma.gl/core");
var _core2 = require("@deck.gl/core");
var _columnLayer = _interopRequireDefault(require("./column-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    value: 1000
  },
  offset: {
    type: 'array',
    value: [1, 1]
  }
};
class GridCellLayer extends _columnLayer.default {
  getGeometry(diskResolution) {
    return new _core.CubeGeometry();
  }
  draw({
    uniforms
  }) {
    const {
      elevationScale,
      extruded,
      offset,
      coverage,
      cellSize,
      angle,
      radiusUnits
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      radius: cellSize / 2,
      radiusUnits: _core2.UNIT[radiusUnits],
      angle,
      offset,
      extruded,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isWireframe: false
    }).draw();
  }
}
exports.default = GridCellLayer;
(0, _defineProperty2.default)(GridCellLayer, "layerName", 'GridCellLayer');
(0, _defineProperty2.default)(GridCellLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./column-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizePath = normalizePath;
var _polygon = require("@math.gl/polygon");
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length = path.length * size;
    flatPath = new Array(length);
    for (let i = 0; i < path.length; i++) {
      for (let j = 0; j < size; j++) {
        flatPath[i * size + j] = path[i][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return (0, _polygon.cutPolylineByGrid)(flatPath, {
      size,
      gridResolution
    });
  }
  if (wrapLongitude) {
    return (0, _polygon.cutPolylineByMercatorBounds)(flatPath, {
      size
    });
  }
  return flatPath;
}
},{"@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _core = require("@deck.gl/core");
var _path = require("./path");
const START_CAP = 1;
const END_CAP = 2;
const INVALID = 4;
class PathTesselator extends _core.Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: {
          size: 1,
          type: Uint8ClampedArray
        }
      }
    });
  }
  get(attributeName) {
    return this.attributes[attributeName];
  }
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  normalizeGeometry(path) {
    if (this.normalize) {
      return (0, _path.normalizePath)(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const {
      vertexStart,
      geometrySize
    } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const {
      positions
    } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const {
      vertexStart,
      geometrySize
    } = context;
    const p = new Array(3);
    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p);
      positions[i * 3] = p[0];
      positions[i * 3 + 1] = p[1];
      positions[i * 3 + 2] = p[2];
    }
  }
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  getPointOnPath(path, index, target = []) {
    const {
      positionSize
    } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i = index * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const {
      positionSize
    } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
}
exports.default = PathTesselator;
function isCut(path) {
  return Array.isArray(path[0]);
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./path":"node_modules/@deck.gl/layers/dist/esm/path-layer/path.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _pathTesselator = _interopRequireDefault(require("./path-tesselator"));
var _pathLayerVertex = _interopRequireDefault(require("./path-layer-vertex.glsl"));
var _pathLayerFragment = _interopRequireDefault(require("./path-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  widthUnits: 'meters',
  widthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  widthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  widthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  jointRounded: false,
  capRounded: false,
  miterLimit: {
    type: 'number',
    min: 0,
    value: 4
  },
  billboard: false,
  _pathType: null,
  getPath: {
    type: 'accessor',
    value: object => object.path
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  rounded: {
    deprecatedFor: ['jointRounded', 'capRounded']
  }
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
class PathLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _pathLayerVertex.default,
      fs: _pathLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      positions: {
        size: 3,
        vertexOffset: 1,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPath',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: 5121,
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getWidth',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        accessor: 'getColor',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR
      },
      instancePickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new _pathTesselator.default({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      changeFlags
    } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const {
        pathTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === 'loop',
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      info.object = data.find(d => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  draw({
    uniforms
  }) {
    const {
      jointRounded,
      capRounded,
      billboard,
      miterLimit,
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: {
            value: new Float32Array(SEGMENT_POSITIONS),
            size: 2
          }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get('positions');
  }
  calculateSegmentTypes(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get('segmentTypes');
  }
}
exports.default = PathLayer;
(0, _defineProperty2.default)(PathLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(PathLayer, "layerName", 'PathLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./path-tesselator":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","./path-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","./path-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"}],"node_modules/earcut/src/earcut.js":[function(require,module,exports) {
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    var p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHoleIndices = getHoleIndices;
exports.getPositions = getPositions;
exports.getSurfaceIndices = getSurfaceIndices;
exports.normalize = normalize;
var _earcut = _interopRequireDefault(require("earcut"));
var _polygon = require("@math.gl/polygon");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const OUTER_POLYGON_WINDING = _polygon.WINDING.CLOCKWISE;
const HOLE_POLYGON_WINDING = _polygon.WINDING.COUNTER_CLOCKWISE;
const windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error('invalid polygon');
  }
}
function getPositions(polygon) {
  return 'positions' in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return 'holeIndices' in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  (0, _polygon.modifyPolygonWindingDirection)(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  (0, _polygon.modifyPolygonWindingDirection)(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ('positions' in polygon) {
    const {
      positions: srcPositions,
      holeIndices: srcHoleIndices
    } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i = 0; i < numVerts; i++) {
    const j = (i + 1) % numVerts;
    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];
    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i = 0; i < numVerts; i++) {
    const o = i * 3;
    const x = positions[o + 0];
    const y = positions[o + 1];
    const z = positions[o + 2];
    positions[o + xIndex] = x;
    positions[o + yIndex] = y;
    positions[o + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p = [];
    for (let i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      if (is3d) {
        p[2] = positions[i + 2];
      }
      const xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {} else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 1, 2, 0);
    }
  }
  return (0, _earcut.default)(positions, holeIndices, positionSize);
}
},{"earcut":"node_modules/earcut/src/earcut.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var Polygon = _interopRequireWildcard(require("./polygon"));
var _core = require("@deck.gl/core");
var _polygon2 = require("@math.gl/polygon");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
class PolygonTesselator extends _core.Tesselator {
  constructor(opts) {
    const {
      fp64,
      IndexType = Uint32Array
    } = opts;
    super({
      ...opts,
      attributes: {
        positions: {
          size: 3,
          type: fp64 ? Float64Array : Float32Array
        },
        vertexValid: {
          type: Uint8ClampedArray,
          size: 1
        },
        indices: {
          type: IndexType,
          size: 1
        }
      }
    });
  }
  get(attributeName) {
    const {
      attributes
    } = this;
    if (attributeName === 'indices') {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error('missing indices buffer');
    }
  }
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return (0, _polygon2.cutPolygonByGrid)(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return (0, _polygon2.cutPolygonByMercatorBounds)(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  getGeometrySize(polygon) {
    if (isCut(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return Polygon.getPositions(polygon).length / this.positionSize;
  }
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      this._updateIndices(polygon, context);
      this._updatePositions(polygon, context);
      this._updateVertexValid(polygon, context);
    }
  }
  _updateIndices(polygon, {
    geometryIndex,
    vertexStart: offset,
    indexStart
  }) {
    const {
      attributes,
      indexStarts,
      typedArrayManager
    } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i = indexStart;
    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  _updatePositions(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      attributes: {
        positions
      },
      positionSize
    } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = Polygon.getPositions(polygon);
    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {
      const x = polygonPositions[j * positionSize];
      const y = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
  }
  _updateVertexValid(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      positionSize
    } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && Polygon.getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
}
exports.default = PolygonTesselator;
function isCut(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}
},{"./polygon":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");
exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");
exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _polygonTesselator = _interopRequireDefault(require("./polygon-tesselator"));
var _solidPolygonLayerVertexTop = _interopRequireDefault(require("./solid-polygon-layer-vertex-top.glsl"));
var _solidPolygonLayerVertexSide = _interopRequireDefault(require("./solid-polygon-layer-vertex-side.glsl"));
var _solidPolygonLayerFragment = _interopRequireDefault(require("./solid-polygon-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: 'CW',
  _full3d: false,
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  getPolygon: {
    type: 'accessor',
    value: f => f.polygon
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: true
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
class SolidPolygonLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders(type) {
    return super.getShaders({
      vs: type === 'top' ? _solidPolygonLayerVertexTop.default : _solidPolygonLayerVertexSide.default,
      fs: _solidPolygonLayerFragment.default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1
      },
      modules: [_core.project32, _core.gouraudLighting, _core.picking]
    });
  }
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const {
      gl,
      viewport
    } = this.context;
    let {
      coordinateSystem
    } = this.props;
    const {
      _full3d
    } = this.props;
    if (viewport.isGeospatial && coordinateSystem === _core.COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = _core.COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new _polygonTesselator.default({
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: !gl || (0, _core2.hasFeatures)(gl, _core2.FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(['instancePickingColors']);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: this.calculateIndices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPolygon',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          positions: {
            vertexOffset: 0,
            divisor: 0
          },
          instancePositions: {
            vertexOffset: 0,
            divisor: 1
          },
          nextPositions: {
            vertexOffset: 1,
            divisor: 1
          }
        }
      },
      vertexValid: {
        size: 1,
        divisor: 1,
        type: 5121,
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getElevation',
        shaderAttributes: {
          elevations: {
            divisor: 0
          },
          instanceElevations: {
            divisor: 1
          }
        }
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          fillColors: {
            divisor: 0
          },
          instanceFillColors: {
            divisor: 1
          }
        }
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          lineColors: {
            divisor: 0
          },
          instanceLineColors: {
            divisor: 1
          }
        }
      },
      pickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
        shaderAttributes: {
          pickingColors: {
            divisor: 0
          },
          instancePickingColors: {
            divisor: 1
          }
        }
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      info.object = data.find(d => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const {
      data
    } = this.props;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }
  draw({
    uniforms
  }) {
    const {
      extruded,
      filled,
      wireframe,
      elevationScale
    } = this.props;
    const {
      topModel,
      sideModel,
      polygonTesselator
    } = this.state;
    const renderUniforms = {
      ...uniforms,
      extruded: Boolean(extruded),
      elevationScale
    };
    if (sideModel) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);
      if (wireframe) {
        sideModel.setDrawMode(3);
        sideModel.setUniforms({
          isWireframe: true
        }).draw();
      }
      if (filled) {
        sideModel.setDrawMode(6);
        sideModel.setUniforms({
          isWireframe: false
        }).draw();
      }
    }
    if (topModel) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.setUniforms(renderUniforms).draw();
    }
  }
  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const {
      props,
      oldProps,
      changeFlags
    } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      var _this$state$models;
      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach(model => model.delete());
      this.setState(this._getModels(this.context.gl));
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({
    props,
    oldProps,
    changeFlags
  }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const {
        polygonTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels(gl) {
    const {
      id,
      filled,
      extruded
    } = this.props;
    let topModel;
    let sideModel;
    if (filled) {
      const shaders = this.getShaders('top');
      shaders.defines.NON_INSTANCED_MODEL = 1;
      topModel = new _core2.Model(gl, {
        ...shaders,
        id: "".concat(id, "-top"),
        drawMode: 4,
        attributes: {
          vertexPositions: new Float32Array([0, 1])
        },
        uniforms: {
          isWireframe: false,
          isSideVertex: false
        },
        vertexCount: 0,
        isIndexed: true
      });
    }
    if (extruded) {
      sideModel = new _core2.Model(gl, {
        ...this.getShaders('side'),
        id: "".concat(id, "-side"),
        geometry: new _core2.Geometry({
          drawMode: 1,
          vertexCount: 4,
          attributes: {
            vertexPositions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        instanceCount: 0,
        isInstanced: 1
      });
      sideModel.userData.excludeAttributes = {
        indices: true
      };
    }
    return {
      models: [sideModel, topModel].filter(Boolean),
      topModel,
      sideModel
    };
  }
  calculateIndices(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get('indices');
  }
  calculatePositions(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get('positions');
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get('vertexValid');
  }
}
exports.default = SolidPolygonLayer;
(0, _defineProperty2.default)(SolidPolygonLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(SolidPolygonLayer, "layerName", 'SolidPolygonLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./polygon-tesselator":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","./solid-polygon-layer-vertex-top.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","./solid-polygon-layer-vertex-side.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","./solid-polygon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceInRange = replaceInRange;
function replaceInRange({
  data,
  getIndex,
  dataRange,
  replace
}) {
  const {
    startRow = 0,
    endRow = Infinity
  } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i = 0; i < count; i++) {
    const row = getIndex(data[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;
  for (let i = 0; i < replace.length; i++) {
    data[index++] = replace[i];
  }
  if (endChunk) {
    for (let i = 0; i < endChunk.length; i++) {
      data[index++] = endChunk[i];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}
},{}],"node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));
var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));
var Polygon = _interopRequireWildcard(require("../solid-polygon-layer/polygon"));
var _utils = require("../utils");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultLineColor = [0, 0, 0, 255];
const defaultFillColor = [0, 0, 0, 255];
const defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: 'CW',
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: {
    type: 'accessor',
    value: f => f.polygon
  },
  getFillColor: {
    type: 'accessor',
    value: defaultFillColor
  },
  getLineColor: {
    type: 'accessor',
    value: defaultLineColor
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: true
};
class PolygonLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      paths: []
    };
    if (this.props.getLineDashArray) {
      _core.log.removed('getLineDashArray', 'PathStyleExtension')();
    }
  }
  updateState({
    changeFlags
  }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map(dataRange => (0, _utils.replaceInRange)({
        data: paths,
        getIndex: p => p.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({
        paths,
        pathsDiff
      });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const {
      data,
      getPolygon,
      positionFormat,
      _normalize
    } = this.props;
    const paths = [];
    const positionSize = positionFormat === 'XY' ? 2 : 3;
    const {
      startRow,
      endRow
    } = dataRange;
    const {
      iterable,
      objectInfo
    } = (0, _core.createIterable)(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = Polygon.normalize(polygon, positionSize);
      }
      const {
        holeIndices
      } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
          paths.push(this.getSubLayerRow({
            path
          }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({
          path: positions
        }, object, objectInfo.index));
      }
    }
    return paths;
  }
  renderLayers() {
    const {
      data,
      _dataDiff,
      stroked,
      filled,
      extruded,
      wireframe,
      _normalize,
      _windingOrder,
      elevationScale,
      transitions,
      positionFormat
    } = this.props;
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified
    } = this.props;
    const {
      getFillColor,
      getLineColor,
      getLineWidth,
      getLineDashArray,
      getElevation,
      getPolygon,
      updateTriggers,
      material
    } = this.props;
    const {
      paths,
      pathsDiff
    } = this.state;
    const FillLayer = this.getSubLayerClass('fill', _solidPolygonLayer.default);
    const StrokeLayer = this.getSubLayerClass('stroke', _pathLayer.default);
    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: 'fill',
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      _pathType: 'loop',
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: 'stroke',
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: x => x.path
    });
    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];
  }
}
exports.default = PolygonLayer;
(0, _defineProperty2.default)(PolygonLayer, "layerName", 'PolygonLayer');
(0, _defineProperty2.default)(PolygonLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","../path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/polygon":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","../utils":"node_modules/@deck.gl/layers/dist/esm/utils.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binaryToFeatureForAccesor = binaryToFeatureForAccesor;
exports.calculatePickingColors = calculatePickingColors;
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: {
      ...data.properties[propertiesIndex]
    }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
    const pickingColor = [];
    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 3 + 0] = pickingColor[0];
      pickingColors[key][i * 3 + 1] = pickingColor[1];
      pickingColors[key][i * 3 + 2] = pickingColor[2];
    }
  }
  return pickingColors;
}
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _iconLayer = _interopRequireDefault(require("../../icon-layer/icon-layer"));
var _multiIconLayerFragment = _interopRequireDefault(require("./multi-icon-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_BUFFER = 192.0 / 256;
const EMPTY_ARRAY = [];
const defaultProps = {
  getIconOffsets: {
    type: 'accessor',
    value: x => x.offsets
  },
  alphaCutoff: 0.001,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: {
    type: 'color',
    value: [0, 0, 0, 255]
  }
};
class MultiIconLayer extends _iconLayer.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return {
      ...super.getShaders(),
      fs: _multiIconLayerFragment.default
    };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: 'getIconOffsets'
      },
      instancePickingColors: {
        type: 5121,
        size: 3,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    let {
      outlineColor
    } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map(x => x / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      _core.log.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))();
    }
  }
  draw(params) {
    const {
      sdf,
      smoothing,
      outlineWidth
    } = this.props;
    const {
      outlineColor
    } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;
    params.uniforms = {
      ...params.uniforms,
      sdfBuffer: DEFAULT_BUFFER,
      outlineBuffer,
      gamma: smoothing,
      sdf: Boolean(sdf),
      outlineColor
    };
    super.draw(params);
    if (sdf && outlineWidth) {
      const {
        iconManager
      } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        this.state.model.draw({
          uniforms: {
            outlineBuffer: DEFAULT_BUFFER
          }
        });
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
}
exports.default = MultiIconLayer;
(0, _defineProperty2.default)(MultiIconLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(MultiIconLayer, "layerName", 'MultiIconLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../../icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./multi-icon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js"}],"node_modules/@mapbox/tiny-sdf/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const INF = 1e20;
class TinySDF {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = 'sans-serif',
    fontWeight = 'normal',
    fontStyle = 'normal'
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;

    // make the canvas size big enough to both have the specified buffer around the glyph
    // for "halo", and account for some glyphs possibly being larger than their font size
    const size = this.size = fontSize + buffer * 4;
    const canvas = this._createCanvas(size);
    const ctx = this.ctx = canvas.getContext('2d', {
      willReadFrequently: true
    });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = 'alphabetic';
    ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
    ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);

    // The integer/pixel part of the top alignment is encoded in metrics.glyphTop
    // The remainder is implicitly encoded in the rasterization
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;

    // If the glyph overflows the canvas size, it will be clipped at the bottom/right
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len);
    const glyph = {
      data,
      width,
      height,
      glyphWidth,
      glyphHeight,
      glyphTop,
      glyphLeft,
      glyphAdvance
    };
    if (glyphWidth === 0 || glyphHeight === 0) return glyph;
    const {
      ctx,
      buffer,
      gridInner,
      gridOuter
    } = this;
    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);

    // Initialize grids outside the glyph range to alpha 0
    gridOuter.fill(INF, 0, len);
    gridInner.fill(0, 0, len);
    for (let y = 0; y < glyphHeight; y++) {
      for (let x = 0; x < glyphWidth; x++) {
        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
        if (a === 0) continue; // empty pixels

        const j = (y + buffer) * width + x + buffer;
        if (a === 1) {
          // fully drawn pixels
          gridOuter[j] = 0;
          gridInner[j] = INF;
        } else {
          // aliased pixels
          const d = 0.5 - a;
          gridOuter[j] = d > 0 ? d * d : 0;
          gridInner[j] = d < 0 ? d * d : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i = 0; i < len; i++) {
      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
      data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
    }
    return glyph;
  }
}

// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
exports.default = TinySDF;
function edt(data, x0, y0, width, height, gridSize, f, v, z) {
  for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);
  for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);
}

// 1D squared distance transform
function edt1d(grid, offset, stride, length, f, v, z) {
  v[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f[0] = grid[offset];
  for (let q = 1, k = 0, s = 0; q < length; q++) {
    f[q] = grid[offset + q * stride];
    const q2 = q * q;
    do {
      const r = v[k];
      s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;
    } while (s <= z[k] && --k > -1);
    k++;
    v[k] = q;
    z[k] = s;
    z[k + 1] = INF;
  }
  for (let q = 0, k = 0; q < length; q++) {
    while (z[k + 1] < q) k++;
    const r = v[k];
    const qr = q - r;
    grid[offset + q * stride] = f[r] + qr * qr;
  }
}
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoWrapping = autoWrapping;
exports.buildMapping = buildMapping;
exports.getTextFromBuffer = getTextFromBuffer;
exports.nextPowOfTwo = nextPowOfTwo;
exports.transformParagraph = transformParagraph;
var _core = require("@deck.gl/core");
const MISSING_CHAR_WIDTH = 32;
const SINGLE_LINE = [];
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  let x = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }
      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i = startIndex; i < endIndex; i++) {
    var _mapping$character;
    const character = text[i];
    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === ' ') {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === undefined) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === 'break-all') {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x = 0;
  let rowHeight = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i] = x + frame.layoutWidth / 2;
      x += frame.layoutWidth;
    } else {
      _core.log.warn("Missing character: ".concat(character, " (").concat(character.codePointAt(0), ")"))();
      leftOffsets[i] = x;
      x += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x = new Array(numCharacters);
  const y = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i = 0; i <= numCharacters; i++) {
    const char = characters[i];
    if (char === '\n' || i === numCharacters) {
      lineEndIndex = i;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          var _iconMapping$char;
          const char = characters[j];
          const layoutOffsetY = ((_iconMapping$char = iconMapping[char]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;
          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === '\n') {
      x[lineStartIndex] = 0;
      y[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return {
    x,
    y,
    rowWidth,
    size
  };
}
function getTextFromBuffer({
  value,
  length,
  stride,
  offset,
  startIndices,
  characterSet
}) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && new Set();
  const texts = new Array(length);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return {
    texts,
    characterCount
  };
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class LRUCache {
  constructor(limit = 5) {
    (0, _defineProperty2.default)(this, "limit", void 0);
    (0, _defineProperty2.default)(this, "_cache", {});
    (0, _defineProperty2.default)(this, "_order", []);
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
}
exports.default = LRUCache;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_FONT_SETTINGS = void 0;
exports.setFontAtlasCacheLimit = setFontAtlasCacheLimit;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _tinySdf = _interopRequireDefault(require("@mapbox/tiny-sdf"));
var _core = require("@deck.gl/core");
var _utils = require("./utils");
var _lruCache = _interopRequireDefault(require("./lru-cache"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
const DEFAULT_FONT_SETTINGS = {
  fontFamily: 'Monaco, monospace',
  fontWeight: 'normal',
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
exports.DEFAULT_FONT_SETTINGS = DEFAULT_FONT_SETTINGS;
const MAX_CANVAS_WIDTH = 1024;
const BASELINE_SCALE = 0.9;
const HEIGHT_SCALE = 1.2;
const CACHE_LIMIT = 3;
let cache = new _lruCache.default(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === 'string') {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign = 'left';
}
function setFontAtlasCacheLimit(limit) {
  _core.log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');
  cache = new _lruCache.default(limit);
}
class FontAtlasManager {
  constructor() {
    (0, _defineProperty2.default)(this, "props", {
      ...DEFAULT_FONT_SETTINGS
    });
    (0, _defineProperty2.default)(this, "_key", void 0);
    (0, _defineProperty2.default)(this, "_atlas", void 0);
  }
  get texture() {
    return this._atlas;
  }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const {
      fontSize,
      buffer
    } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext('2d', {
      willReadFrequently: true
    });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const {
      mapping,
      canvasHeight,
      xOffset,
      yOffset
    } = (0, _utils.buildMapping)({
      getFontWidth: char => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...(cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      })
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new _tinySdf.default({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: "".concat(fontWeight)
      });
      for (const char of characterSet) {
        const {
          data,
          width,
          height,
          glyphTop
        } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    if (sdf) {
      return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
    }
    return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
  }
}
exports.default = FontAtlasManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@mapbox/tiny-sdf":"node_modules/@mapbox/tiny-sdf/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./utils":"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","./lru-cache":"node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _core2 = require("@luma.gl/core");
var _textBackgroundLayerVertex = _interopRequireDefault(require("./text-background-layer-vertex.glsl"));
var _textBackgroundLayerFragment = _interopRequireDefault(require("./text-background-layer-fragment.glsl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const defaultProps = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  padding: {
    type: 'array',
    value: [0, 0, 0, 0]
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  getBoundingRect: {
    type: 'accessor',
    value: [0, 0, 0, 0]
  },
  getFillColor: {
    type: 'accessor',
    value: [0, 0, 0, 255]
  },
  getLineColor: {
    type: 'accessor',
    value: [0, 0, 0, 255]
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  }
};
class TextBackgroundLayer extends _core.Layer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
  }
  getShaders() {
    return super.getShaders({
      vs: _textBackgroundLayerVertex.default,
      fs: _textBackgroundLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle'
      },
      instanceRects: {
        size: 4,
        accessor: 'getBoundingRect'
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const {
      changeFlags
    } = params;
    if (changeFlags.extensionsChanged) {
      var _this$state$model;
      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({
    uniforms
  }) {
    const {
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      getLineWidth
    } = this.props;
    let {
      padding
    } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    this.state.model.setUniforms(uniforms).setUniforms({
      billboard,
      stroked: Boolean(getLineWidth),
      padding,
      sizeUnits: _core.UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    }).draw();
  }
  _getModel(gl) {
    const positions = [0, 0, 1, 0, 1, 1, 0, 1];
    return new _core2.Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
}
exports.default = TextBackgroundLayer;
(0, _defineProperty2.default)(TextBackgroundLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(TextBackgroundLayer, "layerName", 'TextBackgroundLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./text-background-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js","./text-background-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _multiIconLayer = _interopRequireDefault(require("./multi-icon-layer/multi-icon-layer"));
var _fontAtlasManager = _interopRequireWildcard(require("./font-atlas-manager"));
var _utils = require("./utils");
var _textBackgroundLayer = _interopRequireDefault(require("./text-background-layer/text-background-layer"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
const ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_LINE_HEIGHT = 1.0;
const defaultProps = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: {
    type: 'accessor',
    value: [255, 255, 255, 255]
  },
  getBorderColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getBorderWidth: {
    type: 'accessor',
    value: 0
  },
  backgroundPadding: {
    type: 'array',
    value: [0, 0, 0, 0]
  },
  characterSet: {
    type: 'object',
    value: _fontAtlasManager.DEFAULT_FONT_SETTINGS.characterSet
  },
  fontFamily: _fontAtlasManager.DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: _fontAtlasManager.DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: {
    type: 'number',
    value: 0,
    min: 0
  },
  outlineColor: {
    type: 'color',
    value: DEFAULT_COLOR
  },
  fontSettings: {
    type: 'object',
    value: {},
    compare: 1
  },
  wordBreak: 'break-word',
  maxWidth: {
    type: 'number',
    value: -1
  },
  getText: {
    type: 'accessor',
    value: x => x.text
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 32
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getTextAnchor: {
    type: 'accessor',
    value: 'middle'
  },
  getAlignmentBaseline: {
    type: 'accessor',
    value: 'center'
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  backgroundColor: {
    deprecatedFor: ['background', 'getBackgroundColor']
  }
};
class TextLayer extends _core.CompositeLayer {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "getBoundingRect", (object, objectInfo) => {
      let {
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const {
        fontSize
      } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    });
    (0, _defineProperty2.default)(this, "getIconOffsets", (object, objectInfo) => {
      const {
        getTextAnchor,
        getAlignmentBaseline
      } = this.props;
      const {
        x,
        y,
        rowWidth,
        size: [width, height]
      } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i = 0; i < numCharacters; i++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];
        offsets[index++] = (anchorY - 1) * height / 2 + y[i];
      }
      return offsets;
    });
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new _fontAtlasManager.default()
    };
    if (this.props.maxWidth > 0) {
      _core.log.warn('v8.9 breaking change: TextLayer maxWidth is now relative to text size')();
    }
  }
  updateState(params) {
    const {
      props,
      oldProps,
      changeFlags
    } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({
    info
  }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  _updateFontAtlas() {
    const {
      fontSettings,
      fontFamily,
      fontWeight
    } = this.props;
    const {
      fontAtlasManager,
      characterSet
    } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  _updateText() {
    var _attributes;
    const {
      data,
      characterSet
    } = this.props;
    const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;
    let {
      getText
    } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === 'auto' && new Set();
    if (textBuffer && startIndices) {
      const {
        texts,
        characterCount
      } = (0, _utils.getTextFromBuffer)({
        ...(ArrayBuffer.isView(textBuffer) ? {
          value: textBuffer
        } : textBuffer),
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_, {
        index
      }) => texts[index];
    } else {
      const {
        iterable,
        objectInfo
      } = (0, _core.createIterable)(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || '');
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  transformParagraph(object, objectInfo) {
    const {
      fontAtlasManager
    } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const {
      wordBreak,
      lineHeight,
      maxWidth
    } = this.props;
    const paragraph = getText(object, objectInfo) || '';
    return (0, _utils.transformParagraph)(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const {
      startIndices,
      numInstances,
      getText,
      fontAtlasManager: {
        scale,
        texture,
        mapping
      },
      styleVersion
    } = this.state;
    const {
      data,
      _dataDiff,
      getPosition,
      getColor,
      getSize,
      getAngle,
      getPixelOffset,
      getBackgroundColor,
      getBorderColor,
      getBorderWidth,
      backgroundPadding,
      background,
      billboard,
      fontSettings,
      outlineWidth,
      outlineColor,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions,
      updateTriggers
    } = this.props;
    const CharactersLayerClass = this.getSubLayerClass('characters', _multiIconLayer.default);
    const BackgroundLayerClass = this.getSubLayerClass('background', _textBackgroundLayer.default);
    return [background && new BackgroundLayerClass({
      getFillColor: getBackgroundColor,
      getLineColor: getBorderColor,
      getLineWidth: getBorderWidth,
      padding: backgroundPadding,
      getPosition,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getSize: transitions.getSize,
        getFillColor: transitions.getBackgroundColor,
        getLineColor: transitions.getBorderColor,
        getLineWidth: transitions.getBorderWidth,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: 'background',
      updateTriggers: {
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getSize: updateTriggers.getSize,
        getFillColor: updateTriggers.getBackgroundColor,
        getLineColor: updateTriggers.getBorderColor,
        getLineWidth: updateTriggers.getBorderWidth,
        getPixelOffset: updateTriggers.getPixelOffset,
        getBoundingRect: {
          getText: updateTriggers.getText,
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data: data.attributes && data.attributes.background ? {
        length: data.length,
        attributes: data.attributes.background
      } : data,
      _dataDiff,
      autoHighlight: false,
      getBoundingRect: this.getBoundingRect
    }), new CharactersLayerClass({
      sdf: fontSettings.sdf,
      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : _fontAtlasManager.DEFAULT_FONT_SETTINGS.smoothing,
      outlineWidth: outlineWidth / (fontSettings.radius || _fontAtlasManager.DEFAULT_FONT_SETTINGS.radius),
      outlineColor,
      iconAtlas: texture,
      iconMapping: mapping,
      getPosition,
      getColor,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale: sizeScale * scale,
      sizeUnits,
      sizeMinPixels: sizeMinPixels * scale,
      sizeMaxPixels: sizeMaxPixels * scale,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getColor: transitions.getColor,
        getSize: transitions.getSize,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: 'characters',
      updateTriggers: {
        all: updateTriggers.getText,
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getColor: updateTriggers.getColor,
        getSize: updateTriggers.getSize,
        getPixelOffset: updateTriggers.getPixelOffset,
        getIconOffsets: {
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data,
      _dataDiff,
      startIndices,
      numInstances,
      getIconOffsets: this.getIconOffsets,
      getIcon: getText
    })];
  }
  static set fontAtlasCacheLimit(limit) {
    (0, _fontAtlasManager.setFontAtlasCacheLimit)(limit);
  }
}
exports.default = TextLayer;
(0, _defineProperty2.default)(TextLayer, "defaultProps", defaultProps);
(0, _defineProperty2.default)(TextLayer, "layerName", 'TextLayer');
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./multi-icon-layer/multi-icon-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./font-atlas-manager":"node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js","./utils":"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","./text-background-layer/text-background-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.POLYGON_LAYER = exports.POINT_LAYER = exports.LINE_LAYER = void 0;
exports.forwardProps = forwardProps;
exports.getDefaultProps = getDefaultProps;
var _iconLayer = _interopRequireDefault(require("../icon-layer/icon-layer"));
var _scatterplotLayer = _interopRequireDefault(require("../scatterplot-layer/scatterplot-layer"));
var _textLayer = _interopRequireDefault(require("../text-layer/text-layer"));
var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));
var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const POINT_LAYER = {
  circle: {
    type: _scatterplotLayer.default,
    props: {
      filled: 'filled',
      stroked: 'stroked',
      lineWidthMaxPixels: 'lineWidthMaxPixels',
      lineWidthMinPixels: 'lineWidthMinPixels',
      lineWidthScale: 'lineWidthScale',
      lineWidthUnits: 'lineWidthUnits',
      pointRadiusMaxPixels: 'radiusMaxPixels',
      pointRadiusMinPixels: 'radiusMinPixels',
      pointRadiusScale: 'radiusScale',
      pointRadiusUnits: 'radiusUnits',
      pointAntialiasing: 'antialiasing',
      pointBillboard: 'billboard',
      getFillColor: 'getFillColor',
      getLineColor: 'getLineColor',
      getLineWidth: 'getLineWidth',
      getPointRadius: 'getRadius'
    }
  },
  icon: {
    type: _iconLayer.default,
    props: {
      iconAtlas: 'iconAtlas',
      iconMapping: 'iconMapping',
      iconSizeMaxPixels: 'sizeMaxPixels',
      iconSizeMinPixels: 'sizeMinPixels',
      iconSizeScale: 'sizeScale',
      iconSizeUnits: 'sizeUnits',
      iconAlphaCutoff: 'alphaCutoff',
      iconBillboard: 'billboard',
      getIcon: 'getIcon',
      getIconAngle: 'getAngle',
      getIconColor: 'getColor',
      getIconPixelOffset: 'getPixelOffset',
      getIconSize: 'getSize'
    }
  },
  text: {
    type: _textLayer.default,
    props: {
      textSizeMaxPixels: 'sizeMaxPixels',
      textSizeMinPixels: 'sizeMinPixels',
      textSizeScale: 'sizeScale',
      textSizeUnits: 'sizeUnits',
      textBackground: 'background',
      textBackgroundPadding: 'backgroundPadding',
      textFontFamily: 'fontFamily',
      textFontWeight: 'fontWeight',
      textLineHeight: 'lineHeight',
      textMaxWidth: 'maxWidth',
      textOutlineColor: 'outlineColor',
      textOutlineWidth: 'outlineWidth',
      textWordBreak: 'wordBreak',
      textCharacterSet: 'characterSet',
      textBillboard: 'billboard',
      textFontSettings: 'fontSettings',
      getText: 'getText',
      getTextAngle: 'getAngle',
      getTextColor: 'getColor',
      getTextPixelOffset: 'getPixelOffset',
      getTextSize: 'getSize',
      getTextAnchor: 'getTextAnchor',
      getTextAlignmentBaseline: 'getAlignmentBaseline',
      getTextBackgroundColor: 'getBackgroundColor',
      getTextBorderColor: 'getBorderColor',
      getTextBorderWidth: 'getBorderWidth'
    }
  }
};
exports.POINT_LAYER = POINT_LAYER;
const LINE_LAYER = {
  type: _pathLayer.default,
  props: {
    lineWidthUnits: 'widthUnits',
    lineWidthScale: 'widthScale',
    lineWidthMinPixels: 'widthMinPixels',
    lineWidthMaxPixels: 'widthMaxPixels',
    lineJointRounded: 'jointRounded',
    lineCapRounded: 'capRounded',
    lineMiterLimit: 'miterLimit',
    lineBillboard: 'billboard',
    getLineColor: 'getColor',
    getLineWidth: 'getWidth'
  }
};
exports.LINE_LAYER = LINE_LAYER;
const POLYGON_LAYER = {
  type: _solidPolygonLayer.default,
  props: {
    extruded: 'extruded',
    filled: 'filled',
    wireframe: 'wireframe',
    elevationScale: 'elevationScale',
    material: 'material',
    _full3d: '_full3d',
    getElevation: 'getElevation',
    getFillColor: 'getFillColor',
    getLineColor: 'getLineColor'
  }
};
exports.POLYGON_LAYER = POLYGON_LAYER;
function getDefaultProps({
  type,
  props
}) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const {
    transitions,
    updateTriggers
  } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith('get')) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}
},{"../icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","../scatterplot-layer/scatterplot-layer":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","../text-layer/text-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","../path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeojsonFeatures = getGeojsonFeatures;
exports.separateGeojsonFeatures = separateGeojsonFeatures;
exports.validateGeometry = validateGeometry;
var _core = require("@deck.gl/core");
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  _core.log.assert(geojson.type, 'GeoJSON does not have type');
  switch (geojson.type) {
    case 'Feature':
      return [geojson];
    case 'FeatureCollection':
      _core.log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');
      return geojson.features;
    default:
      return [{
        geometry: geojson
      }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const {
    startRow = 0,
    endRow = features.length
  } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const {
      geometry
    } = feature;
    if (!geometry) {
      continue;
    }
    if (geometry.type === 'GeometryCollection') {
      _core.log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');
      const {
        geometries
      } = geometry;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const {
    type,
    coordinates
  } = geometry;
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = separated;
  if (!validateGeometry(type, coordinates)) {
    _core.log.warn("".concat(type, " coordinates are malformed"))();
    return;
  }
  switch (type) {
    case 'Point':
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case 'MultiPoint':
      coordinates.forEach(point => {
        pointFeatures.push(wrapFeature({
          geometry: {
            type: 'Point',
            coordinates: point
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case 'LineString':
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case 'MultiLineString':
      coordinates.forEach(path => {
        lineFeatures.push(wrapFeature({
          geometry: {
            type: 'LineString',
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case 'Polygon':
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach(path => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: {
            type: 'LineString',
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case 'MultiPolygon':
      coordinates.forEach(polygon => {
        polygonFeatures.push(wrapFeature({
          geometry: {
            type: 'Polygon',
            coordinates: polygon
          }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach(path => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: 'LineString',
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
const COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  _core.log.assert(nestLevel, "Unknown GeoJSON type ".concat(type));
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLayerPropsFromBinary = createLayerPropsFromBinary;
exports.createLayerPropsFromFeatures = createLayerPropsFromFeatures;
var _geojsonBinary = require("./geojson-binary");
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f) {
  return f.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const {
    points,
    lines,
    polygons
  } = geojsonBinary;
  const customPickingColors = (0, _geojsonBinary.calculatePickingColors)(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = 'open';
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = 'open';
  return layerProps;
}
},{"./geojson-binary":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));
var _core = require("@deck.gl/core");
var _utils = require("../utils");
var _geojsonBinary = require("./geojson-binary");
var _subLayerMap = require("./sub-layer-map");
var _geojson = require("./geojson");
var _geojsonLayerProps = require("./geojson-layer-props");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const FEATURE_TYPES = ['points', 'linestrings', 'polygons'];
const defaultProps = {
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.circle),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.icon),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.text),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.LINE_LAYER),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POLYGON_LAYER),
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: {
    type: 'object',
    value: null
  },
  iconMapping: {
    type: 'object',
    value: {}
  },
  getIcon: {
    type: 'accessor',
    value: f => f.properties.icon
  },
  getText: {
    type: 'accessor',
    value: f => f.properties.text
  },
  pointType: 'circle',
  getRadius: {
    deprecatedFor: 'getPointRadius'
  }
};
class GeoJsonLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {}
    };
  }
  updateState({
    props,
    changeFlags
  }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const {
      data
    } = this.props;
    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;
    this.setState({
      binary
    });
    if (binary) {
      this._updateStateBinary({
        props,
        changeFlags
      });
    } else {
      this._updateStateJSON({
        props,
        changeFlags
      });
    }
  }
  _updateStateBinary({
    props,
    changeFlags
  }) {
    const layerProps = (0, _geojsonLayerProps.createLayerPropsFromBinary)(props.data, this.encodePickingColor);
    this.setState({
      layerProps
    });
  }
  _updateStateJSON({
    props,
    changeFlags
  }) {
    const features = (0, _geojson.getGeojsonFeatures)(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = (0, _geojson.separateGeojsonFeatures)(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push((0, _utils.replaceInRange)({
            data: newFeatures[key],
            getIndex: f => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = (0, _geojson.separateGeojsonFeatures)(features, wrapFeature);
    }
    const layerProps = (0, _geojsonLayerProps.createLayerPropsFromFeatures)(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index,
      sourceLayer
    } = info;
    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith("".concat(this.id, "-").concat(ft, "-")));
    if (index >= 0 && sourceLayer.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = "".concat(this.id, "-points-");
    const sourceIsPoints = info.featureType === 'points';
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    const {
      extruded,
      wireframe
    } = this.props;
    const {
      layerProps
    } = this.state;
    const id = 'polygons-fill';
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, _subLayerMap.POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = (0, _subLayerMap.forwardProps)(this, _subLayerMap.POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const {
      extruded,
      stroked
    } = this.props;
    const {
      layerProps
    } = this.state;
    const polygonStrokeLayerId = 'polygons-stroke';
    const lineStringsLayerId = 'linestrings';
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, _subLayerMap.LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, _subLayerMap.LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = (0, _subLayerMap.forwardProps)(this, _subLayerMap.LINE_LAYER.props);
      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
        id: polygonStrokeLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
        id: lineStringsLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.lines)];
    }
    return null;
  }
  _renderPointLayers() {
    const {
      pointType
    } = this.props;
    const {
      layerProps,
      binary
    } = this.state;
    let {
      highlightedObjectIndex
    } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split('+'));
    const pointLayers = [];
    for (const type of types) {
      const id = "points-".concat(type);
      const PointLayerMapping = _subLayerMap.POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = (0, _subLayerMap.forwardProps)(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === 'text' && binary) {
          const {
            instancePickingColors,
            ...rest
          } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            data: {
              ...pointsLayerProps.data,
              attributes: rest
            }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const {
      extruded
    } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];
  }
  getSubLayerAccessor(accessor) {
    const {
      binary
    } = this.state;
    if (!binary || typeof accessor !== 'function') {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const {
        data,
        index
      } = info;
      const feature = (0, _geojsonBinary.binaryToFeatureForAccesor)(data, index);
      return accessor(feature, info);
    };
  }
}
exports.default = GeoJsonLayer;
(0, _defineProperty2.default)(GeoJsonLayer, "layerName", 'GeoJsonLayer');
(0, _defineProperty2.default)(GeoJsonLayer, "defaultProps", defaultProps);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../utils":"node_modules/@deck.gl/layers/dist/esm/utils.js","./geojson-binary":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js","./sub-layer-map":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js","./geojson":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js","./geojson-layer-props":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js"}],"node_modules/@deck.gl/layers/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArcLayer", {
  enumerable: true,
  get: function () {
    return _arcLayer.default;
  }
});
Object.defineProperty(exports, "BitmapLayer", {
  enumerable: true,
  get: function () {
    return _bitmapLayer.default;
  }
});
Object.defineProperty(exports, "ColumnLayer", {
  enumerable: true,
  get: function () {
    return _columnLayer.default;
  }
});
Object.defineProperty(exports, "GeoJsonLayer", {
  enumerable: true,
  get: function () {
    return _geojsonLayer.default;
  }
});
Object.defineProperty(exports, "GridCellLayer", {
  enumerable: true,
  get: function () {
    return _gridCellLayer.default;
  }
});
Object.defineProperty(exports, "IconLayer", {
  enumerable: true,
  get: function () {
    return _iconLayer.default;
  }
});
Object.defineProperty(exports, "LineLayer", {
  enumerable: true,
  get: function () {
    return _lineLayer.default;
  }
});
Object.defineProperty(exports, "PathLayer", {
  enumerable: true,
  get: function () {
    return _pathLayer.default;
  }
});
Object.defineProperty(exports, "PointCloudLayer", {
  enumerable: true,
  get: function () {
    return _pointCloudLayer.default;
  }
});
Object.defineProperty(exports, "PolygonLayer", {
  enumerable: true,
  get: function () {
    return _polygonLayer.default;
  }
});
Object.defineProperty(exports, "ScatterplotLayer", {
  enumerable: true,
  get: function () {
    return _scatterplotLayer.default;
  }
});
Object.defineProperty(exports, "SolidPolygonLayer", {
  enumerable: true,
  get: function () {
    return _solidPolygonLayer.default;
  }
});
Object.defineProperty(exports, "TextLayer", {
  enumerable: true,
  get: function () {
    return _textLayer.default;
  }
});
Object.defineProperty(exports, "_MultiIconLayer", {
  enumerable: true,
  get: function () {
    return _multiIconLayer.default;
  }
});
Object.defineProperty(exports, "_TextBackgroundLayer", {
  enumerable: true,
  get: function () {
    return _textBackgroundLayer.default;
  }
});
var _arcLayer = _interopRequireDefault(require("./arc-layer/arc-layer"));
var _bitmapLayer = _interopRequireDefault(require("./bitmap-layer/bitmap-layer"));
var _iconLayer = _interopRequireDefault(require("./icon-layer/icon-layer"));
var _lineLayer = _interopRequireDefault(require("./line-layer/line-layer"));
var _pointCloudLayer = _interopRequireDefault(require("./point-cloud-layer/point-cloud-layer"));
var _scatterplotLayer = _interopRequireDefault(require("./scatterplot-layer/scatterplot-layer"));
var _columnLayer = _interopRequireDefault(require("./column-layer/column-layer"));
var _gridCellLayer = _interopRequireDefault(require("./column-layer/grid-cell-layer"));
var _pathLayer = _interopRequireDefault(require("./path-layer/path-layer"));
var _polygonLayer = _interopRequireDefault(require("./polygon-layer/polygon-layer"));
var _geojsonLayer = _interopRequireDefault(require("./geojson-layer/geojson-layer"));
var _textLayer = _interopRequireDefault(require("./text-layer/text-layer"));
var _solidPolygonLayer = _interopRequireDefault(require("./solid-polygon-layer/solid-polygon-layer"));
var _multiIconLayer = _interopRequireDefault(require("./text-layer/multi-icon-layer/multi-icon-layer"));
var _textBackgroundLayer = _interopRequireDefault(require("./text-layer/text-background-layer/text-background-layer"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./arc-layer/arc-layer":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js","./bitmap-layer/bitmap-layer":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js","./icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./line-layer/line-layer":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js","./point-cloud-layer/point-cloud-layer":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js","./scatterplot-layer/scatterplot-layer":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","./column-layer/column-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js","./column-layer/grid-cell-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","./path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","./polygon-layer/polygon-layer":"node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js","./geojson-layer/geojson-layer":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js","./text-layer/text-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","./solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","./text-layer/multi-icon-layer/multi-icon-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./text-layer/text-background-layer/text-background-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"}],"node_modules/mapbox-gl/dist/mapbox-gl.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/* Mapbox GL JS is Copyright  2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());
})(this, function () {
  'use strict';

  /* eslint-disable */
  var shared, worker, mapboxgl;
  // define gets called three times: one for each chunk. we rely on the order
  // they're imported to know which is which
  function define(_, chunk) {
    if (!shared) {
      shared = chunk;
    } else if (!worker) {
      worker = chunk;
    } else {
      var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
      var sharedChunk = {};
      shared(sharedChunk);
      mapboxgl = chunk(sharedChunk);
      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {
          type: 'text/javascript'
        }));
      }
    }
  }
  define(["exports"], function (t) {
    "use strict";

    var e = "undefined" != typeof self ? self : {},
      r = "2.13.0";
    let n;
    const i = {
        API_URL: "https://api.mapbox.com",
        get API_URL_REGEX() {
          if (null == n) {
            const t = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              n = null != undefined ? new RegExp(undefined) : t;
            } catch (e) {
              n = t;
            }
          }
          return n;
        },
        get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        },
        get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        },
        get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        },
        get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        },
        get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        },
        get EVENTS_URL() {
          return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
        },
        SESSION_PATH: "/map-sessions/v1",
        FEEDBACK_URL: "https://apps.mapbox.com/feedback",
        TILE_URL_VERSION: "v4",
        RASTER_URL_PREFIX: "raster/v1",
        REQUIRE_ACCESS_TOKEN: !0,
        ACCESS_TOKEN: null,
        MAX_PARALLEL_IMAGE_REQUESTS: 16
      },
      s = {
        supported: !1,
        testSupport: function (t) {
          !l && o && (u ? c(t) : a = t);
        }
      };
    let a,
      o,
      l = !1,
      u = !1;
    function c(t) {
      const e = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, e);
      try {
        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, o), t.isContextLost()) return;
        s.supported = !0;
      } catch (t) {}
      t.deleteTexture(e), l = !0;
    }
    e.document && (o = e.document.createElement("img"), o.onload = function () {
      a && c(a), a = null, u = !0;
    }, o.onerror = function () {
      l = !0, a = null;
    }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
    const h = "01";
    var p = f;
    function f(t, e, r, n) {
      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;
    }
    f.prototype = {
      sampleCurveX: function (t) {
        return ((this.ax * t + this.bx) * t + this.cx) * t;
      },
      sampleCurveY: function (t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
      },
      sampleCurveDerivativeX: function (t) {
        return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
      },
      solveCurveX: function (t, e) {
        if (void 0 === e && (e = 1e-6), t < 0) return 0;
        if (t > 1) return 1;
        for (var r = t, n = 0; n < 8; n++) {
          var i = this.sampleCurveX(r) - t;
          if (Math.abs(i) < e) return r;
          var s = this.sampleCurveDerivativeX(r);
          if (Math.abs(s) < 1e-6) break;
          r -= i / s;
        }
        var a = 0,
          o = 1;
        for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? a = r : o = r, r = .5 * (o - a) + a;
        return r;
      },
      solve: function (t, e) {
        return this.sampleCurveY(this.solveCurveX(t, e));
      }
    };
    var d = y;
    function y(t, e) {
      this.x = t, this.y = e;
    }
    y.prototype = {
      clone: function () {
        return new y(this.x, this.y);
      },
      add: function (t) {
        return this.clone()._add(t);
      },
      sub: function (t) {
        return this.clone()._sub(t);
      },
      multByPoint: function (t) {
        return this.clone()._multByPoint(t);
      },
      divByPoint: function (t) {
        return this.clone()._divByPoint(t);
      },
      mult: function (t) {
        return this.clone()._mult(t);
      },
      div: function (t) {
        return this.clone()._div(t);
      },
      rotate: function (t) {
        return this.clone()._rotate(t);
      },
      rotateAround: function (t, e) {
        return this.clone()._rotateAround(t, e);
      },
      matMult: function (t) {
        return this.clone()._matMult(t);
      },
      unit: function () {
        return this.clone()._unit();
      },
      perp: function () {
        return this.clone()._perp();
      },
      round: function () {
        return this.clone()._round();
      },
      mag: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      equals: function (t) {
        return this.x === t.x && this.y === t.y;
      },
      dist: function (t) {
        return Math.sqrt(this.distSqr(t));
      },
      distSqr: function (t) {
        var e = t.x - this.x,
          r = t.y - this.y;
        return e * e + r * r;
      },
      angle: function () {
        return Math.atan2(this.y, this.x);
      },
      angleTo: function (t) {
        return Math.atan2(this.y - t.y, this.x - t.x);
      },
      angleWith: function (t) {
        return this.angleWithSep(t.x, t.y);
      },
      angleWithSep: function (t, e) {
        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
      },
      _matMult: function (t) {
        var e = t[2] * this.x + t[3] * this.y;
        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;
      },
      _add: function (t) {
        return this.x += t.x, this.y += t.y, this;
      },
      _sub: function (t) {
        return this.x -= t.x, this.y -= t.y, this;
      },
      _mult: function (t) {
        return this.x *= t, this.y *= t, this;
      },
      _div: function (t) {
        return this.x /= t, this.y /= t, this;
      },
      _multByPoint: function (t) {
        return this.x *= t.x, this.y *= t.y, this;
      },
      _divByPoint: function (t) {
        return this.x /= t.x, this.y /= t.y, this;
      },
      _unit: function () {
        return this._div(this.mag()), this;
      },
      _perp: function () {
        var t = this.y;
        return this.y = this.x, this.x = -t, this;
      },
      _rotate: function (t) {
        var e = Math.cos(t),
          r = Math.sin(t),
          n = r * this.x + e * this.y;
        return this.x = e * this.x - r * this.y, this.y = n, this;
      },
      _rotateAround: function (t, e) {
        var r = Math.cos(t),
          n = Math.sin(t),
          i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
      },
      _round: function () {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }
    }, y.convert = function (t) {
      return t instanceof y ? t : Array.isArray(t) ? new y(t[0], t[1]) : t;
    };
    const m = Math.PI / 180,
      g = 180 / Math.PI;
    function x(t) {
      return t * m;
    }
    function v(t) {
      return t * g;
    }
    const b = [[0, 0], [1, 0], [1, 1], [0, 1]];
    function w(t) {
      if (t <= 0) return 0;
      if (t >= 1) return 1;
      const e = t * t,
        r = e * t;
      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);
    }
    function _(t, e, r, n) {
      const i = new p(t, e, r, n);
      return function (t) {
        return i.solve(t);
      };
    }
    const A = _(.25, .1, .25, 1);
    function S(t, e, r) {
      return Math.min(r, Math.max(e, t));
    }
    function k(t, e, r) {
      return (r = S((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);
    }
    function I(t, e, r) {
      const n = r - e,
        i = ((t - e) % n + n) % n + e;
      return i === e ? r : i;
    }
    function M(t, e, r) {
      if (!t.length) return r(null, []);
      let n = t.length;
      const i = new Array(t.length);
      let s = null;
      t.forEach((t, a) => {
        e(t, (t, e) => {
          t && (s = t), i[a] = e, 0 == --n && r(s, i);
        });
      });
    }
    function T(t) {
      const e = [];
      for (const r in t) e.push(t[r]);
      return e;
    }
    function z(t, ...e) {
      for (const r of e) for (const e in r) t[e] = r[e];
      return t;
    }
    let B = 1;
    function E() {
      return B++;
    }
    function C() {
      return function t(e) {
        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);
      }();
    }
    function P(t) {
      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    }
    function D(t) {
      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);
    }
    function V(t, e) {
      t.forEach(t => {
        e[t] && (e[t] = e[t].bind(e));
      });
    }
    function L(t, e) {
      return -1 !== t.indexOf(e, t.length - e.length);
    }
    function F(t, e, r) {
      const n = {};
      for (const i in t) n[i] = e.call(r || this, t[i], i, t);
      return n;
    }
    function R(t, e, r) {
      const n = {};
      for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);
      return n;
    }
    function j(t) {
      return Array.isArray(t) ? t.map(j) : "object" == typeof t && t ? F(t, j) : t;
    }
    const U = {};
    function $(t) {
      U[t] || ("undefined" != typeof console && console.warn(t), U[t] = !0);
    }
    function O(t, e, r) {
      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);
    }
    function q(t) {
      let e = 0;
      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);
      return e;
    }
    function N() {
      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
    }
    function G(t) {
      const e = {};
      if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t, r, n, i) => {
        const s = n || i;
        return e[r] = !s || s.toLowerCase(), "";
      }), e["max-age"]) {
        const t = parseInt(e["max-age"], 10);
        isNaN(t) ? delete e["max-age"] : e["max-age"] = t;
      }
      return e;
    }
    let X = null;
    function Z(t) {
      if (null == X) {
        const e = t.navigator ? t.navigator.userAgent : null;
        X = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
      }
      return X;
    }
    function K(t) {
      try {
        const r = e[t];
        return r.setItem("_mapbox_test_", 1), r.removeItem("_mapbox_test_"), !0;
      } catch (t) {
        return !1;
      }
    }
    function Y(t, e) {
      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];
    }
    const H = "mapbox-tiles";
    let W,
      J,
      Q = 500,
      tt = 50;
    function et() {
      try {
        return e.caches;
      } catch (t) {}
    }
    function rt() {
      et() && !W && (W = e.caches.open(H));
    }
    function nt(t) {
      const e = t.indexOf("?");
      if (e < 0) return t;
      const r = function (t) {
          const e = t.indexOf("?");
          return e > 0 ? t.slice(e + 1).split("&") : [];
        }(t),
        n = r.filter(t => {
          const e = t.split("=");
          return "language" === e[0] || "worldview" === e[0];
        });
      return n.length ? `${t.slice(0, e)}?${n.join("&")}` : t.slice(0, e);
    }
    let it = 1 / 0;
    const st = {
      Unknown: "Unknown",
      Style: "Style",
      Source: "Source",
      Tile: "Tile",
      Glyphs: "Glyphs",
      SpriteImage: "SpriteImage",
      SpriteJSON: "SpriteJSON",
      Image: "Image"
    };
    "function" == typeof Object.freeze && Object.freeze(st);
    class at extends Error {
      constructor(t, e, r) {
        401 === e && gt(r) && (t += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t), this.status = e, this.url = r;
      }
      toString() {
        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
      }
    }
    const ot = N() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href;
    const lt = function (t, r) {
        if (!(/^file:/.test(n = t.url) || /^file:/.test(ot()) && !/^\w+:/.test(n))) {
          if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal")) return function (t, r) {
            const n = new e.AbortController(),
              i = new e.Request(t.url, {
                method: t.method || "GET",
                body: t.body,
                credentials: t.credentials,
                headers: t.headers,
                referrer: ot(),
                signal: n.signal
              });
            let s = !1,
              a = !1;
            const o = (l = i.url).indexOf("sku=") > 0 && gt(l);
            var l;
            "json" === t.type && i.headers.set("Accept", "application/json");
            const u = (n, s, l) => {
                if (a) return;
                if (n && "SecurityError" !== n.message && $(n), s && l) return c(s);
                const u = Date.now();
                e.fetch(i).then(e => {
                  if (e.ok) {
                    const t = o ? e.clone() : null;
                    return c(e, t, u);
                  }
                  return r(new at(e.statusText, e.status, t.url));
                }).catch(e => {
                  "AbortError" !== e.name && r(new Error(`${e.message} ${t.url}`));
                });
              },
              c = (n, o, l) => {
                ("arrayBuffer" === t.type ? n.arrayBuffer() : "json" === t.type ? n.json() : n.text()).then(t => {
                  a || (o && l && function (t, r, n) {
                    if (rt(), !W) return;
                    const i = {
                      status: r.status,
                      statusText: r.statusText,
                      headers: new e.Headers()
                    };
                    r.headers.forEach((t, e) => i.headers.set(e, t));
                    const s = G(r.headers.get("Cache-Control") || "");
                    if (s["no-store"]) return;
                    s["max-age"] && i.headers.set("Expires", new Date(n + 1e3 * s["max-age"]).toUTCString());
                    const a = i.headers.get("Expires");
                    a && (new Date(a).getTime() - n < 42e4 || function (t, e) {
                      if (void 0 === J) try {
                        new Response(new ReadableStream()), J = !0;
                      } catch (t) {
                        J = !1;
                      }
                      J ? e(t.body) : t.blob().then(e);
                    }(r, r => {
                      const n = new e.Response(r, i);
                      rt(), W && W.then(e => e.put(nt(t.url), n)).catch(t => $(t.message));
                    }));
                  }(i, o, l), s = !0, r(null, t, n.headers.get("Cache-Control"), n.headers.get("Expires")));
                }).catch(t => {
                  a || r(new Error(t.message));
                });
              };
            return o ? function (t, e) {
              if (rt(), !W) return e(null);
              const r = nt(t.url);
              W.then(t => {
                t.match(r).then(n => {
                  const i = function (t) {
                    if (!t) return !1;
                    const e = new Date(t.headers.get("Expires") || 0),
                      r = G(t.headers.get("Cache-Control") || "");
                    return e > Date.now() && !r["no-cache"];
                  }(n);
                  t.delete(r), i && t.put(r, n.clone()), e(null, n, i);
                }).catch(e);
              }).catch(e);
            }(i, u) : u(null, null), {
              cancel: () => {
                a = !0, s || n.abort();
              }
            };
          }(t, r);
          if (N() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, r, void 0, !0);
        }
        var n;
        return function (t, r) {
          const n = new e.XMLHttpRequest();
          n.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (n.responseType = "arraybuffer");
          for (const e in t.headers) n.setRequestHeader(e, t.headers[e]);
          return "json" === t.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === t.credentials, n.onerror = () => {
            r(new Error(n.statusText));
          }, n.onload = () => {
            if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
              let e = n.response;
              if ("json" === t.type) try {
                e = JSON.parse(n.response);
              } catch (t) {
                return r(t);
              }
              r(null, e, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"));
            } else r(new at(n.statusText, n.status, t.url));
          }, n.send(t.body), {
            cancel: () => n.abort()
          };
        }(t, r);
      },
      ut = function (t, e) {
        return lt(z(t, {
          type: "arrayBuffer"
        }), e);
      };
    function ct(t) {
      const r = e.document.createElement("a");
      return r.href = t, r.protocol === e.document.location.protocol && r.host === e.document.location.host;
    }
    const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
    let pt, ft;
    pt = [], ft = 0;
    const dt = function (t, r) {
        if (s.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), ft >= i.MAX_PARALLEL_IMAGE_REQUESTS) {
          const e = {
            requestParameters: t,
            callback: r,
            cancelled: !1,
            cancel() {
              this.cancelled = !0;
            }
          };
          return pt.push(e), e;
        }
        ft++;
        let n = !1;
        const a = () => {
            if (!n) for (n = !0, ft--; pt.length && ft < i.MAX_PARALLEL_IMAGE_REQUESTS;) {
              const t = pt.shift(),
                {
                  requestParameters: e,
                  callback: r,
                  cancelled: n
                } = t;
              n || (t.cancel = dt(e, r).cancel);
            }
          },
          o = ut(t, (t, n, i, s) => {
            a(), t ? r(t) : n && (e.createImageBitmap ? function (t, r) {
              const n = new e.Blob([new Uint8Array(t)], {
                type: "image/png"
              });
              e.createImageBitmap(n).then(t => {
                r(null, t);
              }).catch(t => {
                r(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(n, (t, e) => r(t, e, i, s)) : function (t, r) {
              const n = new e.Image(),
                i = e.URL;
              n.onload = () => {
                r(null, n), i.revokeObjectURL(n.src), n.onload = null, e.requestAnimationFrame(() => {
                  n.src = ht;
                });
              }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const s = new e.Blob([new Uint8Array(t)], {
                type: "image/png"
              });
              n.src = t.byteLength ? i.createObjectURL(s) : ht;
            }(n, (t, e) => r(t, e, i, s)));
          });
        return {
          cancel: () => {
            o.cancel(), a();
          }
        };
      },
      yt = "NO_ACCESS_TOKEN";
    function mt(t) {
      return 0 === t.indexOf("mapbox:");
    }
    function gt(t) {
      return i.API_URL_REGEX.test(t);
    }
    function xt(t) {
      return i.API_CDN_URL_REGEX.test(t);
    }
    function vt(t) {
      return i.API_STYLE_REGEX.test(t) && !bt(t);
    }
    function bt(t) {
      return i.API_SPRITE_REGEX.test(t);
    }
    const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
    function _t(t) {
      const e = t.match(wt);
      if (!e) throw new Error("Unable to parse URL object");
      return {
        protocol: e[1],
        authority: e[2],
        path: e[3] || "/",
        params: e[4] ? e[4].split("&") : []
      };
    }
    function At(t) {
      const e = t.params.length ? `?${t.params.join("&")}` : "";
      return `${t.protocol}://${t.authority}${t.path}${e}`;
    }
    function St(t) {
      if (!t) return null;
      const r = t.split(".");
      if (!r || 3 !== r.length) return null;
      try {
        return JSON.parse(decodeURIComponent(e.atob(r[1]).split("").map(t => "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2)).join("")));
      } catch (t) {
        return null;
      }
    }
    class kt {
      constructor(t) {
        this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      }
      getStorageKey(t) {
        const r = St(i.ACCESS_TOKEN);
        let n = "";
        return n = r && r.u ? e.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number("0x" + e)))) : i.ACCESS_TOKEN || "", t ? `mapbox.eventData.${t}:${n}` : `mapbox.eventData:${n}`;
      }
      fetchEventData() {
        const t = K("localStorage"),
          r = this.getStorageKey(),
          n = this.getStorageKey("uuid");
        if (t) try {
          const t = e.localStorage.getItem(r);
          t && (this.eventData = JSON.parse(t));
          const i = e.localStorage.getItem(n);
          i && (this.anonId = i);
        } catch (t) {
          $("Unable to read from LocalStorage");
        }
      }
      saveEventData() {
        const t = K("localStorage"),
          r = this.getStorageKey(),
          n = this.getStorageKey("uuid");
        if (t) try {
          e.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r, JSON.stringify(this.eventData));
        } catch (t) {
          $("Unable to write to LocalStorage");
        }
      }
      processRequests(t) {}
      postEvent(t, e, r, n) {
        if (!i.EVENTS_URL) return;
        const s = _t(i.EVENTS_URL);
        s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);
        const a = {
            event: this.type,
            created: new Date(t).toISOString()
          },
          o = e ? z(a, e) : a,
          l = {
            url: At(s),
            headers: {
              "Content-Type": "text/plain"
            },
            body: JSON.stringify([o])
          };
        this.pendingRequest = function (t, e) {
          return lt(z(t, {
            method: "POST"
          }), e);
        }(l, t => {
          this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);
        });
      }
      queueRequest(t, e) {
        this.queue.push(t), this.processRequests(e);
      }
    }
    const It = new class extends kt {
        constructor(t) {
          super("appUserTurnstile"), this._customAccessToken = t;
        }
        postTurnstileEvent(t, e) {
          i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t) && t.some(t => mt(t) || gt(t)) && this.queueRequest(Date.now(), e);
        }
        processRequests(t) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const e = St(i.ACCESS_TOKEN),
            n = e ? e.u : i.ACCESS_TOKEN;
          let s = n !== this.eventData.tokenU;
          D(this.anonId) || (this.anonId = C(), s = !0);
          const a = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const t = new Date(this.eventData.lastSuccess),
              e = new Date(a),
              r = (a - this.eventData.lastSuccess) / 864e5;
            s = s || r >= 1 || r < -1 || t.getDate() !== e.getDate();
          } else s = !0;
          s ? this.postEvent(a, {
            sdkIdentifier: "mapbox-gl-js",
            sdkVersion: r,
            skuId: h,
            "enabled.telemetry": !1,
            userId: this.anonId
          }, t => {
            t || (this.eventData.lastSuccess = a, this.eventData.tokenU = n);
          }, t) : this.processRequests();
        }
      }(),
      Mt = It.postTurnstileEvent.bind(It),
      Tt = new class extends kt {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t, e, r, n) {
          this.skuToken = e, this.errorCb = n, i.EVENTS_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({
            id: t,
            timestamp: Date.now()
          }, r) : this.errorCb(new Error(yt)));
        }
        processRequests(t) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const {
            id: e,
            timestamp: n
          } = this.queue.shift();
          e && this.success[e] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n, {
            sdkIdentifier: "mapbox-gl-js",
            sdkVersion: r,
            skuId: h,
            skuToken: this.skuToken,
            userId: this.anonId
          }, t => {
            t ? this.errorCb(t) : e && (this.success[e] = !0);
          }, t));
        }
      }(),
      zt = Tt.postMapLoadEvent.bind(Tt),
      Bt = new class extends kt {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(t, e) {
          i.EVENTS_URL && (t || i.ACCESS_TOKEN) && this.queueRequest({
            timestamp: Date.now(),
            performanceData: e
          }, t);
        }
        processRequests(t) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const {
              timestamp: n,
              performanceData: i
            } = this.queue.shift(),
            s = function (t) {
              const n = e.performance.getEntriesByType("resource"),
                i = e.performance.getEntriesByType("mark"),
                s = function (t) {
                  const e = {};
                  if (t) for (const r in t) if ("other" !== r) for (const n of t[r]) {
                    const t = `${r}ResolveRangeMin`,
                      i = `${r}ResolveRangeMax`,
                      s = `${r}RequestCount`,
                      a = `${r}RequestCachedCount`;
                    e[t] = Math.min(e[t] || 1 / 0, n.startTime), e[i] = Math.max(e[i] || -1 / 0, n.responseEnd);
                    const o = t => {
                      void 0 === e[t] && (e[t] = 0), ++e[t];
                    };
                    void 0 !== n.transferSize && 0 === n.transferSize && o(a), o(s);
                  }
                  return e;
                }(function (t, e) {
                  const r = {};
                  if (t) for (const n of t) {
                    const t = e(n);
                    void 0 === r[t] && (r[t] = []), r[t].push(n);
                  }
                  return r;
                }(n, Ft)),
                a = e.devicePixelRatio,
                o = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection,
                l = {
                  counters: [],
                  metadata: [],
                  attributes: []
                },
                u = (t, e, r) => {
                  null != r && t.push({
                    name: e,
                    value: r.toString()
                  });
                };
              for (const t in s) u(l.counters, t, s[t]);
              if (t.interactionRange[0] !== 1 / 0 && t.interactionRange[1] !== -1 / 0 && (u(l.counters, "interactionRangeMin", t.interactionRange[0]), u(l.counters, "interactionRangeMax", t.interactionRange[1])), i) for (const t of Object.keys(Vt)) {
                const e = Vt[t],
                  r = i.find(t => t.name === e);
                r && u(l.counters, e, r.startTime);
              }
              return u(l.counters, "visibilityHidden", t.visibilityHidden), u(l.attributes, "style", function (t) {
                if (t) for (const e of t) {
                  const t = e.name.split("?")[0];
                  if (vt(t)) {
                    const e = t.split("/").slice(-2);
                    if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;
                  }
                }
              }(n)), u(l.attributes, "terrainEnabled", t.terrainEnabled ? "true" : "false"), u(l.attributes, "fogEnabled", t.fogEnabled ? "true" : "false"), u(l.attributes, "projection", t.projection), u(l.attributes, "zoom", t.zoom), u(l.metadata, "devicePixelRatio", a), u(l.metadata, "connectionEffectiveType", o ? o.effectiveType : void 0), u(l.metadata, "navigatorUserAgent", e.navigator.userAgent), u(l.metadata, "screenWidth", e.screen.width), u(l.metadata, "screenHeight", e.screen.height), u(l.metadata, "windowWidth", e.innerWidth), u(l.metadata, "windowHeight", e.innerHeight), u(l.metadata, "mapWidth", t.width / a), u(l.metadata, "mapHeight", t.height / a), u(l.metadata, "webglRenderer", t.renderer), u(l.metadata, "webglVendor", t.vendor), u(l.metadata, "sdkVersion", r), u(l.metadata, "sdkIdentifier", "mapbox-gl-js"), l;
            }(i);
          for (const t of s.metadata);
          for (const t of s.counters);
          for (const t of s.attributes);
          this.postEvent(n, s, () => {}, t);
        }
      }(),
      Et = Bt.postPerformanceEvent.bind(Bt),
      Ct = new class extends kt {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t, e, r, n) {
          if (!i.API_URL || !i.SESSION_PATH) return;
          const s = _t(i.API_URL + i.SESSION_PATH);
          s.params.push(`sku=${e || ""}`), s.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`);
          const a = {
            url: At(s),
            headers: {
              "Content-Type": "text/plain"
            }
          };
          this.pendingRequest = function (t, e) {
            return lt(z(t, {
              method: "GET"
            }), e);
          }(a, t => {
            this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);
          });
        }
        getSessionAPI(t, e, r, n) {
          this.skuToken = e, this.errorCb = n, i.SESSION_PATH && i.API_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({
            id: t,
            timestamp: Date.now()
          }, r) : this.errorCb(new Error(yt)));
        }
        processRequests(t) {
          if (this.pendingRequest || 0 === this.queue.length) return;
          const {
            id: e,
            timestamp: r
          } = this.queue.shift();
          e && this.success[e] || this.getSession(r, this.skuToken, t => {
            t ? this.errorCb(t) : e && (this.success[e] = !0);
          }, t);
        }
      }(),
      Pt = Ct.getSessionAPI.bind(Ct),
      Dt = new Set(),
      Vt = {
        create: "create",
        load: "load",
        fullLoad: "fullLoad"
      },
      Lt = {
        mark(t) {
          e.performance.mark(t);
        },
        measure(t, r, n) {
          e.performance.measure(t, r, n);
        }
      };
    function Ft(t) {
      const e = t.name.split("?")[0];
      return xt(e) && e.includes("mapbox-gl.js") ? "javascript" : xt(e) && e.includes("mapbox-gl.css") ? "css" : function (t) {
        return i.API_FONTS_REGEX.test(t);
      }(e) ? "fontRange" : bt(e) ? "sprite" : vt(e) ? "style" : function (t) {
        return i.API_TILEJSON_REGEX.test(t);
      }(e) ? "tilejson" : "other";
    }
    const Rt = e.performance;
    function jt(t) {
      const e = t ? t.url.toString() : void 0;
      return Rt.getEntriesByName(e);
    }
    let Ut, $t, Ot, qt;
    const Nt = {
      now: () => void 0 !== Ot ? Ot : e.performance.now(),
      setNow(t) {
        Ot = t;
      },
      restoreNow() {
        Ot = void 0;
      },
      frame(t) {
        const r = e.requestAnimationFrame(t);
        return {
          cancel: () => e.cancelAnimationFrame(r)
        };
      },
      getImageData(t, r = 0) {
        const {
          width: n,
          height: i
        } = t;
        qt || (qt = e.document.createElement("canvas"));
        const s = qt.getContext("2d", {
          willReadFrequently: !0
        });
        if (!s) throw new Error("failed to create canvas 2d context");
        return (n > qt.width || i > qt.height) && (qt.width = n, qt.height = i), s.clearRect(-r, -r, n + 2 * r, i + 2 * r), s.drawImage(t, 0, 0, n, i), s.getImageData(-r, -r, n + 2 * r, i + 2 * r);
      },
      resolveURL: t => (Ut || (Ut = e.document.createElement("a")), Ut.href = t, Ut.href),
      get devicePixelRatio() {
        return e.devicePixelRatio;
      },
      get prefersReducedMotion() {
        return !!e.matchMedia && (null == $t && ($t = e.matchMedia("(prefers-reduced-motion: reduce)")), $t.matches);
      }
    };
    function Gt(t, e, r) {
      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));
    }
    function Xt(t, e, r) {
      if (r && r[t]) {
        const n = r[t].indexOf(e);
        -1 !== n && r[t].splice(n, 1);
      }
    }
    class Zt {
      constructor(t, e = {}) {
        z(this, e), this.type = t;
      }
    }
    class Kt extends Zt {
      constructor(t, e = {}) {
        super("error", z({
          error: t
        }, e));
      }
    }
    class Yt {
      on(t, e) {
        return this._listeners = this._listeners || {}, Gt(t, e, this._listeners), this;
      }
      off(t, e) {
        return Xt(t, e, this._listeners), Xt(t, e, this._oneTimeListeners), this;
      }
      once(t, e) {
        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Gt(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));
      }
      fire(t, e) {
        "string" == typeof t && (t = new Zt(t, e || {}));
        const r = t.type;
        if (this.listens(r)) {
          t.target = this;
          const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
          for (const r of e) r.call(this, t);
          const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
          for (const e of n) Xt(r, e, this._oneTimeListeners), e.call(this, t);
          const i = this._eventedParent;
          i && (z(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));
        } else t instanceof Kt && console.error(t.error);
        return this;
      }
      listens(t) {
        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));
      }
      setEventedParent(t, e) {
        return this._eventedParent = t, this._eventedParentData = e, this;
      }
    }
    var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
    function Wt(t, ...e) {
      for (const r of e) for (const e in r) t[e] = r[e];
      return t;
    }
    function Jt(t) {
      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;
    }
    function Qt(t) {
      if (Array.isArray(t)) return t.map(Qt);
      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
        const e = {};
        for (const r in t) e[r] = Qt(t[r]);
        return e;
      }
      return Jt(t);
    }
    class te extends Error {
      constructor(t, e) {
        super(e), this.message = e, this.key = t;
      }
    }
    var ee = te;
    class re {
      constructor(t, e = []) {
        this.parent = t, this.bindings = {};
        for (const [t, r] of e) this.bindings[t] = r;
      }
      concat(t) {
        return new re(this, t);
      }
      get(t) {
        if (this.bindings[t]) return this.bindings[t];
        if (this.parent) return this.parent.get(t);
        throw new Error(`${t} not found in scope.`);
      }
      has(t) {
        return !!this.bindings[t] || !!this.parent && this.parent.has(t);
      }
    }
    var ne = re;
    const ie = {
        kind: "null"
      },
      se = {
        kind: "number"
      },
      ae = {
        kind: "string"
      },
      oe = {
        kind: "boolean"
      },
      le = {
        kind: "color"
      },
      ue = {
        kind: "object"
      },
      ce = {
        kind: "value"
      },
      he = {
        kind: "collator"
      },
      pe = {
        kind: "formatted"
      },
      fe = {
        kind: "resolvedImage"
      };
    function de(t, e) {
      return {
        kind: "array",
        itemType: t,
        N: e
      };
    }
    function ye(t) {
      if ("array" === t.kind) {
        const e = ye(t.itemType);
        return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>`;
      }
      return t.kind;
    }
    const me = [ie, se, ae, oe, le, pe, ue, de(ce), fe];
    function ge(t, e) {
      if ("error" === e.kind) return null;
      if ("array" === t.kind) {
        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !ge(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null;
      } else {
        if (t.kind === e.kind) return null;
        if ("value" === t.kind) for (const t of me) if (!ge(t, e)) return null;
      }
      return `Expected ${ye(t)} but found ${ye(e)} instead.`;
    }
    function xe(t, e) {
      return e.some(e => e.kind === t.kind);
    }
    function ve(t, e) {
      return e.some(e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t);
    }
    var be,
      we = {
        transparent: [0, 0, 0, 0],
        aliceblue: [240, 248, 255, 1],
        antiquewhite: [250, 235, 215, 1],
        aqua: [0, 255, 255, 1],
        aquamarine: [127, 255, 212, 1],
        azure: [240, 255, 255, 1],
        beige: [245, 245, 220, 1],
        bisque: [255, 228, 196, 1],
        black: [0, 0, 0, 1],
        blanchedalmond: [255, 235, 205, 1],
        blue: [0, 0, 255, 1],
        blueviolet: [138, 43, 226, 1],
        brown: [165, 42, 42, 1],
        burlywood: [222, 184, 135, 1],
        cadetblue: [95, 158, 160, 1],
        chartreuse: [127, 255, 0, 1],
        chocolate: [210, 105, 30, 1],
        coral: [255, 127, 80, 1],
        cornflowerblue: [100, 149, 237, 1],
        cornsilk: [255, 248, 220, 1],
        crimson: [220, 20, 60, 1],
        cyan: [0, 255, 255, 1],
        darkblue: [0, 0, 139, 1],
        darkcyan: [0, 139, 139, 1],
        darkgoldenrod: [184, 134, 11, 1],
        darkgray: [169, 169, 169, 1],
        darkgreen: [0, 100, 0, 1],
        darkgrey: [169, 169, 169, 1],
        darkkhaki: [189, 183, 107, 1],
        darkmagenta: [139, 0, 139, 1],
        darkolivegreen: [85, 107, 47, 1],
        darkorange: [255, 140, 0, 1],
        darkorchid: [153, 50, 204, 1],
        darkred: [139, 0, 0, 1],
        darksalmon: [233, 150, 122, 1],
        darkseagreen: [143, 188, 143, 1],
        darkslateblue: [72, 61, 139, 1],
        darkslategray: [47, 79, 79, 1],
        darkslategrey: [47, 79, 79, 1],
        darkturquoise: [0, 206, 209, 1],
        darkviolet: [148, 0, 211, 1],
        deeppink: [255, 20, 147, 1],
        deepskyblue: [0, 191, 255, 1],
        dimgray: [105, 105, 105, 1],
        dimgrey: [105, 105, 105, 1],
        dodgerblue: [30, 144, 255, 1],
        firebrick: [178, 34, 34, 1],
        floralwhite: [255, 250, 240, 1],
        forestgreen: [34, 139, 34, 1],
        fuchsia: [255, 0, 255, 1],
        gainsboro: [220, 220, 220, 1],
        ghostwhite: [248, 248, 255, 1],
        gold: [255, 215, 0, 1],
        goldenrod: [218, 165, 32, 1],
        gray: [128, 128, 128, 1],
        green: [0, 128, 0, 1],
        greenyellow: [173, 255, 47, 1],
        grey: [128, 128, 128, 1],
        honeydew: [240, 255, 240, 1],
        hotpink: [255, 105, 180, 1],
        indianred: [205, 92, 92, 1],
        indigo: [75, 0, 130, 1],
        ivory: [255, 255, 240, 1],
        khaki: [240, 230, 140, 1],
        lavender: [230, 230, 250, 1],
        lavenderblush: [255, 240, 245, 1],
        lawngreen: [124, 252, 0, 1],
        lemonchiffon: [255, 250, 205, 1],
        lightblue: [173, 216, 230, 1],
        lightcoral: [240, 128, 128, 1],
        lightcyan: [224, 255, 255, 1],
        lightgoldenrodyellow: [250, 250, 210, 1],
        lightgray: [211, 211, 211, 1],
        lightgreen: [144, 238, 144, 1],
        lightgrey: [211, 211, 211, 1],
        lightpink: [255, 182, 193, 1],
        lightsalmon: [255, 160, 122, 1],
        lightseagreen: [32, 178, 170, 1],
        lightskyblue: [135, 206, 250, 1],
        lightslategray: [119, 136, 153, 1],
        lightslategrey: [119, 136, 153, 1],
        lightsteelblue: [176, 196, 222, 1],
        lightyellow: [255, 255, 224, 1],
        lime: [0, 255, 0, 1],
        limegreen: [50, 205, 50, 1],
        linen: [250, 240, 230, 1],
        magenta: [255, 0, 255, 1],
        maroon: [128, 0, 0, 1],
        mediumaquamarine: [102, 205, 170, 1],
        mediumblue: [0, 0, 205, 1],
        mediumorchid: [186, 85, 211, 1],
        mediumpurple: [147, 112, 219, 1],
        mediumseagreen: [60, 179, 113, 1],
        mediumslateblue: [123, 104, 238, 1],
        mediumspringgreen: [0, 250, 154, 1],
        mediumturquoise: [72, 209, 204, 1],
        mediumvioletred: [199, 21, 133, 1],
        midnightblue: [25, 25, 112, 1],
        mintcream: [245, 255, 250, 1],
        mistyrose: [255, 228, 225, 1],
        moccasin: [255, 228, 181, 1],
        navajowhite: [255, 222, 173, 1],
        navy: [0, 0, 128, 1],
        oldlace: [253, 245, 230, 1],
        olive: [128, 128, 0, 1],
        olivedrab: [107, 142, 35, 1],
        orange: [255, 165, 0, 1],
        orangered: [255, 69, 0, 1],
        orchid: [218, 112, 214, 1],
        palegoldenrod: [238, 232, 170, 1],
        palegreen: [152, 251, 152, 1],
        paleturquoise: [175, 238, 238, 1],
        palevioletred: [219, 112, 147, 1],
        papayawhip: [255, 239, 213, 1],
        peachpuff: [255, 218, 185, 1],
        peru: [205, 133, 63, 1],
        pink: [255, 192, 203, 1],
        plum: [221, 160, 221, 1],
        powderblue: [176, 224, 230, 1],
        purple: [128, 0, 128, 1],
        rebeccapurple: [102, 51, 153, 1],
        red: [255, 0, 0, 1],
        rosybrown: [188, 143, 143, 1],
        royalblue: [65, 105, 225, 1],
        saddlebrown: [139, 69, 19, 1],
        salmon: [250, 128, 114, 1],
        sandybrown: [244, 164, 96, 1],
        seagreen: [46, 139, 87, 1],
        seashell: [255, 245, 238, 1],
        sienna: [160, 82, 45, 1],
        silver: [192, 192, 192, 1],
        skyblue: [135, 206, 235, 1],
        slateblue: [106, 90, 205, 1],
        slategray: [112, 128, 144, 1],
        slategrey: [112, 128, 144, 1],
        snow: [255, 250, 250, 1],
        springgreen: [0, 255, 127, 1],
        steelblue: [70, 130, 180, 1],
        tan: [210, 180, 140, 1],
        teal: [0, 128, 128, 1],
        thistle: [216, 191, 216, 1],
        tomato: [255, 99, 71, 1],
        turquoise: [64, 224, 208, 1],
        violet: [238, 130, 238, 1],
        wheat: [245, 222, 179, 1],
        white: [255, 255, 255, 1],
        whitesmoke: [245, 245, 245, 1],
        yellow: [255, 255, 0, 1],
        yellowgreen: [154, 205, 50, 1]
      };
    function _e(t) {
      return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;
    }
    function Ae(t) {
      return _e("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));
    }
    function Se(t) {
      return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;
      var e;
    }
    function ke(t, e, r) {
      return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;
    }
    try {
      be = {}.parseCSSColor = function (t) {
        var e,
          r = t.replace(/ /g, "").toLowerCase();
        if (r in we) return we[r].slice();
        if ("#" === r[0]) return 4 === r.length ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === r.length && (e = parseInt(r.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;
        var n = r.indexOf("("),
          i = r.indexOf(")");
        if (-1 !== n && i + 1 === r.length) {
          var s = r.substr(0, n),
            a = r.substr(n + 1, i - (n + 1)).split(","),
            o = 1;
          switch (s) {
            case "rgba":
              if (4 !== a.length) return null;
              o = Se(a.pop());
            case "rgb":
              return 3 !== a.length ? null : [Ae(a[0]), Ae(a[1]), Ae(a[2]), o];
            case "hsla":
              if (4 !== a.length) return null;
              o = Se(a.pop());
            case "hsl":
              if (3 !== a.length) return null;
              var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360,
                u = Se(a[1]),
                c = Se(a[2]),
                h = c <= .5 ? c * (u + 1) : c + u - c * u,
                p = 2 * c - h;
              return [_e(255 * ke(p, h, l + 1 / 3)), _e(255 * ke(p, h, l)), _e(255 * ke(p, h, l - 1 / 3)), o];
            default:
              return null;
          }
        }
        return null;
      };
    } catch (t) {}
    class Ie {
      constructor(t, e, r, n = 1) {
        this.r = t, this.g = e, this.b = r, this.a = n;
      }
      static parse(t) {
        if (!t) return;
        if (t instanceof Ie) return t;
        if ("string" != typeof t) return;
        const e = be(t);
        return e ? new Ie(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;
      }
      toString() {
        const [t, e, r, n] = this.toArray();
        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;
      }
      toArray() {
        const {
          r: t,
          g: e,
          b: r,
          a: n
        } = this;
        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];
      }
      toArray01() {
        const {
          r: t,
          g: e,
          b: r,
          a: n
        } = this;
        return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, r / n, n];
      }
      toArray01PremultipliedAlpha() {
        const {
          r: t,
          g: e,
          b: r,
          a: n
        } = this;
        return [t, e, r, n];
      }
    }
    Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
    var Me = Ie;
    class Te {
      constructor(t, e, r) {
        this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
          sensitivity: this.sensitivity,
          usage: "search"
        });
      }
      compare(t, e) {
        return this.collator.compare(t, e);
      }
      resolvedLocale() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      }
    }
    class ze {
      constructor(t, e, r, n, i) {
        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
      }
    }
    class Be {
      constructor(t) {
        this.sections = t;
      }
      static fromString(t) {
        return new Be([new ze(t, null, null, null, null)]);
      }
      isEmpty() {
        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);
      }
      static factory(t) {
        return t instanceof Be ? t : Be.fromString(t);
      }
      toString() {
        return 0 === this.sections.length ? "" : this.sections.map(t => t.text).join("");
      }
      serialize() {
        const t = ["format"];
        for (const e of this.sections) {
          if (e.image) {
            t.push(["image", e.image.name]);
            continue;
          }
          t.push(e.text);
          const r = {};
          e.fontStack && (r["text-font"] = ["literal", e.fontStack.split(",")]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = ["rgba"].concat(e.textColor.toArray())), t.push(r);
        }
        return t;
      }
    }
    class Ee {
      constructor(t) {
        this.name = t.name, this.available = t.available;
      }
      toString() {
        return this.name;
      }
      static fromString(t) {
        return t ? new Ee({
          name: t,
          available: !1
        }) : null;
      }
      serialize() {
        return ["image", this.name];
      }
    }
    function Ce(t, e, r, n) {
      return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
    }
    function Pe(t) {
      if (null === t) return !0;
      if ("string" == typeof t) return !0;
      if ("boolean" == typeof t) return !0;
      if ("number" == typeof t) return !0;
      if (t instanceof Me) return !0;
      if (t instanceof Te) return !0;
      if (t instanceof Be) return !0;
      if (t instanceof Ee) return !0;
      if (Array.isArray(t)) {
        for (const e of t) if (!Pe(e)) return !1;
        return !0;
      }
      if ("object" == typeof t) {
        for (const e in t) if (!Pe(t[e])) return !1;
        return !0;
      }
      return !1;
    }
    function De(t) {
      if (null === t) return ie;
      if ("string" == typeof t) return ae;
      if ("boolean" == typeof t) return oe;
      if ("number" == typeof t) return se;
      if (t instanceof Me) return le;
      if (t instanceof Te) return he;
      if (t instanceof Be) return pe;
      if (t instanceof Ee) return fe;
      if (Array.isArray(t)) {
        const e = t.length;
        let r;
        for (const e of t) {
          const t = De(e);
          if (r) {
            if (r === t) continue;
            r = ce;
            break;
          }
          r = t;
        }
        return de(r || ce, e);
      }
      return ue;
    }
    function Ve(t) {
      const e = typeof t;
      return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof Me || t instanceof Be || t instanceof Ee ? t.toString() : JSON.stringify(t);
    }
    class Le {
      constructor(t, e) {
        this.type = t, this.value = e;
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
        if (!Pe(t[1])) return e.error("invalid value");
        const r = t[1];
        let n = De(r);
        const i = e.expectedType;
        return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new Le(n, r);
      }
      evaluate() {
        return this.value;
      }
      eachChild() {}
      outputDefined() {
        return !0;
      }
      serialize() {
        return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Me ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
      }
    }
    var Fe = Le,
      Re = class {
        constructor(t) {
          this.name = "ExpressionEvaluationError", this.message = t;
        }
        toJSON() {
          return this.message;
        }
      };
    const je = {
      string: ae,
      number: se,
      boolean: oe,
      object: ue
    };
    class Ue {
      constructor(t, e) {
        this.type = t, this.args = e;
      }
      static parse(t, e) {
        if (t.length < 2) return e.error("Expected at least one argument.");
        let r,
          n = 1;
        const i = t[0];
        if ("array" === i) {
          let i, s;
          if (t.length > 2) {
            const r = t[1];
            if ("string" != typeof r || !(r in je) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
            i = je[r], n++;
          } else i = ce;
          if (t.length > 3) {
            if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
            s = t[2], n++;
          }
          r = de(i, s);
        } else r = je[i];
        const s = [];
        for (; n < t.length; n++) {
          const r = e.parse(t[n], n, ce);
          if (!r) return null;
          s.push(r);
        }
        return new Ue(r, s);
      }
      evaluate(t) {
        for (let e = 0; e < this.args.length; e++) {
          const r = this.args[e].evaluate(t);
          if (!ge(this.type, De(r))) return r;
          if (e === this.args.length - 1) throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r))} instead.`);
        }
        return null;
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return this.args.every(t => t.outputDefined());
      }
      serialize() {
        const t = this.type,
          e = [t.kind];
        if ("array" === t.kind) {
          const r = t.itemType;
          if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
            e.push(r.kind);
            const n = t.N;
            ("number" == typeof n || this.args.length > 1) && e.push(n);
          }
        }
        return e.concat(this.args.map(t => t.serialize()));
      }
    }
    var $e = Ue;
    class Oe {
      constructor(t) {
        this.type = pe, this.sections = t;
      }
      static parse(t, e) {
        if (t.length < 2) return e.error("Expected at least one argument.");
        const r = t[1];
        if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");
        const n = [];
        let i = !1;
        for (let r = 1; r <= t.length - 1; ++r) {
          const s = t[r];
          if (i && "object" == typeof s && !Array.isArray(s)) {
            i = !1;
            let t = null;
            if (s["font-scale"] && (t = e.parse(s["font-scale"], 1, se), !t)) return null;
            let r = null;
            if (s["text-font"] && (r = e.parse(s["text-font"], 1, de(ae)), !r)) return null;
            let a = null;
            if (s["text-color"] && (a = e.parse(s["text-color"], 1, le), !a)) return null;
            const o = n[n.length - 1];
            o.scale = t, o.font = r, o.textColor = a;
          } else {
            const s = e.parse(t[r], 1, ce);
            if (!s) return null;
            const a = s.type.kind;
            if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            i = !0, n.push({
              content: s,
              scale: null,
              font: null,
              textColor: null
            });
          }
        }
        return new Oe(n);
      }
      evaluate(t) {
        return new Be(this.sections.map(e => {
          const r = e.content.evaluate(t);
          return De(r) === fe ? new ze("", r, null, null, null) : new ze(Ve(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);
        }));
      }
      eachChild(t) {
        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        const t = ["format"];
        for (const e of this.sections) {
          t.push(e.content.serialize());
          const r = {};
          e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t.push(r);
        }
        return t;
      }
    }
    class qe {
      constructor(t) {
        this.type = fe, this.input = t;
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error("Expected two arguments.");
        const r = e.parse(t[1], 1, ae);
        return r ? new qe(r) : e.error("No image name provided.");
      }
      evaluate(t) {
        const e = this.input.evaluate(t),
          r = Ee.fromString(e);
        return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;
      }
      eachChild(t) {
        t(this.input);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        return ["image", this.input.serialize()];
      }
    }
    const Ne = {
      "to-boolean": oe,
      "to-color": le,
      "to-number": se,
      "to-string": ae
    };
    class Ge {
      constructor(t, e) {
        this.type = t, this.args = e;
      }
      static parse(t, e) {
        if (t.length < 2) return e.error("Expected at least one argument.");
        const r = t[0];
        if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument.");
        const n = Ne[r],
          i = [];
        for (let r = 1; r < t.length; r++) {
          const n = e.parse(t[r], r, ce);
          if (!n) return null;
          i.push(n);
        }
        return new Ge(n, i);
      }
      evaluate(t) {
        if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));
        if ("color" === this.type.kind) {
          let e, r;
          for (const n of this.args) {
            if (e = n.evaluate(t), r = null, e instanceof Me) return e;
            if ("string" == typeof e) {
              const r = t.parseColor(e);
              if (r) return r;
            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Ce(e[0], e[1], e[2], e[3]), !r)) return new Me(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
          }
          throw new Re(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
        }
        if ("number" === this.type.kind) {
          let e = null;
          for (const r of this.args) {
            if (e = r.evaluate(t), null === e) return 0;
            const n = Number(e);
            if (!isNaN(n)) return n;
          }
          throw new Re(`Could not convert ${JSON.stringify(e)} to number.`);
        }
        return "formatted" === this.type.kind ? Be.fromString(Ve(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? Ee.fromString(Ve(this.args[0].evaluate(t))) : Ve(this.args[0].evaluate(t));
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return this.args.every(t => t.outputDefined());
      }
      serialize() {
        if ("formatted" === this.type.kind) return new Oe([{
          content: this.args[0],
          scale: null,
          font: null,
          textColor: null
        }]).serialize();
        if ("resolvedImage" === this.type.kind) return new qe(this.args[0]).serialize();
        const t = [`to-${this.type.kind}`];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }
    }
    var Xe = Ge;
    const Ze = ["Unknown", "Point", "LineString", "Polygon"];
    var Ke = class {
      constructor() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
      }
      id() {
        return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
      }
      geometryType() {
        return this.feature ? "number" == typeof this.feature.type ? Ze[this.feature.type] : this.feature.type : null;
      }
      geometry() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }
      canonicalID() {
        return this.canonical;
      }
      properties() {
        return this.feature && this.feature.properties || {};
      }
      distanceFromCenter() {
        if (this.featureTileCoord && this.featureDistanceData) {
          const t = this.featureDistanceData.center,
            e = this.featureDistanceData.scale,
            {
              x: r,
              y: n
            } = this.featureTileCoord;
          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);
        }
        return 0;
      }
      parseColor(t) {
        let e = this._parseColorCache[t];
        return e || (e = this._parseColorCache[t] = Me.parse(t)), e;
      }
    };
    class Ye {
      constructor(t, e, r, n) {
        this.name = t, this.type = e, this._evaluate = r, this.args = n;
      }
      evaluate(t) {
        return this._evaluate(t, this.args);
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        return [this.name].concat(this.args.map(t => t.serialize()));
      }
      static parse(t, e) {
        const r = t[0],
          n = Ye.definitions[r];
        if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
        const i = Array.isArray(n) ? n[0] : n.type,
          s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,
          a = s.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);
        let o = null;
        for (const [n, s] of a) {
          o = new _r(e.registry, e.path, null, e.scope);
          const a = [];
          let l = !1;
          for (let e = 1; e < t.length; e++) {
            const r = t[e],
              i = Array.isArray(n) ? n[e - 1] : n.type,
              s = o.parse(r, 1 + a.length, i);
            if (!s) {
              l = !0;
              break;
            }
            a.push(s);
          }
          if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {
            for (let t = 0; t < a.length; t++) {
              const e = Array.isArray(n) ? n[t] : n.type,
                r = a[t];
              o.concat(t + 1).checkSubtype(e, r.type);
            }
            if (0 === o.errors.length) return new Ye(r, i, s, a);
          }
        }
        if (1 === a.length) e.errors.push(...o.errors);else {
          const r = (a.length ? a : s).map(([t]) => {
              return e = t, Array.isArray(e) ? `(${e.map(ye).join(", ")})` : `(${ye(e.type)}...)`;
              var e;
            }).join(" | "),
            n = [];
          for (let r = 1; r < t.length; r++) {
            const i = e.parse(t[r], 1 + n.length);
            if (!i) return null;
            n.push(ye(i.type));
          }
          e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
        }
        return null;
      }
      static register(t, e) {
        Ye.definitions = e;
        for (const r in e) t[r] = Ye;
      }
    }
    var He = Ye;
    class We {
      constructor(t, e, r) {
        this.type = he, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error("Expected one argument.");
        const r = t[1];
        if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");
        const n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, oe);
        if (!n) return null;
        const i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, oe);
        if (!i) return null;
        let s = null;
        return r.locale && (s = e.parse(r.locale, 1, ae), !s) ? null : new We(n, i, s);
      }
      evaluate(t) {
        return new Te(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
      }
      eachChild(t) {
        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        const t = {};
        return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];
      }
    }
    const Je = 8192;
    function Qe(t, e) {
      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);
    }
    function tr(t, e) {
      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
    }
    function er(t, e) {
      const r = (180 + t[0]) / 360,
        n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,
        i = Math.pow(2, e.z);
      return [Math.round(r * i * Je), Math.round(n * i * Je)];
    }
    function rr(t, e, r) {
      const n = t[0] - e[0],
        i = t[1] - e[1],
        s = t[0] - r[0],
        a = t[1] - r[1];
      return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;
    }
    function nr(t, e) {
      let r = !1;
      for (let a = 0, o = e.length; a < o; a++) {
        const o = e[a];
        for (let e = 0, a = o.length; e < a - 1; e++) {
          if (rr(t, o[e], o[e + 1])) return !1;
          (i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);
        }
      }
      var n, i, s;
      return r;
    }
    function ir(t, e) {
      for (let r = 0; r < e.length; r++) if (nr(t, e[r])) return !0;
      return !1;
    }
    function sr(t, e, r, n) {
      const i = n[0] - r[0],
        s = n[1] - r[1],
        a = (t[0] - r[0]) * s - i * (t[1] - r[1]),
        o = (e[0] - r[0]) * s - i * (e[1] - r[1]);
      return a > 0 && o < 0 || a < 0 && o > 0;
    }
    function ar(t, e, r) {
      for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && sr(n, i, s, a) && sr(s, a, n, i)) return !0;
      var n, i, s, a, o, l;
      return !1;
    }
    function or(t, e) {
      for (let r = 0; r < t.length; ++r) if (!nr(t[r], e)) return !1;
      for (let r = 0; r < t.length - 1; ++r) if (ar(t[r], t[r + 1], e)) return !1;
      return !0;
    }
    function lr(t, e) {
      for (let r = 0; r < e.length; r++) if (or(t, e[r])) return !0;
      return !1;
    }
    function ur(t, e, r) {
      const n = [];
      for (let i = 0; i < t.length; i++) {
        const s = [];
        for (let n = 0; n < t[i].length; n++) {
          const a = er(t[i][n], r);
          Qe(e, a), s.push(a);
        }
        n.push(s);
      }
      return n;
    }
    function cr(t, e, r) {
      const n = [];
      for (let i = 0; i < t.length; i++) {
        const s = ur(t[i], e, r);
        n.push(s);
      }
      return n;
    }
    function hr(t, e, r, n) {
      if (t[0] < r[0] || t[0] > r[2]) {
        const e = .5 * n;
        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;
        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;
      }
      Qe(e, t);
    }
    function pr(t, e, r, n) {
      const i = Math.pow(2, n.z) * Je,
        s = [n.x * Je, n.y * Je],
        a = [];
      if (!t) return a;
      for (const n of t) for (const t of n) {
        const n = [t.x + s[0], t.y + s[1]];
        hr(n, e, r, i), a.push(n);
      }
      return a;
    }
    function fr(t, e, r, n) {
      const i = Math.pow(2, n.z) * Je,
        s = [n.x * Je, n.y * Je],
        a = [];
      if (!t) return a;
      for (const r of t) {
        const t = [];
        for (const n of r) {
          const r = [n.x + s[0], n.y + s[1]];
          Qe(e, r), t.push(r);
        }
        a.push(t);
      }
      if (e[2] - e[0] <= i / 2) {
        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
        for (const t of a) for (const n of t) hr(n, e, r, i);
      }
      var o;
      return a;
    }
    class dr {
      constructor(t, e) {
        this.type = oe, this.geojson = t, this.geometries = e;
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
        if (Pe(t[1])) {
          const e = t[1];
          if ("FeatureCollection" === e.type) for (let t = 0; t < e.features.length; ++t) {
            const r = e.features[t].geometry.type;
            if ("Polygon" === r || "MultiPolygon" === r) return new dr(e, e.features[t].geometry);
          } else if ("Feature" === e.type) {
            const t = e.geometry.type;
            if ("Polygon" === t || "MultiPolygon" === t) return new dr(e, e.geometry);
          } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new dr(e, e);
        }
        return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }
      evaluate(t) {
        if (null != t.geometry() && null != t.canonicalID()) {
          if ("Point" === t.geometryType()) return function (t, e) {
            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
              i = t.canonicalID();
            if (!i) return !1;
            if ("Polygon" === e.type) {
              const s = ur(e.coordinates, n, i),
                a = pr(t.geometry(), r, n, i);
              if (!tr(r, n)) return !1;
              for (const t of a) if (!nr(t, s)) return !1;
            }
            if ("MultiPolygon" === e.type) {
              const s = cr(e.coordinates, n, i),
                a = pr(t.geometry(), r, n, i);
              if (!tr(r, n)) return !1;
              for (const t of a) if (!ir(t, s)) return !1;
            }
            return !0;
          }(t, this.geometries);
          if ("LineString" === t.geometryType()) return function (t, e) {
            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
              i = t.canonicalID();
            if (!i) return !1;
            if ("Polygon" === e.type) {
              const s = ur(e.coordinates, n, i),
                a = fr(t.geometry(), r, n, i);
              if (!tr(r, n)) return !1;
              for (const t of a) if (!or(t, s)) return !1;
            }
            if ("MultiPolygon" === e.type) {
              const s = cr(e.coordinates, n, i),
                a = fr(t.geometry(), r, n, i);
              if (!tr(r, n)) return !1;
              for (const t of a) if (!lr(t, s)) return !1;
            }
            return !0;
          }(t, this.geometries);
        }
        return !1;
      }
      eachChild() {}
      outputDefined() {
        return !0;
      }
      serialize() {
        return ["within", this.geojson];
      }
    }
    var yr = dr;
    function mr(t) {
      if (t instanceof He) {
        if ("get" === t.name && 1 === t.args.length) return !1;
        if ("feature-state" === t.name) return !1;
        if ("has" === t.name && 1 === t.args.length) return !1;
        if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1;
        if (/^filter-/.test(t.name)) return !1;
      }
      if (t instanceof yr) return !1;
      let e = !0;
      return t.eachChild(t => {
        e && !mr(t) && (e = !1);
      }), e;
    }
    function gr(t) {
      if (t instanceof He && "feature-state" === t.name) return !1;
      let e = !0;
      return t.eachChild(t => {
        e && !gr(t) && (e = !1);
      }), e;
    }
    function xr(t, e) {
      if (t instanceof He && e.indexOf(t.name) >= 0) return !1;
      let r = !0;
      return t.eachChild(t => {
        r && !xr(t, e) && (r = !1);
      }), r;
    }
    class vr {
      constructor(t, e) {
        this.type = e.type, this.name = t, this.boundExpression = e;
      }
      static parse(t, e) {
        if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument.");
        const r = t[1];
        return e.scope.has(r) ? new vr(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
      }
      evaluate(t) {
        return this.boundExpression.evaluate(t);
      }
      eachChild() {}
      outputDefined() {
        return !1;
      }
      serialize() {
        return ["var", this.name];
      }
    }
    var br = vr;
    class wr {
      constructor(t, e = [], r, n = new ne(), i = []) {
        this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r;
      }
      parse(t, e, r, n, i = {}) {
        return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);
      }
      _parse(t, e) {
        function r(t, e, r) {
          return "assert" === r ? new $e(e, [t]) : "coerce" === r ? new Xe(e, [t]) : t;
        }
        if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {
          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          const n = t[0];
          if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
          const i = this.registry[n];
          if (i) {
            let n = i.parse(t, this);
            if (!n) return null;
            if (this.expectedType) {
              const t = this.expectedType,
                i = n.type;
              if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== i.kind) {
                if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== i.kind && "string" !== i.kind) {
                  if (this.checkSubtype(t, i)) return null;
                } else n = r(n, t, e.typeAnnotation || "coerce");
              } else n = r(n, t, e.typeAnnotation || "assert");
            }
            if (!(n instanceof Fe) && "resolvedImage" !== n.type.kind && Ar(n)) {
              const t = new Ke();
              try {
                n = new Fe(n.type, n.evaluate(t));
              } catch (t) {
                return this.error(t.message), null;
              }
            }
            return n;
          }
          return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
        }
        return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
      }
      concat(t, e, r) {
        const n = "number" == typeof t ? this.path.concat(t) : this.path,
          i = r ? this.scope.concat(r) : this.scope;
        return new wr(this.registry, n, e || null, i, this.errors);
      }
      error(t, ...e) {
        const r = `${this.key}${e.map(t => `[${t}]`).join("")}`;
        this.errors.push(new ee(r, t));
      }
      checkSubtype(t, e) {
        const r = ge(t, e);
        return r && this.error(r), r;
      }
    }
    var _r = wr;
    function Ar(t) {
      if (t instanceof br) return Ar(t.boundExpression);
      if (t instanceof He && "error" === t.name) return !1;
      if (t instanceof We) return !1;
      if (t instanceof yr) return !1;
      const e = t instanceof Xe || t instanceof $e;
      let r = !0;
      return t.eachChild(t => {
        r = e ? r && Ar(t) : r && t instanceof Fe;
      }), !!r && mr(t) && xr(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
    }
    function Sr(t, e) {
      const r = t.length - 1;
      let n,
        i,
        s = 0,
        a = r,
        o = 0;
      for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {
        if (o === r || e < i) return o;
        s = o + 1;
      } else {
        if (!(n > e)) throw new Re("Input is not a number.");
        a = o - 1;
      }
      return 0;
    }
    class kr {
      constructor(t, e, r) {
        this.type = t, this.input = e, this.labels = [], this.outputs = [];
        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);
      }
      static parse(t, e) {
        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
        if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
        const r = e.parse(t[1], 1, se);
        if (!r) return null;
        const n = [];
        let i = null;
        e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
        for (let r = 1; r < t.length; r += 2) {
          const s = 1 === r ? -1 / 0 : t[r],
            a = t[r + 1],
            o = r,
            l = r + 1;
          if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
          const u = e.parse(a, l, i);
          if (!u) return null;
          i = i || u.type, n.push([s, u]);
        }
        return new kr(i, r, n);
      }
      evaluate(t) {
        const e = this.labels,
          r = this.outputs;
        if (1 === e.length) return r[0].evaluate(t);
        const n = this.input.evaluate(t);
        if (n <= e[0]) return r[0].evaluate(t);
        const i = e.length;
        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Sr(e, n)].evaluate(t);
      }
      eachChild(t) {
        t(this.input);
        for (const e of this.outputs) t(e);
      }
      outputDefined() {
        return this.outputs.every(t => t.outputDefined());
      }
      serialize() {
        const t = ["step", this.input.serialize()];
        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());
        return t;
      }
    }
    var Ir = kr;
    function Mr(t, e, r) {
      return t * (1 - r) + e * r;
    }
    var Tr = Object.freeze({
      __proto__: null,
      number: Mr,
      color: function (t, e, r) {
        return new Me(Mr(t.r, e.r, r), Mr(t.g, e.g, r), Mr(t.b, e.b, r), Mr(t.a, e.a, r));
      },
      array: function (t, e, r) {
        return t.map((t, n) => Mr(t, e[n], r));
      }
    });
    const zr = .95047,
      Br = 1.08883,
      Er = 4 / 29,
      Cr = 6 / 29,
      Pr = 3 * Cr * Cr,
      Dr = Math.PI / 180,
      Vr = 180 / Math.PI;
    function Lr(t) {
      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / Pr + Er;
    }
    function Fr(t) {
      return t > Cr ? t * t * t : Pr * (t - Er);
    }
    function Rr(t) {
      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);
    }
    function jr(t) {
      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
    }
    function Ur(t) {
      const e = jr(t.r),
        r = jr(t.g),
        n = jr(t.b),
        i = Lr((.4124564 * e + .3575761 * r + .1804375 * n) / zr),
        s = Lr((.2126729 * e + .7151522 * r + .072175 * n) / 1);
      return {
        l: 116 * s - 16,
        a: 500 * (i - s),
        b: 200 * (s - Lr((.0193339 * e + .119192 * r + .9503041 * n) / Br)),
        alpha: t.a
      };
    }
    function $r(t) {
      let e = (t.l + 16) / 116,
        r = isNaN(t.a) ? e : e + t.a / 500,
        n = isNaN(t.b) ? e : e - t.b / 200;
      return e = 1 * Fr(e), r = zr * Fr(r), n = Br * Fr(n), new Me(Rr(3.2404542 * r - 1.5371385 * e - .4985314 * n), Rr(-.969266 * r + 1.8760108 * e + .041556 * n), Rr(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);
    }
    function Or(t, e, r) {
      const n = e - t;
      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
    }
    const qr = {
        forward: Ur,
        reverse: $r,
        interpolate: function (t, e, r) {
          return {
            l: Mr(t.l, e.l, r),
            a: Mr(t.a, e.a, r),
            b: Mr(t.b, e.b, r),
            alpha: Mr(t.alpha, e.alpha, r)
          };
        }
      },
      Nr = {
        forward: function (t) {
          const {
              l: e,
              a: r,
              b: n
            } = Ur(t),
            i = Math.atan2(n, r) * Vr;
          return {
            h: i < 0 ? i + 360 : i,
            c: Math.sqrt(r * r + n * n),
            l: e,
            alpha: t.a
          };
        },
        reverse: function (t) {
          const e = t.h * Dr,
            r = t.c;
          return $r({
            l: t.l,
            a: Math.cos(e) * r,
            b: Math.sin(e) * r,
            alpha: t.alpha
          });
        },
        interpolate: function (t, e, r) {
          return {
            h: Or(t.h, e.h, r),
            c: Mr(t.c, e.c, r),
            l: Mr(t.l, e.l, r),
            alpha: Mr(t.alpha, e.alpha, r)
          };
        }
      };
    var Gr = Object.freeze({
      __proto__: null,
      lab: qr,
      hcl: Nr
    });
    class Xr {
      constructor(t, e, r, n, i) {
        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);
      }
      static interpolationFactor(t, e, r, n) {
        let i = 0;
        if ("exponential" === t.name) i = Zr(e, t.base, r, n);else if ("linear" === t.name) i = Zr(e, 1, r, n);else if ("cubic-bezier" === t.name) {
          const s = t.controlPoints;
          i = new p(s[0], s[1], s[2], s[3]).solve(Zr(e, 1, r, n));
        }
        return i;
      }
      static parse(t, e) {
        let [r, n, i, ...s] = t;
        if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);
        if ("linear" === n[0]) n = {
          name: "linear"
        };else if ("exponential" === n[0]) {
          const t = n[1];
          if ("number" != typeof t) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
          n = {
            name: "exponential",
            base: t
          };
        } else {
          if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
          {
            const t = n.slice(1);
            if (4 !== t.length || t.some(t => "number" != typeof t || t < 0 || t > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
            n = {
              name: "cubic-bezier",
              controlPoints: t
            };
          }
        }
        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
        if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
        if (i = e.parse(i, 2, se), !i) return null;
        const a = [];
        let o = null;
        "interpolate-hcl" === r || "interpolate-lab" === r ? o = le : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType);
        for (let t = 0; t < s.length; t += 2) {
          const r = s[t],
            n = s[t + 1],
            i = t + 3,
            l = t + 4;
          if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
          if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
          const u = e.parse(n, l, o);
          if (!u) return null;
          o = o || u.type, a.push([r, u]);
        }
        return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new Xr(o, r, n, i, a) : e.error(`Type ${ye(o)} is not interpolatable.`);
      }
      evaluate(t) {
        const e = this.labels,
          r = this.outputs;
        if (1 === e.length) return r[0].evaluate(t);
        const n = this.input.evaluate(t);
        if (n <= e[0]) return r[0].evaluate(t);
        const i = e.length;
        if (n >= e[i - 1]) return r[i - 1].evaluate(t);
        const s = Sr(e, n),
          a = Xr.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),
          o = r[s].evaluate(t),
          l = r[s + 1].evaluate(t);
        return "interpolate" === this.operator ? Tr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? Nr.reverse(Nr.interpolate(Nr.forward(o), Nr.forward(l), a)) : qr.reverse(qr.interpolate(qr.forward(o), qr.forward(l), a));
      }
      eachChild(t) {
        t(this.input);
        for (const e of this.outputs) t(e);
      }
      outputDefined() {
        return this.outputs.every(t => t.outputDefined());
      }
      serialize() {
        let t;
        t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        const e = [this.operator, t, this.input.serialize()];
        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());
        return e;
      }
    }
    function Zr(t, e, r, n) {
      const i = n - r,
        s = t - r;
      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
    }
    var Kr = Xr;
    class Yr {
      constructor(t, e) {
        this.type = t, this.args = e;
      }
      static parse(t, e) {
        if (t.length < 2) return e.error("Expectected at least one argument.");
        let r = null;
        const n = e.expectedType;
        n && "value" !== n.kind && (r = n);
        const i = [];
        for (const n of t.slice(1)) {
          const t = e.parse(n, 1 + i.length, r, void 0, {
            typeAnnotation: "omit"
          });
          if (!t) return null;
          r = r || t.type, i.push(t);
        }
        const s = n && i.some(t => ge(n, t.type));
        return new Yr(s ? ce : r, i);
      }
      evaluate(t) {
        let e,
          r = null,
          n = 0;
        for (const i of this.args) {
          if (n++, r = i.evaluate(t), r && r instanceof Ee && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
          if (null !== r) break;
        }
        return r;
      }
      eachChild(t) {
        this.args.forEach(t);
      }
      outputDefined() {
        return this.args.every(t => t.outputDefined());
      }
      serialize() {
        const t = ["coalesce"];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }
    }
    var Hr = Yr;
    class Wr {
      constructor(t, e) {
        this.type = e.type, this.bindings = [].concat(t), this.result = e;
      }
      evaluate(t) {
        return this.result.evaluate(t);
      }
      eachChild(t) {
        for (const e of this.bindings) t(e[1]);
        t(this.result);
      }
      static parse(t, e) {
        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
        const r = [];
        for (let n = 1; n < t.length - 1; n += 2) {
          const i = t[n];
          if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);
          if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
          const s = e.parse(t[n + 1], n + 1);
          if (!s) return null;
          r.push([i, s]);
        }
        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);
        return n ? new Wr(r, n) : null;
      }
      outputDefined() {
        return this.result.outputDefined();
      }
      serialize() {
        const t = ["let"];
        for (const [e, r] of this.bindings) t.push(e, r.serialize());
        return t.push(this.result.serialize()), t;
      }
    }
    var Jr = Wr;
    class Qr {
      constructor(t, e, r) {
        this.type = t, this.index = e, this.input = r;
      }
      static parse(t, e) {
        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, se),
          n = e.parse(t[2], 2, de(e.expectedType || ce));
        return r && n ? new Qr(n.type.itemType, r, n) : null;
      }
      evaluate(t) {
        const e = this.index.evaluate(t),
          r = this.input.evaluate(t);
        if (e < 0) throw new Re(`Array index out of bounds: ${e} < 0.`);
        if (e >= r.length) throw new Re(`Array index out of bounds: ${e} > ${r.length - 1}.`);
        if (e !== Math.floor(e)) throw new Re(`Array index must be an integer, but found ${e} instead.`);
        return r[e];
      }
      eachChild(t) {
        t(this.index), t(this.input);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        return ["at", this.index.serialize(), this.input.serialize()];
      }
    }
    var tn = Qr;
    class en {
      constructor(t, e) {
        this.type = oe, this.needle = t, this.haystack = e;
      }
      static parse(t, e) {
        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, ce),
          n = e.parse(t[2], 2, ce);
        return r && n ? xe(r.type, [oe, ae, se, ie, ce]) ? new en(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r.type)} instead`) : null;
      }
      evaluate(t) {
        const e = this.needle.evaluate(t),
          r = this.haystack.evaluate(t);
        if (null == r) return !1;
        if (!ve(e, ["boolean", "string", "number", "null"])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e))} instead.`);
        if (!ve(r, ["string", "array"])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r))} instead.`);
        return r.indexOf(e) >= 0;
      }
      eachChild(t) {
        t(this.needle), t(this.haystack);
      }
      outputDefined() {
        return !0;
      }
      serialize() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      }
    }
    var rn = en;
    class nn {
      constructor(t, e, r) {
        this.type = se, this.needle = t, this.haystack = e, this.fromIndex = r;
      }
      static parse(t, e) {
        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, ce),
          n = e.parse(t[2], 2, ce);
        if (!r || !n) return null;
        if (!xe(r.type, [oe, ae, se, ie, ce])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r.type)} instead`);
        if (4 === t.length) {
          const i = e.parse(t[3], 3, se);
          return i ? new nn(r, n, i) : null;
        }
        return new nn(r, n);
      }
      evaluate(t) {
        const e = this.needle.evaluate(t),
          r = this.haystack.evaluate(t);
        if (!ve(e, ["boolean", "string", "number", "null"])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e))} instead.`);
        if (!ve(r, ["string", "array"])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r))} instead.`);
        if (this.fromIndex) {
          const n = this.fromIndex.evaluate(t);
          return r.indexOf(e, n);
        }
        return r.indexOf(e);
      }
      eachChild(t) {
        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        if (null != this.fromIndex && void 0 !== this.fromIndex) {
          const t = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];
        }
        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      }
    }
    var sn = nn;
    class an {
      constructor(t, e, r, n, i, s) {
        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
      }
      static parse(t, e) {
        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
        if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");
        let r, n;
        e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
        const i = {},
          s = [];
        for (let a = 2; a < t.length - 1; a += 2) {
          let o = t[a];
          const l = t[a + 1];
          Array.isArray(o) || (o = [o]);
          const u = e.concat(a);
          if (0 === o.length) return u.error("Expected at least one branch label.");
          for (const t of o) {
            if ("number" != typeof t && "string" != typeof t) return u.error("Branch labels must be numbers or strings.");
            if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
            if ("number" == typeof t && Math.floor(t) !== t) return u.error("Numeric branch labels must be integer values.");
            if (r) {
              if (u.checkSubtype(r, De(t))) return null;
            } else r = De(t);
            if (void 0 !== i[String(t)]) return u.error("Branch labels must be unique.");
            i[String(t)] = s.length;
          }
          const c = e.parse(l, a, n);
          if (!c) return null;
          n = n || c.type, s.push(c);
        }
        const a = e.parse(t[1], 1, ce);
        if (!a) return null;
        const o = e.parse(t[t.length - 1], t.length - 1, n);
        return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new an(r, n, a, i, s, o) : null;
      }
      evaluate(t) {
        const e = this.input.evaluate(t);
        return (De(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);
      }
      eachChild(t) {
        t(this.input), this.outputs.forEach(t), t(this.otherwise);
      }
      outputDefined() {
        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();
      }
      serialize() {
        const t = ["match", this.input.serialize()],
          e = Object.keys(this.cases).sort(),
          r = [],
          n = {};
        for (const t of e) {
          const e = n[this.cases[t]];
          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);
        }
        const i = t => "number" === this.inputType.kind ? Number(t) : t;
        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());
        return t.push(this.otherwise.serialize()), t;
      }
    }
    var on = an;
    class ln {
      constructor(t, e, r) {
        this.type = t, this.branches = e, this.otherwise = r;
      }
      static parse(t, e) {
        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
        if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");
        let r;
        e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
        const n = [];
        for (let i = 1; i < t.length - 1; i += 2) {
          const s = e.parse(t[i], i, oe);
          if (!s) return null;
          const a = e.parse(t[i + 1], i + 1, r);
          if (!a) return null;
          n.push([s, a]), r = r || a.type;
        }
        const i = e.parse(t[t.length - 1], t.length - 1, r);
        return i ? new ln(r, n, i) : null;
      }
      evaluate(t) {
        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);
        return this.otherwise.evaluate(t);
      }
      eachChild(t) {
        for (const [e, r] of this.branches) t(e), t(r);
        t(this.otherwise);
      }
      outputDefined() {
        return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();
      }
      serialize() {
        const t = ["case"];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }
    }
    var un = ln;
    class cn {
      constructor(t, e, r, n) {
        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;
      }
      static parse(t, e) {
        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, ce),
          n = e.parse(t[2], 2, se);
        if (!r || !n) return null;
        if (!xe(r.type, [de(ce), ae, ce])) return e.error(`Expected first argument to be of type array or string, but found ${ye(r.type)} instead`);
        if (4 === t.length) {
          const i = e.parse(t[3], 3, se);
          return i ? new cn(r.type, r, n, i) : null;
        }
        return new cn(r.type, r, n);
      }
      evaluate(t) {
        const e = this.input.evaluate(t),
          r = this.beginIndex.evaluate(t);
        if (!ve(e, ["string", "array"])) throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e))} instead.`);
        if (this.endIndex) {
          const n = this.endIndex.evaluate(t);
          return e.slice(r, n);
        }
        return e.slice(r);
      }
      eachChild(t) {
        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        if (null != this.endIndex && void 0 !== this.endIndex) {
          const t = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];
        }
        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      }
    }
    var hn = cn;
    function pn(t, e) {
      return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
    }
    function fn(t, e, r, n) {
      return 0 === n.compare(e, r);
    }
    function dn(t, e, r) {
      const n = "==" !== t && "!=" !== t;
      return class i {
        constructor(t, e, r) {
          this.type = oe, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;
        }
        static parse(t, e) {
          if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");
          const r = t[0];
          let s = e.parse(t[1], 1, ce);
          if (!s) return null;
          if (!pn(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${ye(s.type)}'.`);
          let a = e.parse(t[2], 2, ce);
          if (!a) return null;
          if (!pn(r, a.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${ye(a.type)}'.`);
          if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error(`Cannot compare types '${ye(s.type)}' and '${ye(a.type)}'.`);
          n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new $e(a.type, [s]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new $e(s.type, [a])));
          let o = null;
          if (4 === t.length) {
            if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types.");
            if (o = e.parse(t[3], 3, he), !o) return null;
          }
          return new i(s, a, o);
        }
        evaluate(i) {
          const s = this.lhs.evaluate(i),
            a = this.rhs.evaluate(i);
          if (n && this.hasUntypedArgument) {
            const e = De(s),
              r = De(a);
            if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new Re(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
          }
          if (this.collator && !n && this.hasUntypedArgument) {
            const t = De(s),
              r = De(a);
            if ("string" !== t.kind || "string" !== r.kind) return e(i, s, a);
          }
          return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);
        }
        eachChild(t) {
          t(this.lhs), t(this.rhs), this.collator && t(this.collator);
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          const e = [t];
          return this.eachChild(t => {
            e.push(t.serialize());
          }), e;
        }
      };
    }
    const yn = dn("==", function (t, e, r) {
        return e === r;
      }, fn),
      mn = dn("!=", function (t, e, r) {
        return e !== r;
      }, function (t, e, r, n) {
        return !fn(0, e, r, n);
      }),
      gn = dn("<", function (t, e, r) {
        return e < r;
      }, function (t, e, r, n) {
        return n.compare(e, r) < 0;
      }),
      xn = dn(">", function (t, e, r) {
        return e > r;
      }, function (t, e, r, n) {
        return n.compare(e, r) > 0;
      }),
      vn = dn("<=", function (t, e, r) {
        return e <= r;
      }, function (t, e, r, n) {
        return n.compare(e, r) <= 0;
      }),
      bn = dn(">=", function (t, e, r) {
        return e >= r;
      }, function (t, e, r, n) {
        return n.compare(e, r) >= 0;
      });
    class wn {
      constructor(t, e, r, n, i, s) {
        this.type = ae, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;
      }
      static parse(t, e) {
        if (3 !== t.length) return e.error("Expected two arguments.");
        const r = e.parse(t[1], 1, se);
        if (!r) return null;
        const n = t[2];
        if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
        let i = null;
        if (n.locale && (i = e.parse(n.locale, 1, ae), !i)) return null;
        let s = null;
        if (n.currency && (s = e.parse(n.currency, 1, ae), !s)) return null;
        let a = null;
        if (n.unit && (a = e.parse(n.unit, 1, ae), !a)) return null;
        let o = null;
        if (n["min-fraction-digits"] && (o = e.parse(n["min-fraction-digits"], 1, se), !o)) return null;
        let l = null;
        return n["max-fraction-digits"] && (l = e.parse(n["max-fraction-digits"], 1, se), !l) ? null : new wn(r, i, s, a, o, l);
      }
      evaluate(t) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
          style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
          currency: this.currency ? this.currency.evaluate(t) : void 0,
          unit: this.unit ? this.unit.evaluate(t) : void 0,
          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
        }).format(this.number.evaluate(t));
      }
      eachChild(t) {
        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        const t = {};
        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];
      }
    }
    class _n {
      constructor(t) {
        this.type = se, this.input = t;
      }
      static parse(t, e) {
        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1);
        return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${ye(r.type)} instead.`) : new _n(r) : null;
      }
      evaluate(t) {
        const e = this.input.evaluate(t);
        if ("string" == typeof e) return e.length;
        if (Array.isArray(e)) return e.length;
        throw new Re(`Expected value to be of type string or array, but found ${ye(De(e))} instead.`);
      }
      eachChild(t) {
        t(this.input);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        const t = ["length"];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }
    }
    const An = {
      "==": yn,
      "!=": mn,
      ">": xn,
      "<": gn,
      ">=": bn,
      "<=": vn,
      array: $e,
      at: tn,
      boolean: $e,
      case: un,
      coalesce: Hr,
      collator: We,
      format: Oe,
      image: qe,
      in: rn,
      "index-of": sn,
      interpolate: Kr,
      "interpolate-hcl": Kr,
      "interpolate-lab": Kr,
      length: _n,
      let: Jr,
      literal: Fe,
      match: on,
      number: $e,
      "number-format": wn,
      object: $e,
      slice: hn,
      step: Ir,
      string: $e,
      "to-boolean": Xe,
      "to-color": Xe,
      "to-number": Xe,
      "to-string": Xe,
      var: br,
      within: yr
    };
    function Sn(t, [e, r, n, i]) {
      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);
      const s = i ? i.evaluate(t) : 1,
        a = Ce(e, r, n, s);
      if (a) throw new Re(a);
      return new Me(e / 255 * s, r / 255 * s, n / 255 * s, s);
    }
    function kn(t, e) {
      return t in e;
    }
    function In(t, e) {
      const r = e[t];
      return void 0 === r ? null : r;
    }
    function Mn(t) {
      return {
        type: t
      };
    }
    He.register(An, {
      error: [{
        kind: "error"
      }, [ae], (t, [e]) => {
        throw new Re(e.evaluate(t));
      }],
      typeof: [ae, [ce], (t, [e]) => ye(De(e.evaluate(t)))],
      "to-rgba": [de(se, 4), [le], (t, [e]) => e.evaluate(t).toArray()],
      rgb: [le, [se, se, se], Sn],
      rgba: [le, [se, se, se, se], Sn],
      has: {
        type: oe,
        overloads: [[[ae], (t, [e]) => kn(e.evaluate(t), t.properties())], [[ae, ue], (t, [e, r]) => kn(e.evaluate(t), r.evaluate(t))]]
      },
      get: {
        type: ce,
        overloads: [[[ae], (t, [e]) => In(e.evaluate(t), t.properties())], [[ae, ue], (t, [e, r]) => In(e.evaluate(t), r.evaluate(t))]]
      },
      "feature-state": [ce, [ae], (t, [e]) => In(e.evaluate(t), t.featureState || {})],
      properties: [ue, [], t => t.properties()],
      "geometry-type": [ae, [], t => t.geometryType()],
      id: [ce, [], t => t.id()],
      zoom: [se, [], t => t.globals.zoom],
      pitch: [se, [], t => t.globals.pitch || 0],
      "distance-from-center": [se, [], t => t.distanceFromCenter()],
      "heatmap-density": [se, [], t => t.globals.heatmapDensity || 0],
      "line-progress": [se, [], t => t.globals.lineProgress || 0],
      "sky-radial-progress": [se, [], t => t.globals.skyRadialProgress || 0],
      accumulated: [ce, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],
      "+": [se, Mn(se), (t, e) => {
        let r = 0;
        for (const n of e) r += n.evaluate(t);
        return r;
      }],
      "*": [se, Mn(se), (t, e) => {
        let r = 1;
        for (const n of e) r *= n.evaluate(t);
        return r;
      }],
      "-": {
        type: se,
        overloads: [[[se, se], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[se], (t, [e]) => -e.evaluate(t)]]
      },
      "/": [se, [se, se], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],
      "%": [se, [se, se], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],
      ln2: [se, [], () => Math.LN2],
      pi: [se, [], () => Math.PI],
      e: [se, [], () => Math.E],
      "^": [se, [se, se], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],
      sqrt: [se, [se], (t, [e]) => Math.sqrt(e.evaluate(t))],
      log10: [se, [se], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
      ln: [se, [se], (t, [e]) => Math.log(e.evaluate(t))],
      log2: [se, [se], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
      sin: [se, [se], (t, [e]) => Math.sin(e.evaluate(t))],
      cos: [se, [se], (t, [e]) => Math.cos(e.evaluate(t))],
      tan: [se, [se], (t, [e]) => Math.tan(e.evaluate(t))],
      asin: [se, [se], (t, [e]) => Math.asin(e.evaluate(t))],
      acos: [se, [se], (t, [e]) => Math.acos(e.evaluate(t))],
      atan: [se, [se], (t, [e]) => Math.atan(e.evaluate(t))],
      min: [se, Mn(se), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],
      max: [se, Mn(se), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],
      abs: [se, [se], (t, [e]) => Math.abs(e.evaluate(t))],
      round: [se, [se], (t, [e]) => {
        const r = e.evaluate(t);
        return r < 0 ? -Math.round(-r) : Math.round(r);
      }],
      floor: [se, [se], (t, [e]) => Math.floor(e.evaluate(t))],
      ceil: [se, [se], (t, [e]) => Math.ceil(e.evaluate(t))],
      "filter-==": [oe, [ae, ce], (t, [e, r]) => t.properties()[e.value] === r.value],
      "filter-id-==": [oe, [ce], (t, [e]) => t.id() === e.value],
      "filter-type-==": [oe, [ae], (t, [e]) => t.geometryType() === e.value],
      "filter-<": [oe, [ae, ce], (t, [e, r]) => {
        const n = t.properties()[e.value],
          i = r.value;
        return typeof n == typeof i && n < i;
      }],
      "filter-id-<": [oe, [ce], (t, [e]) => {
        const r = t.id(),
          n = e.value;
        return typeof r == typeof n && r < n;
      }],
      "filter->": [oe, [ae, ce], (t, [e, r]) => {
        const n = t.properties()[e.value],
          i = r.value;
        return typeof n == typeof i && n > i;
      }],
      "filter-id->": [oe, [ce], (t, [e]) => {
        const r = t.id(),
          n = e.value;
        return typeof r == typeof n && r > n;
      }],
      "filter-<=": [oe, [ae, ce], (t, [e, r]) => {
        const n = t.properties()[e.value],
          i = r.value;
        return typeof n == typeof i && n <= i;
      }],
      "filter-id-<=": [oe, [ce], (t, [e]) => {
        const r = t.id(),
          n = e.value;
        return typeof r == typeof n && r <= n;
      }],
      "filter->=": [oe, [ae, ce], (t, [e, r]) => {
        const n = t.properties()[e.value],
          i = r.value;
        return typeof n == typeof i && n >= i;
      }],
      "filter-id->=": [oe, [ce], (t, [e]) => {
        const r = t.id(),
          n = e.value;
        return typeof r == typeof n && r >= n;
      }],
      "filter-has": [oe, [ce], (t, [e]) => e.value in t.properties()],
      "filter-has-id": [oe, [], t => null !== t.id() && void 0 !== t.id()],
      "filter-type-in": [oe, [de(ae)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],
      "filter-id-in": [oe, [de(ce)], (t, [e]) => e.value.indexOf(t.id()) >= 0],
      "filter-in-small": [oe, [ae, de(ce)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],
      "filter-in-large": [oe, [ae, de(ce)], (t, [e, r]) => function (t, e, r, n) {
        for (; r <= n;) {
          const i = r + n >> 1;
          if (e[i] === t) return !0;
          e[i] > t ? n = i - 1 : r = i + 1;
        }
        return !1;
      }(t.properties()[e.value], r.value, 0, r.value.length - 1)],
      all: {
        type: oe,
        overloads: [[[oe, oe], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Mn(oe), (t, e) => {
          for (const r of e) if (!r.evaluate(t)) return !1;
          return !0;
        }]]
      },
      any: {
        type: oe,
        overloads: [[[oe, oe], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Mn(oe), (t, e) => {
          for (const r of e) if (r.evaluate(t)) return !0;
          return !1;
        }]]
      },
      "!": [oe, [oe], (t, [e]) => !e.evaluate(t)],
      "is-supported-script": [oe, [ae], (t, [e]) => {
        const r = t.globals && t.globals.isSupportedScript;
        return !r || r(e.evaluate(t));
      }],
      upcase: [ae, [ae], (t, [e]) => e.evaluate(t).toUpperCase()],
      downcase: [ae, [ae], (t, [e]) => e.evaluate(t).toLowerCase()],
      concat: [ae, Mn(ce), (t, e) => e.map(e => Ve(e.evaluate(t))).join("")],
      "resolved-locale": [ae, [he], (t, [e]) => e.evaluate(t).resolvedLocale()]
    });
    var Tn = An;
    function zn(t) {
      return {
        result: "success",
        value: t
      };
    }
    function Bn(t) {
      return {
        result: "error",
        value: t
      };
    }
    function En(t) {
      return "data-driven" === t["property-type"];
    }
    function Cn(t) {
      return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;
    }
    function Pn(t) {
      return !!t.expression && t.expression.interpolated;
    }
    function Dn(t) {
      return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t;
    }
    function Vn(t) {
      return "object" == typeof t && null !== t && !Array.isArray(t);
    }
    function Ln(t) {
      return t;
    }
    function Fn(t, e) {
      const r = "color" === e.type,
        n = t.stops && "object" == typeof t.stops[0][0],
        i = n || !(n || void 0 !== t.property),
        s = t.type || (Pn(e) ? "exponential" : "interval");
      if (r && ((t = Wt({}, t)).stops && (t.stops = t.stops.map(t => [t[0], Me.parse(t[1])])), t.default = Me.parse(t.default ? t.default : e.default)), t.colorSpace && "rgb" !== t.colorSpace && !Gr[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);
      let a, o, l;
      if ("exponential" === s) a = $n;else if ("interval" === s) a = Un;else if ("categorical" === s) {
        a = jn, o = Object.create(null);
        for (const e of t.stops) o[e[0]] = e[1];
        l = typeof t.stops[0][0];
      } else {
        if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
        a = On;
      }
      if (n) {
        const r = {},
          n = [];
        for (let e = 0; e < t.stops.length; e++) {
          const i = t.stops[e],
            s = i[0].zoom;
          void 0 === r[s] && (r[s] = {
            zoom: s,
            type: t.type,
            property: t.property,
            default: t.default,
            stops: []
          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);
        }
        const i = [];
        for (const t of n) i.push([r[t].zoom, Fn(r[t], e)]);
        const s = {
          name: "linear"
        };
        return {
          kind: "composite",
          interpolationType: s,
          interpolationFactor: Kr.interpolationFactor.bind(void 0, s),
          zoomStops: i.map(t => t[0]),
          evaluate: ({
            zoom: r
          }, n) => $n({
            stops: i,
            base: t.base
          }, e, r).evaluate(r, n)
        };
      }
      if (i) {
        const r = "exponential" === s ? {
          name: "exponential",
          base: void 0 !== t.base ? t.base : 1
        } : null;
        return {
          kind: "camera",
          interpolationType: r,
          interpolationFactor: Kr.interpolationFactor.bind(void 0, r),
          zoomStops: t.stops.map(t => t[0]),
          evaluate: ({
            zoom: r
          }) => a(t, e, r, o, l)
        };
      }
      return {
        kind: "source",
        evaluate(r, n) {
          const i = n && n.properties ? n.properties[t.property] : void 0;
          return void 0 === i ? Rn(t.default, e.default) : a(t, e, i, o, l);
        }
      };
    }
    function Rn(t, e, r) {
      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;
    }
    function jn(t, e, r, n, i) {
      return Rn(typeof r === i ? n[r] : void 0, t.default, e.default);
    }
    function Un(t, e, r) {
      if ("number" !== Dn(r)) return Rn(t.default, e.default);
      const n = t.stops.length;
      if (1 === n) return t.stops[0][1];
      if (r <= t.stops[0][0]) return t.stops[0][1];
      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];
      const i = Sr(t.stops.map(t => t[0]), r);
      return t.stops[i][1];
    }
    function $n(t, e, r) {
      const n = void 0 !== t.base ? t.base : 1;
      if ("number" !== Dn(r)) return Rn(t.default, e.default);
      const i = t.stops.length;
      if (1 === i) return t.stops[0][1];
      if (r <= t.stops[0][0]) return t.stops[0][1];
      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];
      const s = Sr(t.stops.map(t => t[0]), r),
        a = function (t, e, r, n) {
          const i = n - r,
            s = t - r;
          return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
        }(r, n, t.stops[s][0], t.stops[s + 1][0]),
        o = t.stops[s][1],
        l = t.stops[s + 1][1];
      let u = Tr[e.type] || Ln;
      if (t.colorSpace && "rgb" !== t.colorSpace) {
        const e = Gr[t.colorSpace];
        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));
      }
      return "function" == typeof o.evaluate ? {
        evaluate(...t) {
          const e = o.evaluate.apply(void 0, t),
            r = l.evaluate.apply(void 0, t);
          if (void 0 !== e && void 0 !== r) return u(e, r, a);
        }
      } : u(o, l, a);
    }
    function On(t, e, r) {
      return "color" === e.type ? r = Me.parse(r) : "formatted" === e.type ? r = Be.fromString(r.toString()) : "resolvedImage" === e.type ? r = Ee.fromString(r.toString()) : Dn(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), Rn(r, t.default, e.default);
    }
    class qn {
      constructor(t, e) {
        this.expression = t, this._warningHistory = {}, this._evaluator = new Ke(), this._defaultValue = e ? function (t) {
          return "color" === t.type && (Vn(t.default) || Array.isArray(t.default)) ? new Me(0, 0, 0, 0) : "color" === t.type ? Me.parse(t.default) || null : void 0 === t.default ? null : t.default;
        }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;
      }
      evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {
        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
      }
      evaluate(t, e, r, n, i, s, a, o) {
        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;
        try {
          const t = this.expression.evaluate(this._evaluator);
          if (null == t || "number" == typeof t && t != t) return this._defaultValue;
          if (this._enumValues && !(t in this._enumValues)) throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(", ")}, but found ${JSON.stringify(t)} instead.`);
          return t;
        } catch (t) {
          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue;
        }
      }
    }
    function Nn(t) {
      return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in Tn;
    }
    function Gn(t, e) {
      const r = new _r(Tn, [], e ? function (t) {
          const e = {
            color: le,
            string: ae,
            number: se,
            enum: ae,
            boolean: oe,
            formatted: pe,
            resolvedImage: fe
          };
          return "array" === t.type ? de(e[t.value] || ce, t.length) : e[t.type];
        }(e) : void 0),
        n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {
          typeAnnotation: "coerce"
        } : void 0);
      return n ? zn(new qn(n, e)) : Bn(r.errors);
    }
    class Xn {
      constructor(t, e) {
        this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !gr(e.expression);
      }
      evaluateWithoutErrorHandling(t, e, r, n, i, s) {
        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
      }
      evaluate(t, e, r, n, i, s) {
        return this._styleExpression.evaluate(t, e, r, n, i, s);
      }
    }
    class Zn {
      constructor(t, e, r, n) {
        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !gr(e.expression), this.interpolationType = n;
      }
      evaluateWithoutErrorHandling(t, e, r, n, i, s) {
        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
      }
      evaluate(t, e, r, n, i, s) {
        return this._styleExpression.evaluate(t, e, r, n, i, s);
      }
      interpolationFactor(t, e, r) {
        return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t, e, r) : 0;
      }
    }
    function Kn(t, e) {
      if ("error" === (t = Gn(t, e)).result) return t;
      const r = t.value.expression,
        n = mr(r);
      if (!n && !En(e)) return Bn([new ee("", "data expressions not supported")]);
      const i = xr(r, ["zoom", "pitch", "distance-from-center"]);
      if (!i && !Cn(e)) return Bn([new ee("", "zoom expressions not supported")]);
      const s = Hn(r);
      return s || i ? s instanceof ee ? Bn([s]) : s instanceof Kr && !Pn(e) ? Bn([new ee("", '"interpolate" expressions cannot be used with this property')]) : zn(s ? new Zn(n ? "camera" : "composite", t.value, s.labels, s instanceof Kr ? s.interpolation : void 0) : new Xn(n ? "constant" : "source", t.value)) : Bn([new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    }
    class Yn {
      constructor(t, e) {
        this._parameters = t, this._specification = e, Wt(this, Fn(this._parameters, this._specification));
      }
      static deserialize(t) {
        return new Yn(t._parameters, t._specification);
      }
      static serialize(t) {
        return {
          _parameters: t._parameters,
          _specification: t._specification
        };
      }
    }
    function Hn(t) {
      let e = null;
      if (t instanceof Jr) e = Hn(t.result);else if (t instanceof Hr) {
        for (const r of t.args) if (e = Hn(r), e) break;
      } else (t instanceof Ir || t instanceof Kr) && t.input instanceof He && "zoom" === t.input.name && (e = t);
      return e instanceof ee || t.eachChild(t => {
        const r = Hn(t);
        r instanceof ee ? e = r : !e && r ? e = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && r && e !== r && (e = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
      }), e;
    }
    class Wn {
      constructor(t, e, r, n) {
        this.message = (t ? `${t}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
      }
    }
    function Jn(t) {
      const e = t.key,
        r = t.value,
        n = t.valueSpec || {},
        i = t.objectElementValidators || {},
        s = t.style,
        a = t.styleSpec;
      let o = [];
      const l = Dn(r);
      if ("object" !== l) return [new Wn(e, r, `object expected, ${l} found`)];
      for (const t in r) {
        const l = t.split(".")[0],
          u = n[l] || n["*"];
        let c;
        i[l] ? c = i[l] : n[l] ? c = Ci : i["*"] ? c = i["*"] : n["*"] && (c = Ci), c ? o = o.concat(c({
          key: (e ? `${e}.` : e) + t,
          value: r[t],
          valueSpec: u,
          style: s,
          styleSpec: a,
          object: r,
          objectKey: t
        }, r)) : o.push(new Wn(e, r[t], `unknown property "${t}"`));
      }
      for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new Wn(e, r, `missing required property "${t}"`));
      return o;
    }
    function Qn(t) {
      const e = t.value,
        r = t.valueSpec,
        n = t.style,
        i = t.styleSpec,
        s = t.key,
        a = t.arrayElementValidator || Ci;
      if ("array" !== Dn(e)) return [new Wn(s, e, `array expected, ${Dn(e)} found`)];
      if (r.length && e.length !== r.length) return [new Wn(s, e, `array length ${r.length} expected, length ${e.length} found`)];
      if (r["min-length"] && e.length < r["min-length"]) return [new Wn(s, e, `array length at least ${r["min-length"]} expected, length ${e.length} found`)];
      let o = {
        type: r.value,
        values: r.values,
        minimum: r.minimum,
        maximum: r.maximum,
        function: void 0
      };
      i.$version < 7 && (o.function = r.function), "object" === Dn(r.value) && (o = r.value);
      let l = [];
      for (let t = 0; t < e.length; t++) l = l.concat(a({
        array: e,
        arrayIndex: t,
        value: e[t],
        valueSpec: o,
        style: n,
        styleSpec: i,
        key: `${s}[${t}]`
      }));
      return l;
    }
    function ti(t) {
      const e = t.key,
        r = t.value,
        n = t.valueSpec;
      let i = Dn(r);
      if ("number" === i && r != r && (i = "NaN"), "number" !== i) return [new Wn(e, r, `number expected, ${i} found`)];
      if ("minimum" in n) {
        let i = n.minimum;
        if ("array" === Dn(n.minimum) && (i = n.minimum[t.arrayIndex]), r < i) return [new Wn(e, r, `${r} is less than the minimum value ${i}`)];
      }
      if ("maximum" in n) {
        let i = n.maximum;
        if ("array" === Dn(n.maximum) && (i = n.maximum[t.arrayIndex]), r > i) return [new Wn(e, r, `${r} is greater than the maximum value ${i}`)];
      }
      return [];
    }
    function ei(t) {
      const e = t.valueSpec,
        r = Jt(t.value.type);
      let n,
        i,
        s,
        a = {};
      const o = "categorical" !== r && void 0 === t.value.property,
        l = !o,
        u = "array" === Dn(t.value.stops) && "array" === Dn(t.value.stops[0]) && "object" === Dn(t.value.stops[0][0]),
        c = Jn({
          key: t.key,
          value: t.value,
          valueSpec: t.styleSpec.function,
          style: t.style,
          styleSpec: t.styleSpec,
          objectElementValidators: {
            stops: function (t) {
              if ("identity" === r) return [new Wn(t.key, t.value, 'identity function may not have a "stops" property')];
              let e = [];
              const n = t.value;
              return e = e.concat(Qn({
                key: t.key,
                value: n,
                valueSpec: t.valueSpec,
                style: t.style,
                styleSpec: t.styleSpec,
                arrayElementValidator: h
              })), "array" === Dn(n) && 0 === n.length && e.push(new Wn(t.key, n, "array must have at least one stop")), e;
            },
            default: function (t) {
              return Ci({
                key: t.key,
                value: t.value,
                valueSpec: e,
                style: t.style,
                styleSpec: t.styleSpec
              });
            }
          }
        });
      return "identity" === r && o && c.push(new Wn(t.key, t.value, 'missing required property "property"')), "identity" === r || t.value.stops || c.push(new Wn(t.key, t.value, 'missing required property "stops"')), "exponential" === r && t.valueSpec.expression && !Pn(t.valueSpec) && c.push(new Wn(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (l && !En(t.valueSpec) ? c.push(new Wn(t.key, t.value, "property functions not supported")) : o && !Cn(t.valueSpec) && c.push(new Wn(t.key, t.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t.value.property || c.push(new Wn(t.key, t.value, '"property" property is required')), c;
      function h(t) {
        let r = [];
        const n = t.value,
          o = t.key;
        if ("array" !== Dn(n)) return [new Wn(o, n, `array expected, ${Dn(n)} found`)];
        if (2 !== n.length) return [new Wn(o, n, `array length 2 expected, length ${n.length} found`)];
        if (u) {
          if ("object" !== Dn(n[0])) return [new Wn(o, n, `object expected, ${Dn(n[0])} found`)];
          if (void 0 === n[0].zoom) return [new Wn(o, n, "object stop key must have zoom")];
          if (void 0 === n[0].value) return [new Wn(o, n, "object stop key must have value")];
          const e = Jt(n[0].zoom);
          if ("number" != typeof e) return [new Wn(o, n[0].zoom, "stop zoom values must be numbers")];
          if (s && s > e) return [new Wn(o, n[0].zoom, "stop zoom values must appear in ascending order")];
          e !== s && (s = e, i = void 0, a = {}), r = r.concat(Jn({
            key: `${o}[0]`,
            value: n[0],
            valueSpec: {
              zoom: {}
            },
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              zoom: ti,
              value: p
            }
          }));
        } else r = r.concat(p({
          key: `${o}[0]`,
          value: n[0],
          valueSpec: {},
          style: t.style,
          styleSpec: t.styleSpec
        }, n));
        return Nn(Qt(n[1])) ? r.concat([new Wn(`${o}[1]`, n[1], "expressions are not allowed in function stops.")]) : r.concat(Ci({
          key: `${o}[1]`,
          value: n[1],
          valueSpec: e,
          style: t.style,
          styleSpec: t.styleSpec
        }));
      }
      function p(t, s) {
        const o = Dn(t.value),
          l = Jt(t.value),
          u = null !== t.value ? t.value : s;
        if (n) {
          if (o !== n) return [new Wn(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)];
        } else n = o;
        if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l) return [new Wn(t.key, u, "stop domain value must be a number, string, or boolean")];
        if ("number" !== o && "categorical" !== r) {
          let n = `number expected, ${o} found`;
          return En(e) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Wn(t.key, u, n)];
        }
        return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof i && void 0 !== i && l < i ? [new Wn(t.key, u, "stop domain values must appear in ascending order")] : (i = l, "categorical" === r && l in a ? [new Wn(t.key, u, "stop domain values must be unique")] : (a[l] = !0, [])) : [new Wn(t.key, u, `integer expected, found ${String(l)}`)];
      }
    }
    function ri(t) {
      const e = ("property" === t.expressionContext ? Kn : Gn)(Qt(t.value), t.valueSpec);
      if ("error" === e.result) return e.value.map(e => new Wn(`${t.key}${e.key}`, t.value, e.message));
      const r = e.value.expression || e.value._styleExpression.expression;
      if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new Wn(t.key, t.value, `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
      if ("property" === t.expressionContext && "layout" === t.propertyType && !gr(r)) return [new Wn(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')];
      if ("filter" === t.expressionContext) return ni(r, t);
      if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
        if (!xr(r, ["zoom", "feature-state"])) return [new Wn(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        if ("cluster-initial" === t.expressionContext && !mr(r)) return [new Wn(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
      }
      return [];
    }
    function ni(t, e) {
      const r = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
      if (e.valueSpec && e.valueSpec.expression) for (const t of e.valueSpec.expression.parameters) r.delete(t);
      if (0 === r.size) return [];
      const n = [];
      return t instanceof He && r.has(t.name) ? [new Wn(e.key, e.value, `["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild(t => {
        n.push(...ni(t, e));
      }), n);
    }
    function ii(t) {
      const e = t.key,
        r = t.value,
        n = t.valueSpec,
        i = [];
      return Array.isArray(n.values) ? -1 === n.values.indexOf(Jt(r)) && i.push(new Wn(e, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(Jt(r)) && i.push(new Wn(e, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i;
    }
    function si(t) {
      if (!0 === t || !1 === t) return !0;
      if (!Array.isArray(t) || 0 === t.length) return !1;
      switch (t[0]) {
        case "has":
          return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];
        case "in":
          return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));
        case "!in":
        case "!has":
        case "none":
          return !1;
        case "==":
        case "!=":
        case ">":
        case ">=":
        case "<":
        case "<=":
          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
        case "any":
        case "all":
          for (const e of t.slice(1)) if (!si(e) && "boolean" != typeof e) return !1;
          return !0;
        default:
          return !0;
      }
    }
    function ai(t, e = "fill") {
      if (null == t) return {
        filter: () => !0,
        needGeometry: !1,
        needFeature: !1
      };
      si(t) || (t = fi(t));
      const r = t;
      let n = !0;
      try {
        n = function (t) {
          if (!ui(t)) return t;
          let e = Qt(t);
          return li(e), e = oi(e), e;
        }(r);
      } catch (t) {
        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
      }
      const i = Ht[`filter_${e}`],
        s = Gn(n, i);
      let a = null;
      if ("error" === s.result) throw new Error(s.value.map(t => `${t.key}: ${t.message}`).join(", "));
      a = (t, e, r) => s.value.evaluate(t, e, {}, r);
      let o = null,
        l = null;
      if (n !== r) {
        const t = Gn(r, i);
        if ("error" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(", "));
        o = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), l = !mr(t.value.expression);
      }
      return {
        filter: a,
        dynamicFilter: o || void 0,
        needGeometry: pi(n),
        needFeature: !!l
      };
    }
    function oi(t) {
      if (!Array.isArray(t)) return t;
      const e = function (t) {
        if (ci.has(t[0])) for (let e = 1; e < t.length; e++) if (ui(t[e])) return !0;
        return t;
      }(t);
      return !0 === e ? e : e.map(t => oi(t));
    }
    function li(t) {
      let e = !1;
      const r = [];
      if ("case" === t[0]) {
        for (let n = 1; n < t.length - 1; n += 2) e = e || ui(t[n]), r.push(t[n + 1]);
        r.push(t[t.length - 1]);
      } else if ("match" === t[0]) {
        e = e || ui(t[1]);
        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);
        r.push(t[t.length - 1]);
      } else if ("step" === t[0]) {
        e = e || ui(t[1]);
        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);
      }
      e && (t.length = 0, t.push("any", ...r));
      for (let e = 1; e < t.length; e++) li(t[e]);
    }
    function ui(t) {
      if (!Array.isArray(t)) return !1;
      if ("pitch" === (e = t[0]) || "distance-from-center" === e) return !0;
      var e;
      for (let e = 1; e < t.length; e++) if (ui(t[e])) return !0;
      return !1;
    }
    const ci = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
    function hi(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }
    function pi(t) {
      if (!Array.isArray(t)) return !1;
      if ("within" === t[0]) return !0;
      for (let e = 1; e < t.length; e++) if (pi(t[e])) return !0;
      return !1;
    }
    function fi(t) {
      if (!t) return !0;
      const e = t[0];
      return t.length <= 1 ? "any" !== e : "==" === e ? di(t[1], t[2], "==") : "!=" === e ? gi(di(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? di(t[1], t[2], e) : "any" === e ? (r = t.slice(1), ["any"].concat(r.map(fi))) : "all" === e ? ["all"].concat(t.slice(1).map(fi)) : "none" === e ? ["all"].concat(t.slice(1).map(fi).map(gi)) : "in" === e ? yi(t[1], t.slice(2)) : "!in" === e ? gi(yi(t[1], t.slice(2))) : "has" === e ? mi(t[1]) : "!has" === e ? gi(mi(t[1])) : "within" !== e || t;
      var r;
    }
    function di(t, e, r) {
      switch (t) {
        case "$type":
          return [`filter-type-${r}`, e];
        case "$id":
          return [`filter-id-${r}`, e];
        default:
          return [`filter-${r}`, t, e];
      }
    }
    function yi(t, e) {
      if (0 === e.length) return !1;
      switch (t) {
        case "$type":
          return ["filter-type-in", ["literal", e]];
        case "$id":
          return ["filter-id-in", ["literal", e]];
        default:
          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? ["filter-in-large", t, ["literal", e.sort(hi)]] : ["filter-in-small", t, ["literal", e]];
      }
    }
    function mi(t) {
      switch (t) {
        case "$type":
          return !0;
        case "$id":
          return ["filter-has-id"];
        default:
          return ["filter-has", t];
      }
    }
    function gi(t) {
      return ["!", t];
    }
    function xi(t) {
      return si(Qt(t.value)) ? ri(Wt({}, t, {
        expressionContext: "filter",
        valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`]
      })) : vi(t);
    }
    function vi(t) {
      const e = t.value,
        r = t.key;
      if ("array" !== Dn(e)) return [new Wn(r, e, `array expected, ${Dn(e)} found`)];
      const n = t.styleSpec;
      let i,
        s = [];
      if (e.length < 1) return [new Wn(r, e, "filter array must have at least 1 element")];
      switch (s = s.concat(ii({
        key: `${r}[0]`,
        value: e[0],
        valueSpec: n.filter_operator,
        style: t.style,
        styleSpec: t.styleSpec
      })), Jt(e[0])) {
        case "<":
        case "<=":
        case ">":
        case ">=":
          e.length >= 2 && "$type" === Jt(e[1]) && s.push(new Wn(r, e, `"$type" cannot be use with operator "${e[0]}"`));
        case "==":
        case "!=":
          3 !== e.length && s.push(new Wn(r, e, `filter array for operator "${e[0]}" must have 3 elements`));
        case "in":
        case "!in":
          e.length >= 2 && (i = Dn(e[1]), "string" !== i && s.push(new Wn(`${r}[1]`, e[1], `string expected, ${i} found`)));
          for (let a = 2; a < e.length; a++) i = Dn(e[a]), "$type" === Jt(e[1]) ? s = s.concat(ii({
            key: `${r}[${a}]`,
            value: e[a],
            valueSpec: n.geometry_type,
            style: t.style,
            styleSpec: t.styleSpec
          })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new Wn(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));
          break;
        case "any":
        case "all":
        case "none":
          for (let n = 1; n < e.length; n++) s = s.concat(vi({
            key: `${r}[${n}]`,
            value: e[n],
            style: t.style,
            styleSpec: t.styleSpec
          }));
          break;
        case "has":
        case "!has":
          i = Dn(e[1]), 2 !== e.length ? s.push(new Wn(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new Wn(`${r}[1]`, e[1], `string expected, ${i} found`));
          break;
        case "within":
          i = Dn(e[1]), 2 !== e.length ? s.push(new Wn(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "object" !== i && s.push(new Wn(`${r}[1]`, e[1], `object expected, ${i} found`));
      }
      return s;
    }
    function bi(t, e) {
      const r = t.key,
        n = t.style,
        i = t.styleSpec,
        s = t.value,
        a = t.objectKey,
        o = i[`${e}_${t.layerType}`];
      if (!o) return [];
      const l = a.match(/^(.*)-transition$/);
      if ("paint" === e && l && o[l[1]] && o[l[1]].transition) return Ci({
        key: r,
        value: s,
        valueSpec: i.transition,
        style: n,
        styleSpec: i
      });
      const u = t.valueSpec || o[a];
      if (!u) return [new Wn(r, s, `unknown property "${a}"`)];
      let c;
      if ("string" === Dn(s) && En(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [new Wn(r, s, `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c[1])} }\`.`)];
      const h = [];
      return "symbol" === t.layerType && ("text-field" === a && n && !n.glyphs && h.push(new Wn(r, s, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Vn(Qt(s)) && "identity" === Jt(s.type) && h.push(new Wn(r, s, '"text-font" does not support identity functions'))), h.concat(Ci({
        key: t.key,
        value: s,
        valueSpec: u,
        style: n,
        styleSpec: i,
        expressionContext: "property",
        propertyType: e,
        propertyKey: a
      }));
    }
    function wi(t) {
      return bi(t, "paint");
    }
    function _i(t) {
      return bi(t, "layout");
    }
    function Ai(t) {
      let e = [];
      const r = t.value,
        n = t.key,
        i = t.style,
        s = t.styleSpec;
      r.type || r.ref || e.push(new Wn(n, r, 'either "type" or "ref" is required'));
      let a = Jt(r.type);
      const o = Jt(r.ref);
      if (r.id) {
        const s = Jt(r.id);
        for (let a = 0; a < t.arrayIndex; a++) {
          const t = i.layers[a];
          Jt(t.id) === s && e.push(new Wn(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t.id.__line__}`));
        }
      }
      if ("ref" in r) {
        let t;
        ["type", "source", "source-layer", "filter", "layout"].forEach(t => {
          t in r && e.push(new Wn(n, r[t], `"${t}" is prohibited for ref layers`));
        }), i.layers.forEach(e => {
          Jt(e.id) === o && (t = e);
        }), t ? t.ref ? e.push(new Wn(n, r.ref, "ref cannot reference another ref layer")) : a = Jt(t.type) : "string" == typeof o && e.push(new Wn(n, r.ref, `ref layer "${o}" not found`));
      } else if ("background" !== a && "sky" !== a) if (r.source) {
        const t = i.sources && i.sources[r.source],
          s = t && Jt(t.type);
        t ? "vector" === s && "raster" === a ? e.push(new Wn(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === s && "raster" !== a ? e.push(new Wn(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e.push(new Wn(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] && !r.paint["line-trim-offset"] || "geojson" === s && t.lineMetrics || e.push(new Wn(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new Wn(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new Wn(n, r.source, `source "${r.source}" not found`));
      } else e.push(new Wn(n, r, 'missing required property "source"'));
      return e = e.concat(Jn({
        key: n,
        value: r,
        valueSpec: s.layer,
        style: t.style,
        styleSpec: t.styleSpec,
        objectElementValidators: {
          "*": () => [],
          type: () => Ci({
            key: `${n}.type`,
            value: r.type,
            valueSpec: s.layer.type,
            style: t.style,
            styleSpec: t.styleSpec,
            object: r,
            objectKey: "type"
          }),
          filter: t => xi(Wt({
            layerType: a
          }, t)),
          layout: t => Jn({
            layer: r,
            key: t.key,
            value: t.value,
            valueSpec: {},
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              "*": t => _i(Wt({
                layerType: a
              }, t))
            }
          }),
          paint: t => Jn({
            layer: r,
            key: t.key,
            value: t.value,
            valueSpec: {},
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              "*": t => wi(Wt({
                layerType: a
              }, t))
            }
          })
        }
      })), e;
    }
    function Si(t) {
      const e = t.value,
        r = t.key,
        n = Dn(e);
      return "string" !== n ? [new Wn(r, e, `string expected, ${n} found`)] : [];
    }
    const ki = {
      promoteId: function ({
        key: t,
        value: e
      }) {
        if ("string" === Dn(e)) return Si({
          key: t,
          value: e
        });
        {
          const r = [];
          for (const n in e) r.push(...Si({
            key: `${t}.${n}`,
            value: e[n]
          }));
          return r;
        }
      }
    };
    function Ii(t) {
      const e = t.value,
        r = t.key,
        n = t.styleSpec,
        i = t.style;
      if (!e.type) return [new Wn(r, e, '"type" is required')];
      const s = Jt(e.type);
      let a;
      switch (s) {
        case "vector":
        case "raster":
        case "raster-dem":
          return a = Jn({
            key: r,
            value: e,
            valueSpec: n[`source_${s.replace("-", "_")}`],
            style: t.style,
            styleSpec: n,
            objectElementValidators: ki
          }), a;
        case "geojson":
          if (a = Jn({
            key: r,
            value: e,
            valueSpec: n.source_geojson,
            style: i,
            styleSpec: n,
            objectElementValidators: ki
          }), e.cluster) for (const t in e.clusterProperties) {
            const [n, i] = e.clusterProperties[t],
              s = "string" == typeof n ? [n, ["accumulated"], ["get", t]] : n;
            a.push(...ri({
              key: `${r}.${t}.map`,
              value: i,
              expressionContext: "cluster-map"
            })), a.push(...ri({
              key: `${r}.${t}.reduce`,
              value: s,
              expressionContext: "cluster-reduce"
            }));
          }
          return a;
        case "video":
          return Jn({
            key: r,
            value: e,
            valueSpec: n.source_video,
            style: i,
            styleSpec: n
          });
        case "image":
          return Jn({
            key: r,
            value: e,
            valueSpec: n.source_image,
            style: i,
            styleSpec: n
          });
        case "canvas":
          return [new Wn(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
        default:
          return ii({
            key: `${r}.type`,
            value: e.type,
            valueSpec: {
              values: Mi(n)
            },
            style: i,
            styleSpec: n
          });
      }
    }
    function Mi(t) {
      return t.source.reduce((e, r) => {
        const n = t[r];
        return "enum" === n.type.type && (e = e.concat(Object.keys(n.type.values))), e;
      }, []);
    }
    function Ti(t) {
      const e = t.value,
        r = t.styleSpec,
        n = r.light,
        i = t.style;
      let s = [];
      const a = Dn(e);
      if (void 0 === e) return s;
      if ("object" !== a) return s = s.concat([new Wn("light", e, `object expected, ${a} found`)]), s;
      for (const t in e) {
        const a = t.match(/^(.*)-transition$/);
        s = s.concat(a && n[a[1]] && n[a[1]].transition ? Ci({
          key: t,
          value: e[t],
          valueSpec: r.transition,
          style: i,
          styleSpec: r
        }) : n[t] ? Ci({
          key: t,
          value: e[t],
          valueSpec: n[t],
          style: i,
          styleSpec: r
        }) : [new Wn(t, e[t], `unknown property "${t}"`)]);
      }
      return s;
    }
    function zi(t) {
      const e = t.value,
        r = t.key,
        n = t.style,
        i = t.styleSpec,
        s = i.terrain;
      let a = [];
      const o = Dn(e);
      if (void 0 === e) return a;
      if ("object" !== o) return a = a.concat([new Wn("terrain", e, `object expected, ${o} found`)]), a;
      for (const t in e) {
        const r = t.match(/^(.*)-transition$/);
        a = a.concat(r && s[r[1]] && s[r[1]].transition ? Ci({
          key: t,
          value: e[t],
          valueSpec: i.transition,
          style: n,
          styleSpec: i
        }) : s[t] ? Ci({
          key: t,
          value: e[t],
          valueSpec: s[t],
          style: n,
          styleSpec: i
        }) : [new Wn(t, e[t], `unknown property "${t}"`)]);
      }
      if (e.source) {
        const t = n.sources && n.sources[e.source],
          i = t && Jt(t.type);
        t ? "raster-dem" !== i && a.push(new Wn(r, e.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : a.push(new Wn(r, e.source, `source "${e.source}" not found`));
      } else a.push(new Wn(r, e, 'terrain is missing required property "source"'));
      return a;
    }
    function Bi(t) {
      const e = t.value,
        r = t.style,
        n = t.styleSpec,
        i = n.fog;
      let s = [];
      const a = Dn(e);
      if (void 0 === e) return s;
      if ("object" !== a) return s = s.concat([new Wn("fog", e, `object expected, ${a} found`)]), s;
      for (const t in e) {
        const a = t.match(/^(.*)-transition$/);
        s = s.concat(a && i[a[1]] && i[a[1]].transition ? Ci({
          key: t,
          value: e[t],
          valueSpec: n.transition,
          style: r,
          styleSpec: n
        }) : i[t] ? Ci({
          key: t,
          value: e[t],
          valueSpec: i[t],
          style: r,
          styleSpec: n
        }) : [new Wn(t, e[t], `unknown property "${t}"`)]);
      }
      return s;
    }
    const Ei = {
      "*": () => [],
      array: Qn,
      boolean: function (t) {
        const e = t.value,
          r = t.key,
          n = Dn(e);
        return "boolean" !== n ? [new Wn(r, e, `boolean expected, ${n} found`)] : [];
      },
      number: ti,
      color: function (t) {
        const e = t.key,
          r = t.value,
          n = Dn(r);
        return "string" !== n ? [new Wn(e, r, `color expected, ${n} found`)] : null === be(r) ? [new Wn(e, r, `color expected, "${r}" found`)] : [];
      },
      enum: ii,
      filter: xi,
      function: ei,
      layer: Ai,
      object: Jn,
      source: Ii,
      light: Ti,
      terrain: zi,
      fog: Bi,
      string: Si,
      formatted: function (t) {
        return 0 === Si(t).length ? [] : ri(t);
      },
      resolvedImage: function (t) {
        return 0 === Si(t).length ? [] : ri(t);
      },
      projection: function (t) {
        const e = t.value,
          r = t.styleSpec,
          n = r.projection,
          i = t.style;
        let s = [];
        const a = Dn(e);
        if ("object" === a) for (const t in e) s = s.concat(Ci({
          key: t,
          value: e[t],
          valueSpec: n[t],
          style: i,
          styleSpec: r
        }));else "string" !== a && (s = s.concat([new Wn("projection", e, `object or string expected, ${a} found`)]));
        return s;
      }
    };
    function Ci(t) {
      const e = t.value,
        r = t.valueSpec,
        n = t.styleSpec;
      return r.expression && Vn(Jt(e)) ? ei(t) : r.expression && Nn(Qt(e)) ? ri(t) : r.type && Ei[r.type] ? Ei[r.type](t) : Jn(Wt({}, t, {
        valueSpec: r.type ? n[r.type] : r
      }));
    }
    function Pi(t) {
      const e = t.value,
        r = t.key,
        n = Si(t);
      return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new Wn(r, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && n.push(new Wn(r, e, '"glyphs" url must include a "{range}" token'))), n;
    }
    function Di(t, e = Ht) {
      return Fi(Ci({
        key: "",
        value: t,
        valueSpec: e.$root,
        styleSpec: e,
        style: t,
        objectElementValidators: {
          glyphs: Pi,
          "*": () => []
        }
      }));
    }
    const Vi = t => Fi(wi(t)),
      Li = t => Fi(_i(t));
    function Fi(t) {
      return t.slice().sort((t, e) => t.line && e.line ? t.line - e.line : 0);
    }
    function Ri(t, e) {
      let r = !1;
      if (e && e.length) for (const n of e) t.fire(new Kt(new Error(n.message))), r = !0;
      return r;
    }
    var ji = Ui;
    function Ui(t, e, r) {
      var n = this.cells = [];
      if (t instanceof ArrayBuffer) {
        this.arrayBuffer = t;
        var i = new Int32Array(this.arrayBuffer);
        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);
        for (var s = 0; s < this.d * this.d; s++) {
          var a = i[3 + s],
            o = i[3 + s + 1];
          n.push(a === o ? null : i.subarray(a, o));
        }
        var l = i[3 + n.length + 1];
        this.keys = i.subarray(i[3 + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
      } else {
        this.d = e + 2 * r;
        for (var u = 0; u < this.d * this.d; u++) n.push([]);
        this.keys = [], this.bboxes = [];
      }
      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;
      var c = r / e * t;
      this.min = -c, this.max = t + c;
    }
    Ui.prototype.insert = function (t, e, r, n, i) {
      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
    }, Ui.prototype._insertReadonly = function () {
      throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
    }, Ui.prototype._insertCell = function (t, e, r, n, i, s) {
      this.cells[i].push(s);
    }, Ui.prototype.query = function (t, e, r, n, i) {
      var s = this.min,
        a = this.max;
      if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);
      var o = [];
      return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;
    }, Ui.prototype._queryCell = function (t, e, r, n, i, s, a, o) {
      var l = this.cells[i];
      if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {
        var p = l[h];
        if (void 0 === a[p]) {
          var f = 4 * p;
          (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
        }
      }
    }, Ui.prototype._forEachCell = function (t, e, r, n, i, s, a, o) {
      for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {
        var d = this.d * f + p;
        if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, a, o)) return;
      }
    }, Ui.prototype._convertFromCellCoord = function (t) {
      return (t - this.padding) / this.scale;
    }, Ui.prototype._convertToCellCoord = function (t) {
      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
    }, Ui.prototype.toArrayBuffer = function () {
      if (this.arrayBuffer) return this.arrayBuffer;
      for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;
      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);
      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
      for (var s = e, a = 0; a < t.length; a++) {
        var o = t[a];
        i[3 + a] = s, i.set(o, s), s += o.length;
      }
      return i[3 + t.length] = s, i.set(this.keys, s), i[3 + t.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;
    };
    const $i = {};
    function Oi(t, e, r = {}) {
      Object.defineProperty(t, "_classRegistryKey", {
        value: e,
        writeable: !1
      }), $i[e] = {
        klass: t,
        omit: r.omit || []
      };
    }
    Oi(Object, "Object"), ji.serialize = function (t, e) {
      const r = t.toArrayBuffer();
      return e && e.push(r), {
        buffer: r
      };
    }, ji.deserialize = function (t) {
      return new ji(t.buffer);
    }, Object.defineProperty(ji, "name", {
      value: "Grid"
    }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", {
      omit: ["_evaluator"]
    }), Oi(Zn, "ZoomDependentExpression"), Oi(Xn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", {
      omit: ["_evaluate"]
    });
    for (const t in Tn) $i[Tn[t]._classRegistryKey] || Oi(Tn[t], `Expression${t}`);
    function qi(t) {
      return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name);
    }
    function Ni(t) {
      return e.ImageBitmap && t instanceof e.ImageBitmap;
    }
    function Gi(t, r) {
      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;
      if (qi(t) || Ni(t)) return r && r.push(t), t;
      if (ArrayBuffer.isView(t)) {
        const e = t;
        return r && r.push(e.buffer), e;
      }
      if (t instanceof e.ImageData) return r && r.push(t.data.buffer), t;
      if (Array.isArray(t)) {
        const e = [];
        for (const n of t) e.push(Gi(n, r));
        return e;
      }
      if ("object" == typeof t) {
        const e = t.constructor,
          n = e._classRegistryKey;
        if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);
        const i = e.serialize ? e.serialize(t, r) : {};
        if (!e.serialize) {
          for (const e in t) t.hasOwnProperty(e) && ($i[n].omit.indexOf(e) >= 0 || (i[e] = Gi(t[e], r)));
          t instanceof Error && (i.message = t.message);
        }
        if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return "Object" !== n && (i.$name = n), i;
      }
      throw new Error("can't serialize object of type " + typeof t);
    }
    function Xi(t) {
      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || qi(t) || Ni(t) || ArrayBuffer.isView(t) || t instanceof e.ImageData) return t;
      if (Array.isArray(t)) return t.map(Xi);
      if ("object" == typeof t) {
        const e = t.$name || "Object",
          {
            klass: r
          } = $i[e];
        if (!r) throw new Error(`can't deserialize unregistered class ${e}`);
        if (r.deserialize) return r.deserialize(t);
        const n = Object.create(r.prototype);
        for (const e of Object.keys(t)) "$name" !== e && (n[e] = Xi(t[e]));
        return n;
      }
      throw new Error("can't deserialize object of type " + typeof t);
    }
    const Zi = t => t >= 1536 && t <= 1791,
      Ki = t => t >= 1872 && t <= 1919,
      Yi = t => t >= 2208 && t <= 2303,
      Hi = t => t >= 11904 && t <= 12031,
      Wi = t => t >= 12032 && t <= 12255,
      Ji = t => t >= 12272 && t <= 12287,
      Qi = t => t >= 12288 && t <= 12351,
      ts = t => t >= 12352 && t <= 12447,
      es = t => t >= 12448 && t <= 12543,
      rs = t => t >= 12544 && t <= 12591,
      ns = t => t >= 12704 && t <= 12735,
      is = t => t >= 12736 && t <= 12783,
      ss = t => t >= 12784 && t <= 12799,
      as = t => t >= 12800 && t <= 13055,
      os = t => t >= 13056 && t <= 13311,
      ls = t => t >= 13312 && t <= 19903,
      us = t => t >= 19968 && t <= 40959,
      cs = t => t >= 40960 && t <= 42127,
      hs = t => t >= 42128 && t <= 42191,
      ps = t => t >= 44032 && t <= 55215,
      fs = t => t >= 63744 && t <= 64255,
      ds = t => t >= 64336 && t <= 65023,
      ys = t => t >= 65040 && t <= 65055,
      ms = t => t >= 65072 && t <= 65103,
      gs = t => t >= 65104 && t <= 65135,
      xs = t => t >= 65136 && t <= 65279,
      vs = t => t >= 65280 && t <= 65519;
    function bs(t) {
      for (const e of t) if (As(e.charCodeAt(0))) return !0;
      return !1;
    }
    function ws(t) {
      for (const e of t) if (!_s(e.charCodeAt(0))) return !1;
      return !0;
    }
    function _s(t) {
      return !(Zi(t) || Ki(t) || Yi(t) || ds(t) || xs(t));
    }
    function As(t) {
      return !(746 !== t && 747 !== t && (t < 4352 || !(ns(t) || rs(t) || ms(t) && !(t >= 65097 && t <= 65103) || fs(t) || os(t) || Hi(t) || is(t) || !(!Qi(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || ls(t) || us(t) || as(t) || (t => t >= 12592 && t <= 12687)(t) || (t => t >= 43360 && t <= 43391)(t) || (t => t >= 55216 && t <= 55295)(t) || (t => t >= 4352 && t <= 4607)(t) || ps(t) || ts(t) || Ji(t) || (t => t >= 12688 && t <= 12703)(t) || Wi(t) || ss(t) || es(t) && 12540 !== t || !(!vs(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!gs(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t => t >= 5120 && t <= 5759)(t) || (t => t >= 6320 && t <= 6399)(t) || ys(t) || (t => t >= 19904 && t <= 19967)(t) || cs(t) || hs(t))));
    }
    function Ss(t) {
      return !(As(t) || function (t) {
        return !!((t => t >= 128 && t <= 255)(t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || (t => t >= 8192 && t <= 8303)(t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || (t => t >= 8448 && t <= 8527)(t) || (t => t >= 8528 && t <= 8591)(t) || (t => t >= 8960 && t <= 9215)(t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || (t => t >= 9216 && t <= 9279)(t) && 9251 !== t || (t => t >= 9280 && t <= 9311)(t) || (t => t >= 9312 && t <= 9471)(t) || (t => t >= 9632 && t <= 9727)(t) || (t => t >= 9728 && t <= 9983)(t) && !(t >= 9754 && t <= 9759) || (t => t >= 11008 && t <= 11263)(t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Qi(t) || es(t) || (t => t >= 57344 && t <= 63743)(t) || ms(t) || gs(t) || vs(t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);
      }(t));
    }
    function ks(t) {
      return t >= 1424 && t <= 2303 || ds(t) || xs(t);
    }
    function Is(t, e) {
      return !(!e && ks(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (t => t >= 6016 && t <= 6143)(t));
    }
    function Ms(t) {
      for (const e of t) if (ks(e.charCodeAt(0))) return !0;
      return !1;
    }
    const Ts = "deferred",
      zs = "loading",
      Bs = "loaded";
    let Es = null,
      Cs = "unavailable",
      Ps = null;
    const Ds = function (t) {
      t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t);
    };
    function Vs() {
      Ls.fire(new Zt("pluginStateChange", {
        pluginStatus: Cs,
        pluginURL: Ps
      }));
    }
    const Ls = new Yt(),
      Fs = function () {
        return Cs;
      },
      Rs = function () {
        if (Cs !== Ts || !Ps) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Cs = zs, Vs(), Ps && ut({
          url: Ps
        }, t => {
          t ? Ds(t) : (Cs = Bs, Vs());
        });
      },
      js = {
        applyArabicShaping: null,
        processBidirectionalText: null,
        processStyledBidirectionalText: null,
        isLoaded: () => Cs === Bs || null != js.applyArabicShaping,
        isLoading: () => Cs === zs,
        setState(t) {
          Cs = t.pluginStatus, Ps = t.pluginURL;
        },
        isParsed: () => null != js.applyArabicShaping && null != js.processBidirectionalText && null != js.processStyledBidirectionalText,
        getPluginURL: () => Ps
      };
    class Us {
      constructor(t, e) {
        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
      }
      isSupportedScript(t) {
        return function (t, e) {
          for (const r of t) if (!Is(r.charCodeAt(0), e)) return !1;
          return !0;
        }(t, js.isLoaded());
      }
    }
    class $s {
      constructor(t, e) {
        this.property = t, this.value = e, this.expression = function (t, e) {
          if (Vn(t)) return new Yn(t, e);
          if (Nn(t)) {
            const r = Kn(t, e);
            if ("error" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(", "));
            return r.value;
          }
          {
            let r = t;
            return "string" == typeof t && "color" === e.type && (r = Me.parse(t)), {
              kind: "constant",
              evaluate: () => r
            };
          }
        }(void 0 === e ? t.specification.default : e, t.specification);
      }
      isDataDriven() {
        return "source" === this.expression.kind || "composite" === this.expression.kind;
      }
      possiblyEvaluate(t, e, r) {
        return this.property.possiblyEvaluate(this, t, e, r);
      }
    }
    class Os {
      constructor(t) {
        this.property = t, this.value = new $s(t, void 0);
      }
      transitioned(t, e) {
        return new Ns(this.property, this.value, e, z({}, t.transition, this.transition), t.now);
      }
      untransitioned() {
        return new Ns(this.property, this.value, null, {}, 0);
      }
    }
    class qs {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
      }
      getValue(t) {
        return j(this._values[t].value.value);
      }
      setValue(t, e) {
        this._values.hasOwnProperty(t) || (this._values[t] = new Os(this._values[t].property)), this._values[t].value = new $s(this._values[t].property, null === e ? void 0 : j(e));
      }
      getTransition(t) {
        return j(this._values[t].transition);
      }
      setTransition(t, e) {
        this._values.hasOwnProperty(t) || (this._values[t] = new Os(this._values[t].property)), this._values[t].transition = j(e) || void 0;
      }
      serialize() {
        const t = {};
        for (const e of Object.keys(this._values)) {
          const r = this.getValue(e);
          void 0 !== r && (t[e] = r);
          const n = this.getTransition(e);
          void 0 !== n && (t[`${e}-transition`] = n);
        }
        return t;
      }
      transitioned(t, e) {
        const r = new Gs(this._properties);
        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);
        return r;
      }
      untransitioned() {
        const t = new Gs(this._properties);
        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();
        return t;
      }
    }
    class Ns {
      constructor(t, e, r, n, i) {
        const s = n.delay || 0,
          a = n.duration || 0;
        i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + a, t.specification.transition && (n.delay || n.duration) && (this.prior = r);
      }
      possiblyEvaluate(t, e, r) {
        const n = t.now || 0,
          i = this.value.possiblyEvaluate(t, e, r),
          s = this.prior;
        if (s) {
          if (n > this.end) return this.prior = null, i;
          if (this.value.isDataDriven()) return this.prior = null, i;
          if (n < this.begin) return s.possiblyEvaluate(t, e, r);
          {
            const a = (n - this.begin) / (this.end - this.begin);
            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, w(a));
          }
        }
        return i;
      }
    }
    class Gs {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
      }
      possiblyEvaluate(t, e, r) {
        const n = new Ks(this._properties);
        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);
        return n;
      }
      hasTransition() {
        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
        return !1;
      }
    }
    class Xs {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultPropertyValues);
      }
      getValue(t) {
        return j(this._values[t].value);
      }
      setValue(t, e) {
        this._values[t] = new $s(this._values[t].property, null === e ? void 0 : j(e));
      }
      serialize() {
        const t = {};
        for (const e of Object.keys(this._values)) {
          const r = this.getValue(e);
          void 0 !== r && (t[e] = r);
        }
        return t;
      }
      possiblyEvaluate(t, e, r) {
        const n = new Ks(this._properties);
        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);
        return n;
      }
    }
    class Zs {
      constructor(t, e, r) {
        this.property = t, this.value = e, this.parameters = r;
      }
      isConstant() {
        return "constant" === this.value.kind;
      }
      constantOr(t) {
        return "constant" === this.value.kind ? this.value.value : t;
      }
      evaluate(t, e, r, n) {
        return this.property.evaluate(this.value, this.parameters, t, e, r, n);
      }
    }
    class Ks {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
      }
      get(t) {
        return this._values[t];
      }
    }
    class Ys {
      constructor(t) {
        this.specification = t;
      }
      possiblyEvaluate(t, e) {
        return t.expression.evaluate(e);
      }
      interpolate(t, e, r) {
        const n = Tr[this.specification.type];
        return n ? n(t, e, r) : t;
      }
    }
    class Hs {
      constructor(t, e) {
        this.specification = t, this.overrides = e;
      }
      possiblyEvaluate(t, e, r, n) {
        return new Zs(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? {
          kind: "constant",
          value: t.expression.evaluate(e, null, {}, r, n)
        } : t.expression, e);
      }
      interpolate(t, e, r) {
        if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;
        if (void 0 === t.value.value || void 0 === e.value.value) return new Zs(this, {
          kind: "constant",
          value: void 0
        }, t.parameters);
        const n = Tr[this.specification.type];
        return n ? new Zs(this, {
          kind: "constant",
          value: n(t.value.value, e.value.value, r)
        }, t.parameters) : t;
      }
      evaluate(t, e, r, n, i, s) {
        return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, s);
      }
    }
    class Ws {
      constructor(t) {
        this.specification = t;
      }
      possiblyEvaluate(t, e, r, n) {
        return !!t.expression.evaluate(e, null, {}, r, n);
      }
      interpolate() {
        return !1;
      }
    }
    class Js {
      constructor(t) {
        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
        const e = new Us(0, {});
        for (const r in t) {
          const n = t[r];
          n.specification.overridable && this.overridableProperties.push(r);
          const i = this.defaultPropertyValues[r] = new $s(n, void 0),
            s = this.defaultTransitionablePropertyValues[r] = new Os(n);
          this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
        }
      }
    }
    function Qs(t, e) {
      return 256 * (t = S(Math.floor(t), 0, 255)) + S(Math.floor(e), 0, 255);
    }
    Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");
    const ta = {
      Int8: Int8Array,
      Uint8: Uint8Array,
      Int16: Int16Array,
      Uint16: Uint16Array,
      Int32: Int32Array,
      Uint32: Uint32Array,
      Float32: Float32Array
    };
    class ea {
      constructor(t, e) {
        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }
    }
    class ra {
      constructor() {
        this.isTransferred = !1, this.capacity = -1, this.resize(0);
      }
      static serialize(t, e) {
        return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {
          length: t.length,
          arrayBuffer: t.arrayBuffer
        };
      }
      static deserialize(t) {
        const e = Object.create(this.prototype);
        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;
      }
      _trim() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }
      clear() {
        this.length = 0;
      }
      resize(t) {
        this.reserve(t), this.length = t;
      }
      reserve(t) {
        if (t > this.capacity) {
          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          const e = this.uint8;
          this._refreshViews(), e && this.uint8.set(e);
        }
      }
      _refreshViews() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      }
      destroy() {
        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
      }
    }
    function na(t, e = 1) {
      let r = 0,
        n = 0;
      return {
        members: t.map(t => {
          const i = ta[t.type].BYTES_PER_ELEMENT,
            s = r = ia(r, Math.max(e, i)),
            a = t.components || 1;
          return n = Math.max(n, i), r += i * a, {
            name: t.name,
            type: t.type,
            components: a,
            offset: s
          };
        }),
        size: ia(r, Math.max(n, e)),
        alignment: e
      };
    }
    function ia(t, e) {
      return Math.ceil(t / e) * e;
    }
    class sa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }
      emplaceBack(t, e) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e);
      }
      emplace(t, e, r) {
        const n = 2 * t;
        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;
      }
    }
    sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");
    class aa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, r);
      }
      emplace(t, e, r, n) {
        const i = 3 * t;
        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;
      }
    }
    aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");
    class oa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }
      emplace(t, e, r, n, i) {
        const s = 4 * t;
        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;
      }
    }
    oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");
    class la extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s, a) {
        const o = this.length;
        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
      }
      emplace(t, e, r, n, i, s, a, o) {
        const l = 6 * t,
          u = 12 * t,
          c = 3 * t;
        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t;
      }
    }
    la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");
    class ua extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }
      emplace(t, e, r, n, i) {
        const s = 4 * t;
        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;
      }
    }
    ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");
    class ca extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
      }
      emplace(t, e, r, n, i, s) {
        const a = 6 * t,
          o = 3 * t;
        return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t;
      }
    }
    ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");
    class ha extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }
      emplace(t, e, r, n, i) {
        const s = 4 * t;
        return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t;
      }
    }
    ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");
    class pa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s) {
        const a = this.length;
        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);
      }
      emplace(t, e, r, n, i, s, a) {
        const o = 6 * t;
        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;
      }
    }
    pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");
    class fa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {
        const p = this.length;
        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h);
      }
      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {
        const f = 12 * t;
        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t;
      }
    }
    fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");
    class da extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s) {
        const a = this.length;
        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);
      }
      emplace(t, e, r, n, i, s, a) {
        const o = 10 * t,
          l = 5 * t;
        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t;
      }
    }
    da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");
    class ya extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
      }
      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }
      emplace(t, e) {
        return this.uint32[1 * t + 0] = e, t;
      }
    }
    ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");
    class ma extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {
        const f = this.length;
        return this.resize(f + 1), this.emplace(f, t, e, r, n, i, s, a, o, l, u, c, h, p);
      }
      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
        const d = 20 * t,
          y = 10 * t;
        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[d + 14] = c, this.uint32[y + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t;
      }
    }
    ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");
    class ga extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s, a) {
        const o = this.length;
        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
      }
      emplace(t, e, r, n, i, s, a, o) {
        const l = 8 * t;
        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t;
      }
    }
    ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");
    class xa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
      }
      emplace(t, e, r, n, i, s) {
        const a = 4 * t,
          o = 8 * t;
        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;
      }
    }
    xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");
    class va extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }
      emplace(t, e, r, n, i) {
        const s = 12 * t,
          a = 3 * t;
        return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t;
      }
    }
    va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");
    class ba extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, r);
      }
      emplace(t, e, r, n) {
        const i = 3 * t;
        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;
      }
    }
    ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");
    class wa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, r);
      }
      emplace(t, e, r, n) {
        const i = 3 * t;
        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;
      }
    }
    wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");
    class _a extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {
        const w = this.length;
        return this.resize(w + 1), this.emplace(w, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b);
      }
      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w) {
        const _ = 30 * t,
          A = 15 * t,
          S = 60 * t;
        return this.int16[_ + 0] = e, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = a, this.uint16[_ + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = f, this.float32[A + 10] = d, this.float32[A + 11] = y, this.uint8[S + 48] = m, this.uint8[S + 49] = g, this.uint8[S + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[S + 58] = w, t;
      }
    }
    _a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
    class Aa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z) {
        const B = this.length;
        return this.resize(B + 1), this.emplace(B, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z);
      }
      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z, B) {
        const E = 38 * t,
          C = 19 * t;
        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = f, this.uint16[E + 16] = d, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = w, this.uint16[E + 24] = _, this.uint16[E + 25] = A, this.uint16[E + 26] = S, this.uint16[E + 27] = k, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t;
      }
    }
    Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");
    class Sa extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }
      emplace(t, e) {
        return this.float32[1 * t + 0] = e, t;
      }
    }
    Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");
    class ka extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n, i) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
      }
      emplace(t, e, r, n, i, s) {
        const a = 5 * t;
        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t;
      }
    }
    ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");
    class Ia extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }
      emplace(t, e, r, n, i) {
        const s = 6 * t;
        return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;
      }
    }
    Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");
    class Ma extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t, e) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e);
      }
      emplace(t, e, r) {
        const n = 2 * t;
        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;
      }
    }
    Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");
    class Ta extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }
      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }
      emplace(t, e) {
        return this.uint16[1 * t + 0] = e, t;
      }
    }
    Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");
    class za extends ra {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }
      emplaceBack(t, e) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e);
      }
      emplace(t, e, r) {
        const n = 2 * t;
        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;
      }
    }
    za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");
    class Ba extends ea {
      get projectedAnchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      get projectedAnchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      get projectedAnchorZ() {
        return this._structArray.int16[this._pos2 + 2];
      }
      get tileAnchorX() {
        return this._structArray.int16[this._pos2 + 3];
      }
      get tileAnchorY() {
        return this._structArray.int16[this._pos2 + 4];
      }
      get x1() {
        return this._structArray.float32[this._pos4 + 3];
      }
      get y1() {
        return this._structArray.float32[this._pos4 + 4];
      }
      get x2() {
        return this._structArray.float32[this._pos4 + 5];
      }
      get y2() {
        return this._structArray.float32[this._pos4 + 6];
      }
      get padding() {
        return this._structArray.int16[this._pos2 + 14];
      }
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 8];
      }
      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 18];
      }
      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 19];
      }
    }
    Ba.prototype.size = 40;
    class Ea extends ma {
      get(t) {
        return new Ba(this, t);
      }
    }
    Oi(Ea, "CollisionBoxArray");
    class Ca extends ea {
      get projectedAnchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      get projectedAnchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      get projectedAnchorZ() {
        return this._structArray.int16[this._pos2 + 2];
      }
      get tileAnchorX() {
        return this._structArray.float32[this._pos4 + 2];
      }
      get tileAnchorY() {
        return this._structArray.float32[this._pos4 + 3];
      }
      get glyphStartIndex() {
        return this._structArray.uint16[this._pos2 + 8];
      }
      get numGlyphs() {
        return this._structArray.uint16[this._pos2 + 9];
      }
      get vertexStartIndex() {
        return this._structArray.uint32[this._pos4 + 5];
      }
      get lineStartIndex() {
        return this._structArray.uint32[this._pos4 + 6];
      }
      get lineLength() {
        return this._structArray.uint32[this._pos4 + 7];
      }
      get segment() {
        return this._structArray.uint16[this._pos2 + 16];
      }
      get lowerSize() {
        return this._structArray.uint16[this._pos2 + 17];
      }
      get upperSize() {
        return this._structArray.uint16[this._pos2 + 18];
      }
      get lineOffsetX() {
        return this._structArray.float32[this._pos4 + 10];
      }
      get lineOffsetY() {
        return this._structArray.float32[this._pos4 + 11];
      }
      get writingMode() {
        return this._structArray.uint8[this._pos1 + 48];
      }
      get placedOrientation() {
        return this._structArray.uint8[this._pos1 + 49];
      }
      set placedOrientation(t) {
        this._structArray.uint8[this._pos1 + 49] = t;
      }
      get hidden() {
        return this._structArray.uint8[this._pos1 + 50];
      }
      set hidden(t) {
        this._structArray.uint8[this._pos1 + 50] = t;
      }
      get crossTileID() {
        return this._structArray.uint32[this._pos4 + 13];
      }
      set crossTileID(t) {
        this._structArray.uint32[this._pos4 + 13] = t;
      }
      get associatedIconIndex() {
        return this._structArray.int16[this._pos2 + 28];
      }
      get flipState() {
        return this._structArray.uint8[this._pos1 + 58];
      }
      set flipState(t) {
        this._structArray.uint8[this._pos1 + 58] = t;
      }
    }
    Ca.prototype.size = 60;
    class Pa extends _a {
      get(t) {
        return new Ca(this, t);
      }
    }
    Oi(Pa, "PlacedSymbolArray");
    class Da extends ea {
      get projectedAnchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }
      get projectedAnchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }
      get projectedAnchorZ() {
        return this._structArray.int16[this._pos2 + 2];
      }
      get tileAnchorX() {
        return this._structArray.float32[this._pos4 + 2];
      }
      get tileAnchorY() {
        return this._structArray.float32[this._pos4 + 3];
      }
      get rightJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 8];
      }
      get centerJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 9];
      }
      get leftJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 10];
      }
      get verticalPlacedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 11];
      }
      get placedIconSymbolIndex() {
        return this._structArray.int16[this._pos2 + 12];
      }
      get verticalPlacedIconSymbolIndex() {
        return this._structArray.int16[this._pos2 + 13];
      }
      get key() {
        return this._structArray.uint16[this._pos2 + 14];
      }
      get textBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 15];
      }
      get textBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 16];
      }
      get verticalTextBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 17];
      }
      get verticalTextBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 18];
      }
      get iconBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 19];
      }
      get iconBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 20];
      }
      get verticalIconBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 21];
      }
      get verticalIconBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 22];
      }
      get featureIndex() {
        return this._structArray.uint16[this._pos2 + 23];
      }
      get numHorizontalGlyphVertices() {
        return this._structArray.uint16[this._pos2 + 24];
      }
      get numVerticalGlyphVertices() {
        return this._structArray.uint16[this._pos2 + 25];
      }
      get numIconVertices() {
        return this._structArray.uint16[this._pos2 + 26];
      }
      get numVerticalIconVertices() {
        return this._structArray.uint16[this._pos2 + 27];
      }
      get useRuntimeCollisionCircles() {
        return this._structArray.uint16[this._pos2 + 28];
      }
      get crossTileID() {
        return this._structArray.uint32[this._pos4 + 15];
      }
      set crossTileID(t) {
        this._structArray.uint32[this._pos4 + 15] = t;
      }
      get textOffset0() {
        return this._structArray.float32[this._pos4 + 16];
      }
      get textOffset1() {
        return this._structArray.float32[this._pos4 + 17];
      }
      get collisionCircleDiameter() {
        return this._structArray.float32[this._pos4 + 18];
      }
    }
    Da.prototype.size = 76;
    class Va extends Aa {
      get(t) {
        return new Da(this, t);
      }
    }
    Oi(Va, "SymbolInstanceArray");
    class La extends Sa {
      getoffsetX(t) {
        return this.float32[1 * t + 0];
      }
    }
    Oi(La, "GlyphOffsetArray");
    class Fa extends sa {
      getx(t) {
        return this.int16[2 * t + 0];
      }
      gety(t) {
        return this.int16[2 * t + 1];
      }
    }
    Oi(Fa, "SymbolLineVertexArray");
    class Ra extends ea {
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 0];
      }
      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 2];
      }
      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 3];
      }
      get layoutVertexArrayOffset() {
        return this._structArray.uint16[this._pos2 + 4];
      }
    }
    Ra.prototype.size = 12;
    class ja extends Ia {
      get(t) {
        return new Ra(this, t);
      }
    }
    Oi(ja, "FeatureIndexArray");
    class Ua extends Ma {
      geta_centroid_pos0(t) {
        return this.uint16[2 * t + 0];
      }
      geta_centroid_pos1(t) {
        return this.uint16[2 * t + 1];
      }
    }
    Oi(Ua, "FillExtrusionCentroidArray");
    const $a = na([{
        name: "a_pattern",
        components: 4,
        type: "Uint16"
      }, {
        name: "a_pixel_ratio",
        components: 1,
        type: "Float32"
      }]),
      Oa = na([{
        name: "a_dash",
        components: 4,
        type: "Uint16"
      }]);
    var qa = {},
      Na = {
        get exports() {
          return qa;
        },
        set exports(t) {
          qa = t;
        }
      },
      Ga = {};
    ({
      get exports() {
        return Ga;
      },
      set exports(t) {
        Ga = t;
      }
    }).exports = function (t, e) {
      var r, n, i, s, a, o, l, u;
      for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);
      switch (l = 0, r) {
        case 3:
          l ^= (255 & t.charCodeAt(u + 2)) << 16;
        case 2:
          l ^= (255 & t.charCodeAt(u + 1)) << 8;
        case 1:
          i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
      }
      return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
    };
    var Xa = {};
    ({
      get exports() {
        return Xa;
      },
      set exports(t) {
        Xa = t;
      }
    }).exports = function (t, e) {
      for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;
      switch (n) {
        case 3:
          i ^= (255 & t.charCodeAt(s + 2)) << 16;
        case 2:
          i ^= (255 & t.charCodeAt(s + 1)) << 8;
        case 1:
          i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
      }
      return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
    };
    var Za = Ga,
      Ka = Xa;
    Na.exports = Za, qa.murmur3 = Za, qa.murmur2 = Ka;
    class Ya {
      constructor() {
        this.ids = [], this.positions = [], this.indexed = !1;
      }
      add(t, e, r, n) {
        this.ids.push(Ha(t)), this.positions.push(e, r, n);
      }
      getPositions(t) {
        const e = Ha(t);
        let r = 0,
          n = this.ids.length - 1;
        for (; r < n;) {
          const t = r + n >> 1;
          this.ids[t] >= e ? n = t : r = t + 1;
        }
        const i = [];
        for (; this.ids[r] === e;) i.push({
          index: this.positions[3 * r],
          start: this.positions[3 * r + 1],
          end: this.positions[3 * r + 2]
        }), r++;
        return i;
      }
      static serialize(t, e) {
        const r = new Float64Array(t.ids),
          n = new Uint32Array(t.positions);
        return Wa(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {
          ids: r,
          positions: n
        };
      }
      static deserialize(t) {
        const e = new Ya();
        return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;
      }
    }
    function Ha(t) {
      const e = +t;
      return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : qa(String(t));
    }
    function Wa(t, e, r, n) {
      for (; r < n;) {
        const i = t[r + n >> 1];
        let s = r - 1,
          a = n + 1;
        for (;;) {
          do {
            s++;
          } while (t[s] < i);
          do {
            a--;
          } while (t[a] > i);
          if (s >= a) break;
          Ja(t, s, a), Ja(e, 3 * s, 3 * a), Ja(e, 3 * s + 1, 3 * a + 1), Ja(e, 3 * s + 2, 3 * a + 2);
        }
        a - r < n - a ? (Wa(t, e, r, a), r = a + 1) : (Wa(t, e, a + 1, n), n = a);
      }
    }
    function Ja(t, e, r) {
      const n = t[e];
      t[e] = t[r], t[r] = n;
    }
    Oi(Ya, "FeaturePositionMap");
    class Qa {
      constructor(t) {
        this.gl = t.gl, this.initialized = !1;
      }
      fetchUniformLocation(t, e) {
        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;
      }
    }
    class to extends Qa {
      constructor(t) {
        super(t), this.current = 0;
      }
      set(t, e, r) {
        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
      }
    }
    class eo extends Qa {
      constructor(t) {
        super(t), this.current = [0, 0, 0, 0];
      }
      set(t, e, r) {
        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
      }
    }
    class ro extends Qa {
      constructor(t) {
        super(t), this.current = Me.transparent;
      }
      set(t, e, r) {
        this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
      }
    }
    const no = new Float32Array(16),
      io = new Float32Array(9),
      so = new Float32Array(4);
    function ao(t) {
      return [Qs(255 * t.r, 255 * t.g), Qs(255 * t.b, 255 * t.a)];
    }
    class oo {
      constructor(t, e, r) {
        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;
      }
      setUniform(t, e, r, n, i) {
        e.set(t, i, n.constantOr(this.value));
      }
      getBinding(t, e) {
        return "color" === this.type ? new ro(t) : new to(t);
      }
    }
    class lo {
      constructor(t, e) {
        this.uniformNames = e.map(t => `u_${t}`), this.pattern = null, this.pixelRatio = 1;
      }
      setConstantPatternPositions(t) {
        this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br);
      }
      setUniform(t, e, r, n, i) {
        const s = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;
        s && e.set(t, i, s);
      }
      getBinding(t, e) {
        return "u_pattern" === e || "u_dash" === e ? new eo(t) : new to(t);
      }
    }
    class uo {
      constructor(t, e, r, n) {
        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({
          name: `a_${t}`,
          type: "Float32",
          components: "color" === r ? 2 : 1,
          offset: 0
        })), this.paintVertexArray = new n();
      }
      populatePaintArray(t, e, r, n, i, s) {
        const a = this.paintVertexArray.length,
          o = this.expression.evaluate(new Us(0), e, {}, i, n, s);
        this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);
      }
      updatePaintArray(t, e, r, n, i) {
        const s = this.expression.evaluate({
          zoom: 0
        }, r, n, void 0, i);
        this._setPaintValue(t, e, s);
      }
      _setPaintValue(t, e, r) {
        if ("color" === this.type) {
          const n = ao(r);
          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);
        } else {
          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);
          this.maxValue = Math.max(this.maxValue, Math.abs(r));
        }
      }
      upload(t) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
    }
    class co {
      constructor(t, e, r, n, i, s) {
        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({
          name: `a_${t}`,
          type: "Float32",
          components: "color" === r ? 4 : 2,
          offset: 0
        })), this.paintVertexArray = new s();
      }
      populatePaintArray(t, e, r, n, i, s) {
        const a = this.expression.evaluate(new Us(this.zoom), e, {}, i, n, s),
          o = this.expression.evaluate(new Us(this.zoom + 1), e, {}, i, n, s),
          l = this.paintVertexArray.length;
        this.paintVertexArray.resize(t), this._setPaintValue(l, t, a, o);
      }
      updatePaintArray(t, e, r, n, i) {
        const s = this.expression.evaluate({
            zoom: this.zoom
          }, r, n, void 0, i),
          a = this.expression.evaluate({
            zoom: this.zoom + 1
          }, r, n, void 0, i);
        this._setPaintValue(t, e, s, a);
      }
      _setPaintValue(t, e, r, n) {
        if ("color" === this.type) {
          const i = ao(r),
            s = ao(n);
          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);
        } else {
          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);
          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
        }
      }
      upload(t) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
      setUniform(t, e, r, n, i) {
        const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
          a = S(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
        e.set(t, i, a);
      }
      getBinding(t, e) {
        return new to(t);
      }
    }
    class ho {
      constructor(t, e, r, n, i) {
        this.expression = t, this.layerId = i, this.paintVertexAttributes = ("array" === r ? Oa : $a).members;
        for (let t = 0; t < e.length; ++t);
        this.paintVertexArray = new n();
      }
      populatePaintArray(t, e, r) {
        const n = this.paintVertexArray.length;
        this.paintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);
      }
      updatePaintArray(t, e, r, n, i, s) {
        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);
      }
      _setPaintValues(t, e, r, n) {
        if (!n || !r) return;
        const i = n[r];
        if (!i) return;
        const {
          tl: s,
          br: a,
          pixelRatio: o
        } = i;
        for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);
      }
      upload(t) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }
      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }
    }
    class po {
      constructor(t, e, r = () => !0) {
        this.binders = {}, this._buffers = [];
        const n = [];
        for (const i in t.paint._values) {
          if (!r(i)) continue;
          const s = t.paint.get(i);
          if (!(s instanceof Zs && En(s.property.specification))) continue;
          const a = mo(i, t.type),
            o = s.value,
            l = s.property.specification.type,
            u = s.property.useIntegerZoom,
            c = "line-dasharray" === i || i.endsWith("pattern"),
            h = "line-dasharray" === i && "constant" !== t.layout.get("line-cap").value.kind;
          if ("constant" !== o.kind || h) {
            if ("source" === o.kind || h || c) {
              const e = vo(i, l, "source");
              this.binders[i] = c ? new ho(o, a, l, e, t.id) : new uo(o, a, l, e), n.push(`/a_${i}`);
            } else {
              const t = vo(i, l, "composite");
              this.binders[i] = new co(o, a, l, u, e, t), n.push(`/z_${i}`);
            }
          } else this.binders[i] = c ? new lo(o.value, a) : new oo(o.value, a, l), n.push(`/u_${i}`);
        }
        this.cacheKey = n.sort().join("");
      }
      getMaxValue(t) {
        const e = this.binders[t];
        return e instanceof uo || e instanceof co ? e.maxValue : 0;
      }
      populatePaintArrays(t, e, r, n, i, s) {
        for (const a in this.binders) {
          const o = this.binders[a];
          (o instanceof uo || o instanceof co || o instanceof ho) && o.populatePaintArray(t, e, r, n, i, s);
        }
      }
      setConstantPatternPositions(t) {
        for (const e in this.binders) {
          const r = this.binders[e];
          r instanceof lo && r.setConstantPatternPositions(t);
        }
      }
      updatePaintArrays(t, e, r, n, i, s) {
        let a = !1;
        for (const o in t) {
          const l = e.getPositions(o);
          for (const e of l) {
            const l = r.feature(e.index);
            for (const r in this.binders) {
              const u = this.binders[r];
              if ((u instanceof uo || u instanceof co || u instanceof ho) && !0 === u.expression.isStateDependent) {
                const c = n.paint.get(r);
                u.expression = c.value, u.updatePaintArray(e.start, e.end, l, t[o], i, s), a = !0;
              }
            }
          }
        }
        return a;
      }
      defines() {
        const t = [];
        for (const e in this.binders) {
          const r = this.binders[e];
          (r instanceof oo || r instanceof lo) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));
        }
        return t;
      }
      getBinderAttributes() {
        const t = [];
        for (const e in this.binders) {
          const r = this.binders[e];
          if (r instanceof uo || r instanceof co || r instanceof ho) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);
        }
        return t;
      }
      getBinderUniforms() {
        const t = [];
        for (const e in this.binders) {
          const r = this.binders[e];
          if (r instanceof oo || r instanceof lo || r instanceof co) for (const e of r.uniformNames) t.push(e);
        }
        return t;
      }
      getPaintVertexBuffers() {
        return this._buffers;
      }
      getUniforms(t) {
        const e = [];
        for (const r in this.binders) {
          const n = this.binders[r];
          if (n instanceof oo || n instanceof lo || n instanceof co) for (const i of n.uniformNames) e.push({
            name: i,
            property: r,
            binding: n.getBinding(t, i)
          });
        }
        return e;
      }
      setUniforms(t, e, r, n, i) {
        for (const {
          name: e,
          property: s,
          binding: a
        } of r) this.binders[s].setUniform(t, a, i, n.get(s), e);
      }
      updatePaintBuffers() {
        this._buffers = [];
        for (const t in this.binders) {
          const e = this.binders[t];
          (e instanceof uo || e instanceof co || e instanceof ho) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);
        }
      }
      upload(t) {
        for (const e in this.binders) {
          const r = this.binders[e];
          (r instanceof uo || r instanceof co || r instanceof ho) && r.upload(t);
        }
        this.updatePaintBuffers();
      }
      destroy() {
        for (const t in this.binders) {
          const e = this.binders[t];
          (e instanceof uo || e instanceof co || e instanceof ho) && e.destroy();
        }
      }
    }
    class fo {
      constructor(t, e, r = () => !0) {
        this.programConfigurations = {};
        for (const n of t) this.programConfigurations[n.id] = new po(n, e, r);
        this.needsUpload = !1, this._featureMap = new Ya(), this._bufferOffset = 0;
      }
      populatePaintArrays(t, e, r, n, i, s, a) {
        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a);
        void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
      }
      updatePaintArrays(t, e, r, n, i) {
        for (const s of r) this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, e, s, n, i) || this.needsUpload;
      }
      get(t) {
        return this.programConfigurations[t];
      }
      upload(t) {
        if (this.needsUpload) {
          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);
          this.needsUpload = !1;
        }
      }
      destroy() {
        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
      }
    }
    const yo = {
      "text-opacity": ["opacity"],
      "icon-opacity": ["opacity"],
      "text-color": ["fill_color"],
      "icon-color": ["fill_color"],
      "text-halo-color": ["halo_color"],
      "icon-halo-color": ["halo_color"],
      "text-halo-blur": ["halo_blur"],
      "icon-halo-blur": ["halo_blur"],
      "text-halo-width": ["halo_width"],
      "icon-halo-width": ["halo_width"],
      "line-gap-width": ["gapwidth"],
      "line-pattern": ["pattern", "pixel_ratio"],
      "fill-pattern": ["pattern", "pixel_ratio"],
      "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
      "line-dasharray": ["dash"]
    };
    function mo(t, e) {
      return yo[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")];
    }
    const go = {
        "line-pattern": {
          source: ca,
          composite: ca
        },
        "fill-pattern": {
          source: ca,
          composite: ca
        },
        "fill-extrusion-pattern": {
          source: ca,
          composite: ca
        },
        "line-dasharray": {
          source: ha,
          composite: ha
        }
      },
      xo = {
        color: {
          source: za,
          composite: ua
        },
        number: {
          source: Sa,
          composite: za
        }
      };
    function vo(t, e, r) {
      const n = go[t];
      return n && n[r] || xo[e][r];
    }
    Oi(oo, "ConstantBinder"), Oi(lo, "PatternConstantBinder"), Oi(uo, "SourceExpressionBinder"), Oi(ho, "PatternCompositeBinder"), Oi(co, "CompositeExpressionBinder"), Oi(po, "ProgramConfiguration", {
      omit: ["_buffers"]
    }), Oi(fo, "ProgramConfigurationSet");
    const bo = "-transition";
    class wo extends Yt {
      constructor(t, e) {
        if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
          filter: () => !0,
          needGeometry: !1,
          needFeature: !1
        }, this._filterCompiled = !1, "custom" !== t.type && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, "background" !== t.type && "sky" !== t.type && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new Xs(e.layout)), e.paint)) {
          this._transitionablePaint = new qs(e.paint);
          for (const e in t.paint) this.setPaintProperty(e, t.paint[e], {
            validate: !1
          });
          for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], {
            validate: !1
          });
          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e.paint);
        }
      }
      getLayoutProperty(t) {
        return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);
      }
      setLayoutProperty(t, e, r = {}) {
        null != e && this._validate(Li, `layers.${this.id}.layout.${t}`, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);
      }
      getPaintProperty(t) {
        return L(t, bo) ? this._transitionablePaint.getTransition(t.slice(0, -bo.length)) : this._transitionablePaint.getValue(t);
      }
      setPaintProperty(t, e, r = {}) {
        if (null != e && this._validate(Vi, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;
        if (L(t, bo)) return this._transitionablePaint.setTransition(t.slice(0, -bo.length), e || void 0), !1;
        {
          const r = this._transitionablePaint._values[t],
            n = r.value.isDataDriven(),
            i = r.value;
          this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);
          const s = this._transitionablePaint._values[t].value,
            a = s.isDataDriven(),
            o = L(t, "pattern") || "line-dasharray" === t;
          return a || n || o || this._handleOverridablePaintPropertyUpdate(t, i, s);
        }
      }
      _handleSpecialPaintPropertyUpdate(t) {}
      getProgramIds() {
        return null;
      }
      getProgramConfiguration(t) {
        return null;
      }
      _handleOverridablePaintPropertyUpdate(t, e, r) {
        return !1;
      }
      isHidden(t) {
        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;
      }
      updateTransitions(t) {
        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
      }
      hasTransition() {
        return this._transitioningPaint.hasTransition();
      }
      recalculate(t, e) {
        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);
      }
      serialize() {
        const t = {
          id: this.id,
          type: this.type,
          source: this.source,
          "source-layer": this.sourceLayer,
          metadata: this.metadata,
          minzoom: this.minzoom,
          maxzoom: this.maxzoom,
          filter: this.filter,
          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
          paint: this._transitionablePaint && this._transitionablePaint.serialize()
        };
        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), R(t, (t, e) => !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length));
      }
      _validate(t, e, r, n, i = {}) {
        return (!i || !1 !== i.validate) && Ri(this, t.call(Di, {
          key: e,
          layerType: this.type,
          objectKey: r,
          value: n,
          styleSpec: Ht,
          style: {
            glyphs: !0,
            sprite: !0
          }
        }));
      }
      is3D() {
        return !1;
      }
      isSky() {
        return !1;
      }
      isTileClipped() {
        return !1;
      }
      hasOffscreenPass() {
        return !1;
      }
      resize() {}
      isStateDependent() {
        for (const t in this.paint._values) {
          const e = this.paint.get(t);
          if (e instanceof Zs && En(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
        }
        return !1;
      }
      compileFilter() {
        this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = !0);
      }
      invalidateCompiledFilter() {
        this._filterCompiled = !1;
      }
      dynamicFilter() {
        return this._featureFilter.dynamicFilter;
      }
      dynamicFilterNeedsFeature() {
        return this._featureFilter.needFeature;
      }
    }
    const _o = na([{
        name: "a_pos",
        components: 2,
        type: "Int16"
      }], 4),
      Ao = na([{
        name: "a_pos_3",
        components: 3,
        type: "Int16"
      }, {
        name: "a_pos_normal_3",
        components: 3,
        type: "Int16"
      }]);
    class So {
      constructor(t = []) {
        this.segments = t;
      }
      prepareSegment(t, e, r, n) {
        let i = this.segments[this.segments.length - 1];
        return t > So.MAX_VERTEX_ARRAY_LENGTH && $(`Max vertices per segment is ${So.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > So.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
          vertexOffset: e.length,
          primitiveOffset: r.length,
          vertexLength: 0,
          primitiveLength: 0
        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
      }
      get() {
        return this.segments;
      }
      destroy() {
        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();
      }
      static simpleSegment(t, e, r, n) {
        return new So([{
          vertexOffset: t,
          primitiveOffset: e,
          vertexLength: r,
          primitiveLength: n,
          vaos: {},
          sortKey: 0
        }]);
      }
    }
    So.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(So, "SegmentVector");
    var ko = 8192;
    class Io {
      constructor(t, e) {
        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));
      }
      setNorthEast(t) {
        return this._ne = t instanceof ru ? new ru(t.lng, t.lat) : ru.convert(t), this;
      }
      setSouthWest(t) {
        return this._sw = t instanceof ru ? new ru(t.lng, t.lat) : ru.convert(t), this;
      }
      extend(t) {
        const e = this._sw,
          r = this._ne;
        let n, i;
        if (t instanceof ru) n = t, i = t;else {
          if (!(t instanceof Io)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Io.convert(t)) : this.extend(ru.convert(t)) : "object" == typeof t && null !== t && t.hasOwnProperty("lat") && t.hasOwnProperty("lon") ? this.extend(ru.convert(t)) : this;
          if (n = t._sw, i = t._ne, !n || !i) return this;
        }
        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new ru(n.lng, n.lat), this._ne = new ru(i.lng, i.lat)), this;
      }
      getCenter() {
        return new ru((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }
      getSouthWest() {
        return this._sw;
      }
      getNorthEast() {
        return this._ne;
      }
      getNorthWest() {
        return new ru(this.getWest(), this.getNorth());
      }
      getSouthEast() {
        return new ru(this.getEast(), this.getSouth());
      }
      getWest() {
        return this._sw.lng;
      }
      getSouth() {
        return this._sw.lat;
      }
      getEast() {
        return this._ne.lng;
      }
      getNorth() {
        return this._ne.lat;
      }
      toArray() {
        return [this._sw.toArray(), this._ne.toArray()];
      }
      toString() {
        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
      }
      isEmpty() {
        return !(this._sw && this._ne);
      }
      contains(t) {
        const {
          lng: e,
          lat: r
        } = ru.convert(t);
        let n = this._sw.lng <= e && e <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
      }
      static convert(t) {
        return !t || t instanceof Io ? t : new Io(t);
      }
    }
    var Mo = 1e-6,
      To = "undefined" != typeof Float32Array ? Float32Array : Array;
    function zo() {
      var t = new To(9);
      return To != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
    }
    function Bo(t, e, r) {
      var n = e[0],
        i = e[1],
        s = e[2],
        a = e[3],
        o = e[4],
        l = e[5],
        u = e[6],
        c = e[7],
        h = e[8],
        p = r[0],
        f = r[1],
        d = r[2],
        y = r[3],
        m = r[4],
        g = r[5],
        x = r[6],
        v = r[7],
        b = r[8];
      return t[0] = p * n + f * a + d * u, t[1] = p * i + f * o + d * c, t[2] = p * s + f * l + d * h, t[3] = y * n + m * a + g * u, t[4] = y * i + m * o + g * c, t[5] = y * s + m * l + g * h, t[6] = x * n + v * a + b * u, t[7] = x * i + v * o + b * c, t[8] = x * s + v * l + b * h, t;
    }
    function Eo(t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function Co(t, e) {
      var r = e[0],
        n = e[1],
        i = e[2],
        s = e[3],
        a = e[4],
        o = e[5],
        l = e[6],
        u = e[7],
        c = e[8],
        h = e[9],
        p = e[10],
        f = e[11],
        d = e[12],
        y = e[13],
        m = e[14],
        g = e[15],
        x = r * o - n * a,
        v = r * l - i * a,
        b = r * u - s * a,
        w = n * l - i * o,
        _ = n * u - s * o,
        A = i * u - s * l,
        S = c * y - h * d,
        k = c * m - p * d,
        I = c * g - f * d,
        M = h * m - p * y,
        T = h * g - f * y,
        z = p * g - f * m,
        B = x * z - v * T + b * M + w * I - _ * k + A * S;
      return B ? (t[0] = (o * z - l * T + u * M) * (B = 1 / B), t[1] = (i * T - n * z - s * M) * B, t[2] = (y * A - m * _ + g * w) * B, t[3] = (p * _ - h * A - f * w) * B, t[4] = (l * I - a * z - u * k) * B, t[5] = (r * z - i * I + s * k) * B, t[6] = (m * b - d * A - g * v) * B, t[7] = (c * A - p * b + f * v) * B, t[8] = (a * T - o * I + u * S) * B, t[9] = (n * I - r * T - s * S) * B, t[10] = (d * _ - y * b + g * x) * B, t[11] = (h * b - c * _ - f * x) * B, t[12] = (o * k - a * M - l * S) * B, t[13] = (r * M - n * k + i * S) * B, t[14] = (y * v - d * w - m * x) * B, t[15] = (c * w - h * v + p * x) * B, t) : null;
    }
    function Po(t, e, r) {
      var n = e[0],
        i = e[1],
        s = e[2],
        a = e[3],
        o = e[4],
        l = e[5],
        u = e[6],
        c = e[7],
        h = e[8],
        p = e[9],
        f = e[10],
        d = e[11],
        y = e[12],
        m = e[13],
        g = e[14],
        x = e[15],
        v = r[0],
        b = r[1],
        w = r[2],
        _ = r[3];
      return t[0] = v * n + b * o + w * h + _ * y, t[1] = v * i + b * l + w * p + _ * m, t[2] = v * s + b * u + w * f + _ * g, t[3] = v * a + b * c + w * d + _ * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t[5] = v * i + b * l + w * p + _ * m, t[6] = v * s + b * u + w * f + _ * g, t[7] = v * a + b * c + w * d + _ * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t[9] = v * i + b * l + w * p + _ * m, t[10] = v * s + b * u + w * f + _ * g, t[11] = v * a + b * c + w * d + _ * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t[13] = v * i + b * l + w * p + _ * m, t[14] = v * s + b * u + w * f + _ * g, t[15] = v * a + b * c + w * d + _ * x, t;
    }
    function Do(t, e, r) {
      var n,
        i,
        s,
        a,
        o,
        l,
        u,
        c,
        h,
        p,
        f,
        d,
        y = r[0],
        m = r[1],
        g = r[2];
      return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + f * g + e[14], t[15] = a * y + c * m + d * g + e[15]), t;
    }
    function Vo(t, e, r) {
      var n = r[0],
        i = r[1],
        s = r[2];
      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
    }
    function Lo(t, e, r) {
      var n = Math.sin(r),
        i = Math.cos(r),
        s = e[4],
        a = e[5],
        o = e[6],
        l = e[7],
        u = e[8],
        c = e[9],
        h = e[10],
        p = e[11];
      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;
    }
    function Fo(t, e, r) {
      var n = Math.sin(r),
        i = Math.cos(r),
        s = e[0],
        a = e[1],
        o = e[2],
        l = e[3],
        u = e[8],
        c = e[9],
        h = e[10],
        p = e[11];
      return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;
    }
    function Ro(t, e) {
      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function jo(t, e, r) {
      var n,
        i,
        s,
        a = r[0],
        o = r[1],
        l = r[2],
        u = Math.hypot(a, o, l);
      return u < Mo ? null : (a *= u = 1 / u, o *= u, l *= u, n = Math.sin(e), i = Math.cos(e), t[0] = a * a * (s = 1 - i) + i, t[1] = o * a * s + l * n, t[2] = l * a * s - o * n, t[3] = 0, t[4] = a * o * s - l * n, t[5] = o * o * s + i, t[6] = l * o * s + a * n, t[7] = 0, t[8] = a * l * s + o * n, t[9] = o * l * s - a * n, t[10] = l * l * s + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
    }
    Math.hypot || (Math.hypot = function () {
      for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];
      return Math.sqrt(t);
    });
    var Uo = Po;
    function $o() {
      var t = new To(3);
      return To != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }
    function Oo(t) {
      var e = new To(3);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
    }
    function qo(t) {
      return Math.hypot(t[0], t[1], t[2]);
    }
    function No(t, e, r) {
      var n = new To(3);
      return n[0] = t, n[1] = e, n[2] = r, n;
    }
    function Go(t, e, r) {
      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;
    }
    function Xo(t, e, r) {
      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;
    }
    function Zo(t, e, r) {
      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;
    }
    function Ko(t, e, r) {
      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;
    }
    function Yo(t, e, r) {
      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;
    }
    function Ho(t, e, r) {
      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;
    }
    function Wo(t, e, r, n) {
      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;
    }
    function Jo(t, e) {
      var r = e[0],
        n = e[1],
        i = e[2],
        s = r * r + n * n + i * i;
      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;
    }
    function Qo(t, e) {
      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    }
    function tl(t, e, r) {
      var n = e[0],
        i = e[1],
        s = e[2],
        a = r[0],
        o = r[1],
        l = r[2];
      return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t;
    }
    function el(t, e, r) {
      var n = e[0],
        i = e[1],
        s = e[2],
        a = r[3] * n + r[7] * i + r[11] * s + r[15];
      return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t;
    }
    function rl(t, e, r) {
      var n = r[0],
        i = r[1],
        s = r[2],
        a = e[0],
        o = e[1],
        l = e[2],
        u = i * l - s * o,
        c = s * a - n * l,
        h = n * o - i * a,
        p = i * h - s * c,
        f = s * u - n * h,
        d = n * c - i * u,
        y = 2 * r[3];
      return c *= y, h *= y, f *= 2, d *= 2, t[0] = a + (u *= y) + (p *= 2), t[1] = o + c + f, t[2] = l + h + d, t;
    }
    var nl,
      il = Xo,
      sl = Zo,
      al = qo;
    function ol(t, e, r) {
      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;
    }
    function ll(t, e) {
      var r = e[0],
        n = e[1],
        i = e[2],
        s = e[3],
        a = r * r + n * n + i * i + s * s;
      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = r * a, t[1] = n * a, t[2] = i * a, t[3] = s * a, t;
    }
    function ul(t, e, r) {
      var n = e[0],
        i = e[1],
        s = e[2],
        a = e[3];
      return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;
    }
    function cl() {
      var t = new To(4);
      return To != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
    }
    function hl(t) {
      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }
    function pl(t, e, r) {
      r *= .5;
      var n = e[0],
        i = e[1],
        s = e[2],
        a = e[3],
        o = Math.sin(r),
        l = Math.cos(r);
      return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = s * l - i * o, t[3] = a * l - n * o, t;
    }
    function fl(t, e, r) {
      r *= .5;
      var n = e[0],
        i = e[1],
        s = e[2],
        a = e[3],
        o = Math.sin(r),
        l = Math.cos(r);
      return t[0] = n * l - s * o, t[1] = i * l + a * o, t[2] = s * l + n * o, t[3] = a * l - i * o, t;
    }
    $o(), nl = new To(4), To != Float32Array && (nl[0] = 0, nl[1] = 0, nl[2] = 0, nl[3] = 0);
    var dl = ll;
    $o(), No(1, 0, 0), No(0, 1, 0), cl(), cl(), zo();
    const yl = na([{
        type: "Float32",
        name: "a_globe_pos",
        components: 3
      }, {
        type: "Float32",
        name: "a_uv",
        components: 2
      }]),
      {
        members: ml
      } = yl,
      gl = na([{
        name: "a_pos_3",
        components: 3,
        type: "Int16"
      }]);
    var xl = na([{
      name: "a_pos",
      type: "Int16",
      components: 2
    }]);
    class vl {
      constructor(t, e) {
        this.pos = t, this.dir = e;
      }
      intersectsPlane(t, e, r) {
        const n = Qo(e, this.dir);
        if (Math.abs(n) < 1e-6) return !1;
        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;
        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
      }
      closestPointOnSphere(t, e, r) {
        if (function (t, e) {
          var r = t[0],
            n = t[1],
            i = t[2],
            s = e[0],
            a = e[1],
            o = e[2];
          return Math.abs(r - s) <= Mo * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= Mo * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= Mo * Math.max(1, Math.abs(i), Math.abs(o));
        }(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;
        const [n, i, s] = this.dir,
          a = this.pos[0] - t[0],
          o = this.pos[1] - t[1],
          l = this.pos[2] - t[2],
          u = n * n + i * i + s * s,
          c = 2 * (a * n + o * i + l * s),
          h = c * c - 4 * u * (a * a + o * o + l * l - e * e);
        if (h < 0) {
          const t = Math.max(-c / 2, 0),
            u = a + n * t,
            h = o + i * t,
            p = l + s * t,
            f = Math.hypot(u, h, p);
          return r[0] = u * e / f, r[1] = h * e / f, r[2] = p * e / f, !1;
        }
        {
          const t = (-c - Math.sqrt(h)) / (2 * u);
          if (t < 0) {
            const t = Math.hypot(a, o, l);
            return r[0] = a * e / t, r[1] = o * e / t, r[2] = l * e / t, !1;
          }
          return r[0] = a + n * t, r[1] = o + i * t, r[2] = l + s * t, !0;
        }
      }
    }
    class bl {
      constructor(t, e, r, n, i) {
        this.TL = t, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;
      }
      static fromInvProjectionMatrix(t, e, r) {
        const n = [-1, 1, 1],
          i = [1, 1, 1],
          s = [1, -1, 1],
          a = [-1, -1, 1],
          o = el(n, n, t),
          l = el(i, i, t),
          u = el(s, s, t),
          c = el(a, a, t);
        return new bl(o, l, u, c, e / r);
      }
    }
    class wl {
      constructor(t, e) {
        this.points = t, this.planes = e;
      }
      static fromInvProjectionMatrix(t, e, r, n) {
        const i = Math.pow(2, r),
          s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {
            const s = ul([], r, t),
              a = 1 / s[3] / e * i;
            return function (t, e, r) {
              return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;
            }(s, s, [a, a, n ? 1 / s[3] : a, a]);
          }),
          a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {
            const e = Jo([], tl([], il([], s[t[0]], s[t[1]]), il([], s[t[2]], s[t[1]]))),
              r = -Qo(e, s[t[1]]);
            return e.concat(r);
          });
        return new wl(s, a);
      }
    }
    class _l {
      static fromPoints(t) {
        const e = [1 / 0, 1 / 0, 1 / 0],
          r = [-1 / 0, -1 / 0, -1 / 0];
        for (const n of t) Ko(e, e, n), Yo(r, r, n);
        return new _l(e, r);
      }
      static applyTransform(t, e) {
        const r = t.getCorners();
        for (let t = 0; t < r.length; ++t) el(r[t], r[t], e);
        return _l.fromPoints(r);
      }
      constructor(t, e) {
        this.min = t, this.max = e, this.center = Ho([], Go([], this.min, this.max), .5);
      }
      quadrant(t) {
        const e = [t % 2 == 0, t < 2],
          r = Oo(this.min),
          n = Oo(this.max);
        for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];
        return n[2] = this.max[2], new _l(r, n);
      }
      distanceX(t) {
        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
      }
      distanceY(t) {
        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
      }
      distanceZ(t) {
        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];
      }
      getCorners() {
        const t = this.min,
          e = this.max;
        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];
      }
      intersects(t) {
        const e = this.getCorners();
        let r = !0;
        for (let n = 0; n < t.planes.length; n++) {
          const i = t.planes[n];
          let s = 0;
          for (let t = 0; t < e.length; t++) s += Qo(i, e[t]) + i[3] >= 0;
          if (0 === s) return 0;
          s !== e.length && (r = !1);
        }
        if (r) return 2;
        for (let e = 0; e < 3; e++) {
          let r = Number.MAX_VALUE,
            n = -Number.MAX_VALUE;
          for (let i = 0; i < t.points.length; i++) {
            const s = t.points[i][e] - this.min[e];
            r = Math.min(r, s), n = Math.max(n, s);
          }
          if (n < 0 || r > this.max[e] - this.min[e]) return 0;
        }
        return 1;
      }
    }
    const Al = ko / Math.PI / 2,
      Sl = 64,
      kl = [Sl, 32, 16],
      Il = -Al,
      Ml = Al,
      Tl = [new _l([Il, Il, Il], [Ml, Ml, Ml]), new _l([Il, Il, Il], [0, 0, Ml]), new _l([0, Il, Il], [Ml, 0, Ml]), new _l([Il, 0, Il], [0, Ml, Ml]), new _l([0, 0, Il], [Ml, Ml, Ml])];
    function zl(t) {
      return t * Al / tu;
    }
    function Bl(t, e, r, n = !0) {
      const i = Ho([], t._camera.position, t.worldSize),
        s = [e, r, 1, 1];
      ul(s, s, t.pixelMatrixInverse), ol(s, s, 1 / s[3]);
      const a = Jo([], il([], s, i)),
        o = t.globeMatrix,
        l = [o[12], o[13], o[14]],
        u = il([], l, i),
        c = qo(u),
        h = Jo([], u),
        p = t.worldSize / (2 * Math.PI),
        f = Qo(h, a),
        d = Math.asin(p / c);
      if (d < Math.acos(f)) {
        if (!n) return null;
        const t = [],
          e = [];
        Ho(t, a, c / f), Jo(e, il(e, t, u)), Jo(a, Go(a, u, Ho(a, e, Math.tan(d) * c)));
      }
      const y = [];
      new vl(i, a).closestPointOnSphere(l, p, y);
      const m = Jo([], Y(o, 0)),
        g = Jo([], Y(o, 1)),
        x = Jo([], Y(o, 2)),
        b = Qo(m, y),
        w = Qo(g, y),
        _ = Qo(x, y),
        A = v(Math.asin(-w / p));
      let k = v(Math.atan2(b, _));
      k = t.center.lng + function (t, e) {
        const r = (e - t + 180) % 360 - 180;
        return r < -180 ? r + 360 : r;
      }(t.center.lng, k);
      const I = iu(k),
        M = S(su(A), 0, 1);
      return new pu(I, M);
    }
    class El {
      constructor(t, e, r) {
        this.a = il([], t, r), this.b = il([], e, r), this.center = r;
        const n = Jo([], this.a),
          i = Jo([], this.b);
        this.angle = Math.acos(Qo(n, i));
      }
    }
    function Cl(t, e) {
      if (0 === t.angle) return null;
      let r;
      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {
        const i = Math.sin(r);
        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
      }(t.a[e], t.b[e], t.angle, S(r, 0, 1)) + t.center[e];
    }
    function Pl(t) {
      if (t.z <= 1) return Tl[t.z + 2 * t.y + t.x];
      const e = jl(Rl(t));
      return _l.fromPoints(e);
    }
    function Dl(t, e, r) {
      return Ho(t, t, 1 - r), Wo(t, t, e, r);
    }
    function Vl(t, e) {
      const r = Kl(e.zoom);
      if (0 === r) return Pl(t);
      const n = Rl(t),
        i = jl(n),
        s = iu(n.getWest()) * e.worldSize,
        a = iu(n.getEast()) * e.worldSize,
        o = su(n.getNorth()) * e.worldSize,
        l = su(n.getSouth()) * e.worldSize,
        u = [s, o, 0],
        c = [a, o, 0],
        h = [s, l, 0],
        p = [a, l, 0],
        f = Co([], e.globeMatrix);
      return el(u, u, f), el(c, c, f), el(h, h, f), el(p, p, f), i[0] = Dl(i[0], h, r), i[1] = Dl(i[1], p, r), i[2] = Dl(i[2], c, r), i[3] = Dl(i[3], u, r), _l.fromPoints(i);
    }
    function Ll(t, e, r) {
      for (const n of t) el(n, n, e), Ho(n, n, r);
    }
    function Fl(t, e, r) {
      const n = e / t.worldSize,
        i = t.globeMatrix;
      if (r.z <= 1) {
        const t = Pl(r).getCorners();
        return Ll(t, i, n), _l.fromPoints(t);
      }
      const s = Rl(r),
        a = jl(s);
      Ll(a, i, n);
      const o = Number.MAX_VALUE,
        l = [-o, -o, -o],
        u = [o, o, o];
      if (s.contains(t.center)) {
        for (const t of a) Ko(u, u, t), Yo(l, l, t);
        l[2] = 0;
        const e = t.point,
          r = [e.x * n, e.y * n, 0];
        return Ko(u, u, r), Yo(l, l, r), new _l(u, l);
      }
      const c = [i[12] * n, i[13] * n, i[14] * n],
        h = s.getCenter(),
        p = S(t.center.lat, -cu, cu),
        f = S(h.lat, -cu, cu),
        d = iu(t.center.lng),
        y = su(p);
      let m = d - iu(h.lng);
      const g = y - su(f);
      m > .5 ? m -= 1 : m < -.5 && (m += 1);
      let v = 0;
      Math.abs(m) > Math.abs(g) ? v = m >= 0 ? 1 : 3 : (v = g >= 0 ? 0 : 2, Wo(c, c, [i[4] * n, i[5] * n, i[6] * n], -Math.sin(x(g >= 0 ? s.getSouth() : s.getNorth())) * Al));
      const b = a[v],
        w = a[(v + 1) % 4],
        _ = new El(b, w, c),
        A = [Cl(_, 0) || b[0], Cl(_, 1) || b[1], Cl(_, 2) || b[2]],
        k = Kl(t.zoom);
      if (k > 0) {
        const n = function ({
          x: t,
          y: e,
          z: r
        }, n, i, s, a) {
          const o = 1 / (1 << r);
          let l = t * o,
            u = l + o,
            c = e * o,
            h = c + o,
            p = 0;
          const f = (l + u) / 2 - s;
          return f > .5 ? p = -1 : f < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]];
        }(r, e, t._pixelsPerMercatorPixel, d, y);
        for (let t = 0; t < a.length; t++) Dl(a[t], n[t], k);
        const i = Go([], n[v], n[(v + 1) % 4]);
        Ho(i, i, .5), Dl(A, i, k);
      }
      for (const t of a) Ko(u, u, t), Yo(l, l, t);
      return u[2] = Math.min(b[2], w[2]), Ko(u, u, A), Yo(l, l, A), new _l(u, l);
    }
    function Rl({
      x: t,
      y: e,
      z: r
    }) {
      const n = 1 / (1 << r),
        i = new ru(ou(t * n), lu((e + 1) * n)),
        s = new ru(ou((t + 1) * n), lu(e * n));
      return new Io(i, s);
    }
    function jl(t) {
      const e = x(t.getNorth()),
        r = x(t.getSouth()),
        n = Math.cos(e),
        i = Math.cos(r),
        s = Math.sin(e),
        a = Math.sin(r),
        o = t.getWest(),
        l = t.getEast();
      return [Ul(i, a, o), Ul(i, a, l), Ul(n, s, l), Ul(n, s, o)];
    }
    function Ul(t, e, r, n = Al) {
      return r = x(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];
    }
    function $l(t, e, r) {
      return Ul(Math.cos(x(t)), Math.sin(x(t)), e, r);
    }
    function Ol(t, e, r, n) {
      const i = 1 << r.z,
        s = (t / ko + r.x) / i;
      return $l(lu((e / ko + r.y) / i), ou(s), n);
    }
    function ql({
      min: t,
      max: e
    }) {
      return 16383 / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);
    }
    const Nl = new Float64Array(16);
    function Gl(t) {
      const e = ql(t),
        r = Ro(Nl, [e, e, e]);
      return Do(r, r, ((n = [])[0] = -(i = t.min)[0], n[1] = -i[1], n[2] = -i[2], n));
      var n, i;
    }
    function Xl(t) {
      const e = (n = t.min, (r = Nl)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);
      var r, n;
      const i = 1 / ql(t);
      return Vo(e, e, [i, i, i]);
    }
    function Zl(t, e, r, n, i) {
      const s = function (t) {
          const e = ko / (2 * Math.PI);
          return t / (2 * Math.PI) / e;
        }(r),
        a = [t, e, -r / (2 * Math.PI)],
        o = Eo(new Float64Array(16));
      return Do(o, o, a), Vo(o, o, [s, s, s]), Lo(o, o, x(-i)), Fo(o, o, x(-n)), o;
    }
    function Kl(t) {
      return k(5, 6, t);
    }
    function Yl(t, e) {
      const r = $l(e.lat, e.lng),
        n = function (t) {
          const e = $l(t._center.lat, t._center.lng);
          let r = tl([], No(0, 1, 0), e);
          const n = jo([], -t.angle, e);
          r = el(r, r, n), jo(n, -t._pitch, r);
          const i = Jo([], e);
          return Ho(i, i, zl(t.cameraToCenterDistance / t.pixelsPerMeter)), el(i, i, n), Go([], e, i);
        }(t);
      return a = (i = Xo([], n, r))[0], o = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], f = (p = Math.sqrt(a * a + o * o + l * l) * Math.sqrt(u * u + c * c + h * h)) && Qo(i, s) / p, Math.acos(Math.min(Math.max(f, -1), 1));
      var i, s, a, o, l, u, c, h, p, f;
    }
    function Hl(t, e) {
      return Yl(t, e) > Math.PI / 2 * 1.01;
    }
    const Wl = x(85),
      Jl = Math.cos(Wl),
      Ql = Math.sin(Wl),
      tu = 6371008.8,
      eu = 2 * Math.PI * tu;
    class ru {
      constructor(t, e) {
        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);
        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      }
      wrap() {
        return new ru(I(this.lng, -180, 180), this.lat);
      }
      toArray() {
        return [this.lng, this.lat];
      }
      toString() {
        return `LngLat(${this.lng}, ${this.lat})`;
      }
      distanceTo(t) {
        const e = Math.PI / 180,
          r = this.lat * e,
          n = t.lat * e,
          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);
        return tu * Math.acos(Math.min(i, 1));
      }
      toBounds(t = 0) {
        const e = 360 * t / 40075017,
          r = e / Math.cos(Math.PI / 180 * this.lat);
        return new Io(new ru(this.lng - r, this.lat - e), new ru(this.lng + r, this.lat + e));
      }
      toEcef(t) {
        const e = zl(t);
        return $l(this.lat, this.lng, Al + e);
      }
      static convert(t) {
        if (t instanceof ru) return t;
        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new ru(Number(t[0]), Number(t[1]));
        if (!Array.isArray(t) && "object" == typeof t && null !== t) return new ru(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      }
    }
    function nu(t) {
      return eu * Math.cos(t * Math.PI / 180);
    }
    function iu(t) {
      return (180 + t) / 360;
    }
    function su(t) {
      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;
    }
    function au(t, e) {
      return t / nu(e);
    }
    function ou(t) {
      return 360 * t - 180;
    }
    function lu(t) {
      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;
    }
    function uu(t, e) {
      return t * nu(lu(e));
    }
    const cu = 85.051129;
    function hu(t) {
      return 1 / Math.cos(t * Math.PI / 180);
    }
    class pu {
      constructor(t, e, r = 0) {
        this.x = +t, this.y = +e, this.z = +r;
      }
      static fromLngLat(t, e = 0) {
        const r = ru.convert(t);
        return new pu(iu(r.lng), su(r.lat), au(e, r.lat));
      }
      toLngLat() {
        return new ru(ou(this.x), lu(this.y));
      }
      toAltitude() {
        return uu(this.z, this.y);
      }
      meterInMercatorCoordinateUnits() {
        return 1 / eu * hu(lu(this.y));
      }
    }
    function fu(t, e, r, n, i, s, a, o, l) {
      const u = (e + n) / 2,
        c = (r + i) / 2,
        h = new d(u, c);
      o(h), function (t, e, r, n, i, s) {
        const a = r - i,
          o = n - s;
        return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o);
      }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (fu(t, e, r, u, c, s, h, o, l), fu(t, u, c, n, i, h, a, o, l)) : t.push(a);
    }
    function du(t, e, r) {
      let n = t[0],
        i = n.x,
        s = n.y;
      e(n);
      const a = [n];
      for (let o = 1; o < t.length; o++) {
        const l = t[o],
          {
            x: u,
            y: c
          } = l;
        e(l), fu(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;
      }
      return a;
    }
    function yu(t, e, r, n) {
      if (n(e, r)) {
        const i = e.add(r)._mult(.5);
        yu(t, e, i, n), yu(t, i, r, n);
      } else t.push(r);
    }
    function mu(t, e) {
      let r = t[0];
      const n = [r];
      for (let i = 1; i < t.length; i++) {
        const s = t[i];
        yu(n, r, s, e), r = s;
      }
      return n;
    }
    const gu = Math.pow(2, 14) - 1,
      xu = -gu - 1;
    function vu(t, e) {
      const r = Math.round(t.x * e),
        n = Math.round(t.y * e);
      return t.x = S(r, xu, gu), t.y = S(n, xu, gu), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && $("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t;
    }
    function bu(t, e, r) {
      const n = t.loadGeometry(),
        i = t.extent,
        s = ko / i;
      if (e && r && r.projection.isReprojectedInTileSpace) {
        const s = 1 << e.z,
          {
            scale: a,
            x: o,
            y: l,
            projection: u
          } = r,
          c = t => {
            const r = ou((e.x + t.x / i) / s),
              n = lu((e.y + t.y / i) / s),
              c = u.project(r, n);
            t.x = (c.x * a - o) * i, t.y = (c.y * a - l) * i;
          };
        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = du(n[e], c, 1);else {
          const t = [];
          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));
          n[e] = t;
        }
      }
      for (const t of n) for (const e of t) vu(e, s);
      return n;
    }
    function wu(t, e) {
      return {
        type: t.type,
        id: t.id,
        properties: t.properties,
        geometry: e ? bu(t) : []
      };
    }
    function _u(t, e, r, n, i) {
      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);
    }
    function Au(t, e, r) {
      const n = 16384;
      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
    }
    class Su {
      constructor(t) {
        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.segments = new So(), this.programConfigurations = new fo(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);
      }
      populate(t, e, r, n) {
        const i = this.layers[0],
          s = [];
        let a = null;
        "circle" === i.type && (a = i.layout.get("circle-sort-key"));
        for (const {
          feature: e,
          id: i,
          index: o,
          sourceLayerIndex: l
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            u = wu(e, t);
          if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u, r)) continue;
          const c = a ? a.evaluate(u, {}, r) : void 0,
            h = {
              id: i,
              properties: e.properties,
              type: e.type,
              sourceLayerIndex: l,
              index: o,
              geometry: t ? u.geometry : bu(e, r, n),
              patterns: {},
              sortKey: c
            };
          s.push(h);
        }
        a && s.sort((t, e) => t.sortKey - e.sortKey);
        let o = null;
        "globe" === n.projection.name && (this.globeExtVertexArray = new pa(), o = n.projection);
        for (const n of s) {
          const {
              geometry: i,
              index: s,
              sourceLayerIndex: a
            } = n,
            l = t[s].feature;
          this.addFeature(n, i, s, e.availableImages, r, o), e.featureIndex.insert(l, i, s, a, this.index);
        }
      }
      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _o.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Ao.members))), this.programConfigurations.upload(t), this.uploaded = !0;
      }
      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
      }
      addFeature(t, e, r, n, i, s) {
        for (const r of e) for (const e of r) {
          const r = e.x,
            n = e.y;
          if (r < 0 || r >= ko || n < 0 || n >= ko) continue;
          if (s) {
            const t = s.projectTilePoint(r, n, i),
              e = s.upVector(i, r, n),
              a = this.globeExtVertexArray;
            Au(a, t, e), Au(a, t, e), Au(a, t, e), Au(a, t, e);
          }
          const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),
            o = a.vertexLength;
          _u(this.layoutVertexArray, r, n, -1, -1), _u(this.layoutVertexArray, r, n, 1, -1), _u(this.layoutVertexArray, r, n, 1, 1), _u(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i);
      }
    }
    function ku(t, e) {
      for (let r = 0; r < t.length; r++) if (Du(e, t[r])) return !0;
      for (let r = 0; r < e.length; r++) if (Du(t, e[r])) return !0;
      return !!zu(t, e);
    }
    function Iu(t, e, r) {
      return !!Du(t, e) || !!Eu(e, t, r);
    }
    function Mu(t, e) {
      if (1 === t.length) return Pu(e, t[0]);
      for (let r = 0; r < e.length; r++) {
        const n = e[r];
        for (let e = 0; e < n.length; e++) if (Du(t, n[e])) return !0;
      }
      for (let r = 0; r < t.length; r++) if (Pu(e, t[r])) return !0;
      for (let r = 0; r < e.length; r++) if (zu(t, e[r])) return !0;
      return !1;
    }
    function Tu(t, e, r) {
      if (t.length > 1) {
        if (zu(t, e)) return !0;
        for (let n = 0; n < e.length; n++) if (Eu(e[n], t, r)) return !0;
      }
      for (let n = 0; n < t.length; n++) if (Eu(t[n], e, r)) return !0;
      return !1;
    }
    function zu(t, e) {
      if (0 === t.length || 0 === e.length) return !1;
      for (let r = 0; r < t.length - 1; r++) {
        const n = t[r],
          i = t[r + 1];
        for (let t = 0; t < e.length - 1; t++) if (Bu(n, i, e[t], e[t + 1])) return !0;
      }
      return !1;
    }
    function Bu(t, e, r, n) {
      return O(t, r, n) !== O(e, r, n) && O(t, e, r) !== O(t, e, n);
    }
    function Eu(t, e, r) {
      const n = r * r;
      if (1 === e.length) return t.distSqr(e[0]) < n;
      for (let r = 1; r < e.length; r++) if (Cu(t, e[r - 1], e[r]) < n) return !0;
      return !1;
    }
    function Cu(t, e, r) {
      const n = e.distSqr(r);
      if (0 === n) return t.distSqr(e);
      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;
      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
    }
    function Pu(t, e) {
      let r,
        n,
        i,
        s = !1;
      for (let a = 0; a < t.length; a++) {
        r = t[a];
        for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
      }
      return s;
    }
    function Du(t, e) {
      let r = !1;
      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {
        const s = t[n],
          a = t[i];
        s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);
      }
      return r;
    }
    function Vu(t, e, r, n, i) {
      for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;
      const s = [new d(e, r), new d(e, i), new d(n, i), new d(n, r)];
      if (t.length > 2) for (const e of s) if (Du(t, e)) return !0;
      for (let e = 0; e < t.length - 1; e++) if (Lu(t[e], t[e + 1], s)) return !0;
      return !1;
    }
    function Lu(t, e, r) {
      const n = r[0],
        i = r[2];
      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;
      const s = O(t, e, r[0]);
      return s !== O(t, e, r[1]) || s !== O(t, e, r[2]) || s !== O(t, e, r[3]);
    }
    function Fu(t, e, r) {
      const n = e.paint.get(t).value;
      return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);
    }
    function Ru(t) {
      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
    }
    function ju(t, e, r, n, i) {
      if (!e[0] && !e[1]) return t;
      const s = d.convert(e)._mult(i);
      "viewport" === r && s._rotate(-n);
      const a = [];
      for (let e = 0; e < t.length; e++) a.push(t[e].sub(s));
      return a;
    }
    function Uu(t, e, r, n) {
      const i = d.convert(t)._mult(n);
      return "viewport" === e && i._rotate(-r), i;
    }
    Oi(Su, "CircleBucket", {
      omit: ["layers"]
    });
    const $u = new Js({
      "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"])
    });
    var Ou = {
      paint: new Js({
        "circle-radius": new Hs(Ht.paint_circle["circle-radius"]),
        "circle-color": new Hs(Ht.paint_circle["circle-color"]),
        "circle-blur": new Hs(Ht.paint_circle["circle-blur"]),
        "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]),
        "circle-translate": new Ys(Ht.paint_circle["circle-translate"]),
        "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]),
        "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]),
        "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]),
        "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]),
        "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]),
        "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"])
      }),
      layout: $u
    };
    function qu(t, e, r, n, i, s, a, o, l) {
      if (s && t.queryGeometry.isAboveHorizon) return !1;
      s && (l *= t.pixelToTileUnitsFactor);
      const u = t.tileID.canonical,
        c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
      for (const h of e) for (const e of h) {
        const h = e.add(o),
          p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0,
          f = r.projection.projectTilePoint(h.x, h.y, u);
        if (p > 0) {
          const t = r.projection.upVector(u, h.x, h.y);
          f.x += t[0] * c * p, f.y += t[1] * c * p, f.z += t[2] * c * p;
        }
        const d = s ? h : Nu(f.x, f.y, f.z, n),
          y = s ? t.tilespaceRays.map(t => Zu(t, p)) : t.queryGeometry.screenGeometry,
          m = ul([], [f.x, f.y, f.z, 1], n);
        if (!a && s ? l *= m[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / m[3]), s) {
          const t = lu((e.y / ko + u.y) / (1 << u.z));
          l /= r.projection.pixelsPerMeter(t, 1) / au(1, t);
        }
        if (Iu(y, d, l)) return !0;
      }
      return !1;
    }
    function Nu(t, e, r, n) {
      const i = ul([], [t, e, r, 1], n);
      return new d(i[0] / i[3], i[1] / i[3]);
    }
    const Gu = No(0, 0, 0),
      Xu = No(0, 0, 1);
    function Zu(t, e) {
      const r = $o();
      return Gu[2] = e, t.intersectsPlane(Gu, Xu, r), new d(r[0], r[1]);
    }
    class Ku extends Su {}
    function Yu(t, {
      width: e,
      height: r
    }, n, i) {
      if (i) {
        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
      } else i = new Uint8Array(e * r * n);
      return t.width = e, t.height = r, t.data = i, t;
    }
    function Hu(t, e, r) {
      const {
        width: n,
        height: i
      } = e;
      n === t.width && i === t.height || (Wu(t, e, {
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }, {
        width: Math.min(t.width, n),
        height: Math.min(t.height, i)
      }, r), t.width = n, t.height = i, t.data = e.data);
    }
    function Wu(t, e, r, n, i, s) {
      if (0 === i.width || 0 === i.height) return e;
      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy");
      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
      const a = t.data,
        o = e.data;
      for (let l = 0; l < i.height; l++) {
        const u = ((r.y + l) * t.width + r.x) * s,
          c = ((n.y + l) * e.width + n.x) * s;
        for (let t = 0; t < i.width * s; t++) o[c + t] = a[u + t];
      }
      return e;
    }
    Oi(Ku, "HeatmapBucket", {
      omit: ["layers"]
    });
    class Ju {
      constructor(t, e) {
        Yu(this, t, 1, e);
      }
      resize(t) {
        Hu(this, new Ju(t), 1);
      }
      clone() {
        return new Ju({
          width: this.width,
          height: this.height
        }, new Uint8Array(this.data));
      }
      static copy(t, e, r, n, i) {
        Wu(t, e, r, n, i, 1);
      }
    }
    class Qu {
      constructor(t, e) {
        Yu(this, t, 4, e);
      }
      resize(t) {
        Hu(this, new Qu(t), 4);
      }
      replace(t, e) {
        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
      }
      clone() {
        return new Qu({
          width: this.width,
          height: this.height
        }, new Uint8Array(this.data));
      }
      static copy(t, e, r, n, i) {
        Wu(t, e, r, n, i, 4);
      }
    }
    Oi(Ju, "AlphaImage"), Oi(Qu, "RGBAImage");
    var tc = {
      paint: new Js({
        "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]),
        "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]),
        "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]),
        "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]),
        "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"])
      })
    };
    function ec(t) {
      const e = {},
        r = t.resolution || 256,
        n = t.clips ? t.clips.length : 1,
        i = t.image || new Qu({
          width: r,
          height: n
        }),
        s = (r, n, s) => {
          e[t.evaluationKey] = s;
          const a = t.expression.evaluate(e);
          i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);
        };
      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {
        const o = n / (r - 1),
          {
            start: l,
            end: u
          } = t.clips[e];
        s(i, a, l * (1 - o) + u * o);
      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));
      return i;
    }
    var rc = {
      paint: new Js({
        "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]),
        "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]),
        "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]),
        "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]),
        "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]),
        "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"])
      })
    };
    const nc = na([{
        name: "a_pos",
        components: 2,
        type: "Int16"
      }], 4),
      {
        members: ic
      } = nc;
    var sc = {};
    function ac(t, e, r) {
      r = r || 2;
      var n,
        i,
        s,
        a,
        o,
        l,
        u,
        c = e && e.length,
        h = c ? e[0] * r : t.length,
        p = oc(t, 0, h, r, !0),
        f = [];
      if (!p || p.next === p.prev) return f;
      if (c && (p = function (t, e, r, n) {
        var i,
          s,
          a,
          o = [];
        for (i = 0, s = e.length; i < s; i++) (a = oc(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(xc(a));
        for (o.sort(dc), i = 0; i < o.length; i++) r = yc(o[i], r);
        return r;
      }(t, e, p, r)), t.length > 80 * r) {
        n = s = t[0], i = a = t[1];
        for (var d = r; d < h; d += r) (o = t[d]) < n && (n = o), (l = t[d + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);
        u = 0 !== (u = Math.max(s - n, a - i)) ? 32767 / u : 0;
      }
      return uc(p, f, r, n, i, u, 0), f;
    }
    function oc(t, e, r, n, i) {
      var s, a;
      if (i === Ec(t, e, r, n) > 0) for (s = e; s < r; s += n) a = Tc(s, t[s], t[s + 1], a);else for (s = r - n; s >= e; s -= n) a = Tc(s, t[s], t[s + 1], a);
      return a && _c(a, a.next) && (zc(a), a = a.next), a;
    }
    function lc(t, e) {
      if (!t) return t;
      e || (e = t);
      var r,
        n = t;
      do {
        if (r = !1, n.steiner || !_c(n, n.next) && 0 !== wc(n.prev, n, n.next)) n = n.next;else {
          if (zc(n), (n = e = n.prev) === n.next) break;
          r = !0;
        }
      } while (r || n !== e);
      return e;
    }
    function uc(t, e, r, n, i, s, a) {
      if (t) {
        !a && s && function (t, e, r, n) {
          var i = t;
          do {
            0 === i.z && (i.z = gc(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
          } while (i !== t);
          i.prevZ.nextZ = null, i.prevZ = null, function (t) {
            var e,
              r,
              n,
              i,
              s,
              a,
              o,
              l,
              u = 1;
            do {
              for (r = t, t = null, s = null, a = 0; r;) {
                for (a++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);
                for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
                r = n;
              }
              s.nextZ = null, u *= 2;
            } while (a > 1);
          }(i);
        }(t, n, i, s);
        for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? hc(t, n, i, s) : cc(t)) e.push(o.i / r | 0), e.push(t.i / r | 0), e.push(l.i / r | 0), zc(t), t = l.next, u = l.next;else if ((t = l) === u) {
          a ? 1 === a ? uc(t = pc(lc(t), e, r), e, r, n, i, s, 2) : 2 === a && fc(t, e, r, n, i, s) : uc(lc(t), e, r, n, i, s, 1);
          break;
        }
      }
    }
    function cc(t) {
      var e = t.prev,
        r = t,
        n = t.next;
      if (wc(e, r, n) >= 0) return !1;
      for (var i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, f = o > l ? o > u ? o : u : l > u ? l : u, d = n.next; d !== e;) {
        if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && vc(i, o, s, l, a, u, d.x, d.y) && wc(d.prev, d, d.next) >= 0) return !1;
        d = d.next;
      }
      return !0;
    }
    function hc(t, e, r, n) {
      var i = t.prev,
        s = t,
        a = t.next;
      if (wc(i, s, a) >= 0) return !1;
      for (var o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = gc(f, d, e, r, n), x = gc(y, m, e, r, n), v = t.prevZ, b = t.nextZ; v && v.z >= g && b && b.z <= x;) {
        if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && vc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0) return !1;
        if (v = v.prevZ, b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && vc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0) return !1;
        b = b.nextZ;
      }
      for (; v && v.z >= g;) {
        if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && vc(o, c, l, h, u, p, v.x, v.y) && wc(v.prev, v, v.next) >= 0) return !1;
        v = v.prevZ;
      }
      for (; b && b.z <= x;) {
        if (b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && vc(o, c, l, h, u, p, b.x, b.y) && wc(b.prev, b, b.next) >= 0) return !1;
        b = b.nextZ;
      }
      return !0;
    }
    function pc(t, e, r) {
      var n = t;
      do {
        var i = n.prev,
          s = n.next.next;
        !_c(i, s) && Ac(i, n, n.next, s) && Ic(i, s) && Ic(s, i) && (e.push(i.i / r | 0), e.push(n.i / r | 0), e.push(s.i / r | 0), zc(n), zc(n.next), n = t = s), n = n.next;
      } while (n !== t);
      return lc(n);
    }
    function fc(t, e, r, n, i, s) {
      var a = t;
      do {
        for (var o = a.next.next; o !== a.prev;) {
          if (a.i !== o.i && bc(a, o)) {
            var l = Mc(a, o);
            return a = lc(a, a.next), l = lc(l, l.next), uc(a, e, r, n, i, s, 0), void uc(l, e, r, n, i, s, 0);
          }
          o = o.next;
        }
        a = a.next;
      } while (a !== t);
    }
    function dc(t, e) {
      return t.x - e.x;
    }
    function yc(t, e) {
      var r = function (t, e) {
        var r,
          n = e,
          i = t.x,
          s = t.y,
          a = -1 / 0;
        do {
          if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
            var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (o <= i && o > a && (a = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;
          }
          n = n.next;
        } while (n !== e);
        if (!r) return null;
        var l,
          u = r,
          c = r.x,
          h = r.y,
          p = 1 / 0;
        n = r;
        do {
          i >= n.x && n.x >= c && i !== n.x && vc(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), Ic(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && mc(r, n))) && (r = n, p = l)), n = n.next;
        } while (n !== u);
        return r;
      }(t, e);
      if (!r) return e;
      var n = Mc(r, t);
      return lc(n, n.next), lc(r, r.next);
    }
    function mc(t, e) {
      return wc(t.prev, t, e.prev) < 0 && wc(e.next, t, t.next) < 0;
    }
    function gc(t, e, r, n, i) {
      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
    }
    function xc(t) {
      var e = t,
        r = t;
      do {
        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
      } while (e !== t);
      return r;
    }
    function vc(t, e, r, n, i, s, a, o) {
      return (i - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o);
    }
    function bc(t, e) {
      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
        var r = t;
        do {
          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Ac(r, r.next, t, e)) return !0;
          r = r.next;
        } while (r !== t);
        return !1;
      }(t, e) && (Ic(t, e) && Ic(e, t) && function (t, e) {
        var r = t,
          n = !1,
          i = (t.x + e.x) / 2,
          s = (t.y + e.y) / 2;
        do {
          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
        } while (r !== t);
        return n;
      }(t, e) && (wc(t.prev, t, e.prev) || wc(t, e.prev, e)) || _c(t, e) && wc(t.prev, t, t.next) > 0 && wc(e.prev, e, e.next) > 0);
    }
    function wc(t, e, r) {
      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);
    }
    function _c(t, e) {
      return t.x === e.x && t.y === e.y;
    }
    function Ac(t, e, r, n) {
      var i = kc(wc(t, e, r)),
        s = kc(wc(t, e, n)),
        a = kc(wc(r, n, t)),
        o = kc(wc(r, n, e));
      return i !== s && a !== o || !(0 !== i || !Sc(t, r, e)) || !(0 !== s || !Sc(t, n, e)) || !(0 !== a || !Sc(r, t, n)) || !(0 !== o || !Sc(r, e, n));
    }
    function Sc(t, e, r) {
      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);
    }
    function kc(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }
    function Ic(t, e) {
      return wc(t.prev, t, t.next) < 0 ? wc(t, e, t.next) >= 0 && wc(t, t.prev, e) >= 0 : wc(t, e, t.prev) < 0 || wc(t, t.next, e) < 0;
    }
    function Mc(t, e) {
      var r = new Bc(t.i, t.x, t.y),
        n = new Bc(e.i, e.x, e.y),
        i = t.next,
        s = e.prev;
      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
    }
    function Tc(t, e, r, n) {
      var i = new Bc(t, e, r);
      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
    }
    function zc(t) {
      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }
    function Bc(t, e, r) {
      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
    }
    function Ec(t, e, r, n) {
      for (var i = 0, s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;
      return i;
    }
    function Cc(t, e, r, n, i) {
      Pc(t, e, r || 0, n || t.length - 1, i || Vc);
    }
    function Pc(t, e, r, n, i) {
      for (; n > r;) {
        if (n - r > 600) {
          var s = n - r + 1,
            a = e - r + 1,
            o = Math.log(s),
            l = .5 * Math.exp(2 * o / 3),
            u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
          Pc(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);
        }
        var c = t[e],
          h = r,
          p = n;
        for (Dc(t, r, e), i(t[n], c) > 0 && Dc(t, r, n); h < p;) {
          for (Dc(t, h, p), h++, p--; i(t[h], c) < 0;) h++;
          for (; i(t[p], c) > 0;) p--;
        }
        0 === i(t[r], c) ? Dc(t, r, p) : Dc(t, ++p, n), p <= e && (r = p + 1), e <= p && (n = p - 1);
      }
    }
    function Dc(t, e, r) {
      var n = t[e];
      t[e] = t[r], t[r] = n;
    }
    function Vc(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }
    function Lc(t, e) {
      const r = t.length;
      if (r <= 1) return [t];
      const n = [];
      let i, s;
      for (let e = 0; e < r; e++) {
        const r = q(t[e]);
        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));
      }
      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (Cc(n[t], e, 1, n[t].length - 1, Fc), n[t] = n[t].slice(0, e));
      return n;
    }
    function Fc(t, e) {
      return e.area - t.area;
    }
    function Rc(t, e, r) {
      const n = r.patternDependencies;
      let i = !1;
      for (const r of e) {
        const e = r.paint.get(`${t}-pattern`);
        e.isConstant() || (i = !0);
        const s = e.constantOr(null);
        s && (i = !0, n[s] = !0);
      }
      return i;
    }
    function jc(t, e, r, n, i) {
      const s = i.patternDependencies;
      for (const a of e) {
        const e = a.paint.get(`${t}-pattern`).value;
        if ("constant" !== e.kind) {
          let t = e.evaluate({
            zoom: n
          }, r, {}, i.availableImages);
          t = t && t.name ? t.name : t, s[t] = !0, r.patterns[a.id] = t;
        }
      }
      return r;
    }
    ({
      get exports() {
        return sc;
      },
      set exports(t) {
        sc = t;
      }
    }).exports = ac, sc.default = ac, ac.deviation = function (t, e, r, n) {
      var i = e && e.length,
        s = Math.abs(Ec(t, 0, i ? e[0] * r : t.length, r));
      if (i) for (var a = 0, o = e.length; a < o; a++) s -= Math.abs(Ec(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));
      var l = 0;
      for (a = 0; a < n.length; a += 3) {
        var u = n[a] * r,
          c = n[a + 1] * r,
          h = n[a + 2] * r;
        l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));
      }
      return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);
    }, ac.flatten = function (t) {
      for (var e = t[0][0].length, r = {
          vertices: [],
          holes: [],
          dimensions: e
        }, n = 0, i = 0; i < t.length; i++) {
        for (var s = 0; s < t[i].length; s++) for (var a = 0; a < e; a++) r.vertices.push(t[i][s][a]);
        i > 0 && r.holes.push(n += t[i - 1].length);
      }
      return r;
    };
    class Uc {
      constructor(t) {
        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new sa(), this.indexArray = new wa(), this.indexArray2 = new Ma(), this.programConfigurations = new fo(t.layers, t.zoom), this.segments = new So(), this.segments2 = new So(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection;
      }
      populate(t, e, r, n) {
        this.hasPattern = Rc("fill", this.layers, e);
        const i = this.layers[0].layout.get("fill-sort-key"),
          s = [];
        for (const {
          feature: a,
          id: o,
          index: l,
          sourceLayerIndex: u
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            c = wu(a, t);
          if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), c, r)) continue;
          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,
            p = {
              id: o,
              properties: a.properties,
              type: a.type,
              sourceLayerIndex: u,
              index: l,
              geometry: t ? c.geometry : bu(a, r, n),
              patterns: {},
              sortKey: h
            };
          s.push(p);
        }
        i && s.sort((t, e) => t.sortKey - e.sortKey);
        for (const n of s) {
          const {
            geometry: i,
            index: s,
            sourceLayerIndex: a
          } = n;
          if (this.hasPattern) {
            const t = jc("fill", this.layers, n, this.zoom, e);
            this.patternFeatures.push(t);
          } else this.addFeature(n, i, s, r, {}, e.availableImages);
          e.featureIndex.insert(t[s].feature, i, s, a, this.index);
        }
      }
      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }
      addFeatures(t, e, r, n, i) {
        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ic), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
      }
      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }
      addFeature(t, e, r, n, i, s = []) {
        for (const t of Lc(e, 500)) {
          let e = 0;
          for (const r of t) e += r.length;
          const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),
            n = r.vertexLength,
            i = [],
            s = [];
          for (const e of t) {
            if (0 === e.length) continue;
            e !== t[0] && s.push(i.length / 2);
            const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),
              n = r.vertexLength;
            this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);
            for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);
            r.vertexLength += e.length, r.primitiveLength += e.length;
          }
          const a = sc(i, s);
          for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);
          r.vertexLength += e, r.primitiveLength += a.length / 3;
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
      }
    }
    Oi(Uc, "FillBucket", {
      omit: ["layers", "patternFeatures"]
    });
    const $c = new Js({
      "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"])
    });
    var Oc = {
      paint: new Js({
        "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]),
        "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]),
        "fill-color": new Hs(Ht.paint_fill["fill-color"]),
        "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]),
        "fill-translate": new Ys(Ht.paint_fill["fill-translate"]),
        "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]),
        "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"])
      }),
      layout: $c
    };
    const qc = na([{
        name: "a_pos_normal_ed",
        components: 4,
        type: "Int16"
      }]),
      Nc = na([{
        name: "a_centroid_pos",
        components: 2,
        type: "Uint16"
      }]),
      Gc = na([{
        name: "a_pos_3",
        components: 3,
        type: "Int16"
      }, {
        name: "a_pos_normal_3",
        components: 3,
        type: "Int16"
      }]),
      {
        members: Xc
      } = qc;
    var Zc = {},
      Kc = d,
      Yc = Hc;
    function Hc(t, e, r, n, i) {
      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(Wc, this, e);
    }
    function Wc(t, e, r) {
      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {
        for (var r = t.readVarint() + t.pos; t.pos < r;) {
          var n = e._keys[t.readVarint()],
            i = e._values[t.readVarint()];
          e.properties[n] = i;
        }
      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);
    }
    function Jc(t) {
      for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);
      return n;
    }
    Hc.types = ["Unknown", "Point", "LineString", "Polygon"], Hc.prototype.loadGeometry = function () {
      var t = this._pbf;
      t.pos = this._geometry;
      for (var e, r = t.readVarint() + t.pos, n = 1, i = 0, s = 0, a = 0, o = []; t.pos < r;) {
        if (i <= 0) {
          var l = t.readVarint();
          n = 7 & l, i = l >> 3;
        }
        if (i--, 1 === n || 2 === n) s += t.readSVarint(), a += t.readSVarint(), 1 === n && (e && o.push(e), e = []), e.push(new Kc(s, a));else {
          if (7 !== n) throw new Error("unknown command " + n);
          e && e.push(e[0].clone());
        }
      }
      return e && o.push(e), o;
    }, Hc.prototype.bbox = function () {
      var t = this._pbf;
      t.pos = this._geometry;
      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {
        if (n <= 0) {
          var c = t.readVarint();
          r = 7 & c, n = c >> 3;
        }
        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error("unknown command " + r);
      }
      return [a, l, o, u];
    }, Hc.prototype.toGeoJSON = function (t, e, r) {
      var n,
        i,
        s = this.extent * Math.pow(2, r),
        a = this.extent * t,
        o = this.extent * e,
        l = this.loadGeometry(),
        u = Hc.types[this.type];
      function c(t) {
        for (var e = 0; e < t.length; e++) {
          var r = t[e];
          t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];
        }
      }
      switch (this.type) {
        case 1:
          var h = [];
          for (n = 0; n < l.length; n++) h[n] = l[n][0];
          c(l = h);
          break;
        case 2:
          for (n = 0; n < l.length; n++) c(l[n]);
          break;
        case 3:
          for (l = function (t) {
            var e = t.length;
            if (e <= 1) return [t];
            for (var r, n, i = [], s = 0; s < e; s++) {
              var a = Jc(t[s]);
              0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));
            }
            return r && i.push(r), i;
          }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);
      }
      1 === l.length ? l = l[0] : u = "Multi" + u;
      var p = {
        type: "Feature",
        geometry: {
          type: u,
          coordinates: l
        },
        properties: this.properties
      };
      return "id" in this && (p.id = this.id), p;
    };
    var Qc = Yc,
      th = eh;
    function eh(t, e) {
      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(rh, this, e), this.length = this._features.length;
    }
    function rh(t, e, r) {
      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {
        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {
          var n = t.readVarint() >> 3;
          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;
        }
        return e;
      }(r));
    }
    eh.prototype.feature = function (t) {
      if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
      this._pbf.pos = this._features[t];
      var e = this._pbf.readVarint() + this._pbf.pos;
      return new Qc(this._pbf, e, this.extent, this._keys, this._values);
    };
    var nh = th;
    function ih(t, e, r) {
      if (3 === t) {
        var n = new nh(r, r.readVarint() + r.pos);
        n.length && (e[n.name] = n);
      }
    }
    var sh = Zc.VectorTile = function (t, e) {
        this.layers = t.readFields(ih, {}, e);
      },
      ah = Zc.VectorTileFeature = Yc;
    function oh(t, e, r, n) {
      const i = [],
        s = 0 === n ? (t, e, r, n, i, s) => {
          t.push(new d(s, r + (s - e) / (n - e) * (i - r)));
        } : (t, e, r, n, i, s) => {
          t.push(new d(e + (s - r) / (i - r) * (n - e), s));
        };
      for (const a of t) {
        const t = [];
        for (const i of a) {
          if (i.length <= 2) continue;
          const a = [];
          for (let t = 0; t < i.length - 1; t++) {
            const o = i[t].x,
              l = i[t].y,
              u = i[t + 1].x,
              c = i[t + 1].y,
              h = 0 === n ? o : l,
              p = 0 === n ? u : c;
            h < e ? p > e && s(a, o, l, u, c, e) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t]), p < e && h >= e && s(a, o, l, u, c, e), p > r && h <= r && s(a, o, l, u, c, r);
          }
          let o = i[i.length - 1];
          const l = 0 === n ? o.x : o.y;
          l >= e && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t.push(a));
        }
        t.length && i.push(t);
      }
      return i;
    }
    Zc.VectorTileLayer = th;
    const lh = ah.types,
      uh = Math.pow(2, 13);
    function ch(t, e, r, n, i, s, a, o) {
      t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * uh) << 1) + i, Math.round(o));
    }
    function hh(t, e, r) {
      const n = 16384;
      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
    }
    class ph {
      constructor() {
        this.acc = new d(0, 0), this.polyCount = [];
      }
      startRing(t) {
        this.currentPolyCount = {
          edges: 0,
          top: 0
        }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d(t.x, t.y), this.max = new d(t.x, t.y));
      }
      append(t, e) {
        this.currentPolyCount.edges++, this.acc._add(t);
        const r = this.min,
          n = this.max;
        t.x < r.x ? r.x = t.x : t.x > n.x && (n.x = t.x), t.y < r.y ? r.y = t.y : t.y > n.y && (n.y = t.y), ((0 === t.x || t.x === ko) && t.x === e.x) != ((0 === t.y || t.y === ko) && t.y === e.y) && this.processBorderOverlap(t, e), e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Mr(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > ko != t.x > ko && this.addBorderIntersection(1, Mr(e.y, t.y, (ko - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Mr(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > ko != t.y > ko && this.addBorderIntersection(3, Mr(e.x, t.x, (ko - e.y) / (t.y - e.y)));
      }
      addBorderIntersection(t, e) {
        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
        const r = this.borders[t];
        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
      }
      processBorderOverlap(t, e) {
        if (t.x === e.x) {
          if (t.y === e.y) return;
          const r = 0 === t.x ? 0 : 1;
          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);
        } else {
          const r = 0 === t.y ? 2 : 3;
          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);
        }
      }
      centroid() {
        const t = this.polyCount.reduce((t, e) => t + e.edges, 0);
        return 0 !== t ? this.acc.div(t)._round() : new d(0, 0);
      }
      span() {
        return new d(this.max.x - this.min.x, this.max.y - this.min.y);
      }
      intersectsCount() {
        return this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0);
      }
    }
    class fh {
      constructor(t) {
        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t.projection, this.layoutVertexArray = new oa(), this.centroidVertexArray = new Ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t.layers, t.zoom), this.segments = new So(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.enableTerrain = t.enableTerrain;
      }
      populate(t, e, r, n) {
        this.features = [], this.hasPattern = Rc("fill-extrusion", this.layers, e), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function (t) {
          const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));
          return 80150034 * e / (e * e + 1) / ko / (1 << t.z);
        }(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
        for (const {
          feature: i,
          id: s,
          index: a,
          sourceLayerIndex: o
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            l = wu(i, t);
          if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), l, r)) continue;
          const u = {
              id: s,
              sourceLayerIndex: o,
              index: a,
              geometry: t ? l.geometry : bu(i, r, n),
              properties: i.properties,
              type: i.type,
              patterns: {}
            },
            c = this.layoutVertexArray.length;
          this.hasPattern ? this.features.push(jc("fill-extrusion", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n), e.featureIndex.insert(i, u.geometry, a, o, this.index, c);
        }
        this.sortBorders();
      }
      addFeatures(t, e, r, n, i) {
        for (const t of this.features) {
          const {
            geometry: s
          } = t;
          this.addFeature(t, s, t.index, e, r, n, i);
        }
        this.sortBorders();
      }
      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Xc), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Gc.members, !0))), this.programConfigurations.upload(t), this.uploaded = !0;
      }
      uploadCentroid(t) {
        0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Nc.members, !0), this.needsCentroidUpdate = !1);
      }
      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }
      addFeature(t, e, r, n, i, s, a) {
        const o = [new d(0, 0), new d(ko, ko)],
          l = a.projection,
          u = "globe" === l.name,
          c = this.enableTerrain && !u ? new ph() : null,
          h = "Polygon" === lh[t.type];
        u && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa());
        const p = Lc(e, 500);
        for (let t = p.length - 1; t >= 0; t--) {
          const e = p[t];
          (0 === e.length || (f = e[0]).every(t => t.x <= 0) || f.every(t => t.x >= ko) || f.every(t => t.y <= 0) || f.every(t => t.y >= ko)) && p.splice(t, 1);
        }
        var f;
        let y;
        if (u) y = wh(p, o, n);else {
          y = [];
          for (const t of p) y.push({
            polygon: t,
            bounds: o
          });
        }
        const m = h ? this.edgeRadius : 0;
        for (const {
          polygon: t,
          bounds: e
        } of y) {
          let r = 0,
            i = 0;
          for (const e of t) h && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += h ? e.length - 1 : e.length;
          const s = this.segments.prepareSegment((h ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);
          if (h) {
            const e = [],
              i = [];
            r = s.vertexLength;
            for (const r of t) {
              let a, o;
              r.length && r !== t[0] && i.push(e.length / 2), a = r[1].sub(r[0])._perp()._unit();
              for (let t = 1; t < r.length; t++) {
                const i = r[t],
                  c = r[t === r.length - 1 ? 1 : t + 1];
                let {
                  x: h,
                  y: p
                } = i;
                if (m) {
                  o = c.sub(i)._perp()._unit();
                  const t = a.add(o)._unit(),
                    e = m * Math.min(4, 1 / (a.x * t.x + a.y * t.y));
                  h += e * t.x, p += e * t.y, a = o;
                }
                ch(this.layoutVertexArray, h, p, 0, 0, 1, 1, 0), s.vertexLength++, e.push(i.x, i.y), u && hh(this.layoutVertexExtArray, l.projectTilePoint(h, p, n), l.upVector(n, h, p));
              }
            }
            const a = sc(e, i);
            for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(r + a[t], r + a[t + 2], r + a[t + 1]), s.primitiveLength++;
          }
          for (const i of t) {
            c && i.length && c.startRing(i[0]);
            let t,
              a,
              o,
              p = i.length > 4 && xh(i[i.length - 2], i[0], i[1]),
              f = m ? yh(i[i.length - 2], i[0], i[1], m) : 0;
            a = i[1].sub(i[0])._perp()._unit();
            let d = !0;
            for (let y = 1, g = 0; y < i.length; y++) {
              let x = i[y - 1],
                v = i[y];
              const b = i[y === i.length - 1 ? 1 : y + 1];
              if (c && h && c.currentPolyCount.top++, gh(v, x, e)) {
                m && (a = b.sub(v)._perp()._unit(), d = !d);
                continue;
              }
              c && c.append(v, x);
              const w = v.sub(x)._perp(),
                _ = w.x / (Math.abs(w.x) + Math.abs(w.y)),
                A = w.y > 0 ? 1 : 0,
                S = x.dist(v);
              if (g + S > 32768 && (g = 0), m) {
                o = b.sub(v)._perp()._unit();
                let t = mh(x, v, b, dh(a, o), m);
                isNaN(t) && (t = 0);
                const e = v.sub(x)._unit();
                x = x.add(e.mult(f))._round(), v = v.add(e.mult(-t))._round(), f = t, a = o;
              }
              const k = s.vertexLength,
                I = i.length > 4 && xh(x, v, b);
              let M = vh(g, p, d);
              if (ch(this.layoutVertexArray, x.x, x.y, _, A, 0, 0, M), ch(this.layoutVertexArray, x.x, x.y, _, A, 0, 1, M), g += S, M = vh(g, I, !d), p = I, ch(this.layoutVertexArray, v.x, v.y, _, A, 0, 0, M), ch(this.layoutVertexArray, v.x, v.y, _, A, 0, 1, M), s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, m) {
                const n = r + (1 === y ? i.length - 2 : y - 2),
                  a = 1 === y ? r : n + 1;
                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, a, k + 3), s.primitiveLength += 2, void 0 === t && (t = k), !gh(b, i[y], e)) {
                  const e = y === i.length - 1 ? t : s.vertexLength;
                  this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, a, e + 1), s.primitiveLength += 3;
                }
                d = !d;
              }
              if (u) {
                const t = this.layoutVertexExtArray,
                  e = l.projectTilePoint(x.x, x.y, n),
                  r = l.projectTilePoint(v.x, v.y, n),
                  i = l.upVector(n, x.x, x.y),
                  s = l.upVector(n, v.x, v.y);
                hh(t, e, i), hh(t, e, i), hh(t, r, s), hh(t, r, s);
              }
            }
            h && (r += i.length - 1);
          }
        }
        if (c && c.polyCount.length > 0) {
          if (c.borders) {
            c.vertexArrayOffset = this.centroidVertexArray.length;
            const t = c.borders,
              e = this.featuresOnBorder.push(c) - 1;
            for (let r = 0; r < 4; r++) t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);
          }
          this.encodeCentroid(c.borders ? void 0 : c.centroid(), c);
        }
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
      }
      sortBorders() {
        for (let t = 0; t < 4; t++) this.borders[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);
      }
      encodeCentroid(t, e, r = !0) {
        let n, i;
        if (t) {
          if (0 !== t.y) {
            const r = e.span()._mult(this.tileToMeter);
            n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));
          } else n = Math.ceil(7 * (t.x + 450)), i = 0;
        } else n = 0, i = +r;
        let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;
        for (const t of e.polyCount) {
          r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);
          for (let e = 0; e < t.top; e++) this.centroidVertexArray.emplace(s++, n, i);
          for (let e = 0; e < 2 * t.edges; e++) this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);
        }
      }
    }
    function dh(t, e) {
      const r = t.add(e)._unit();
      return t.x * r.x + t.y * r.y;
    }
    function yh(t, e, r, n) {
      const i = e.sub(t)._perp()._unit(),
        s = r.sub(e)._perp()._unit();
      return mh(t, e, r, dh(i, s), n);
    }
    function mh(t, e, r, n, i) {
      const s = Math.sqrt(1 - n * n);
      return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * s / n);
    }
    function gh(t, e, r) {
      return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y;
    }
    function xh(t, e, r) {
      if (t.x < 0 || t.x >= ko || e.x < 0 || e.x >= ko || r.x < 0 || r.x >= ko) return !1;
      const n = r.sub(e),
        i = n.perp(),
        s = t.sub(e);
      return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;
    }
    function vh(t, e, r) {
      const n = e ? 2 | t : -3 & t;
      return r ? 1 | n : -2 & n;
    }
    function bh() {
      const t = Math.PI / 32,
        e = Math.tan(t),
        r = tu;
      return r * Math.sqrt(1 + 2 * e * e) - r;
    }
    function wh(t, e, r) {
      const n = 1 << r.z,
        i = ou(r.x / n),
        s = ou((r.x + 1) / n),
        a = lu(r.y / n),
        o = lu((r.y + 1) / n);
      return function (t, e, r, n, i = 0, s) {
        const a = [];
        if (!t.length || !r || !n) return a;
        const o = (t, e) => {
            for (const r of t) a.push({
              polygon: r,
              bounds: e
            });
          },
          l = Math.ceil(Math.log2(r)),
          u = Math.ceil(Math.log2(n)),
          c = l - u,
          h = [];
        for (let t = 0; t < Math.abs(c); t++) h.push(c > 0 ? 0 : 1);
        for (let t = 0; t < Math.min(l, u); t++) h.push(0), h.push(1);
        let p = t;
        if (p = oh(p, e[0].y - i, e[1].y + i, 1), p = oh(p, e[0].x - i, e[1].x + i, 0), !p.length) return a;
        const f = [];
        for (h.length ? f.push({
          polygons: p,
          bounds: e,
          depth: 0
        }) : o(p, e); f.length;) {
          const t = f.pop(),
            e = t.depth,
            r = h[e],
            n = t.bounds[0],
            a = t.bounds[1],
            l = 0 === r ? n.x : n.y,
            u = 0 === r ? a.x : a.y,
            c = s ? s(r, l, u) : .5 * (l + u),
            p = oh(t.polygons, l - i, c + i, r),
            y = oh(t.polygons, c - i, u + i, r);
          if (p.length) {
            const t = [n, new d(0 === r ? c : a.x, 1 === r ? c : a.y)];
            h.length > e + 1 ? f.push({
              polygons: p,
              bounds: t,
              depth: e + 1
            }) : o(p, t);
          }
          if (y.length) {
            const t = [new d(0 === r ? c : n.x, 1 === r ? c : n.y), a];
            h.length > e + 1 ? f.push({
              polygons: y,
              bounds: t,
              depth: e + 1
            }) : o(y, t);
          }
        }
        return a;
      }(t, e, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t, e, i) => {
        if (0 === t) return .5 * (e + i);
        {
          const t = lu((r.y + e / ko) / n);
          return (su(.5 * (lu((r.y + i / ko) / n) + t)) * n - r.y) * ko;
        }
      });
    }
    Oi(fh, "FillExtrusionBucket", {
      omit: ["layers", "features"]
    }), Oi(ph, "PartMetadata");
    const _h = new Js({
      "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
    });
    var Ah = {
      paint: new Js({
        "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]),
        "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]),
        "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]),
        "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
        "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]),
        "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]),
        "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]),
        "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
        "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
        "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"])
      }),
      layout: _h
    };
    function Sh(t, e, r) {
      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];
    }
    class kh {
      constructor(t, e, r) {
        this.z = t, this.x = e, this.y = r, this.key = Th(0, t, t, e, r);
      }
      equals(t) {
        return this.z === t.z && this.x === t.x && this.y === t.y;
      }
      url(t, e) {
        const r = function (t, e, r) {
            var n = Sh(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r),
              i = Sh(256 * (t + 1), 256 * (e + 1), r);
            return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
          }(this.x, this.y, this.z),
          n = function (t, e, r) {
            let n,
              i = "";
            for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);
            return i;
          }(this.z, this.x, this.y);
        return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
      }
      toString() {
        return `${this.z}/${this.x}/${this.y}`;
      }
    }
    class Ih {
      constructor(t, e) {
        this.wrap = t, this.canonical = e, this.key = Th(t, e.z, e.z, e.x, e.y);
      }
    }
    class Mh {
      constructor(t, e, r, n, i) {
        this.overscaledZ = t, this.wrap = e, this.canonical = new kh(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : Th(e, t, r, n, i);
      }
      equals(t) {
        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
      }
      scaledTo(t) {
        const e = this.canonical.z - t;
        return t > this.canonical.z ? new Mh(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mh(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);
      }
      calculateScaledKey(t, e = !0) {
        if (this.overscaledZ === t && e) return this.key;
        if (t > this.canonical.z) return Th(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);
        {
          const r = this.canonical.z - t;
          return Th(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);
        }
      }
      isChildOf(t) {
        if (t.wrap !== this.wrap) return !1;
        const e = this.canonical.z - t.canonical.z;
        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;
      }
      children(t) {
        if (this.overscaledZ >= t) return [new Mh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        const e = this.canonical.z + 1,
          r = 2 * this.canonical.x,
          n = 2 * this.canonical.y;
        return [new Mh(e, this.wrap, e, r, n), new Mh(e, this.wrap, e, r + 1, n), new Mh(e, this.wrap, e, r, n + 1), new Mh(e, this.wrap, e, r + 1, n + 1)];
      }
      isLessThan(t) {
        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
      }
      wrapped() {
        return new Mh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }
      unwrapTo(t) {
        return new Mh(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
      }
      overscaleFactor() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }
      toUnwrapped() {
        return new Ih(this.wrap, this.canonical);
      }
      toString() {
        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
      }
    }
    function Th(t, e, r, n, i) {
      const s = 1 << Math.min(r, 22);
      let a = s * (i % s) + n % s;
      return t && r < 22 && (a += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);
    }
    Oi(kh, "CanonicalTileID"), Oi(Mh, "OverscaledTileID", {
      omit: ["projMatrix"]
    });
    class zh extends d {
      constructor(t, e, r) {
        super(t, e), this.z = r;
      }
    }
    function Bh(t, e) {
      return t.x * e.x + t.y * e.y;
    }
    function Eh(t, e) {
      if (1 === t.length) {
        let r = 0;
        const n = e[r++];
        let i;
        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;
        for (; r < e.length; r++) {
          const s = e[r],
            a = t[0],
            o = i.sub(n),
            l = s.sub(n),
            u = a.sub(n),
            c = Bh(o, o),
            h = Bh(o, l),
            p = Bh(l, l),
            f = Bh(u, o),
            d = Bh(u, l),
            y = c * p - h * h,
            m = (p * f - h * d) / y,
            g = (c * d - h * f) / y,
            x = n.z * (1 - m - g) + i.z * m + s.z * g;
          if (isFinite(x)) return x;
        }
        return 1 / 0;
      }
      {
        let t = 1 / 0;
        for (const r of e) t = Math.min(t, r.z);
        return t;
      }
    }
    function Ch(t, e, r, n, i, s, a, o) {
      const l = a * i.getElevationAt(t, e, !0, !0),
        u = 0 !== s[0],
        c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function (t, e, r) {
          const n = Math.floor(e[0] / 8),
            i = Math.floor(e[1] / 8),
            s = 10 * (e[0] - 8 * n),
            a = 10 * (e[1] - 8 * i),
            o = t.getElevationAt(n, i, !0, !0),
            l = t.getMeterToDEM(r),
            u = Math.floor(.5 * (s * l - 1)),
            c = Math.floor(.5 * (a * l - 1)),
            h = t.tileCoordToPixel(n, i),
            p = 2 * u + 1,
            f = 2 * c + 1,
            d = function (t, e, r, n, i) {
              return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];
            }(t, h.x - u, h.y - c, p, f),
            y = Math.abs(d[0] - d[1]),
            m = Math.abs(d[2] - d[3]),
            g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),
            x = Math.min(.25, .5 * l * (y + m) / p),
            v = Math.min(.25, .5 * l * g / f);
          return o + Math.max(x * s, v * a);
        }(i, s, o) : l;
      return {
        base: l + (0 === r) ? -1 : r,
        top: u ? Math.max(c + n, l + r + 2) : l + n
      };
    }
    const Ph = na([{
        name: "a_pos_normal",
        components: 2,
        type: "Int16"
      }, {
        name: "a_data",
        components: 4,
        type: "Uint8"
      }, {
        name: "a_linesofar",
        components: 1,
        type: "Float32"
      }], 4),
      {
        members: Dh
      } = Ph,
      Vh = na([{
        name: "a_packed",
        components: 4,
        type: "Float32"
      }]),
      {
        members: Lh
      } = Vh,
      Fh = ah.types,
      Rh = Math.cos(Math.PI / 180 * 37.5);
    class jh {
      constructor(t) {
        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {
          this.gradients[t.id] = {};
        }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.indexArray = new wa(), this.programConfigurations = new fo(t.layers, t.zoom), this.segments = new So(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);
      }
      populate(t, e, r, n) {
        this.hasPattern = Rc("line", this.layers, e);
        const i = this.layers[0].layout.get("line-sort-key"),
          s = [];
        for (const {
          feature: e,
          id: a,
          index: o,
          sourceLayerIndex: l
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
            u = wu(e, t);
          if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u, r)) continue;
          const c = i ? i.evaluate(u, {}, r) : void 0,
            h = {
              id: a,
              properties: e.properties,
              type: e.type,
              sourceLayerIndex: l,
              index: o,
              geometry: t ? u.geometry : bu(e, r, n),
              patterns: {},
              sortKey: c
            };
          s.push(h);
        }
        i && s.sort((t, e) => t.sortKey - e.sortKey);
        const {
            lineAtlas: a,
            featureIndex: o
          } = e,
          l = this.addConstantDashes(a);
        for (const n of s) {
          const {
            geometry: i,
            index: s,
            sourceLayerIndex: u
          } = n;
          if (l && this.addFeatureDashes(n, a), this.hasPattern) {
            const t = jc("line", this.layers, n, this.zoom, e);
            this.patternFeatures.push(t);
          } else this.addFeature(n, i, s, r, a.positions, e.availableImages);
          o.insert(t[s].feature, i, s, u, this.index);
        }
      }
      addConstantDashes(t) {
        let e = !1;
        for (const r of this.layers) {
          const n = r.paint.get("line-dasharray").value,
            i = r.layout.get("line-cap").value;
          if ("constant" !== n.kind || "constant" !== i.kind) e = !0;else {
            const e = i.value,
              r = n.value;
            if (!r) continue;
            t.addDash(r, e);
          }
        }
        return e;
      }
      addFeatureDashes(t, e) {
        const r = this.zoom;
        for (const n of this.layers) {
          const i = n.paint.get("line-dasharray").value,
            s = n.layout.get("line-cap").value;
          if ("constant" === i.kind && "constant" === s.kind) continue;
          let a, o;
          if ("constant" === i.kind) {
            if (a = i.value, !a) continue;
          } else a = i.evaluate({
            zoom: r
          }, t);
          o = "constant" === s.kind ? s.value : s.evaluate({
            zoom: r
          }, t), e.addDash(a, o), t.patterns[n.id] = e.getKey(a, o);
        }
      }
      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }
      addFeatures(t, e, r, n, i) {
        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }
      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }
      upload(t) {
        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Lh)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
      }
      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }
      lineFeatureClips(t) {
        if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return {
          start: +t.properties.mapbox_clip_start,
          end: +t.properties.mapbox_clip_end
        };
      }
      addFeature(t, e, r, n, i, s) {
        const a = this.layers[0].layout,
          o = a.get("line-join").evaluate(t, {}),
          l = a.get("line-cap").evaluate(t, {}),
          u = a.get("line-miter-limit"),
          c = a.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(t);
        for (const r of e) this.addLine(r, t, o, l, u, c);
        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
      }
      addLine(t, e, r, n, i, s) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);
          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);
          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }
        const a = "Polygon" === Fh[e.type];
        let o = t.length;
        for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;
        let l = 0;
        for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;
        if (o < (a ? 3 : 2)) return;
        "bevel" === r && (i = 1.05);
        const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
          c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);
        let h, p, f, d, y;
        this.e1 = this.e2 = -1, a && (h = t[o - 2], y = t[l].sub(h)._unit()._perp());
        for (let e = l; e < o; e++) {
          if (f = e === o - 1 ? a ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;
          y && (d = y), h && (p = h), h = t[e], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;
          let m = d.add(y);
          0 === m.x && 0 === m.y || m._unit();
          const g = d.x * y.x + d.y * y.y,
            x = m.x * y.x + m.y * y.y,
            v = 0 !== x ? 1 / x : 1 / 0,
            b = 2 * Math.sqrt(2 - 2 * x),
            w = x < Rh && p && f,
            _ = d.x * y.y - d.y * y.x > 0;
          if (w && e > l) {
            const t = h.dist(p);
            if (t > 2 * u) {
              const e = h.sub(h.sub(p)._mult(u / t)._round());
              this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;
            }
          }
          const A = p && f;
          let S = A ? r : a ? "butt" : n;
          if (A && "round" === S && (v < s ? S = "miter" : v <= 2 && (S = "fakeround")), "miter" === S && v > i && (S = "bevel"), "bevel" === S && (v > 2 && (S = "flipbevel"), v < i && (S = "miter")), p && this.updateDistance(p, h), "miter" === S) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if ("flipbevel" === S) {
            if (v > 100) m = y.mult(-1);else {
              const t = v * d.add(y).mag() / d.sub(y).mag();
              m._perp()._mult(t * (_ ? -1 : 1));
            }
            this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);
          } else if ("bevel" === S || "fakeround" === S) {
            const t = -Math.sqrt(v * v - 1),
              e = _ ? t : 0,
              r = _ ? 0 : t;
            if (p && this.addCurrentVertex(h, d, e, r, c), "fakeround" === S) {
              const t = Math.round(180 * b / Math.PI / 20);
              for (let e = 1; e < t; e++) {
                let r = e / t;
                if (.5 !== r) {
                  const t = r - .5;
                  r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));
                }
                const n = y.sub(d)._mult(r)._add(d)._unit()._mult(_ ? -1 : 1);
                this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);
              }
            }
            f && this.addCurrentVertex(h, y, -e, -r, c);
          } else if ("butt" === S) this.addCurrentVertex(h, m, 0, 0, c);else if ("square" === S) {
            const t = p ? 1 : -1;
            p || this.addCurrentVertex(h, m, t, t, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t, t, c);
          } else "round" === S && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));
          if (w && e < o - 1) {
            const t = h.dist(f);
            if (t > 2 * u) {
              const e = h.add(f.sub(h)._mult(u / t)._round());
              this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;
            }
          }
        }
      }
      addCurrentVertex(t, e, r, n, i, s = !1) {
        const a = e.y * n - e.x,
          o = -e.y - e.x * n;
        this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i);
      }
      addHalfVertex({
        x: t,
        y: e
      }, r, n, i, s, a, o) {
        this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
        const l = o.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;
      }
      updateScaledDistance() {
        if (this.lineClips) {
          const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);
          this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;
        } else this.lineSoFar = this.distance;
      }
      updateDistance(t, e) {
        this.distance += t.dist(e), this.updateScaledDistance();
      }
    }
    Oi(jh, "LineBucket", {
      omit: ["layers", "patternFeatures"]
    });
    const Uh = new Js({
      "line-cap": new Hs(Ht.layout_line["line-cap"]),
      "line-join": new Hs(Ht.layout_line["line-join"]),
      "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]),
      "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]),
      "line-sort-key": new Hs(Ht.layout_line["line-sort-key"])
    });
    var $h = {
      paint: new Js({
        "line-opacity": new Hs(Ht.paint_line["line-opacity"]),
        "line-color": new Hs(Ht.paint_line["line-color"]),
        "line-translate": new Ys(Ht.paint_line["line-translate"]),
        "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]),
        "line-width": new Hs(Ht.paint_line["line-width"]),
        "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]),
        "line-offset": new Hs(Ht.paint_line["line-offset"]),
        "line-blur": new Hs(Ht.paint_line["line-blur"]),
        "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]),
        "line-pattern": new Hs(Ht.paint_line["line-pattern"]),
        "line-gradient": new Ws(Ht.paint_line["line-gradient"]),
        "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"])
      }),
      layout: Uh
    };
    const Oh = new class extends Hs {
      possiblyEvaluate(t, e) {
        return e = new Us(Math.floor(e.zoom), {
          now: e.now,
          fadeDuration: e.fadeDuration,
          transition: e.transition
        }), super.possiblyEvaluate(t, e);
      }
      evaluate(t, e, r, n) {
        return e = z({}, e, {
          zoom: Math.floor(e.zoom)
        }), super.evaluate(t, e, r, n);
      }
    }($h.paint.properties["line-width"].specification);
    function qh(t, e) {
      return e > 0 ? e + 2 * t : t;
    }
    Oh.useIntegerZoom = !0;
    const Nh = na([{
        name: "a_pos_offset",
        components: 4,
        type: "Int16"
      }, {
        name: "a_tex_size",
        components: 4,
        type: "Uint16"
      }, {
        name: "a_pixeloffset",
        components: 4,
        type: "Int16"
      }], 4),
      Gh = na([{
        name: "a_globe_anchor",
        components: 3,
        type: "Int16"
      }, {
        name: "a_globe_normal",
        components: 3,
        type: "Float32"
      }], 4),
      Xh = na([{
        name: "a_projected_pos",
        components: 4,
        type: "Float32"
      }], 4);
    na([{
      name: "a_fade_opacity",
      components: 1,
      type: "Uint32"
    }], 4);
    const Zh = na([{
        name: "a_placed",
        components: 2,
        type: "Uint8"
      }, {
        name: "a_shift",
        components: 2,
        type: "Float32"
      }]),
      Kh = na([{
        name: "a_size_scale",
        components: 1,
        type: "Float32"
      }, {
        name: "a_padding",
        components: 2,
        type: "Float32"
      }]);
    na([{
      type: "Int16",
      name: "projectedAnchorX"
    }, {
      type: "Int16",
      name: "projectedAnchorY"
    }, {
      type: "Int16",
      name: "projectedAnchorZ"
    }, {
      type: "Int16",
      name: "tileAnchorX"
    }, {
      type: "Int16",
      name: "tileAnchorY"
    }, {
      type: "Float32",
      name: "x1"
    }, {
      type: "Float32",
      name: "y1"
    }, {
      type: "Float32",
      name: "x2"
    }, {
      type: "Float32",
      name: "y2"
    }, {
      type: "Int16",
      name: "padding"
    }, {
      type: "Uint32",
      name: "featureIndex"
    }, {
      type: "Uint16",
      name: "sourceLayerIndex"
    }, {
      type: "Uint16",
      name: "bucketIndex"
    }]);
    const Yh = na([{
        name: "a_pos",
        components: 3,
        type: "Int16"
      }, {
        name: "a_anchor_pos",
        components: 2,
        type: "Int16"
      }, {
        name: "a_extrude",
        components: 2,
        type: "Int16"
      }], 4),
      Hh = na([{
        name: "a_pos_2f",
        components: 2,
        type: "Float32"
      }, {
        name: "a_radius",
        components: 1,
        type: "Float32"
      }, {
        name: "a_flags",
        components: 2,
        type: "Int16"
      }], 4);
    na([{
      name: "triangle",
      components: 3,
      type: "Uint16"
    }]), na([{
      type: "Int16",
      name: "projectedAnchorX"
    }, {
      type: "Int16",
      name: "projectedAnchorY"
    }, {
      type: "Int16",
      name: "projectedAnchorZ"
    }, {
      type: "Float32",
      name: "tileAnchorX"
    }, {
      type: "Float32",
      name: "tileAnchorY"
    }, {
      type: "Uint16",
      name: "glyphStartIndex"
    }, {
      type: "Uint16",
      name: "numGlyphs"
    }, {
      type: "Uint32",
      name: "vertexStartIndex"
    }, {
      type: "Uint32",
      name: "lineStartIndex"
    }, {
      type: "Uint32",
      name: "lineLength"
    }, {
      type: "Uint16",
      name: "segment"
    }, {
      type: "Uint16",
      name: "lowerSize"
    }, {
      type: "Uint16",
      name: "upperSize"
    }, {
      type: "Float32",
      name: "lineOffsetX"
    }, {
      type: "Float32",
      name: "lineOffsetY"
    }, {
      type: "Uint8",
      name: "writingMode"
    }, {
      type: "Uint8",
      name: "placedOrientation"
    }, {
      type: "Uint8",
      name: "hidden"
    }, {
      type: "Uint32",
      name: "crossTileID"
    }, {
      type: "Int16",
      name: "associatedIconIndex"
    }, {
      type: "Uint8",
      name: "flipState"
    }]), na([{
      type: "Int16",
      name: "projectedAnchorX"
    }, {
      type: "Int16",
      name: "projectedAnchorY"
    }, {
      type: "Int16",
      name: "projectedAnchorZ"
    }, {
      type: "Float32",
      name: "tileAnchorX"
    }, {
      type: "Float32",
      name: "tileAnchorY"
    }, {
      type: "Int16",
      name: "rightJustifiedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "centerJustifiedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "leftJustifiedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "verticalPlacedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "placedIconSymbolIndex"
    }, {
      type: "Int16",
      name: "verticalPlacedIconSymbolIndex"
    }, {
      type: "Uint16",
      name: "key"
    }, {
      type: "Uint16",
      name: "textBoxStartIndex"
    }, {
      type: "Uint16",
      name: "textBoxEndIndex"
    }, {
      type: "Uint16",
      name: "verticalTextBoxStartIndex"
    }, {
      type: "Uint16",
      name: "verticalTextBoxEndIndex"
    }, {
      type: "Uint16",
      name: "iconBoxStartIndex"
    }, {
      type: "Uint16",
      name: "iconBoxEndIndex"
    }, {
      type: "Uint16",
      name: "verticalIconBoxStartIndex"
    }, {
      type: "Uint16",
      name: "verticalIconBoxEndIndex"
    }, {
      type: "Uint16",
      name: "featureIndex"
    }, {
      type: "Uint16",
      name: "numHorizontalGlyphVertices"
    }, {
      type: "Uint16",
      name: "numVerticalGlyphVertices"
    }, {
      type: "Uint16",
      name: "numIconVertices"
    }, {
      type: "Uint16",
      name: "numVerticalIconVertices"
    }, {
      type: "Uint16",
      name: "useRuntimeCollisionCircles"
    }, {
      type: "Uint32",
      name: "crossTileID"
    }, {
      type: "Float32",
      components: 2,
      name: "textOffset"
    }, {
      type: "Float32",
      name: "collisionCircleDiameter"
    }]), na([{
      type: "Float32",
      name: "offsetX"
    }]), na([{
      type: "Int16",
      name: "x"
    }, {
      type: "Int16",
      name: "y"
    }]);
    var Wh = 24;
    const Jh = 128;
    function Qh(t, e) {
      const {
        expression: r
      } = e;
      if ("constant" === r.kind) return {
        kind: "constant",
        layoutSize: r.evaluate(new Us(t + 1))
      };
      if ("source" === r.kind) return {
        kind: "source"
      };
      {
        const {
          zoomStops: e,
          interpolationType: n
        } = r;
        let i = 0;
        for (; i < e.length && e[i] <= t;) i++;
        i = Math.max(0, i - 1);
        let s = i;
        for (; s < e.length && e[s] < t + 1;) s++;
        s = Math.min(e.length - 1, s);
        const a = e[i],
          o = e[s];
        return "composite" === r.kind ? {
          kind: "composite",
          minZoom: a,
          maxZoom: o,
          interpolationType: n
        } : {
          kind: "camera",
          minZoom: a,
          maxZoom: o,
          minSize: r.evaluate(new Us(a)),
          maxSize: r.evaluate(new Us(o)),
          interpolationType: n
        };
      }
    }
    function tp(t, {
      uSize: e,
      uSizeT: r
    }, {
      lowerSize: n,
      upperSize: i
    }) {
      return "source" === t.kind ? n / Jh : "composite" === t.kind ? Mr(n / Jh, i / Jh, r) : e;
    }
    function ep(t, e) {
      let r = 0,
        n = 0;
      if ("constant" === t.kind) n = t.layoutSize;else if ("source" !== t.kind) {
        const {
            interpolationType: i,
            minZoom: s,
            maxZoom: a
          } = t,
          o = i ? S(Kr.interpolationFactor(i, e, s, a), 0, 1) : 0;
        "camera" === t.kind ? n = Mr(t.minSize, t.maxSize, o) : r = o;
      }
      return {
        uSizeT: r,
        uSize: n
      };
    }
    var rp = Object.freeze({
      __proto__: null,
      getSizeData: Qh,
      evaluateSizeForFeature: tp,
      evaluateSizeForZoom: ep,
      SIZE_PACK_FACTOR: Jh
    });
    function np(t, e, r) {
      return t.sections.forEach(t => {
        t.text = function (t, e, r) {
          const n = e.layout.get("text-transform").evaluate(r, {});
          return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), js.applyArabicShaping && (t = js.applyArabicShaping(t)), t;
        }(t.text, e, r);
      }), t;
    }
    const ip = {
      "!": "",
      "#": "",
      $: "",
      "%": "",
      "&": "",
      "(": "",
      ")": "",
      "*": "",
      "+": "",
      ",": "",
      "-": "",
      ".": "",
      "/": "",
      ":": "",
      ";": "",
      "<": "",
      "=": "",
      ">": "",
      "?": "",
      "@": "",
      "[": "",
      "\\": "",
      "]": "",
      "^": "",
      _: "",
      "`": "",
      "{": "",
      "|": "",
      "}": "",
      "~": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    };
    function sp(t) {
      return "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t;
    }
    function ap(t) {
      return "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t;
    }
    var op = cp,
      lp = function (t, e, r, n, i) {
        var s,
          a,
          o = 8 * i - n - 1,
          l = (1 << o) - 1,
          u = l >> 1,
          c = -7,
          h = r ? i - 1 : 0,
          p = r ? -1 : 1,
          f = t[e + h];
        for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);
        for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);
        if (0 === s) s = 1 - u;else {
          if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);
          a += Math.pow(2, n), s -= u;
        }
        return (f ? -1 : 1) * a * Math.pow(2, s - n);
      },
      up = function (t, e, r, n, i, s) {
        var a,
          o,
          l,
          u = 8 * s - i - 1,
          c = (1 << u) - 1,
          h = c >> 1,
          p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          f = n ? 0 : s - 1,
          d = n ? 1 : -1,
          y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);
        for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);
        t[r + f - d] |= 128 * y;
      };
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    function cp(t) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
    }
    cp.Varint = 0, cp.Fixed64 = 1, cp.Bytes = 2, cp.Fixed32 = 5;
    var hp = 4294967296,
      pp = 1 / hp,
      fp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
    function dp(t) {
      return t.type === cp.Bytes ? t.readVarint() + t.pos : t.pos + 1;
    }
    function yp(t, e, r) {
      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);
    }
    function mp(t, e, r) {
      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
      r.realloc(n);
      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];
    }
    function gp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);
    }
    function xp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);
    }
    function vp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);
    }
    function bp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);
    }
    function wp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);
    }
    function _p(t, e) {
      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);
    }
    function Ap(t, e) {
      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);
    }
    function Sp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);
    }
    function kp(t, e) {
      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);
    }
    function Ip(t, e) {
      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];
    }
    function Mp(t, e, r) {
      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;
    }
    function Tp(t, e) {
      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);
    }
    function zp(t, e, r) {
      e.glyphs = [], 1 === t && r.readMessage(Bp, e);
    }
    function Bp(t, e, r) {
      if (3 === t) {
        const {
          id: t,
          bitmap: n,
          width: i,
          height: s,
          left: a,
          top: o,
          advance: l
        } = r.readMessage(Ep, {});
        e.glyphs.push({
          id: t,
          bitmap: new Ju({
            width: i + 6,
            height: s + 6
          }, n),
          metrics: {
            width: i,
            height: s,
            left: a,
            top: o,
            advance: l
          }
        });
      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());
    }
    function Ep(t, e, r) {
      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());
    }
    function Cp(t) {
      let e = 0,
        r = 0;
      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);
      t.sort((t, e) => e.h - t.h);
      const n = [{
        x: 0,
        y: 0,
        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
        h: 1 / 0
      }];
      let i = 0,
        s = 0;
      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {
        const r = n[t];
        if (!(e.w > r.w || e.h > r.h)) {
          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
            const e = n.pop();
            t < n.length && (n[t] = e);
          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({
            x: r.x + e.w,
            y: r.y,
            w: r.w - e.w,
            h: e.h
          }), r.y += e.h, r.h -= e.h);
          break;
        }
      }
      return {
        w: i,
        h: s,
        fill: e / (i * s) || 0
      };
    }
    cp.prototype = {
      destroy: function () {
        this.buf = null;
      },
      readFields: function (t, e, r) {
        for (r = r || this.length; this.pos < r;) {
          var n = this.readVarint(),
            i = n >> 3,
            s = this.pos;
          this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);
        }
        return e;
      },
      readMessage: function (t, e) {
        return this.readFields(t, e, this.readVarint() + this.pos);
      },
      readFixed32: function () {
        var t = Ip(this.buf, this.pos);
        return this.pos += 4, t;
      },
      readSFixed32: function () {
        var t = Tp(this.buf, this.pos);
        return this.pos += 4, t;
      },
      readFixed64: function () {
        var t = Ip(this.buf, this.pos) + Ip(this.buf, this.pos + 4) * hp;
        return this.pos += 8, t;
      },
      readSFixed64: function () {
        var t = Ip(this.buf, this.pos) + Tp(this.buf, this.pos + 4) * hp;
        return this.pos += 8, t;
      },
      readFloat: function () {
        var t = lp(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, t;
      },
      readDouble: function () {
        var t = lp(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, t;
      },
      readVarint: function (t) {
        var e,
          r,
          n = this.buf;
        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {
          var n,
            i,
            s = r.buf;
          if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return yp(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return yp(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return yp(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return yp(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return yp(t, n, e);
          if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return yp(t, n, e);
          throw new Error("Expected varint not more than 10 bytes");
        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));
      },
      readVarint64: function () {
        return this.readVarint(!0);
      },
      readSVarint: function () {
        var t = this.readVarint();
        return t % 2 == 1 ? (t + 1) / -2 : t / 2;
      },
      readBoolean: function () {
        return Boolean(this.readVarint());
      },
      readString: function () {
        var t = this.readVarint() + this.pos,
          e = this.pos;
        return this.pos = t, t - e >= 12 && fp ? function (t, e, r) {
          return fp.decode(t.subarray(e, r));
        }(this.buf, e, t) : function (t, e, r) {
          for (var n = "", i = e; i < r;) {
            var s,
              a,
              o,
              l = t[i],
              u = null,
              c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
            if (i + c > r) break;
            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
          }
          return n;
        }(this.buf, e, t);
      },
      readBytes: function () {
        var t = this.readVarint() + this.pos,
          e = this.buf.subarray(this.pos, t);
        return this.pos = t, e;
      },
      readPackedVarint: function (t, e) {
        if (this.type !== cp.Bytes) return t.push(this.readVarint(e));
        var r = dp(this);
        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));
        return t;
      },
      readPackedSVarint: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readSVarint());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readSVarint());
        return t;
      },
      readPackedBoolean: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readBoolean());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readBoolean());
        return t;
      },
      readPackedFloat: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readFloat());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readFloat());
        return t;
      },
      readPackedDouble: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readDouble());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readDouble());
        return t;
      },
      readPackedFixed32: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readFixed32());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readFixed32());
        return t;
      },
      readPackedSFixed32: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readSFixed32());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());
        return t;
      },
      readPackedFixed64: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readFixed64());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readFixed64());
        return t;
      },
      readPackedSFixed64: function (t) {
        if (this.type !== cp.Bytes) return t.push(this.readSFixed64());
        var e = dp(this);
        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());
        return t;
      },
      skip: function (t) {
        var e = 7 & t;
        if (e === cp.Varint) for (; this.buf[this.pos++] > 127;);else if (e === cp.Bytes) this.pos = this.readVarint() + this.pos;else if (e === cp.Fixed32) this.pos += 4;else {
          if (e !== cp.Fixed64) throw new Error("Unimplemented type: " + e);
          this.pos += 8;
        }
      },
      writeTag: function (t, e) {
        this.writeVarint(t << 3 | e);
      },
      realloc: function (t) {
        for (var e = this.length || 16; e < this.pos + t;) e *= 2;
        if (e !== this.length) {
          var r = new Uint8Array(e);
          r.set(this.buf), this.buf = r, this.length = e;
        }
      },
      finish: function () {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      },
      writeFixed32: function (t) {
        this.realloc(4), Mp(this.buf, t, this.pos), this.pos += 4;
      },
      writeSFixed32: function (t) {
        this.realloc(4), Mp(this.buf, t, this.pos), this.pos += 4;
      },
      writeFixed64: function (t) {
        this.realloc(8), Mp(this.buf, -1 & t, this.pos), Mp(this.buf, Math.floor(t * pp), this.pos + 4), this.pos += 8;
      },
      writeSFixed64: function (t) {
        this.realloc(8), Mp(this.buf, -1 & t, this.pos), Mp(this.buf, Math.floor(t * pp), this.pos + 4), this.pos += 8;
      },
      writeVarint: function (t) {
        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {
          var r, n;
          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
          e.realloc(10), function (t, e, r) {
            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);
          }(r, 0, e), function (t, e) {
            var r = (7 & t) << 4;
            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));
          }(n, e);
        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
      },
      writeSVarint: function (t) {
        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
      },
      writeBoolean: function (t) {
        this.writeVarint(Boolean(t));
      },
      writeString: function (t) {
        t = String(t), this.realloc(4 * t.length), this.pos++;
        var e = this.pos;
        this.pos = function (t, e, r) {
          for (var n, i, s = 0; s < e.length; s++) {
            if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
              if (!i) {
                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;
                continue;
              }
              if (n < 56320) {
                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;
                continue;
              }
              n = i - 55296 << 10 | n - 56320 | 65536, i = null;
            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);
            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);
          }
          return r;
        }(this.buf, t, this.pos);
        var r = this.pos - e;
        r >= 128 && mp(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
      },
      writeFloat: function (t) {
        this.realloc(4), up(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;
      },
      writeDouble: function (t) {
        this.realloc(8), up(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;
      },
      writeBytes: function (t) {
        var e = t.length;
        this.writeVarint(e), this.realloc(e);
        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];
      },
      writeRawMessage: function (t, e) {
        this.pos++;
        var r = this.pos;
        t(e, this);
        var n = this.pos - r;
        n >= 128 && mp(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
      },
      writeMessage: function (t, e, r) {
        this.writeTag(t, cp.Bytes), this.writeRawMessage(e, r);
      },
      writePackedVarint: function (t, e) {
        e.length && this.writeMessage(t, gp, e);
      },
      writePackedSVarint: function (t, e) {
        e.length && this.writeMessage(t, xp, e);
      },
      writePackedBoolean: function (t, e) {
        e.length && this.writeMessage(t, wp, e);
      },
      writePackedFloat: function (t, e) {
        e.length && this.writeMessage(t, vp, e);
      },
      writePackedDouble: function (t, e) {
        e.length && this.writeMessage(t, bp, e);
      },
      writePackedFixed32: function (t, e) {
        e.length && this.writeMessage(t, _p, e);
      },
      writePackedSFixed32: function (t, e) {
        e.length && this.writeMessage(t, Ap, e);
      },
      writePackedFixed64: function (t, e) {
        e.length && this.writeMessage(t, Sp, e);
      },
      writePackedSFixed64: function (t, e) {
        e.length && this.writeMessage(t, kp, e);
      },
      writeBytesField: function (t, e) {
        this.writeTag(t, cp.Bytes), this.writeBytes(e);
      },
      writeFixed32Field: function (t, e) {
        this.writeTag(t, cp.Fixed32), this.writeFixed32(e);
      },
      writeSFixed32Field: function (t, e) {
        this.writeTag(t, cp.Fixed32), this.writeSFixed32(e);
      },
      writeFixed64Field: function (t, e) {
        this.writeTag(t, cp.Fixed64), this.writeFixed64(e);
      },
      writeSFixed64Field: function (t, e) {
        this.writeTag(t, cp.Fixed64), this.writeSFixed64(e);
      },
      writeVarintField: function (t, e) {
        this.writeTag(t, cp.Varint), this.writeVarint(e);
      },
      writeSVarintField: function (t, e) {
        this.writeTag(t, cp.Varint), this.writeSVarint(e);
      },
      writeStringField: function (t, e) {
        this.writeTag(t, cp.Bytes), this.writeString(e);
      },
      writeFloatField: function (t, e) {
        this.writeTag(t, cp.Fixed32), this.writeFloat(e);
      },
      writeDoubleField: function (t, e) {
        this.writeTag(t, cp.Fixed64), this.writeDouble(e);
      },
      writeBooleanField: function (t, e) {
        this.writeVarintField(t, Boolean(e));
      }
    };
    class Pp {
      constructor(t, {
        pixelRatio: e,
        version: r,
        stretchX: n,
        stretchY: i,
        content: s
      }) {
        this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;
      }
      get tl() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }
      get br() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }
      get displaySize() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }
    }
    class Dp {
      constructor(t, e) {
        const r = {},
          n = {};
        this.haveRenderCallbacks = [];
        const i = [];
        this.addImages(t, r, i), this.addImages(e, n, i);
        const {
            w: s,
            h: a
          } = Cp(i),
          o = new Qu({
            width: s || 1,
            height: a || 1
          });
        for (const e in t) {
          const n = t[e],
            i = r[e].paddedRect;
          Qu.copy(n.data, o, {
            x: 0,
            y: 0
          }, {
            x: i.x + 1,
            y: i.y + 1
          }, n.data);
        }
        for (const t in e) {
          const r = e[t],
            i = n[t].paddedRect,
            s = i.x + 1,
            a = i.y + 1,
            l = r.data.width,
            u = r.data.height;
          Qu.copy(r.data, o, {
            x: 0,
            y: 0
          }, {
            x: s,
            y: a
          }, r.data), Qu.copy(r.data, o, {
            x: 0,
            y: u - 1
          }, {
            x: s,
            y: a - 1
          }, {
            width: l,
            height: 1
          }), Qu.copy(r.data, o, {
            x: 0,
            y: 0
          }, {
            x: s,
            y: a + u
          }, {
            width: l,
            height: 1
          }), Qu.copy(r.data, o, {
            x: l - 1,
            y: 0
          }, {
            x: s - 1,
            y: a
          }, {
            width: 1,
            height: u
          }), Qu.copy(r.data, o, {
            x: 0,
            y: 0
          }, {
            x: s + l,
            y: a
          }, {
            width: 1,
            height: u
          });
        }
        this.image = o, this.iconPositions = r, this.patternPositions = n;
      }
      addImages(t, e, r) {
        for (const n in t) {
          const i = t[n],
            s = {
              x: 0,
              y: 0,
              w: i.data.width + 2,
              h: i.data.height + 2
            };
          r.push(s), e[n] = new Pp(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
        }
      }
      patchUpdatedImages(t, e) {
        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e)), t.dispatchRenderCallbacks(this.haveRenderCallbacks);
        for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);
      }
      patchUpdatedImage(t, e, r) {
        if (!t || !e) return;
        if (t.version === e.version) return;
        t.version = e.version;
        const [n, i] = t.tl;
        r.update(e.data, void 0, {
          x: n,
          y: i
        });
      }
    }
    Oi(Pp, "ImagePosition"), Oi(Dp, "ImageAtlas");
    const Vp = {
      horizontal: 1,
      vertical: 2,
      horizontalOnly: 3
    };
    class Lp {
      constructor() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      }
      static forText(t, e) {
        const r = new Lp();
        return r.scale = t || 1, r.fontStack = e, r;
      }
      static forImage(t) {
        const e = new Lp();
        return e.imageName = t, e;
      }
    }
    class Fp {
      constructor() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      }
      static fromFeature(t, e) {
        const r = new Fp();
        for (let n = 0; n < t.sections.length; n++) {
          const i = t.sections[n];
          i.image ? r.addImageSection(i) : r.addTextSection(i, e);
        }
        return r;
      }
      length() {
        return this.text.length;
      }
      getSection(t) {
        return this.sections[this.sectionIndex[t]];
      }
      getSections() {
        return this.sections;
      }
      getSectionIndex(t) {
        return this.sectionIndex[t];
      }
      getCharCode(t) {
        return this.text.charCodeAt(t);
      }
      verticalizePunctuation(t) {
        this.text = function (t, e) {
          let r = "";
          for (let n = 0; n < t.length; n++) {
            const i = t.charCodeAt(n + 1) || null,
              s = t.charCodeAt(n - 1) || null;
            r += !e && (i && Ss(i) && !ip[t[n + 1]] || s && Ss(s) && !ip[t[n - 1]]) || !ip[t[n]] ? t[n] : ip[t[n]];
          }
          return r;
        }(this.text, t);
      }
      trim() {
        let t = 0;
        for (let e = 0; e < this.text.length && jp[this.text.charCodeAt(e)]; e++) t++;
        let e = this.text.length;
        for (let r = this.text.length - 1; r >= 0 && r >= t && jp[this.text.charCodeAt(r)]; r--) e--;
        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);
      }
      substring(t, e) {
        const r = new Fp();
        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;
      }
      toString() {
        return this.text;
      }
      getMaxScale() {
        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);
      }
      addTextSection(t, e) {
        this.text += t.text, this.sections.push(Lp.forText(t.scale, t.fontStack || e));
        const r = this.sections.length - 1;
        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);
      }
      addImageSection(t) {
        const e = t.image ? t.image.name : "";
        if (0 === e.length) return void $("Can't add FormattedSection with an empty image.");
        const r = this.getNextImageSectionCharCode();
        r ? (this.text += String.fromCharCode(r), this.sections.push(Lp.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : $("Reached maximum number of images 6401");
      }
      getNextImageSectionCharCode() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      }
    }
    function Rp(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d) {
      const y = Fp.fromFeature(t, i);
      h === Vp.vertical && y.verticalizePunctuation(p);
      let m = [];
      const g = function (t, e, r, n, i, s) {
          if (!t) return [];
          const a = [],
            o = function (t, e, r, n, i, s) {
              let a = 0;
              for (let r = 0; r < t.length(); r++) {
                const o = t.getSection(r);
                a += $p(t.getCharCode(r), o, n, i, e, s);
              }
              return a / Math.max(1, Math.ceil(a / r));
            }(t, e, r, n, i, s),
            l = t.text.indexOf("") >= 0;
          let u = 0;
          for (let r = 0; r < t.length(); r++) {
            const h = t.getSection(r),
              p = t.getCharCode(r);
            if (jp[p] || (u += $p(p, h, n, i, e, s)), r < t.length() - 1) {
              const e = !((c = p) < 11904 || !(ns(c) || rs(c) || ms(c) || fs(c) || os(c) || Hi(c) || is(c) || Qi(c) || ls(c) || us(c) || as(c) || vs(c) || ts(c) || Ji(c) || Wi(c) || ss(c) || es(c) || ys(c) || hs(c) || cs(c)));
              (Up[p] || e || h.imageName) && a.push(Np(r + 1, u, o, a, qp(p, t.getCharCode(r + 1), e && l), !1));
            }
          }
          var c;
          return Gp(Np(t.length(), u, o, a, 0, !0));
        }(y, u, s, e, n, f),
        {
          processBidirectionalText: x,
          processStyledBidirectionalText: v
        } = js;
      if (x && 1 === y.sections.length) {
        const t = x(y.toString(), g);
        for (const e of t) {
          const t = new Fp();
          t.text = e, t.sections = y.sections;
          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);
          m.push(t);
        }
      } else if (v) {
        const t = v(y.text, y.sectionIndex, g);
        for (const e of t) {
          const t = new Fp();
          t.text = e[0], t.sectionIndex = e[1], t.sections = y.sections, m.push(t);
        }
      } else m = function (t, e) {
        const r = [],
          n = t.text;
        let i = 0;
        for (const n of e) r.push(t.substring(i, n)), i = n;
        return i < n.length && r.push(t.substring(i, n.length)), r;
      }(y, g);
      const b = [],
        w = {
          positionedLines: b,
          text: y.toString(),
          top: c[1],
          bottom: c[1],
          left: c[0],
          right: c[0],
          writingMode: h,
          iconsInText: !1,
          verticalizable: !1,
          hasBaseline: !1
        };
      return function (t, e, r, n, i, s, a, o, l, u, c, h) {
        let p = 0,
          f = 0,
          d = 0;
        const y = "right" === o ? 1 : "left" === o ? 0 : .5;
        let m = !1;
        for (const t of i) {
          const r = t.getSections();
          for (const t of r) {
            if (t.imageName) continue;
            const r = e[t.fontStack];
            if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;
          }
          if (!m) break;
        }
        let g = 0;
        for (const a of i) {
          a.trim();
          const i = a.getMaxScale(),
            o = (i - 1) * Wh,
            v = {
              positionedGlyphs: [],
              lineOffset: 0
            };
          t.positionedLines[g] = v;
          const b = v.positionedGlyphs;
          let w = 0;
          if (!a.length()) {
            f += s, ++g;
            continue;
          }
          let _ = 0,
            A = 0;
          for (let s = 0; s < a.length(); s++) {
            const o = a.getSection(s),
              d = a.getSectionIndex(s),
              y = a.getCharCode(s);
            let g = o.scale,
              v = null,
              S = null,
              k = null,
              I = Wh,
              M = 0;
            const T = !(l === Vp.horizontal || !c && !As(y) || c && (jp[y] || (x = y, Zi(x) || Ki(x) || Yi(x) || ds(x) || xs(x))));
            if (o.imageName) {
              const e = n[o.imageName];
              if (!e) continue;
              k = o.imageName, t.iconsInText = t.iconsInText || !0, S = e.paddedRect;
              const r = e.displaySize;
              g = g * Wh / h, v = {
                width: r[0],
                height: r[1],
                left: 1,
                top: -3,
                advance: T ? r[1] : r[0],
                localGlyph: !1
              }, M = m ? -v.height * g : i * Wh - 17 - r[1] * g, I = v.advance;
              const s = (T ? r[0] : r[1]) * g - Wh * i;
              s > 0 && s > w && (w = s);
            } else {
              const t = r[o.fontStack];
              if (!t) continue;
              t[y] && (S = t[y]);
              const n = e[o.fontStack];
              if (!n) continue;
              const s = n.glyphs[y];
              if (!s) continue;
              if (v = s.metrics, I = 8203 !== y ? Wh : 0, m) {
                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,
                  e = void 0 !== n.descender ? Math.abs(n.descender) : 0,
                  r = (t + e) * g;
                _ < r && (_ = r, A = (t - e) / 2 * g), M = -t * g;
              } else M = (i - g) * Wh - 17;
            }
            T ? (t.verticalizable = !0, b.push({
              glyph: y,
              imageName: k,
              x: p,
              y: f + M,
              vertical: T,
              scale: g,
              localGlyph: v.localGlyph,
              fontStack: o.fontStack,
              sectionIndex: d,
              metrics: v,
              rect: S
            }), p += I * g + u) : (b.push({
              glyph: y,
              imageName: k,
              x: p,
              y: f + M,
              vertical: T,
              scale: g,
              localGlyph: v.localGlyph,
              fontStack: o.fontStack,
              sectionIndex: d,
              metrics: v,
              rect: S
            }), p += v.advance * g + u);
          }
          0 !== b.length && (d = Math.max(p - u, d), m ? Zp(b, y, w, A, s * i / 2) : Zp(b, y, w, 0, s / 2)), p = 0;
          const S = s * i + w;
          v.lineOffset = Math.max(w, o), f += S, ++g;
        }
        var x;
        const v = f,
          {
            horizontalAlign: b,
            verticalAlign: w
          } = Xp(a);
        (function (t, e, r, n, i, s) {
          const a = (e - r) * i,
            o = -s * n;
          for (const e of t) for (const t of e.positionedGlyphs) t.x += a, t.y += o;
        })(t.positionedLines, y, b, w, d, v), t.top += -w * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d, t.hasBaseline = m;
      }(w, e, r, n, m, a, o, l, h, u, p, d), !function (t) {
        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;
        return !0;
      }(b) && w;
    }
    const jp = {
        9: !0,
        10: !0,
        11: !0,
        12: !0,
        13: !0,
        32: !0
      },
      Up = {
        10: !0,
        32: !0,
        38: !0,
        40: !0,
        41: !0,
        43: !0,
        45: !0,
        47: !0,
        173: !0,
        183: !0,
        8203: !0,
        8208: !0,
        8211: !0,
        8231: !0
      };
    function $p(t, e, r, n, i, s) {
      if (e.imageName) {
        const t = n[e.imageName];
        return t ? t.displaySize[0] * e.scale * Wh / s + i : 0;
      }
      {
        const n = r[e.fontStack],
          s = n && n.glyphs[t];
        return s ? s.metrics.advance * e.scale + i : 0;
      }
    }
    function Op(t, e, r, n) {
      const i = Math.pow(t - e, 2);
      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
    }
    function qp(t, e, r) {
      let n = 0;
      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
    }
    function Np(t, e, r, n, i, s) {
      let a = null,
        o = Op(e, r, i, s);
      for (const t of n) {
        const n = Op(e - t.x, r, i, s) + t.badness;
        n <= o && (a = t, o = n);
      }
      return {
        index: t,
        x: e,
        priorBreak: a,
        badness: o
      };
    }
    function Gp(t) {
      return t ? Gp(t.priorBreak).concat(t.index) : [];
    }
    function Xp(t) {
      let e = .5,
        r = .5;
      switch (t) {
        case "right":
        case "top-right":
        case "bottom-right":
          e = 1;
          break;
        case "left":
        case "top-left":
        case "bottom-left":
          e = 0;
      }
      switch (t) {
        case "bottom":
        case "bottom-right":
        case "bottom-left":
          r = 1;
          break;
        case "top":
        case "top-right":
        case "top-left":
          r = 0;
      }
      return {
        horizontalAlign: e,
        verticalAlign: r
      };
    }
    function Zp(t, e, r, n, i) {
      if (!(e || r || n || i)) return;
      const s = t.length - 1,
        a = t[s],
        o = (a.x + a.metrics.advance * a.scale) * e;
      for (let e = 0; e <= s; e++) t[e].x -= o, t[e].y += r + n + i;
    }
    function Kp(t, e, r) {
      const {
          horizontalAlign: n,
          verticalAlign: i
        } = Xp(r),
        s = e[0] - t.displaySize[0] * n,
        a = e[1] - t.displaySize[1] * i;
      return {
        image: t,
        top: a,
        bottom: a + t.displaySize[1],
        left: s,
        right: s + t.displaySize[0]
      };
    }
    function Yp(t, e, r, n, i, s) {
      const a = t.image;
      let o;
      if (a.content) {
        const t = a.content,
          e = a.pixelRatio || 1;
        o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];
      }
      const l = e.left * s,
        u = e.right * s;
      let c, h, p, f;
      "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);
      const d = e.top * s,
        y = e.bottom * s;
      return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {
        image: a,
        top: c,
        right: h,
        bottom: p,
        left: f,
        collisionPadding: o
      };
    }
    class Hp extends d {
      constructor(t, e, r, n, i) {
        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
      }
      clone() {
        return new Hp(this.x, this.y, this.z, this.angle, this.segment);
      }
    }
    function Wp(t, e, r, n, i) {
      if (void 0 === e.segment) return !0;
      let s = e,
        a = e.segment + 1,
        o = 0;
      for (; o > -r / 2;) {
        if (a--, a < 0) return !1;
        o -= t[a].dist(s), s = t[a];
      }
      o += t[a].dist(t[a + 1]), a++;
      const l = [];
      let u = 0;
      for (; o < r / 2;) {
        const e = t[a],
          r = t[a + 1];
        if (!r) return !1;
        let s = t[a - 1].angleTo(e) - e.angleTo(r);
        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
          distance: o,
          angleDelta: s
        }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;
        if (u > i) return !1;
        a++, o += e.dist(r);
      }
      return !0;
    }
    function Jp(t) {
      let e = 0;
      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);
      return e;
    }
    function Qp(t, e, r) {
      return t ? .6 * e * r : 0;
    }
    function tf(t, e) {
      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
    }
    function ef(t, e, r, n, i, s) {
      const a = Qp(r, i, s),
        o = tf(r, n) * s;
      let l = 0;
      const u = Jp(t) / 2;
      for (let r = 0; r < t.length - 1; r++) {
        const n = t[r],
          i = t[r + 1],
          s = n.dist(i);
        if (l + s > u) {
          const c = (u - l) / s,
            h = Mr(n.x, i.x, c),
            p = Mr(n.y, i.y, c),
            f = new Hp(h, p, 0, i.angleTo(n), r);
          return !a || Wp(t, f, o, a, e) ? f : void 0;
        }
        l += s;
      }
    }
    function rf(t, e, r, n, i, s, a, o, l) {
      const u = Qp(n, s, a),
        c = tf(n, i),
        h = c * a,
        p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
      return e - h < e / 4 && (e = h + e / 4), nf(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);
    }
    function nf(t, e, r, n, i, s, a, o, l) {
      const u = s / 2,
        c = Jp(t);
      let h = 0,
        p = e - r,
        f = [];
      for (let e = 0; e < t.length - 1; e++) {
        const a = t[e],
          o = t[e + 1],
          d = a.dist(o),
          y = o.angleTo(a);
        for (; p + r < h + d;) {
          p += r;
          const m = (p - h) / d,
            g = Mr(a.x, o.x, m),
            x = Mr(a.y, o.y, m);
          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
            const r = new Hp(g, x, 0, y, e);
            r._round(), n && !Wp(t, r, s, n, i) || f.push(r);
          }
        }
        h += d;
      }
      return o || f.length || a || (f = nf(t, h / 2, r, n, i, s, a, !0, l)), f;
    }
    function sf(t, e, r, n, i) {
      const s = [];
      for (let a = 0; a < t.length; a++) {
        const o = t[a];
        let l;
        for (let t = 0; t < o.length - 1; t++) {
          let a = o[t],
            u = o[t + 1];
          a.x < e && u.x < e || (a.x < e ? a = new d(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e && (u = new d(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new d(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new d(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new d(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new d(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new d(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new d(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [a], s.push(l)), l.push(u)))));
        }
      }
      return s;
    }
    Oi(Hp, "Anchor");
    const af = 1e20;
    function of(t, e, r, n, i, s, a, o, l) {
      for (let u = e; u < e + n; u++) lf(t, r * s + u, s, i, a, o, l);
      for (let u = r; u < r + i; u++) lf(t, u * s + e, 1, n, a, o, l);
    }
    function lf(t, e, r, n, i, s, a) {
      s[0] = 0, a[0] = -af, a[1] = af, i[0] = t[e];
      for (let o = 1, l = 0, u = 0; o < n; o++) {
        i[o] = t[e + o * r];
        const n = o * o;
        do {
          const t = s[l];
          u = (i[o] - i[t] + n - t * t) / (o - t) / 2;
        } while (u <= a[l] && --l > -1);
        l++, s[l] = o, a[l] = u, a[l + 1] = af;
      }
      for (let o = 0, l = 0; o < n; o++) {
        for (; a[l + 1] < o;) l++;
        const n = s[l],
          u = o - n;
        t[e + o * r] = i[n] + u * u;
      }
    }
    const uf = {
      none: 0,
      ideographs: 1,
      all: 2
    };
    class cf {
      constructor(t, e, r) {
        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.entries = {}, this.localGlyphs = {
          200: {},
          400: {},
          500: {},
          900: {}
        };
      }
      setURL(t) {
        this.url = t;
      }
      getGlyphs(t, e) {
        const r = [];
        for (const e in t) for (const n of t[e]) r.push({
          stack: e,
          id: n
        });
        M(r, ({
          stack: t,
          id: e
        }, r) => {
          let n = this.entries[t];
          n || (n = this.entries[t] = {
            glyphs: {},
            requests: {},
            ranges: {},
            ascender: void 0,
            descender: void 0
          });
          let i = n.glyphs[e];
          if (void 0 !== i) return void r(null, {
            stack: t,
            id: e,
            glyph: i
          });
          if (i = this._tinySDF(n, t, e), i) return n.glyphs[e] = i, void r(null, {
            stack: t,
            id: e,
            glyph: i
          });
          const s = Math.floor(e / 256);
          if (256 * s > 65535) return void r(new Error("glyphs > 65535 not supported"));
          if (n.ranges[s]) return void r(null, {
            stack: t,
            id: e,
            glyph: i
          });
          let a = n.requests[s];
          a || (a = n.requests[s] = [], cf.loadGlyphRange(t, s, this.url, this.requestManager, (t, e) => {
            if (e) {
              n.ascender = e.ascender, n.descender = e.descender;
              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);
              n.ranges[s] = !0;
            }
            for (const r of a) r(t, e);
            delete n.requests[s];
          })), a.push((n, i) => {
            n ? r(n) : i && r(null, {
              stack: t,
              id: e,
              glyph: i.glyphs[e] || null
            });
          });
        }, (t, r) => {
          if (t) e(t);else if (r) {
            const t = {};
            for (const {
              stack: e,
              id: n,
              glyph: i
            } of r) void 0 === t[e] && (t[e] = {}), void 0 === t[e].glyphs && (t[e].glyphs = {}), t[e].glyphs[n] = i && {
              id: i.id,
              bitmap: i.bitmap.clone(),
              metrics: i.metrics
            }, t[e].ascender = this.entries[e].ascender, t[e].descender = this.entries[e].descender;
            e(null, t);
          }
        });
      }
      _doesCharSupportLocalGlyph(t) {
        return this.localGlyphMode !== uf.none && (this.localGlyphMode === uf.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t) || ps(t) || ts(t) || es(t) || Qi(t)));
      }
      _tinySDF(t, e, r) {
        const n = this.localFontFamily;
        if (!n || !this._doesCharSupportLocalGlyph(r)) return;
        let i = t.tinySDF;
        if (!i) {
          let r = "400";
          /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t.tinySDF = new cf.TinySDF({
            fontFamily: n,
            fontWeight: r,
            fontSize: 48,
            buffer: 6,
            radius: 16
          }), i.fontWeight = r;
        }
        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
        const s = String.fromCharCode(r),
          {
            data: a,
            width: o,
            height: l,
            glyphWidth: u,
            glyphHeight: c,
            glyphLeft: h,
            glyphTop: p,
            glyphAdvance: f
          } = i.draw(s);
        return this.localGlyphs[i.fontWeight][r] = {
          id: r,
          bitmap: new Ju({
            width: o,
            height: l
          }, a),
          metrics: {
            width: u / 2,
            height: c / 2,
            left: h / 2,
            top: p / 2 - 27,
            advance: f / 2,
            localGlyph: !0
          }
        };
      }
    }
    function hf(t, e, r, n) {
      const i = [],
        s = t.image,
        a = s.pixelRatio,
        o = s.paddedRect.w - 2,
        l = s.paddedRect.h - 2,
        u = t.right - t.left,
        c = t.bottom - t.top,
        h = s.stretchX || [[0, o]],
        p = s.stretchY || [[0, l]],
        f = (t, e) => t + e[1] - e[0],
        y = h.reduce(f, 0),
        m = p.reduce(f, 0),
        g = o - y,
        x = l - m;
      let v = 0,
        b = y,
        w = 0,
        _ = m,
        A = 0,
        S = g,
        k = 0,
        I = x;
      if (s.content && n) {
        const t = s.content;
        v = pf(h, 0, t[0]), w = pf(p, 0, t[1]), b = pf(h, t[0], t[2]), _ = pf(p, t[1], t[3]), A = t[0] - v, k = t[1] - w, S = t[2] - t[0] - b, I = t[3] - t[1] - _;
      }
      const M = (n, i, o, l) => {
        const h = df(n.stretch - v, b, u, t.left),
          p = yf(n.fixed - A, S, n.stretch, y),
          f = df(i.stretch - w, _, c, t.top),
          g = yf(i.fixed - k, I, i.stretch, m),
          x = df(o.stretch - v, b, u, t.left),
          M = yf(o.fixed - A, S, o.stretch, y),
          T = df(l.stretch - w, _, c, t.top),
          z = yf(l.fixed - k, I, l.stretch, m),
          B = new d(h, f),
          E = new d(x, f),
          C = new d(x, T),
          P = new d(h, T),
          D = new d(p / a, g / a),
          V = new d(M / a, z / a),
          L = e * Math.PI / 180;
        if (L) {
          const t = Math.sin(L),
            e = Math.cos(L),
            r = [e, -t, t, e];
          B._matMult(r), E._matMult(r), P._matMult(r), C._matMult(r);
        }
        const F = n.stretch + n.fixed,
          R = i.stretch + i.fixed;
        return {
          tl: B,
          tr: E,
          bl: P,
          br: C,
          tex: {
            x: s.paddedRect.x + 1 + F,
            y: s.paddedRect.y + 1 + R,
            w: o.stretch + o.fixed - F,
            h: l.stretch + l.fixed - R
          },
          writingMode: void 0,
          glyphOffset: [0, 0],
          sectionIndex: 0,
          pixelOffsetTL: D,
          pixelOffsetBR: V,
          minFontScaleX: S / a / u,
          minFontScaleY: I / a / c,
          isSDF: r
        };
      };
      if (n && (s.stretchX || s.stretchY)) {
        const t = ff(h, g, y),
          e = ff(p, x, m);
        for (let r = 0; r < t.length - 1; r++) {
          const n = t[r],
            s = t[r + 1];
          for (let t = 0; t < e.length - 1; t++) i.push(M(n, e[t], s, e[t + 1]));
        }
      } else i.push(M({
        fixed: 0,
        stretch: -1
      }, {
        fixed: 0,
        stretch: -1
      }, {
        fixed: 0,
        stretch: o + 1
      }, {
        fixed: 0,
        stretch: l + 1
      }));
      return i;
    }
    function pf(t, e, r) {
      let n = 0;
      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));
      return n;
    }
    function ff(t, e, r) {
      const n = [{
        fixed: -1,
        stretch: 0
      }];
      for (const [e, r] of t) {
        const t = n[n.length - 1];
        n.push({
          fixed: e - t.stretch,
          stretch: t.stretch
        }), n.push({
          fixed: e - t.stretch,
          stretch: t.stretch + (r - e)
        });
      }
      return n.push({
        fixed: e + 1,
        stretch: r
      }), n;
    }
    function df(t, e, r, n) {
      return t / e * r + n;
    }
    function yf(t, e, r, n) {
      return t - e * r / n;
    }
    function mf(t, e, r, n) {
      const i = e + t.positionedLines[n].lineOffset;
      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;
    }
    cf.loadGlyphRange = function (t, e, r, n, i) {
      const s = 256 * e,
        a = s + 255,
        o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t).replace("{range}", `${s}-${a}`), st.Glyphs);
      ut(o, (t, e) => {
        if (t) i(t);else if (e) {
          const t = {},
            r = function (t) {
              return new op(t).readFields(zp, {});
            }(e);
          for (const e of r.glyphs) t[e.id] = e;
          i(null, {
            glyphs: t,
            ascender: r.ascender,
            descender: r.descender
          });
        }
      });
    }, cf.TinySDF = class {
      constructor({
        fontSize: t = 24,
        buffer: e = 3,
        radius: r = 8,
        cutoff: n = .25,
        fontFamily: i = "sans-serif",
        fontWeight: s = "normal",
        fontStyle: a = "normal"
      } = {}) {
        this.buffer = e, this.cutoff = n, this.radius = r;
        const o = this.size = t + 4 * e,
          l = this._createCanvas(o),
          u = this.ctx = l.getContext("2d", {
            willReadFrequently: !0
          });
        u.font = `${a} ${s} ${t}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
      }
      _createCanvas(t) {
        const e = document.createElement("canvas");
        return e.width = e.height = t, e;
      }
      draw(t) {
        const {
            width: e,
            actualBoundingBoxAscent: r,
            actualBoundingBoxDescent: n,
            actualBoundingBoxLeft: i,
            actualBoundingBoxRight: s
          } = this.ctx.measureText(t),
          a = Math.ceil(r),
          o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))),
          l = Math.min(this.size - this.buffer, a + Math.ceil(n)),
          u = o + 2 * this.buffer,
          c = l + 2 * this.buffer,
          h = Math.max(u * c, 0),
          p = new Uint8ClampedArray(h),
          f = {
            data: p,
            width: u,
            height: c,
            glyphWidth: o,
            glyphHeight: l,
            glyphTop: a,
            glyphLeft: 0,
            glyphAdvance: e
          };
        if (0 === o || 0 === l) return f;
        const {
          ctx: d,
          buffer: y,
          gridInner: m,
          gridOuter: g
        } = this;
        d.clearRect(y, y, o, l), d.fillText(t, y, y + a);
        const x = d.getImageData(y, y, o, l);
        g.fill(af, 0, h), m.fill(0, 0, h);
        for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {
          const r = x.data[4 * (t * o + e) + 3] / 255;
          if (0 === r) continue;
          const n = (t + y) * u + e + y;
          if (1 === r) g[n] = 0, m[n] = af;else {
            const t = .5 - r;
            g[n] = t > 0 ? t * t : 0, m[n] = t < 0 ? t * t : 0;
          }
        }
        of(g, 0, 0, u, c, u, this.f, this.v, this.z), of(m, y, y, o, l, u, this.f, this.v, this.z);
        for (let t = 0; t < h; t++) {
          const e = Math.sqrt(g[t]) - Math.sqrt(m[t]);
          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
        }
        return f;
      }
    };
    class gf {
      constructor(t = [], e = xf) {
        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);
      }
      push(t) {
        this.data.push(t), this.length++, this._up(this.length - 1);
      }
      pop() {
        if (0 === this.length) return;
        const t = this.data[0],
          e = this.data.pop();
        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;
      }
      peek() {
        return this.data[0];
      }
      _up(t) {
        const {
            data: e,
            compare: r
          } = this,
          n = e[t];
        for (; t > 0;) {
          const i = t - 1 >> 1,
            s = e[i];
          if (r(n, s) >= 0) break;
          e[t] = s, t = i;
        }
        e[t] = n;
      }
      _down(t) {
        const {
            data: e,
            compare: r
          } = this,
          n = this.length >> 1,
          i = e[t];
        for (; t < n;) {
          let n = 1 + (t << 1),
            s = e[n];
          const a = n + 1;
          if (a < this.length && r(e[a], s) < 0 && (n = a, s = e[a]), r(s, i) >= 0) break;
          e[t] = s, t = n;
        }
        e[t] = i;
      }
    }
    function xf(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }
    function vf(t, e = 1, r = !1) {
      let n = 1 / 0,
        i = 1 / 0,
        s = -1 / 0,
        a = -1 / 0;
      const o = t[0];
      for (let t = 0; t < o.length; t++) {
        const e = o[t];
        (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > a) && (a = e.y);
      }
      const l = Math.min(s - n, a - i);
      let u = l / 2;
      const c = new gf([], bf);
      if (0 === l) return new d(n, i);
      for (let e = n; e < s; e += l) for (let r = i; r < a; r += l) c.push(new wf(e + u, r + u, u, t));
      let h = function (t) {
          let e = 0,
            r = 0,
            n = 0;
          const i = t[0];
          for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {
            const s = i[t],
              o = i[a],
              l = s.x * o.y - o.x * s.y;
            r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;
          }
          return new wf(r / e, n / e, 0, t);
        }(t),
        p = c.length;
      for (; c.length;) {
        const n = c.pop();
        (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new wf(n.p.x - u, n.p.y - u, u, t)), c.push(new wf(n.p.x + u, n.p.y - u, u, t)), c.push(new wf(n.p.x - u, n.p.y + u, u, t)), c.push(new wf(n.p.x + u, n.p.y + u, u, t)), p += 4);
      }
      return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
    }
    function bf(t, e) {
      return e.max - t.max;
    }
    function wf(t, e, r, n) {
      this.p = new d(t, e), this.h = r, this.d = function (t, e) {
        let r = !1,
          n = 1 / 0;
        for (let i = 0; i < e.length; i++) {
          const s = e[i];
          for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {
            const i = s[e],
              o = s[a];
            i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Cu(t, i, o));
          }
        }
        return (r ? 1 : -1) * Math.sqrt(n);
      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
    }
    const _f = Number.POSITIVE_INFINITY,
      Af = Math.sqrt(2);
    function Sf(t, [e, r]) {
      let n = 0,
        i = 0;
      if (r === _f) {
        e < 0 && (e = 0);
        const r = e / Af;
        switch (t) {
          case "top-right":
          case "top-left":
            i = r - 7;
            break;
          case "bottom-right":
          case "bottom-left":
            i = 7 - r;
            break;
          case "bottom":
            i = 7 - e;
            break;
          case "top":
            i = e - 7;
        }
        switch (t) {
          case "top-right":
          case "bottom-right":
            n = -r;
            break;
          case "top-left":
          case "bottom-left":
            n = r;
            break;
          case "left":
            n = e;
            break;
          case "right":
            n = -e;
        }
      } else {
        switch (e = Math.abs(e), r = Math.abs(r), t) {
          case "top-right":
          case "top-left":
          case "top":
            i = r - 7;
            break;
          case "bottom-right":
          case "bottom-left":
          case "bottom":
            i = 7 - r;
        }
        switch (t) {
          case "top-right":
          case "bottom-right":
          case "right":
            n = -e;
            break;
          case "top-left":
          case "bottom-left":
          case "left":
            n = e;
        }
      }
      return [n, i];
    }
    function kf(t, e, r, n, i, s, a, o, l, u) {
      t.createArrays(), t.tilePixelRatio = ko / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;
      const c = t.layers[0].layout,
        h = t.layers[0]._unevaluatedLayout._values,
        p = {};
      if ("composite" === t.textSizeData.kind) {
        const {
          minZoom: e,
          maxZoom: r
        } = t.textSizeData;
        p.compositeTextSizes = [h["text-size"].possiblyEvaluate(new Us(e), o), h["text-size"].possiblyEvaluate(new Us(r), o)];
      }
      if ("composite" === t.iconSizeData.kind) {
        const {
          minZoom: e,
          maxZoom: r
        } = t.iconSizeData;
        p.compositeIconSizes = [h["icon-size"].possiblyEvaluate(new Us(e), o), h["icon-size"].possiblyEvaluate(new Us(r), o)];
      }
      p.layoutTextSize = h["text-size"].possiblyEvaluate(new Us(l + 1), o), p.layoutIconSize = h["icon-size"].possiblyEvaluate(new Us(l + 1), o), p.textMaxSize = h["text-size"].possiblyEvaluate(new Us(18), o);
      const f = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement"),
        d = c.get("text-size");
      for (const s of t.features) {
        const l = c.get("text-font").evaluate(s, {}, o).join(","),
          h = d.evaluate(s, {}, o),
          y = p.layoutTextSize.evaluate(s, {}, o),
          m = (p.layoutIconSize.evaluate(s, {}, o), {
            horizontal: {},
            vertical: void 0
          }),
          g = s.text;
        let x,
          v = [0, 0];
        if (g) {
          const n = g.toString(),
            a = c.get("text-letter-spacing").evaluate(s, {}, o) * Wh,
            u = c.get("text-line-height").evaluate(s, {}, o) * Wh,
            p = ws(n) ? a : 0,
            d = c.get("text-anchor").evaluate(s, {}, o),
            x = c.get("text-variable-anchor");
          if (!x) {
            const t = c.get("text-radial-offset").evaluate(s, {}, o);
            v = t ? Sf(d, [t * Wh, _f]) : c.get("text-offset").evaluate(s, {}, o).map(t => t * Wh);
          }
          let b = f ? "center" : c.get("text-justify").evaluate(s, {}, o);
          const w = "point" === c.get("symbol-placement"),
            _ = w ? c.get("text-max-width").evaluate(s, {}, o) * Wh : 1 / 0,
            A = s => {
              t.allowVerticalPlacement && bs(n) && (m.vertical = Rp(g, e, r, i, l, _, u, d, s, p, v, Vp.vertical, !0, y, h));
            };
          if (!f && x) {
            const t = "auto" === b ? x.map(t => If(t)) : [b];
            let n = !1;
            for (let s = 0; s < t.length; s++) {
              const a = t[s];
              if (!m.horizontal[a]) if (n) m.horizontal[a] = m.horizontal[0];else {
                const t = Rp(g, e, r, i, l, _, u, "center", a, p, v, Vp.horizontal, !1, y, h);
                t && (m.horizontal[a] = t, n = 1 === t.positionedLines.length);
              }
            }
            A("left");
          } else {
            if ("auto" === b && (b = If(d)), w || c.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n)) {
              const t = Rp(g, e, r, i, l, _, u, d, b, p, v, Vp.horizontal, !1, y, h);
              t && (m.horizontal[b] = t);
            }
            A(w ? "left" : b);
          }
        }
        let b = !1;
        if (s.icon && s.icon.name) {
          const e = n[s.icon.name];
          e && (x = Kp(i[s.icon.name], c.get("icon-offset").evaluate(s, {}, o), c.get("icon-anchor").evaluate(s, {}, o)), b = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && $("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e.pixelRatio !== t.pixelRatio || 0 !== c.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));
        }
        const w = Bf(m.horizontal) || m.vertical;
        t.iconsInText || (t.iconsInText = !!w && w.iconsInText), (w || x) && Mf(t, s, m, x, n, p, y, 0, v, b, a, o, u);
      }
      s && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);
    }
    function If(t) {
      switch (t) {
        case "right":
        case "top-right":
        case "bottom-right":
          return "right";
        case "left":
        case "top-left":
        case "bottom-left":
          return "left";
      }
      return "center";
    }
    function Mf(t, e, r, n, i, s, a, o, l, u, c, h, p) {
      let f = s.textMaxSize.evaluate(e, {}, h);
      void 0 === f && (f = a);
      const d = t.layers[0].layout,
        y = d.get("icon-offset").evaluate(e, {}, h),
        m = Bf(r.horizontal) || r.vertical,
        g = "globe" === p.name,
        v = a / 24,
        b = t.tilePixelRatio * f / 24,
        w = (z = t.overscaling, t.zoom > 18 && z > 2 && (z >>= 1), Math.max(ko / (512 * z), 1) * d.get("symbol-spacing")),
        _ = d.get("text-padding") * t.tilePixelRatio,
        A = d.get("icon-padding") * t.tilePixelRatio,
        S = x(d.get("text-max-angle")),
        k = "map" === d.get("text-rotation-alignment") && "point" !== d.get("symbol-placement"),
        I = "map" === d.get("icon-rotation-alignment") && "point" !== d.get("symbol-placement"),
        M = d.get("symbol-placement"),
        T = w / 2;
      var z;
      const B = d.get("icon-text-fit");
      let E;
      n && "none" !== B && (t.allowVerticalPlacement && r.vertical && (E = Yp(n, r.vertical, B, d.get("icon-text-fit-padding"), y, v)), m && (n = Yp(n, m, B, d.get("icon-text-fit-padding"), y, v)));
      const C = (a, o, f) => {
        if (o.x < 0 || o.x >= ko || o.y < 0 || o.y >= ko) return;
        let d = null;
        if (g) {
          const {
            x: t,
            y: e,
            z: r
          } = p.projectTilePoint(o.x, o.y, f);
          d = {
            anchor: new Hp(t, e, r, 0, void 0),
            up: p.upVector(f, o.x, o.y)
          };
        }
        !function (t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S) {
          const k = t.addToLineVertexArray(e, n);
          let I,
            M,
            T,
            z,
            B,
            E,
            C,
            P = 0,
            D = 0,
            V = 0,
            L = 0,
            F = -1,
            R = -1;
          const j = {};
          let U = qa("");
          const O = r ? r.anchor : e;
          let q = 0,
            N = 0;
          if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [q, N] = l.layout.get("text-offset").evaluate(b, {}, S).map(t => t * Wh) : (q = l.layout.get("text-radial-offset").evaluate(b, {}, S) * Wh, N = _f), t.allowVerticalPlacement && i.vertical) {
            const t = i.vertical;
            if (d) E = Cf(t), o && (C = Cf(o));else {
              const r = l.layout.get("text-rotate").evaluate(b, {}, S) + 90;
              T = Ef(u, O, e, c, h, p, t, f, r, y), o && (z = Ef(u, O, e, c, h, p, o, g, r));
            }
          }
          if (s) {
            const n = l.layout.get("icon-rotate").evaluate(b, {}, S),
              i = "none" !== l.layout.get("icon-text-fit"),
              a = hf(s, n, _, i),
              f = o ? hf(o, n, _, i) : void 0;
            M = Ef(u, O, e, c, h, p, s, g, n), P = 4 * a.length;
            const d = t.iconSizeData;
            let y = null;
            "source" === d.kind ? (y = [Jh * l.layout.get("icon-size").evaluate(b, {}, S)], y[0] > Tf && $(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d.kind && (y = [Jh * w.compositeIconSizes[0].evaluate(b, {}, S), Jh * w.compositeIconSizes[1].evaluate(b, {}, S)], (y[0] > Tf || y[1] > Tf) && $(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t.addSymbols(t.icon, a, y, v, x, b, !1, r, e, k.lineStartIndex, k.lineLength, -1, A, S), F = t.icon.placedSymbolArray.length - 1, f && (D = 4 * f.length, t.addSymbols(t.icon, f, y, v, x, b, Vp.vertical, r, e, k.lineStartIndex, k.lineLength, -1, A, S), R = t.icon.placedSymbolArray.length - 1);
          }
          for (const n in i.horizontal) {
            const s = i.horizontal[n];
            I || (U = qa(s.text), d ? B = Cf(s) : I = Ef(u, O, e, c, h, p, s, f, l.layout.get("text-rotate").evaluate(b, {}, S), y));
            const o = 1 === s.positionedLines.length;
            if (V += zf(t, r, e, s, a, l, d, b, y, k, i.vertical ? Vp.horizontal : Vp.horizontalOnly, o ? Object.keys(i.horizontal) : [n], j, F, w, A, S), o) break;
          }
          i.vertical && (L += zf(t, r, e, i.vertical, a, l, d, b, y, k, Vp.vertical, ["vertical"], j, R, w, A, S));
          let G = -1;
          const X = (t, e) => t ? Math.max(t, e) : e;
          G = X(B, G), G = X(E, G), G = X(C, G);
          const Z = G > -1 ? 1 : 0;
          t.glyphOffsetArray.length >= hd.MAX_GLYPHS && $("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(O.x, O.y, O.z, e.x, e.y, j.right >= 0 ? j.right : -1, j.center >= 0 ? j.center : -1, j.left >= 0 ? j.left : -1, j.vertical >= 0 ? j.vertical : -1, F, R, U, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, z || t.collisionBoxArray.length, z ? z + 1 : t.collisionBoxArray.length, c, V, L, P, D, Z, 0, q, N, G);
        }(t, o, d, a, r, n, i, E, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, _, k, l, 0, A, I, y, e, s, u, c, h);
      };
      if ("line" === M) for (const i of sf(e.geometry, 0, 0, ko, ko)) {
        const e = rf(i, w, S, r.vertical || m, n, 24, b, t.overscaling, ko);
        for (const r of e) {
          const e = m;
          e && Pf(t, e.text, T, r) || C(i, r, h);
        }
      } else if ("line-center" === M) {
        for (const t of e.geometry) if (t.length > 1) {
          const e = ef(t, S, r.vertical || m, n, 24, b);
          e && C(t, e, h);
        }
      } else if ("Polygon" === e.type) for (const t of Lc(e.geometry, 0)) {
        const e = vf(t, 16);
        C(t[0], new Hp(e.x, e.y, 0, 0, void 0), h);
      } else if ("LineString" === e.type) for (const t of e.geometry) C(t, new Hp(t[0].x, t[0].y, 0, 0, void 0), h);else if ("Point" === e.type) for (const t of e.geometry) for (const e of t) C([e], new Hp(e.x, e.y, 0, 0, void 0), h);
    }
    const Tf = 32640;
    function zf(t, e, r, n, i, s, a, o, l, u, c, h, p, f, y, m, g) {
      const x = function (t, e, r, n, i, s, a, o) {
          const l = [];
          if (0 === e.positionedLines.length) return l;
          const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180,
            c = function (t) {
              const e = t[0],
                r = t[1],
                n = e * r;
              return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];
            }(r);
          let h = Math.abs(e.top - e.bottom);
          for (const t of e.positionedLines) h -= t.lineOffset;
          const p = e.positionedLines.length,
            f = h / p;
          let y = e.top - r[1];
          for (let t = 0; t < p; ++t) {
            const n = e.positionedLines[t];
            y = mf(e, f, y, t);
            for (const t of n.positionedGlyphs) {
              if (!t.rect) continue;
              const n = t.rect || {};
              let s = 4,
                h = !0,
                p = 1,
                f = 0;
              if (t.imageName) {
                const e = a[t.imageName];
                if (!e) continue;
                if (e.sdf) {
                  $("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                h = !1, p = e.pixelRatio, s = 1 / p;
              }
              const m = (i || o) && t.vertical,
                g = t.metrics.advance * t.scale / 2,
                x = t.metrics,
                v = t.rect;
              if (null === v) continue;
              o && e.verticalizable && (f = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);
              const b = i ? [t.x + g, t.y] : [0, 0];
              let w = [0, 0],
                _ = [0, 0],
                A = !1;
              i || (m ? (_ = [t.x + g + c[0], t.y + c[1] - f], A = !0) : w = [t.x + g + r[0], t.y + r[1] - f]);
              const S = v.w * t.scale / (p * (t.localGlyph ? 2 : 1)),
                k = v.h * t.scale / (p * (t.localGlyph ? 2 : 1));
              let I, M, T, z;
              if (m) {
                const e = t.y - y,
                  r = new d(-g, g - e),
                  n = -Math.PI / 2,
                  i = new d(..._);
                I = new d(-g + w[0], w[1]), I._rotateAround(n, r)._add(i), I.x += -e + g, I.y -= (x.left - s) * t.scale;
                const a = t.imageName ? x.advance * t.scale : Wh * t.scale,
                  o = String.fromCharCode(t.glyph);
                sp(o) ? I.x += (1 - s) * t.scale : ap(o) ? I.x += a - x.height * t.scale + (-s - 1) * t.scale : I.x += t.imageName || x.width + 2 * s === v.w && x.height + 2 * s === v.h ? (a - k) / 2 : (a - (x.height + 2 * s) * t.scale) / 2, M = new d(I.x, I.y - S), T = new d(I.x + k, I.y), z = new d(I.x + k, I.y - S);
              } else {
                const e = (x.left - s) * t.scale - g + w[0],
                  r = (-x.top - s) * t.scale + w[1],
                  n = e + S,
                  i = r + k;
                I = new d(e, r), M = new d(n, r), T = new d(e, i), z = new d(n, i);
              }
              if (u) {
                let t;
                t = i ? new d(0, 0) : A ? new d(c[0], c[1]) : new d(r[0], r[1]), I._rotateAround(u, t), M._rotateAround(u, t), T._rotateAround(u, t), z._rotateAround(u, t);
              }
              const B = new d(0, 0),
                E = new d(0, 0);
              l.push({
                tl: I,
                tr: M,
                bl: T,
                br: z,
                tex: n,
                writingMode: e.writingMode,
                glyphOffset: b,
                sectionIndex: t.sectionIndex,
                isSDF: h,
                pixelOffsetTL: B,
                pixelOffsetBR: E,
                minFontScaleX: 0,
                minFontScaleY: 0
              });
            }
          }
          return l;
        }(0, n, l, s, a, o, i, t.allowVerticalPlacement),
        v = t.textSizeData;
      let b = null;
      "source" === v.kind ? (b = [Jh * s.layout.get("text-size").evaluate(o, {}, g)], b[0] > Tf && $(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v.kind && (b = [Jh * y.compositeTextSizes[0].evaluate(o, {}, g), Jh * y.compositeTextSizes[1].evaluate(o, {}, g)], (b[0] > Tf || b[1] > Tf) && $(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t.addSymbols(t.text, x, b, l, a, o, c, e, r, u.lineStartIndex, u.lineLength, f, m, g);
      for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;
      return 4 * x.length;
    }
    function Bf(t) {
      for (const e in t) return t[e];
      return null;
    }
    function Ef(t, e, r, n, i, s, a, o, l, u) {
      let c = a.top,
        h = a.bottom,
        p = a.left,
        f = a.right;
      const y = a.collisionPadding;
      if (y && (p -= y[0], c -= y[1], f += y[2], h += y[3]), l) {
        const t = new d(p, c),
          e = new d(f, c),
          r = new d(p, h),
          n = new d(f, h),
          i = x(l);
        let s = new d(0, 0);
        u && (s = new d(u[0], u[1])), t._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t.x, e.x, r.x, n.x), f = Math.max(t.x, e.x, r.x, n.x), c = Math.min(t.y, e.y, r.y, n.y), h = Math.max(t.y, e.y, r.y, n.y);
      }
      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, f, h, o, n, i, s), t.length - 1;
    }
    function Cf(t) {
      t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);
      const e = t.bottom - t.top;
      return e > 0 ? Math.max(10, e) : null;
    }
    function Pf(t, e, r, n) {
      const i = t.compareText;
      if (e in i) {
        const t = i[e];
        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;
      } else i[e] = [];
      return i[e].push(n), !1;
    }
    function Df(t, e) {
      const r = t.fovAboveCenter,
        n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,
        i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),
        s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01)),
        a = Math.sin(t._pitch) * s + i;
      return Math.min(1.01 * a, i * (1 / t._horizonShift));
    }
    function Vf(t, e) {
      if (!e.isReprojectedInTileSpace) return {
        scale: 1 << t.z,
        x: t.x,
        y: t.y,
        x2: t.x + 1,
        y2: t.y + 1,
        projection: e
      };
      const r = Math.pow(2, -t.z),
        n = t.x * r,
        i = (t.x + 1) * r,
        s = t.y * r,
        a = (t.y + 1) * r,
        o = ou(n),
        l = ou(i),
        u = lu(s),
        c = lu(a),
        h = e.project(o, u),
        p = e.project(l, u),
        f = e.project(l, c),
        d = e.project(o, c);
      let y = Math.min(h.x, p.x, f.x, d.x),
        m = Math.min(h.y, p.y, f.y, d.y),
        g = Math.max(h.x, p.x, f.x, d.x),
        x = Math.max(h.y, p.y, f.y, d.y);
      const v = r / 16;
      function b(t, r, n, i, s, a) {
        const o = (n + s) / 2,
          l = (i + a) / 2,
          u = e.project(ou(o), lu(l)),
          c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);
        y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, s, a));
      }
      b(h, p, n, s, i, s), b(p, f, i, s, i, a), b(f, d, i, a, n, a), b(d, h, n, a, n, s), y -= v, m -= v, g += v, x += v;
      const w = 1 / Math.max(g - y, x - m);
      return {
        scale: w,
        x: y * w,
        y: m * w,
        x2: g * w,
        y2: x * w,
        projection: e
      };
    }
    const Lf = Eo(new Float32Array(16));
    class Ff {
      constructor(t) {
        this.spec = t, this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
      }
      project(t, e) {
        return {
          x: 0,
          y: 0,
          z: 0
        };
      }
      unproject(t, e) {
        return new ru(0, 0);
      }
      projectTilePoint(t, e, r) {
        return {
          x: t,
          y: e,
          z: 0
        };
      }
      locationPoint(t, e, r = !0) {
        return t._coordinatePoint(t.locationCoordinate(e), r);
      }
      pixelsPerMeter(t, e) {
        return au(1, t) * e;
      }
      pixelSpaceConversion(t, e, r) {
        return 1;
      }
      farthestPixelDistance(t) {
        return Df(t, t.pixelsPerMeter);
      }
      pointCoordinate(t, e, r, n) {
        const i = t.horizonLineFromTop(!1),
          s = new d(e, Math.max(i, r));
        return t.rayIntersectionCoordinate(t.pointRayIntersection(s, n));
      }
      pointCoordinate3D(t, e, r) {
        const n = new d(e, r);
        if (t.elevation) return t.elevation.pointCoordinate(n);
        {
          const e = this.pointCoordinate(t, n.x, n.y, 0);
          return [e.x, e.y, e.z];
        }
      }
      isPointAboveHorizon(t, e) {
        if (t.elevation) return !this.pointCoordinate3D(t, e.x, e.y);
        const r = t.horizonLineFromTop();
        return e.y < r;
      }
      createInversionMatrix(t, e) {
        return Lf;
      }
      createTileMatrix(t, e, r) {
        let n, i, s;
        const a = r.canonical,
          o = Eo(new Float64Array(16));
        if (this.isReprojectedInTileSpace) {
          const l = Vf(a, this);
          n = 1, i = l.x + r.wrap * l.scale, s = l.y, Vo(o, o, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);
        } else n = e / t.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;
        return Do(o, o, [i, s, 0]), Vo(o, o, [n / ko, n / ko, 1]), o;
      }
      upVector(t, e, r) {
        return [0, 0, 1];
      }
      upVectorScale(t, e, r) {
        return {
          metersToTile: 1
        };
      }
    }
    class Rf extends Ff {
      constructor(t) {
        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];
        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],
          n = Math.sin(x(e));
        this.n = (n + Math.sin(x(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
      }
      project(t, e) {
        const {
            n: r,
            c: n,
            r0: i
          } = this,
          s = x(t - this.center[0]),
          a = x(e),
          o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
        return {
          x: o * Math.sin(s * r),
          y: o * Math.cos(s * r) - i,
          z: 0
        };
      }
      unproject(t, e) {
        const {
            n: r,
            c: n,
            r0: i
          } = this,
          s = i + e;
        let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);
        s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));
        const o = x(this.center[0]) * r;
        a = I(a, -Math.PI - o, Math.PI - o);
        const l = S(v(a / r) + this.center[0], -180, 180),
          u = Math.asin(S((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),
          c = S(v(u), -cu, cu);
        return new ru(l, c);
      }
    }
    const jf = 1.340264,
      Uf = -.081106,
      $f = 893e-6,
      Of = .003796,
      qf = Math.sqrt(3) / 2;
    class Nf extends Ff {
      project(t, e) {
        e = e / 180 * Math.PI, t = t / 180 * Math.PI;
        const r = Math.asin(qf * Math.sin(e)),
          n = r * r,
          i = n * n * n;
        return {
          x: .5 * (t * Math.cos(r) / (qf * (jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n))) / Math.PI + .5),
          y: 1 - .5 * (r * (jf + Uf * n + i * ($f + Of * n)) / Math.PI + 1),
          z: 0
        };
      }
      unproject(t, e) {
        t = (2 * t - .5) * Math.PI;
        let r = e = (2 * (1 - e) - 1) * Math.PI,
          n = r * r,
          i = n * n * n;
        for (let t, s, a, o = 0; o < 12 && (s = r * (jf + Uf * n + i * ($f + Of * n)) - e, a = jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n), t = s / a, r = S(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);
        const s = qf * t * (jf + 3 * Uf * n + i * (7 * $f + 9 * Of * n)) / Math.cos(r),
          a = Math.asin(Math.sin(r) / qf),
          o = S(180 * s / Math.PI, -180, 180),
          l = S(180 * a / Math.PI, -cu, cu);
        return new ru(o, l);
      }
    }
    class Gf extends Ff {
      constructor(t) {
        super(t), this.wrap = !0, this.supportsWorldCopies = !0;
      }
      project(t, e) {
        return {
          x: .5 + t / 360,
          y: .5 - e / 360,
          z: 0
        };
      }
      unproject(t, e) {
        const r = 360 * (t - .5),
          n = S(360 * (.5 - e), -cu, cu);
        return new ru(r, n);
      }
    }
    const Xf = Math.PI / 2;
    function Zf(t) {
      return Math.tan((Xf + t) / 2);
    }
    class Kf extends Ff {
      constructor(t) {
        super(t), this.center = t.center || [0, 30];
        const [e, r] = this.parallels = t.parallels || [30, 30];
        let n = x(e),
          i = x(r);
        this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
        const s = Math.cos(n),
          a = Zf(n);
        this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Zf(i) / a), this.f = s * Math.pow(Zf(n), this.n) / this.n;
      }
      project(t, e) {
        e = x(e), this.southernCenter && (e = -e), t = x(t - this.center[0]);
        const r = 1e-6,
          {
            n: n,
            f: i
          } = this;
        i > 0 ? e < -Xf + r && (e = -Xf + r) : e > Xf - r && (e = Xf - r);
        const s = i / Math.pow(Zf(e), n);
        let a = s * Math.sin(n * t),
          o = i - s * Math.cos(n * t);
        return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {
          x: a,
          y: this.southernCenter ? o : 1 - o,
          z: 0
        };
      }
      unproject(t, e) {
        t = (2 * t - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;
        const {
            n: r,
            f: n
          } = this,
          i = n - e,
          s = Math.sign(i),
          a = Math.sign(r) * Math.sqrt(t * t + i * i);
        let o = Math.atan2(t, Math.abs(i)) * s;
        i * r < 0 && (o -= Math.PI * Math.sign(t) * s);
        const l = S(v(o / r) + this.center[0], -180, 180),
          u = S(v(2 * Math.atan(Math.pow(n / a, 1 / r)) - Xf), -cu, cu);
        return new ru(l, this.southernCenter ? -u : u);
      }
    }
    class Yf extends Ff {
      constructor(t) {
        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
      }
      project(t, e) {
        return {
          x: iu(t),
          y: su(e),
          z: 0
        };
      }
      unproject(t, e) {
        const r = ou(t),
          n = lu(e);
        return new ru(r, n);
      }
    }
    const Hf = x(cu);
    class Wf extends Ff {
      project(t, e) {
        const r = (e = x(e)) * e,
          n = r * r;
        return {
          x: .5 * ((t = x(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
          z: 0
        };
      }
      unproject(t, e) {
        t = (2 * t - .5) * Math.PI;
        let r = e = (2 * (1 - e) - 1) * Math.PI,
          n = 25,
          i = 0,
          s = r * r;
        do {
          s = r * r;
          const t = s * s;
          i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = S(r - i, -Hf, Hf);
        } while (Math.abs(i) > 1e-6 && --n > 0);
        s = r * r;
        const a = S(v(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),
          o = v(r);
        return new ru(a, o);
      }
    }
    const Jf = x(cu);
    class Qf extends Ff {
      project(t, e) {
        e = x(e), t = x(t);
        const r = Math.cos(e),
          n = 2 / Math.PI,
          i = Math.acos(r * Math.cos(t / 2)),
          s = Math.sin(i) / i,
          a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,
          o = .5 * (e + Math.sin(e) / s) || 0;
        return {
          x: .5 * (a / Math.PI + .5),
          y: 1 - .5 * (o / Math.PI + 1),
          z: 0
        };
      }
      unproject(t, e) {
        let r = t = (2 * t - .5) * Math.PI,
          n = e = (2 * (1 - e) - 1) * Math.PI,
          i = 25;
        const s = 1e-6;
        let a = 0,
          o = 0;
        do {
          const i = Math.cos(n),
            s = Math.sin(n),
            l = 2 * s * i,
            u = s * s,
            c = i * i,
            h = Math.cos(r / 2),
            p = Math.sin(r / 2),
            f = 2 * h * p,
            d = p * p,
            y = 1 - c * h * h,
            m = y ? 1 / y : 0,
            g = y ? Math.acos(i * h) * Math.sqrt(1 / y) : 0,
            x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t,
            v = .5 * (g * s + n) - e,
            b = .5 * m * (c * d + g * i * h * u) + 1 / Math.PI,
            w = m * (f * l / 4 - g * s * p),
            _ = .125 * m * (l * p - g * s * c * f),
            A = .5 * m * (u * h + g * d * i) + .5,
            k = w * _ - A * b;
          a = (v * w - x * A) / k, o = (x * _ - v * b) / k, r = S(r - a, -Math.PI, Math.PI), n = S(n - o, -Jf, Jf);
        } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);
        return new ru(v(r), v(n));
      }
    }
    class td extends Ff {
      constructor(t) {
        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(x(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
      }
      project(t, e) {
        const {
          scale: r,
          cosPhi: n
        } = this;
        return {
          x: x(t) * n * r + .5,
          y: -Math.sin(x(e)) / n * r + .5,
          z: 0
        };
      }
      unproject(t, e) {
        const {
            scale: r,
            cosPhi: n
          } = this,
          i = -(e - .5) / r,
          s = S(v((t - .5) / r) / n, -180, 180),
          a = Math.asin(S(i * n, -1, 1)),
          o = S(v(a), -cu, cu);
        return new ru(s, o);
      }
    }
    class ed extends Yf {
      constructor(t) {
        super(t), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
      }
      projectTilePoint(t, e, r) {
        const n = Ol(t, e, r);
        return el(n, n, Gl(Pl(r))), {
          x: n[0],
          y: n[1],
          z: n[2]
        };
      }
      locationPoint(t, e) {
        const r = $l(e.lat, e.lng),
          n = Jo([], r),
          i = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;
        Wo(r, r, n, au(1, 0) * ko * i);
        const s = Eo(new Float64Array(16));
        return Po(s, t.pixelMatrix, t.globeMatrix), el(r, r, s), new d(r[0], r[1]);
      }
      pixelsPerMeter(t, e) {
        return au(1, 0) * e;
      }
      pixelSpaceConversion(t, e, r) {
        const n = au(1, t) * e,
          i = Mr(au(1, 45) * e, n, r);
        return this.pixelsPerMeter(t, e) / i;
      }
      createTileMatrix(t, e, r) {
        const n = Xl(Pl(r.canonical));
        return Po(new Float64Array(16), t.globeMatrix, n);
      }
      createInversionMatrix(t, e) {
        const {
            center: r
          } = t,
          n = Gl(Pl(e));
        return Fo(n, n, x(r.lng)), Lo(n, n, x(r.lat)), Vo(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]), Float32Array.from(n);
      }
      pointCoordinate(t, e, r, n) {
        return Bl(t, e, r, !0) || new pu(0, 0);
      }
      pointCoordinate3D(t, e, r) {
        const n = this.pointCoordinate(t, e, r, 0);
        return [n.x, n.y, n.z];
      }
      isPointAboveHorizon(t, e) {
        return !Bl(t, e.x, e.y, !1);
      }
      farthestPixelDistance(t) {
        const e = function (t, e) {
            const r = t.cameraToCenterDistance,
              n = t._centerAltitude * e,
              i = t._camera,
              s = t._camera.forward(),
              a = Go([], Ho([], s, -r), [0, 0, n]),
              o = t.worldSize / (2 * Math.PI),
              l = [0, 0, -o],
              u = t.width / t.height,
              c = Math.tan(t.fovAboveCenter),
              h = Ho([], i.up(), c),
              p = Ho([], i.right(), c * u),
              f = Jo([], Go([], Go([], s, h), p)),
              d = [];
            let y;
            if (new vl(a, f).closestPointOnSphere(l, o, d)) {
              const e = Go([], d, l),
                r = il([], e, a);
              y = Math.cos(t.fovAboveCenter) * qo(r);
            } else {
              const t = il([], a, l),
                e = il([], l, a);
              Jo(e, e);
              const r = qo(t) - o;
              y = Math.sqrt(r * (r + 2 * o));
              const n = Math.acos(y / (o + r)) - Math.acos(Qo(s, e));
              y *= Math.cos(n);
            }
            return 1.01 * y;
          }(t, this.pixelsPerMeter(t.center.lat, t.worldSize)),
          r = Kl(t.zoom);
        if (r > 0) {
          const n = Df(t, au(1, t.center.lat) * t.worldSize),
            i = t.worldSize / (2 * Math.PI),
            s = Math.max(t.width, t.height) / t.worldSize * Math.PI;
          return Mr(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));
        }
        return e;
      }
      upVector(t, e, r) {
        return Ol(e, r, t, 1);
      }
      upVectorScale(t) {
        return {
          metersToTile: zl(ql(Pl(t)))
        };
      }
    }
    function rd(t) {
      const e = t.parallels,
        r = !!e && Math.abs(e[0] + e[1]) < .01;
      switch (t.name) {
        case "mercator":
          return new Yf(t);
        case "equirectangular":
          return new Gf(t);
        case "naturalEarth":
          return new Wf(t);
        case "equalEarth":
          return new Nf(t);
        case "winkelTripel":
          return new Qf(t);
        case "albers":
          return r ? new td(t) : new Rf(t);
        case "lambertConformalConic":
          return r ? new td(t) : new Kf(t);
        case "globe":
          return new ed(t);
      }
      throw new Error(`Invalid projection name: ${t.name}`);
    }
    const nd = ah.types,
      id = [{
        name: "a_fade_opacity",
        components: 1,
        type: "Uint8",
        offset: 0
      }];
    function sd(t, e, r, n, i, s, a, o, l, u, c, h, p) {
      const f = o ? Math.min(Tf, Math.round(o[0])) : 0,
        d = o ? Math.min(Tf, Math.round(o[1])) : 0;
      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
    }
    function ad(t, e, r, n, i, s, a) {
      t.emplaceBack(e, r, n, i, s, a);
    }
    function od(t, e, r, n, i) {
      t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i);
    }
    function ld(t) {
      for (const e of t.sections) if (Ms(e.text)) return !0;
      return !1;
    }
    class ud {
      constructor(t) {
        this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t, this.segments = new So(), this.dynamicLayoutVertexArray = new ua(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Pa(), this.globeExtVertexArray = new da();
      }
      isEmpty() {
        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
      }
      upload(t, e, r, n) {
        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Nh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Xh.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, id, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Gh.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));
      }
      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
      }
    }
    Oi(ud, "SymbolBuffers");
    class cd {
      constructor(t, e, r) {
        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new So(), this.collisionVertexArray = new va(), this.collisionVertexArrayExt = new ba();
      }
      upload(t) {
        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Zh.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Kh.members, !0);
      }
      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
      }
    }
    Oi(cd, "CollisionBuffers");
    class hd {
      constructor(t) {
        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Eo([]), this.placementViewportMatrix = Eo([]);
        const e = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = Qh(this.zoom, e["text-size"]), this.iconSizeData = Qh(this.zoom, e["icon-size"]);
        const r = this.layers[0].layout,
          n = r.get("symbol-sort-key"),
          i = r.get("symbol-z-order");
        this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map(t => Vp[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection;
      }
      createArrays() {
        this.text = new ud(new fo(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new ud(new fo(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new La(), this.lineVertexArray = new Fa(), this.symbolInstances = new Va();
      }
      calculateGlyphDependencies(t, e, r, n, i) {
        for (let r = 0; r < t.length; r++) if (e[t.charCodeAt(r)] = !0, n && i) {
          const n = ip[t.charAt(r)];
          n && (e[n.charCodeAt(0)] = !0);
        }
      }
      populate(t, e, r, n) {
        const i = this.layers[0],
          s = i.layout,
          a = "globe" === this.projection.name,
          o = s.get("text-font"),
          l = s.get("text-field"),
          u = s.get("icon-image"),
          c = ("constant" !== l.value.kind || l.value.value instanceof Be && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0),
          h = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0,
          p = s.get("symbol-sort-key");
        if (this.features = [], !c && !h) return;
        const f = e.iconDependencies,
          d = e.glyphDependencies,
          y = e.availableImages,
          m = new Us(this.zoom);
        for (const {
          feature: e,
          id: l,
          index: u,
          sourceLayerIndex: g
        } of t) {
          const t = i._featureFilter.needGeometry,
            x = wu(e, t);
          if (!i._featureFilter.filter(m, x, r)) continue;
          if (t || (x.geometry = bu(e, r, n)), a && 1 !== e.type && r.z <= 5) {
            const t = x.geometry,
              e = .98078528056,
              n = (t, n) => Qo(Ol(t.x, t.y, r, 1), Ol(n.x, n.y, r, 1)) < e;
            for (let e = 0; e < t.length; e++) t[e] = mu(t[e], n);
          }
          let v, b;
          if (c) {
            const t = i.getValueAndResolveTokens("text-field", x, r, y),
              e = Be.factory(t);
            ld(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Fs() || this.hasRTLText && js.isParsed()) && (v = np(e, i, x));
          }
          if (h) {
            const t = i.getValueAndResolveTokens("icon-image", x, r, y);
            b = t instanceof Ee ? t : Ee.fromString(t);
          }
          if (!v && !b) continue;
          const w = this.sortFeaturesByKey ? p.evaluate(x, {}, r) : void 0;
          if (this.features.push({
            id: l,
            text: v,
            icon: b,
            index: u,
            sourceLayerIndex: g,
            geometry: x.geometry,
            properties: e.properties,
            type: nd[e.type],
            sortKey: w
          }), b && (f[b.name] = !0), v) {
            const t = o.evaluate(x, {}, r).join(","),
              e = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Vp.vertical) >= 0;
            for (const r of v.sections) if (r.image) f[r.image.name] = !0;else {
              const n = bs(v.toString()),
                i = r.fontStack || t,
                s = d[i] = d[i] || {};
              this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
            }
          }
        }
        "line" === s.get("symbol-placement") && (this.features = function (t) {
          const e = {},
            r = {},
            n = [];
          let i = 0;
          function s(e) {
            n.push(t[e]), i++;
          }
          function a(t, e, i) {
            const s = r[t];
            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
          }
          function o(t, r, i) {
            const s = e[r];
            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
          }
          function l(t, e, r) {
            const n = r ? e[0][e[0].length - 1] : e[0][0];
            return `${t}:${n.x}:${n.y}`;
          }
          for (let u = 0; u < t.length; u++) {
            const c = t[u],
              h = c.geometry,
              p = c.text ? c.text.toString() : null;
            if (!p) {
              s(u);
              continue;
            }
            const f = l(p, h),
              d = l(p, h, !0);
            if (f in r && d in e && r[f] !== e[d]) {
              const t = o(f, d, h),
                i = a(f, d, n[t].geometry);
              delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;
            } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);
          }
          return n.filter(t => t.geometry);
        }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);
      }
      update(t, e, r, n) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));
      }
      isEmpty() {
        return 0 === this.symbolInstances.length && !this.hasRTLText;
      }
      uploadPending() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }
      upload(t) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
      }
      destroyDebugData() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }
      getProjection() {
        return this.projectionInstance || (this.projectionInstance = rd(this.projection)), this.projectionInstance;
      }
      destroy() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }
      addToLineVertexArray(t, e) {
        const r = this.lineVertexArray.length;
        if (void 0 !== t.segment) for (const {
          x: t,
          y: r
        } of e) this.lineVertexArray.emplaceBack(t, r);
        return {
          lineStartIndex: r,
          lineLength: this.lineVertexArray.length - r
        };
      }
      addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
        const d = t.indexArray,
          y = t.layoutVertexArray,
          m = t.globeExtVertexArray,
          g = t.segments.prepareSegment(4 * e.length, y, d, this.canOverlap ? s.sortKey : void 0),
          x = this.glyphOffsetArray.length,
          v = g.vertexLength,
          b = this.allowVerticalPlacement && a === Vp.vertical ? Math.PI / 2 : 0,
          w = s.text && s.text.sections;
        for (let n = 0; n < e.length; n++) {
          const {
              tl: i,
              tr: a,
              bl: u,
              br: c,
              tex: h,
              pixelOffsetTL: x,
              pixelOffsetBR: v,
              minFontScaleX: _,
              minFontScaleY: A,
              glyphOffset: S,
              isSDF: k,
              sectionIndex: I
            } = e[n],
            M = g.vertexLength,
            T = S[1];
          if (sd(y, l.x, l.y, i.x, T + i.y, h.x, h.y, r, k, x.x, x.y, _, A), sd(y, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, k, v.x, x.y, _, A), sd(y, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, k, x.x, v.y, _, A), sd(y, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, k, v.x, v.y, _, A), o) {
            const {
                x: e,
                y: r,
                z: n
              } = o.anchor,
              [i, s, a] = o.up;
            ad(m, e, r, n, i, s, a), ad(m, e, r, n, i, s, a), ad(m, e, r, n, i, s, a), ad(m, e, r, n, i, s, a), od(t.dynamicLayoutVertexArray, e, r, n, b);
          } else od(t.dynamicLayoutVertexArray, l.x, l.y, l.z, b);
          d.emplaceBack(M, M + 1, M + 2), d.emplaceBack(M + 1, M + 2, M + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S[0]), n !== e.length - 1 && I === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, f, w && w[I]);
        }
        const _ = o ? o.anchor : l;
        t.placedSymbolArray.emplaceBack(_.x, _.y, _.z, l.x, l.y, x, this.glyphOffsetArray.length - x, v, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
      }
      _commitLayoutVertex(t, e, r, n, i, s, a) {
        t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
      }
      _addCollisionDebugVertices(t, e, r, n, i, s, a) {
        const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),
          l = o.vertexLength,
          u = a.tileAnchorX,
          c = a.tileAnchorY;
        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
        r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new d(t.x1, t.y2)), o.vertexLength += 4;
        const h = r.indexArray;
        h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
      }
      _addTextDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
            i = this.getSymbolInstanceTextSize(t, s, e, a);
          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
        }
      }
      _addIconDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
            i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);
          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
        }
      }
      generateCollisionDebugBuffers(t, e) {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new cd(ga, Yh.members, Ma), this.iconCollisionBox = new cd(ga, Yh.members, Ma);
        const r = ep(this.iconSizeData, t),
          n = ep(this.textSizeData, t);
        for (let i = 0; i < this.symbolInstances.length; i++) {
          const s = this.symbolInstances.get(i);
          this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
        }
      }
      getSymbolInstanceTextSize(t, e, r, n) {
        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),
          s = tp(this.textSizeData, t, i) / Wh;
        return this.tilePixelRatio * s;
      }
      getSymbolInstanceIconSize(t, e, r) {
        const n = this.icon.placedSymbolArray.get(r),
          i = tp(this.iconSizeData, t, n);
        return this.tilePixelRatio * i;
      }
      _commitDebugCollisionVertexUpdate(t, e, r) {
        t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);
      }
      _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
            i = this.getSymbolInstanceTextSize(t, s, e, a);
          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);
        }
      }
      _updateIconDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
            i = this.getSymbolInstanceIconSize(t, e, s);
          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);
        }
      }
      updateCollisionDebugBuffers(t, e) {
        if (!this.hasDebugData()) return;
        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
        const r = ep(this.iconSizeData, t),
          n = ep(this.textSizeData, t);
        for (let i = 0; i < this.symbolInstances.length; i++) {
          const s = this.symbolInstances.get(i);
          this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s.placedIconSymbolIndex);
        }
        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
      }
      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {
        const u = {};
        if (e < r) {
          const {
            x1: r,
            y1: n,
            x2: i,
            y2: s,
            padding: a,
            projectedAnchorX: o,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p,
            featureIndex: f
          } = t.get(e);
          u.textBox = {
            x1: r,
            y1: n,
            x2: i,
            y2: s,
            padding: a,
            projectedAnchorX: o,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p
          }, u.textFeatureIndex = f;
        }
        if (n < i) {
          const {
            x1: e,
            y1: r,
            x2: i,
            y2: s,
            padding: a,
            projectedAnchorX: o,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p,
            featureIndex: f
          } = t.get(n);
          u.verticalTextBox = {
            x1: e,
            y1: r,
            x2: i,
            y2: s,
            padding: a,
            projectedAnchorX: o,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p
          }, u.verticalTextFeatureIndex = f;
        }
        if (s < a) {
          const {
            x1: e,
            y1: r,
            x2: n,
            y2: i,
            padding: a,
            projectedAnchorX: o,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p,
            featureIndex: f
          } = t.get(s);
          u.iconBox = {
            x1: e,
            y1: r,
            x2: n,
            y2: i,
            padding: a,
            projectedAnchorX: o,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p
          }, u.iconFeatureIndex = f;
        }
        if (o < l) {
          const {
            x1: e,
            y1: r,
            x2: n,
            y2: i,
            padding: s,
            projectedAnchorX: a,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p,
            featureIndex: f
          } = t.get(o);
          u.verticalIconBox = {
            x1: e,
            y1: r,
            x2: n,
            y2: i,
            padding: s,
            projectedAnchorX: a,
            projectedAnchorY: l,
            projectedAnchorZ: c,
            tileAnchorX: h,
            tileAnchorY: p
          }, u.verticalIconFeatureIndex = f;
        }
        return u;
      }
      deserializeCollisionBoxes(t) {
        this.collisionArrays = [];
        for (let e = 0; e < this.symbolInstances.length; e++) {
          const r = this.symbolInstances.get(e);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
        }
      }
      hasTextData() {
        return this.text.segments.get().length > 0;
      }
      hasIconData() {
        return this.icon.segments.get().length > 0;
      }
      hasDebugData() {
        return this.textCollisionBox && this.iconCollisionBox;
      }
      hasTextCollisionBoxData() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }
      hasIconCollisionBoxData() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }
      addIndicesForPlacedSymbol(t, e) {
        const r = t.placedSymbolArray.get(e),
          n = r.vertexStartIndex + 4 * r.numGlyphs;
        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);
      }
      getSortedSymbolIndexes(t) {
        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
        const e = Math.sin(t),
          r = Math.cos(t),
          n = [],
          i = [],
          s = [];
        for (let t = 0; t < this.symbolInstances.length; ++t) {
          s.push(t);
          const a = this.symbolInstances.get(t);
          n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
        }
        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;
      }
      addToSortKeyRanges(t, e) {
        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
          sortKey: e,
          symbolInstanceStart: t,
          symbolInstanceEnd: t + 1
        });
      }
      sortFeatures(t) {
        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
          for (const t of this.symbolInstanceIndexes) {
            const e = this.symbolInstances.get(t);
            this.featureSortOrder.push(e.featureIndex);
            const {
              rightJustifiedTextSymbolIndex: r,
              centerJustifiedTextSymbolIndex: n,
              leftJustifiedTextSymbolIndex: i,
              verticalPlacedTextSymbolIndex: s,
              placedIconSymbolIndex: a,
              verticalPlacedIconSymbolIndex: o
            } = e;
            r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
          }
          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }
    }
    Oi(hd, "SymbolBucket", {
      omit: ["layers", "collisionBoxArray", "features", "compareText"]
    }), hd.MAX_GLYPHS = 65535, hd.addDynamicAttributes = od;
    const pd = new Js({
      "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]),
      "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]),
      "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]),
      "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]),
      "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]),
      "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]),
      "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]),
      "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]),
      "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]),
      "icon-size": new Hs(Ht.layout_symbol["icon-size"]),
      "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]),
      "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]),
      "icon-image": new Hs(Ht.layout_symbol["icon-image"]),
      "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]),
      "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]),
      "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]),
      "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]),
      "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]),
      "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]),
      "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]),
      "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]),
      "text-field": new Hs(Ht.layout_symbol["text-field"]),
      "text-font": new Hs(Ht.layout_symbol["text-font"]),
      "text-size": new Hs(Ht.layout_symbol["text-size"]),
      "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]),
      "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]),
      "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]),
      "text-justify": new Hs(Ht.layout_symbol["text-justify"]),
      "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]),
      "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]),
      "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]),
      "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]),
      "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]),
      "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]),
      "text-padding": new Ys(Ht.layout_symbol["text-padding"]),
      "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]),
      "text-transform": new Hs(Ht.layout_symbol["text-transform"]),
      "text-offset": new Hs(Ht.layout_symbol["text-offset"]),
      "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]),
      "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]),
      "text-optional": new Ys(Ht.layout_symbol["text-optional"])
    });
    var fd = {
      paint: new Js({
        "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]),
        "icon-color": new Hs(Ht.paint_symbol["icon-color"]),
        "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]),
        "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]),
        "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]),
        "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]),
        "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]),
        "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]),
        "text-color": new Hs(Ht.paint_symbol["text-color"], {
          runtimeType: le,
          getOverride: t => t.textColor,
          hasOverride: t => !!t.textColor
        }),
        "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]),
        "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]),
        "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]),
        "text-translate": new Ys(Ht.paint_symbol["text-translate"]),
        "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"])
      }),
      layout: pd
    };
    class dd {
      constructor(t) {
        this.type = t.property.overrides ? t.property.overrides.runtimeType : ie, this.defaultValue = t;
      }
      evaluate(t) {
        if (t.formattedSection) {
          const e = this.defaultValue.property.overrides;
          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);
        }
        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
      }
      eachChild(t) {
        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
      }
      outputDefined() {
        return !1;
      }
      serialize() {
        return null;
      }
    }
    Oi(dd, "FormatSectionOverride", {
      omit: ["defaultValue"]
    });
    class yd extends wo {
      constructor(t) {
        super(t, fd);
      }
      recalculate(t, e) {
        super.recalculate(t, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
        const r = this.layout.get("text-writing-mode");
        if (r) {
          const t = [];
          for (const e of r) t.indexOf(e) < 0 && t.push(e);
          this.layout._values["text-writing-mode"] = t;
        } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
        this._setPaintOverrides();
      }
      getValueAndResolveTokens(t, e, r, n) {
        const i = this.layout.get(t).evaluate(e, {}, r, n),
          s = this._unevaluatedLayout._values[t];
        return s.isDataDriven() || Nn(s.value) || !i ? i : function (t, e) {
          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : "");
        }(e.properties, i);
      }
      createBucket(t) {
        return new hd(t);
      }
      queryRadius() {
        return 0;
      }
      queryIntersectsFeature() {
        return !1;
      }
      _setPaintOverrides() {
        for (const t of fd.paint.overridableProperties) {
          if (!yd.hasPaintOverride(this.layout, t)) continue;
          const e = this.paint.get(t),
            r = new dd(e),
            n = new qn(r, e.property.specification);
          let i = null;
          i = "constant" === e.value.kind || "source" === e.value.kind ? new Xn("source", n) : new Zn("composite", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new Zs(e.property, i, e.parameters);
        }
      }
      _handleOverridablePaintPropertyUpdate(t, e, r) {
        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && yd.hasPaintOverride(this.layout, t);
      }
      static hasPaintOverride(t, e) {
        const r = t.get("text-field"),
          n = fd.paint.properties[e];
        let i = !1;
        const s = t => {
          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
        };
        if ("constant" === r.value.kind && r.value.value instanceof Be) s(r.value.value.sections);else if ("source" === r.value.kind) {
          const t = e => {
              i || (e instanceof Fe && De(e.value) === pe ? s(e.value.sections) : e instanceof Oe ? s(e.sections) : e.eachChild(t));
            },
            e = r.value;
          e._styleExpression && t(e._styleExpression.expression);
        }
        return i;
      }
      getProgramConfiguration(t) {
        return new po(this, t);
      }
    }
    var md = {
        paint: new Js({
          "background-color": new Ys(Ht.paint_background["background-color"]),
          "background-pattern": new Ys(Ht.paint_background["background-pattern"]),
          "background-opacity": new Ys(Ht.paint_background["background-opacity"])
        })
      },
      gd = {
        paint: new Js({
          "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]),
          "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]),
          "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]),
          "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]),
          "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]),
          "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]),
          "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]),
          "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"])
        })
      };
    class xd extends wo {
      constructor(t) {
        super(t, {}), this.implementation = t;
      }
      is3D() {
        return "3d" === this.implementation.renderingMode;
      }
      hasOffscreenPass() {
        return void 0 !== this.implementation.prerender;
      }
      isLayerDraped() {
        return void 0 !== this.implementation.renderToTile;
      }
      shouldRedrape() {
        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
      }
      recalculate() {}
      updateTransitions() {}
      hasTransition() {
        return !1;
      }
      serialize() {}
      onAdd(t) {
        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);
      }
      onRemove(t) {
        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);
      }
    }
    var vd = {
      paint: new Js({
        "sky-type": new Ys(Ht.paint_sky["sky-type"]),
        "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]),
        "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]),
        "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]),
        "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]),
        "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]),
        "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]),
        "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]),
        "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"])
      })
    };
    function bd(t, e, r) {
      const n = [0, 0, 1],
        i = hl([]);
      return fl(i, i, r ? -x(t) + Math.PI : x(t)), pl(i, i, -x(e)), rl(n, n, i), Jo(n, n);
    }
    const wd = {
      circle: class extends wo {
        constructor(t) {
          super(t, Ou);
        }
        createBucket(t) {
          return new Su(t);
        }
        queryRadius(t) {
          const e = t;
          return Fu("circle-radius", this, e) + Fu("circle-stroke-width", this, e) + Ru(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t, e, r, n, i, s, a, o) {
          const l = Uu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
            u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
          return qu(t, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
        }
        getProgramIds() {
          return ["circle"];
        }
        getProgramConfiguration(t) {
          return new po(this, t);
        }
      },
      heatmap: class extends wo {
        createBucket(t) {
          return new Ku(t);
        }
        constructor(t) {
          super(t, tc), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          "heatmap-color" === t && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = ec({
            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
            evaluationKey: "heatmapDensity",
            image: this.colorRamp
          }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t) {
          return Fu("heatmap-radius", this, t);
        }
        queryIntersectsFeature(t, e, r, n, i, s, a, o) {
          const l = this.paint.get("heatmap-radius").evaluate(e, r);
          return qu(t, n, s, a, o, !0, !0, new d(0, 0), l);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getProgramConfiguration(t) {
          return new po(this, t);
        }
      },
      hillshade: class extends wo {
        constructor(t) {
          super(t, rc);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
      },
      fill: class extends wo {
        constructor(t) {
          super(t, Oc);
        }
        getProgramIds() {
          const t = this.paint.get("fill-pattern"),
            e = t && t.constantOr(1),
            r = [e ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
        }
        getProgramConfiguration(t) {
          return new po(this, t);
        }
        recalculate(t, e) {
          super.recalculate(t, e);
          const r = this.paint._values["fill-outline-color"];
          "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t) {
          return new Uc(t);
        }
        queryRadius() {
          return Ru(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t, e, r, n, i, s) {
          return !t.queryGeometry.isAboveHorizon && Mu(ju(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), n);
        }
        isTileClipped() {
          return !0;
        }
      },
      "fill-extrusion": class extends wo {
        constructor(t) {
          super(t, Ah);
        }
        createBucket(t) {
          return new fh(t);
        }
        queryRadius() {
          return Ru(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        getProgramConfiguration(t) {
          return new po(this, t);
        }
        queryIntersectsFeature(t, e, r, n, i, s, a, o, l) {
          const u = Uu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
            c = this.paint.get("fill-extrusion-height").evaluate(e, r),
            h = this.paint.get("fill-extrusion-base").evaluate(e, r),
            p = [0, 0],
            f = o && s.elevation,
            y = s.elevation ? s.elevation.exaggeration() : 1,
            m = t.tile.getBucket(this);
          if (f && m instanceof fh) {
            const t = m.centroidVertexArray,
              e = l + 1;
            e < t.length && (p[0] = t.geta_centroid_pos0(e), p[1] = t.geta_centroid_pos1(e));
          }
          if (0 === p[0] && 1 === p[1]) return !1;
          "globe" === s.projection.name && (n = wh([n], [new d(0, 0), new d(ko, ko)], t.tileID.canonical).map(t => t.polygon).flat());
          const g = f ? o : null,
            [x, v] = function (t, e, r, n, i, s, a, o, l, u, c) {
              return "globe" === t.projection.name ? function (t, e, r, n, i, s, a, o, l, u, c) {
                const h = [],
                  p = [],
                  f = t.projection.upVectorScale(c, t.center.lat, t.worldSize).metersToTile,
                  d = [0, 0, 0, 1],
                  y = [0, 0, 0, 1],
                  m = (t, e, r, n) => {
                    t[0] = e, t[1] = r, t[2] = n, t[3] = 1;
                  },
                  g = bh();
                r > 0 && (r += g), n += g;
                for (const g of e) {
                  const e = [],
                    x = [];
                  for (const h of g) {
                    const p = h.x + i.x,
                      g = h.y + i.y,
                      v = t.projection.projectTilePoint(p, g, c),
                      b = t.projection.upVector(c, h.x, h.y);
                    let w = r,
                      _ = n;
                    if (a) {
                      const t = Ch(p, g, r, n, a, o, l, u);
                      w += t.base, _ += t.top;
                    }
                    0 !== r ? m(d, v.x + b[0] * f * w, v.y + b[1] * f * w, v.z + b[2] * f * w) : m(d, v.x, v.y, v.z), m(y, v.x + b[0] * f * _, v.y + b[1] * f * _, v.z + b[2] * f * _), el(d, d, s), el(y, y, s), e.push(new zh(d[0], d[1], d[2])), x.push(new zh(y[0], y[1], y[2]));
                  }
                  h.push(e), p.push(x);
                }
                return [h, p];
              }(t, e, r, n, i, s, a, o, l, u, c) : a ? function (t, e, r, n, i, s, a, o, l) {
                const u = [],
                  c = [],
                  h = [0, 0, 0, 1];
                for (const p of t) {
                  const t = [],
                    f = [];
                  for (const u of p) {
                    const c = u.x + n.x,
                      p = u.y + n.y,
                      d = Ch(c, p, e, r, s, a, o, l);
                    h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, ul(h, h, i), h[3] = Math.max(h[3], 1e-5);
                    const y = new zh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                    h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, ul(h, h, i), h[3] = Math.max(h[3], 1e-5);
                    const m = new zh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                    t.push(y), f.push(m);
                  }
                  u.push(t), c.push(f);
                }
                return [u, c];
              }(e, r, n, i, s, a, o, l, u) : function (t, e, r, n, i) {
                const s = [],
                  a = [],
                  o = i[8] * e,
                  l = i[9] * e,
                  u = i[10] * e,
                  c = i[11] * e,
                  h = i[8] * r,
                  p = i[9] * r,
                  f = i[10] * r,
                  d = i[11] * r;
                for (const e of t) {
                  const t = [],
                    r = [];
                  for (const s of e) {
                    const e = s.x + n.x,
                      a = s.y + n.y,
                      y = i[0] * e + i[4] * a + i[12],
                      m = i[1] * e + i[5] * a + i[13],
                      g = i[2] * e + i[6] * a + i[14],
                      x = i[3] * e + i[7] * a + i[15],
                      v = y + o,
                      b = m + l,
                      w = g + u,
                      _ = Math.max(x + c, 1e-5),
                      A = y + h,
                      S = m + p,
                      k = g + f,
                      I = Math.max(x + d, 1e-5);
                    t.push(new zh(v / _, b / _, w / _)), r.push(new zh(A / I, S / I, k / I));
                  }
                  s.push(t), a.push(r);
                }
                return [s, a];
              }(e, r, n, i, s);
            }(s, n, h, c, u, a, g, p, y, s.center.lat, t.tileID.canonical),
            b = t.queryGeometry;
          return function (t, e, r) {
            let n = 1 / 0;
            Mu(r, e) && (n = Eh(r, e[0]));
            for (let i = 0; i < e.length; i++) {
              const s = e[i],
                a = t[i];
              for (let t = 0; t < s.length - 1; t++) {
                const e = s[t],
                  i = [e, s[t + 1], a[t + 1], a[t], e];
                ku(r, i) && (n = Math.min(n, Eh(r, i)));
              }
            }
            return n !== 1 / 0 && n;
          }(x, v, b.isPointQuery() ? b.screenBounds : b.screenGeometry);
        }
      },
      line: class extends wo {
        constructor(t) {
          super(t, $h), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t) {
          if ("line-gradient" === t) {
            const t = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(t, e) {
          super.recalculate(t, e), this.paint._values["line-floorwidth"] = Oh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
        }
        createBucket(t) {
          return new jh(t);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getProgramConfiguration(t) {
          return new po(this, t);
        }
        queryRadius(t) {
          const e = t,
            r = qh(Fu("line-width", this, e), Fu("line-gap-width", this, e)),
            n = Fu("line-offset", this, e);
          return r / 2 + Math.abs(n) + Ru(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t, e, r, n, i, s) {
          if (t.queryGeometry.isAboveHorizon) return !1;
          const a = ju(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
            o = t.pixelToTileUnitsFactor / 2 * qh(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)),
            l = this.paint.get("line-offset").evaluate(e, r);
          return l && (n = function (t, e) {
            const r = [],
              n = new d(0, 0);
            for (let i = 0; i < t.length; i++) {
              const s = t[i],
                a = [];
              for (let t = 0; t < s.length; t++) {
                const r = s[t - 1],
                  i = s[t],
                  o = s[t + 1],
                  l = 0 === t ? n : i.sub(r)._unit()._perp(),
                  u = t === s.length - 1 ? n : o.sub(i)._unit()._perp(),
                  c = l._add(u)._unit();
                c._mult(1 / (c.x * u.x + c.y * u.y)), a.push(c._mult(e)._add(i));
              }
              r.push(a);
            }
            return r;
          }(n, l * t.pixelToTileUnitsFactor)), function (t, e, r) {
            for (let n = 0; n < e.length; n++) {
              const i = e[n];
              if (t.length >= 3) for (let e = 0; e < i.length; e++) if (Du(t, i[e])) return !0;
              if (Tu(t, i, r)) return !0;
            }
            return !1;
          }(a, n, o);
        }
        isTileClipped() {
          return !0;
        }
      },
      symbol: yd,
      background: class extends wo {
        constructor(t) {
          super(t, md);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
      },
      raster: class extends wo {
        constructor(t) {
          super(t, gd);
        }
        getProgramIds() {
          return ["raster"];
        }
      },
      sky: class extends wo {
        constructor(t) {
          super(t, vd), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t) {
          "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0);
        }
        _updateColorRamp() {
          this.colorRamp = ec({
            expression: this._transitionablePaint._values["sky-gradient"].value.expression,
            evaluationKey: "skyRadialProgress"
          }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e = t.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
          }
          return !1;
        }
        getCenter(t, e) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const r = this.paint.get("sky-atmosphere-sun"),
              n = !r,
              i = t.style.light,
              s = i.properties.get("position");
            return n && "viewport" === i.properties.get("anchor") && $("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? bd(s.azimuthal, 90 - s.polar, e) : bd(r[0], 90 - r[1], e);
          }
          const r = this.paint.get("sky-gradient-center");
          return bd(r[0], 90 - r[1], e);
        }
        is3D() {
          return !1;
        }
        isSky() {
          return !0;
        }
        markSkyboxValid(t) {
          this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return !0;
        }
        getProgramIds() {
          const t = this.paint.get("sky-type");
          return "atmosphere" === t ? ["skyboxCapture", "skybox"] : "gradient" === t ? ["skyboxGradient"] : null;
        }
      }
    };
    class _d {
      constructor(t, e, r, n) {
        this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);
      }
      update(t, r, n) {
        const {
            width: i,
            height: s
          } = t,
          {
            context: a
          } = this,
          {
            gl: o
          } = a,
          {
            HTMLImageElement: l,
            HTMLCanvasElement: u,
            HTMLVideoElement: c,
            ImageData: h,
            ImageBitmap: p
          } = e;
        if (o.bindTexture(o.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i && this.size[1] === s) {
          const {
            x: e,
            y: r
          } = n || {
            x: 0,
            y: 0
          };
          t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e, r, o.RGBA, o.UNSIGNED_BYTE, t) : o.texSubImage2D(o.TEXTURE_2D, 0, e, r, i, s, o.RGBA, o.UNSIGNED_BYTE, t.data);
        } else this.size = [i, s], t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, s, 0, this.format, o.UNSIGNED_BYTE, t.data);
        this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);
      }
      bind(t, e) {
        const {
            context: r
          } = this,
          {
            gl: n
          } = r;
        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);
      }
      isSizePowerOfTwo() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }
      destroy() {
        const {
          gl: t
        } = this.context;
        t.deleteTexture(this.texture), this.texture = null;
      }
    }
    class Ad {
      constructor(t) {
        this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
          this._triggered = !1, this._callback();
        });
      }
      trigger() {
        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
          this._triggered = !1, this._callback();
        }, 0));
      }
      remove() {
        this._channel = void 0, this._callback = () => {};
      }
    }
    class Sd {
      constructor() {
        this.tasks = {}, this.taskQueue = [], V(["process"], this), this.invoker = new Ad(this.process), this.nextId = 0;
      }
      add(t, e) {
        const r = this.nextId++,
          n = function ({
            type: t,
            isSymbolTile: e,
            zoom: r
          }) {
            return r = r || 0, "message" === t ? 0 : "maybePrepare" !== t || e ? "parseTile" !== t || e ? "parseTile" === t && e ? 300 - r : "maybePrepare" === t && e ? 400 - r : 500 : 200 - r : 100 - r;
          }(e);
        if (0 === n) {
          N();
          try {
            t();
          } finally {}
          return {
            cancel: () => {}
          };
        }
        return this.tasks[r] = {
          fn: t,
          metadata: e,
          priority: n,
          id: r
        }, this.taskQueue.push(r), this.invoker.trigger(), {
          cancel: () => {
            delete this.tasks[r];
          }
        };
      }
      process() {
        N();
        try {
          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;
          const t = this.pick();
          if (null === t) return;
          const e = this.tasks[t];
          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;
          e.fn();
        } finally {}
      }
      pick() {
        let t = null,
          e = 1 / 0;
        for (let r = 0; r < this.taskQueue.length; r++) {
          const n = this.tasks[this.taskQueue[r]];
          n.priority < e && (e = n.priority, t = r);
        }
        if (null === t) return null;
        const r = this.taskQueue[t];
        return this.taskQueue.splice(t, 1), r;
      }
      remove() {
        this.invoker.remove();
      }
    }
    class kd {
      constructor(t) {
        this._stringToNumber = {}, this._numberToString = [];
        for (let e = 0; e < t.length; e++) {
          const r = t[e];
          this._stringToNumber[r] = e, this._numberToString[e] = r;
        }
      }
      encode(t) {
        return this._stringToNumber[t];
      }
      decode(t) {
        return this._numberToString[t];
      }
    }
    const Id = ["tile", "layer", "source", "sourceLayer", "state"];
    class Md {
      constructor(t, e, r, n, i) {
        this.type = "Feature", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;
      }
      get geometry() {
        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
      }
      set geometry(t) {
        this._geometry = t;
      }
      toJSON() {
        const t = {
          type: "Feature",
          geometry: this.geometry,
          properties: this.properties
        };
        void 0 !== this.id && (t.id = this.id);
        for (const e of Id) void 0 !== this[e] && (t[e] = this[e]);
        return t;
      }
    }
    const Td = 32,
      zd = 33,
      Bd = new Uint16Array(8184);
    for (let t = 0; t < 2046; t++) {
      let e = t + 2,
        r = 0,
        n = 0,
        i = 0,
        s = 0,
        a = 0,
        o = 0;
      for (1 & e ? i = s = a = Td : r = n = o = Td; (e >>= 1) > 1;) {
        const t = r + i >> 1,
          l = n + s >> 1;
        1 & e ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t, o = l;
      }
      const l = 4 * t;
      Bd[l + 0] = r, Bd[l + 1] = n, Bd[l + 2] = i, Bd[l + 3] = s;
    }
    const Ed = new Uint16Array(2178),
      Cd = new Uint8Array(1089),
      Pd = new Uint16Array(1089);
    function Dd(t) {
      return 0 === t ? -.03125 : 32 === t ? .03125 : 0;
    }
    var Vd = na([{
      name: "a_pos",
      type: "Int16",
      components: 2
    }, {
      name: "a_texture_pos",
      type: "Int16",
      components: 2
    }]);
    const Ld = {
      type: 2,
      extent: ko,
      loadGeometry: () => [[new d(0, 0), new d(8193, 0), new d(8193, 8193), new d(0, 8193), new d(0, 0)]]
    };
    class Fd {
      constructor(t, e, r, n, i) {
        this.tileID = t, this.uid = E(), this.uses = 0, this.tileSize = e, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection);
      }
      registerFadeDuration(t) {
        const e = t + this.timeAdded;
        e < Nt.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);
      }
      wasRequested() {
        return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
      }
      get tileTransform() {
        return this._tileTransform || (this._tileTransform = Vf(this.tileID.canonical, this.projection)), this._tileTransform;
      }
      loadVectorData(t, e, r) {
        if (this.unloadVectorData(), this.state = "loaded", t) {
          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {
            const r = {};
            if (!e) return r;
            for (const n of t) {
              const t = n.layerIds.map(t => e.getLayer(t)).filter(Boolean);
              if (0 !== t.length) {
                n.layers = t, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map(e => t.filter(t => t.id === e)[0]));
                for (const e of t) r[e.id] = n;
              }
            }
            return r;
          }(t.buckets, e.style), this.hasSymbolBuckets = !1;
          for (const t in this.buckets) {
            const e = this.buckets[t];
            if (e instanceof hd) {
              if (this.hasSymbolBuckets = !0, !r) break;
              e.justReloaded = !0;
            }
          }
          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {
            const e = this.buckets[t];
            if (e instanceof hd && e.hasRTLText) {
              this.hasRTLText = !0, js.isLoading() || js.isLoaded() || "deferred" !== Fs() || Rs();
              break;
            }
          }
          this.queryPadding = 0;
          for (const t in this.buckets) {
            const r = this.buckets[t];
            this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(r));
          }
          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas);
        } else this.collisionBoxArray = new Ea();
      }
      unloadVectorData() {
        if (this.hasData()) {
          for (const t in this.buckets) this.buckets[t].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      getBucket(t) {
        return this.buckets[t.id];
      }
      upload(t) {
        for (const e in this.buckets) {
          const r = this.buckets[e];
          r.uploadPending() && r.upload(t);
        }
        const e = t.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new _d(t, this.imageAtlas.image, e.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new _d(t, this.glyphAtlasImage, e.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _d(t, this.lineAtlas.image, e.ALPHA), this.lineAtlas.uploaded = !0);
      }
      prepare(t) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
      }
      queryRenderedFeatures(t, e, r, n, i, s, a, o) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
          tileResult: n,
          pixelPosMatrix: a,
          transform: s,
          params: i,
          tileTransform: this.tileTransform
        }, t, e, r) : {};
      }
      querySourceFeatures(t, e) {
        const r = this.latestFeatureIndex;
        if (!r || !r.rawTileData) return;
        const n = r.loadVTLayers(),
          i = e ? e.sourceLayer : "",
          s = n._geojsonTileLayer || n[i];
        if (!s) return;
        const a = ai(e && e.filter),
          {
            z: o,
            x: l,
            y: u
          } = this.tileID.canonical,
          c = {
            z: o,
            x: l,
            y: u
          };
        for (let e = 0; e < s.length; e++) {
          const n = s.feature(e);
          if (a.needGeometry) {
            const t = wu(n, !0);
            if (!a.filter(new Us(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;
          } else if (!a.filter(new Us(this.tileID.overscaledZ), n)) continue;
          const h = r.getId(n, i),
            p = new Md(n, o, l, u, h);
          p.tile = c, t.push(p);
        }
      }
      hasData() {
        return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
      }
      patternsLoaded() {
        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }
      setExpiryData(t) {
        const e = this.expirationTime;
        if (t.cacheControl) {
          const e = G(t.cacheControl);
          e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"]);
        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
        if (this.expirationTime) {
          const t = Date.now();
          let r = !1;
          if (this.expirationTime > t) r = !1;else if (e) {
            if (this.expirationTime < e) r = !0;else {
              const n = this.expirationTime - e;
              n ? this.expirationTime = t + Math.max(n, 3e4) : r = !0;
            }
          } else r = !0;
          r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }
      getExpiryTimeout() {
        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }
      setFeatureState(t, e) {
        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e) return;
        const r = this.latestFeatureIndex.loadVTLayers(),
          n = e.style.listImages();
        for (const i in this.buckets) {
          if (!e.style.hasLayer(i)) continue;
          const s = this.buckets[i],
            a = s.layers[0].sourceLayer || "_geojsonTileLayer",
            o = r[a],
            l = t[a];
          if (!o || !l || 0 === Object.keys(l).length) continue;
          if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof jh || s instanceof Uc) {
            const t = e.style._getSourceCache(s.layers[0].source);
            e._terrain && e._terrain.enabled && t && s.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID);
          }
          const u = e && e.style && e.style.getLayer(i);
          u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));
        }
      }
      holdingForFade() {
        return void 0 !== this.symbolFadeHoldUntil;
      }
      symbolFadeFinished() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
      }
      clearFadeHold() {
        this.symbolFadeHoldUntil = void 0;
      }
      setHoldDuration(t) {
        this.symbolFadeHoldUntil = Nt.now() + t;
      }
      setTexture(t, e) {
        const r = e.context,
          n = r.gl;
        this.texture = this.texture || e.getTileTexture(t.width), this.texture ? this.texture.update(t, {
          useMipmap: !0
        }) : (this.texture = new _d(r, t, n.RGBA, {
          useMipmap: !0
        }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax));
      }
      setDependencies(t, e) {
        const r = {};
        for (const t of e) r[t] = !0;
        this.dependencies[t] = r;
      }
      hasDependency(t, e) {
        for (const r of t) {
          const t = this.dependencies[r];
          if (t) for (const r of e) if (t[r]) return !0;
        }
        return !1;
      }
      clearQueryDebugViz() {}
      _makeDebugTileBoundsBuffers(t, e) {
        if (!e || "mercator" === e.name || this._tileDebugBuffer) return;
        const r = bu(Ld, this.tileID.canonical, this.tileTransform)[0],
          n = new sa(),
          i = new Ta();
        for (let t = 0; t < r.length; t++) {
          const {
            x: e,
            y: s
          } = r[t];
          n.emplaceBack(e, s), i.emplaceBack(t);
        }
        i.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, xl.members), this._tileDebugSegments = So.simpleSegment(0, 0, n.length, i.length);
      }
      _makeTileBoundsBuffers(t, e) {
        if (this._tileBoundsBuffer || !e || "mercator" === e.name) return;
        const r = bu(Ld, this.tileID.canonical, this.tileTransform)[0];
        let n, i;
        if (this.isRaster) {
          const t = function (t, e) {
            const r = Vf(t, e),
              n = Math.pow(2, t.z);
            for (let i = 0; i < zd; i++) for (let s = 0; s < zd; s++) {
              const a = ou((t.x + (s + Dd(s)) / Td) / n),
                o = lu((t.y + (i + Dd(i)) / Td) / n),
                l = e.project(a, o),
                u = i * zd + s;
              Ed[2 * u + 0] = Math.round((l.x * r.scale - r.x) * ko), Ed[2 * u + 1] = Math.round((l.y * r.scale - r.y) * ko);
            }
            Cd.fill(0), Pd.fill(0);
            for (let t = 2045; t >= 0; t--) {
              const e = 4 * t,
                r = Bd[e + 0],
                n = Bd[e + 1],
                i = Bd[e + 2],
                s = Bd[e + 3],
                a = r + i >> 1,
                o = n + s >> 1,
                l = a + o - n,
                u = o + r - a,
                c = n * zd + r,
                h = s * zd + i,
                p = o * zd + a,
                f = Math.hypot((Ed[2 * c + 0] + Ed[2 * h + 0]) / 2 - Ed[2 * p + 0], (Ed[2 * c + 1] + Ed[2 * h + 1]) / 2 - Ed[2 * p + 1]) >= 16;
              if (Cd[p] = Cd[p] || (f ? 1 : 0), t < 1022) {
                const t = (n + u >> 1) * zd + (r + l >> 1),
                  e = (s + u >> 1) * zd + (i + l >> 1);
                Cd[p] = Cd[p] || Cd[t] || Cd[e];
              }
            }
            const i = new oa(),
              s = new wa();
            let a = 0;
            function o(t, e) {
              const r = e * zd + t;
              return 0 === Pd[r] && (i.emplaceBack(Ed[2 * r + 0], Ed[2 * r + 1], t * ko / Td, e * ko / Td), Pd[r] = ++a), Pd[r] - 1;
            }
            function l(t, e, r, n, i, a) {
              const u = t + r >> 1,
                c = e + n >> 1;
              if (Math.abs(t - i) + Math.abs(e - a) > 1 && Cd[c * zd + u]) l(i, a, t, e, u, c), l(r, n, i, a, u, c);else {
                const l = o(t, e),
                  u = o(r, n),
                  c = o(i, a);
                s.emplaceBack(l, u, c);
              }
            }
            return l(0, 0, Td, Td, Td, 0), l(Td, Td, 0, 0, 0, Td), {
              vertices: i,
              indices: s
            };
          }(this.tileID.canonical, e);
          n = t.vertices, i = t.indices;
        } else {
          n = new oa(), i = new wa();
          for (const {
            x: t,
            y: e
          } of r) n.emplaceBack(t, e, 0, 0);
          const t = sc(n.int16, void 0, 4);
          for (let e = 0; e < t.length; e += 3) i.emplaceBack(t[e], t[e + 1], t[e + 2]);
        }
        this._tileBoundsBuffer = t.createVertexBuffer(n, Vd.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(i), this._tileBoundsSegments = So.simpleSegment(0, 0, n.length, i.length);
      }
      _makeGlobeTileDebugBuffers(t, e) {
        const r = e.projection;
        if (!r || "globe" !== r.name || e.freezeTileCoverage) return;
        const n = this.tileID.canonical,
          i = Gl(Vl(n, e)),
          s = Kl(e.zoom);
        let a;
        s > 0 && (a = Co(new Float64Array(16), e.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, n, e, i, a, s), this._makeGlobeTileDebugTextBuffer(t, n, e, i, a, s);
      }
      _globePoint(t, e, r, n, i, s, a) {
        let o = Ol(t, e, r);
        if (s) {
          const i = 1 << r.z,
            l = iu(n.center.lng),
            u = su(n.center.lat),
            c = (r.x + .5) / i - l;
          let h = 0;
          c > .5 ? h = -1 : c < -.5 && (h = 1);
          let p = (t / ko + r.x) / i + h,
            f = (e / ko + r.y) / i;
          p = (p - l) * n._pixelsPerMercatorPixel + l, f = (f - u) * n._pixelsPerMercatorPixel + u;
          const d = [p * n.worldSize, f * n.worldSize, 0];
          el(d, d, s), o = Dl(o, d, a);
        }
        return el(o, o, i);
      }
      _makeGlobeTileDebugBorderBuffer(t, e, r, n, i, s) {
        const a = new sa(),
          o = new Ta(),
          l = new aa(),
          u = (t, u, c, h, p) => {
            const f = (c - t) / (p - 1),
              d = (h - u) / (p - 1),
              y = a.length;
            for (let c = 0; c < p; c++) {
              const h = t + c * f,
                p = u + c * d;
              a.emplaceBack(h, p);
              const m = this._globePoint(h, p, e, r, n, i, s);
              l.emplaceBack(m[0], m[1], m[2]), o.emplaceBack(y + c);
            }
          },
          c = ko;
        u(0, 0, c, 0, 16), u(c, 0, c, c, 16), u(c, c, 0, c, 16), u(0, c, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(o), this._tileDebugBuffer = t.createVertexBuffer(a, xl.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(l, gl.members), this._tileDebugSegments = So.simpleSegment(0, 0, a.length, o.length);
      }
      _makeGlobeTileDebugTextBuffer(t, e, r, n, i, s) {
        const a = new sa(),
          o = new wa(),
          l = new aa(),
          u = 25;
        o.reserve(32), a.reserve(u), l.reserve(u);
        const c = (t, e) => u * t + e;
        for (let t = 0; t < u; t++) {
          const o = 2048 * t;
          for (let t = 0; t < u; t++) {
            const u = 2048 * t;
            a.emplaceBack(u, o);
            const c = this._globePoint(u, o, e, r, n, i, s);
            l.emplaceBack(c[0], c[1], c[2]);
          }
        }
        for (let t = 0; t < 4; t++) for (let e = 0; e < 4; e++) {
          const r = c(t, e),
            n = c(t, e + 1),
            i = c(t + 1, e),
            s = c(t + 1, e + 1);
          o.emplaceBack(r, n, i), o.emplaceBack(i, n, s);
        }
        this._tileDebugTextIndexBuffer = t.createIndexBuffer(o), this._tileDebugTextBuffer = t.createVertexBuffer(a, xl.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(l, gl.members), this._tileDebugTextSegments = So.simpleSegment(0, 0, u, 32);
      }
    }
    class Rd {
      constructor() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      }
      updateState(t, e, r) {
        const n = String(e);
        if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, z(this.stateChanges[t][n], r), null === this.deletedStates[t]) {
          this.deletedStates[t] = {};
          for (const e in this.state[t]) e !== n && (this.deletedStates[t][e] = null);
        } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {
          this.deletedStates[t][n] = {};
          for (const e in this.state[t][n]) r[e] || (this.deletedStates[t][n][e] = null);
        } else for (const e in r) this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e];
      }
      removeFeatureState(t, e, r) {
        if (null === this.deletedStates[t]) return;
        const n = String(e);
        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {
          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) this.deletedStates[t][n][r] = null;else this.deletedStates[t][n] = null;
        } else this.deletedStates[t] = null;
      }
      getState(t, e) {
        const r = String(e),
          n = z({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);
        if (null === this.deletedStates[t]) return {};
        if (this.deletedStates[t]) {
          const r = this.deletedStates[t][e];
          if (null === r) return {};
          for (const t in r) delete n[t];
        }
        return n;
      }
      initializeTileState(t, e) {
        t.setFeatureState(this.state, e);
      }
      coalesceChanges(t, e) {
        const r = {};
        for (const t in this.stateChanges) {
          this.state[t] = this.state[t] || {};
          const e = {};
          for (const r in this.stateChanges[t]) this.state[t][r] || (this.state[t][r] = {}), z(this.state[t][r], this.stateChanges[t][r]), e[r] = this.state[t][r];
          r[t] = e;
        }
        for (const t in this.deletedStates) {
          this.state[t] = this.state[t] || {};
          const e = {};
          if (null === this.deletedStates[t]) for (const r in this.state[t]) e[r] = {}, this.state[t][r] = {};else for (const r in this.deletedStates[t]) {
            if (null === this.deletedStates[t][r]) this.state[t][r] = {};else if (this.state[t][r]) for (const e of Object.keys(this.deletedStates[t][r])) delete this.state[t][r][e];
            e[r] = this.state[t][r];
          }
          r[t] = r[t] || {}, z(r[t], e);
        }
        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const n in t) t[n].setFeatureState(r, e);
      }
    }
    class jd {
      constructor(t) {
        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];
      }
      getElevation(t, e) {
        const r = this.toIdx(t, e);
        return {
          min: this.minimums[r],
          max: this.maximums[r]
        };
      }
      isLeaf(t, e) {
        return this.leaves[this.toIdx(t, e)];
      }
      toIdx(t, e) {
        return e * this.size + t;
      }
    }
    function Ud(t, e, r, n) {
      let i = 0,
        s = Number.MAX_VALUE;
      for (let a = 0; a < 3; a++) if (Math.abs(n[a]) < 1e-15) {
        if (r[a] < t[a] || r[a] > e[a]) return null;
      } else {
        const o = 1 / n[a];
        let l = (t[a] - r[a]) * o,
          u = (e[a] - r[a]) * o;
        if (l > u) {
          const t = l;
          l = u, u = t;
        }
        if (l > i && (i = l), u < s && (s = u), i > s) return null;
      }
      return i;
    }
    function $d(t, e, r, n, i, s, a, o, l, u, c) {
      const h = n - t,
        p = i - e,
        f = s - r,
        d = a - t,
        y = o - e,
        m = l - r,
        g = c[1] * m - c[2] * y,
        x = c[2] * d - c[0] * m,
        v = c[0] * y - c[1] * d,
        b = h * g + p * x + f * v;
      if (Math.abs(b) < 1e-15) return null;
      const w = 1 / b,
        _ = u[0] - t,
        A = u[1] - e,
        S = u[2] - r,
        k = (_ * g + A * x + S * v) * w;
      if (k < 0 || k > 1) return null;
      const I = A * f - S * p,
        M = S * h - _ * f,
        T = _ * p - A * h,
        z = (c[0] * I + c[1] * M + c[2] * T) * w;
      return z < 0 || k + z > 1 ? null : (d * I + y * M + m * T) * w;
    }
    function Od(t, e, r) {
      return (t - e) / (r - e);
    }
    function qd(t, e, r, n, i, s, a, o, l) {
      const u = 1 << r,
        c = s - n,
        h = a - i,
        p = (t + 1) / u * c + n,
        f = (e + 0) / u * h + i,
        d = (e + 1) / u * h + i;
      o[0] = (t + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;
    }
    class Nd {
      constructor(t) {
        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
        const e = function (t) {
            const e = Math.ceil(Math.log2(t.dim / 8)),
              r = [];
            let n = Math.ceil(Math.pow(2, e));
            const i = 1 / n,
              s = (t, e, r, n, i) => {
                const s = n ? 1 : 0,
                  a = (t + 1) * r - s,
                  o = e * r,
                  l = (e + 1) * r - s;
                i[0] = t * r, i[1] = o, i[2] = a, i[3] = l;
              };
            let a = new jd(n);
            const o = [];
            for (let e = 0; e < n * n; e++) {
              s(e % n, Math.floor(e / n), i, !1, o);
              const r = Xd(o[0], o[1], t),
                l = Xd(o[2], o[1], t),
                u = Xd(o[2], o[3], t),
                c = Xd(o[0], o[3], t);
              a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
            }
            for (r.push(a), n /= 2; n >= 1; n /= 2) {
              const t = r[r.length - 1];
              a = new jd(n);
              for (let e = 0; e < n * n; e++) {
                s(e % n, Math.floor(e / n), 2, !0, o);
                const r = t.getElevation(o[0], o[1]),
                  i = t.getElevation(o[2], o[1]),
                  l = t.getElevation(o[2], o[3]),
                  u = t.getElevation(o[0], o[3]),
                  c = t.isLeaf(o[0], o[1]),
                  h = t.isLeaf(o[2], o[1]),
                  p = t.isLeaf(o[2], o[3]),
                  f = t.isLeaf(o[0], o[3]),
                  d = Math.min(r.min, i.min, l.min, u.min),
                  y = Math.max(r.max, i.max, l.max, u.max),
                  m = c && h && p && f;
                a.maximums.push(y), a.minimums.push(d), a.leaves.push(y - d <= 5 && m ? 1 : 0);
              }
              r.push(a);
            }
            return r;
          }(this.dem),
          r = e.length - 1,
          n = e[r];
        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
      }
      raycastRoot(t, e, r, n, i, s, a = 1) {
        return Ud([t, e, -100], [r, n, this.maximums[0] * a], i, s);
      }
      raycast(t, e, r, n, i, s, a = 1) {
        if (!this.nodeCount) return null;
        const o = this.raycastRoot(t, e, r, n, i, s, a);
        if (null == o) return null;
        const l = [],
          u = [],
          c = [],
          h = [],
          p = [{
            idx: 0,
            t: o,
            nodex: 0,
            nodey: 0,
            depth: 0
          }];
        for (; p.length > 0;) {
          const {
            idx: o,
            t: f,
            nodex: d,
            nodey: y,
            depth: m
          } = p.pop();
          if (this.leaves[o]) {
            qd(d, y, m, t, e, r, n, c, h);
            const o = 1 << m,
              l = (d + 0) / o,
              u = (d + 1) / o,
              p = (y + 0) / o,
              g = (y + 1) / o,
              x = Xd(l, p, this.dem) * a,
              v = Xd(u, p, this.dem) * a,
              b = Xd(u, g, this.dem) * a,
              w = Xd(l, g, this.dem) * a,
              _ = $d(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),
              A = $d(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s),
              S = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);
            if (S !== Number.MAX_VALUE) return S;
            {
              const t = Wo([], i, s, f);
              if (Gd(x, v, w, b, Od(t[0], c[0], h[0]), Od(t[1], c[1], h[1])) >= t[2]) return f;
            }
            continue;
          }
          let g = 0;
          for (let p = 0; p < this._siblingOffset.length; p++) {
            qd((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;
            const f = Ud(c, h, i, s);
            if (null != f) {
              const t = f;
              l[p] = t;
              let e = !1;
              for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);
              e || (u[g] = p), g++;
            }
          }
          for (let t = 0; t < g; t++) {
            const e = u[t];
            p.push({
              idx: this.childOffsets[o] + e,
              t: l[e],
              nodex: (d << 1) + this._siblingOffset[e][0],
              nodey: (y << 1) + this._siblingOffset[e][1],
              depth: m + 1
            });
          }
        }
        return null;
      }
      _addNode(t, e, r) {
        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
      }
      _construct(t, e, r, n, i) {
        if (1 === t[n].isLeaf(e, r)) return;
        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
        const s = n - 1,
          a = t[s];
        let o = 0,
          l = 0;
        for (let t = 0; t < this._siblingOffset.length; t++) {
          const n = 2 * e + this._siblingOffset[t][0],
            i = 2 * r + this._siblingOffset[t][1],
            s = a.getElevation(n, i),
            u = a.isLeaf(n, i),
            c = this._addNode(s.min, s.max, u);
          u && (o |= 1 << t), l || (l = c);
        }
        for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
      }
    }
    function Gd(t, e, r, n, i, s) {
      return Mr(Mr(t, r, s), Mr(e, n, s), i);
    }
    function Xd(t, e, r) {
      const n = r.dim,
        i = S(t * n - .5, 0, n - 1),
        s = S(e * n - .5, 0, n - 1),
        a = Math.floor(i),
        o = Math.floor(s),
        l = Math.min(a + 1, n - 1),
        u = Math.min(o + 1, n - 1);
      return Gd(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
    }
    const Zd = {
      mapbox: [6553.6, 25.6, .1, 1e4],
      terrarium: [256, 1, 1 / 256, 32768]
    };
    class Kd {
      get tree() {
        return this._tree || this._buildQuadTree(), this._tree;
      }
      constructor(t, e, r, n = !1, i = !1) {
        if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square");
        if (r && "mapbox" !== r && "terrarium" !== r) return $(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
        this.stride = e.height;
        const s = this.dim = e.height - 2,
          a = new Uint32Array(e.data.buffer);
        if (this.pixels = new Uint8Array(e.data.buffer), this.encoding = r || "mapbox", this.borderReady = n, !n) {
          for (let t = 0; t < s; t++) a[this._idx(-1, t)] = a[this._idx(0, t)], a[this._idx(s, t)] = a[this._idx(s - 1, t)], a[this._idx(t, -1)] = a[this._idx(t, 0)], a[this._idx(t, s)] = a[this._idx(t, s - 1)];
          a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();
        }
      }
      _buildQuadTree() {
        this._tree = new Nd(this);
      }
      get(t, e, r = !1) {
        r && (t = S(t, -1, this.dim), e = S(e, -1, this.dim));
        const n = 4 * this._idx(t, e);
        return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);
      }
      static getUnpackVector(t) {
        return Zd[t];
      }
      get unpackVector() {
        return Zd[this.encoding];
      }
      _idx(t, e) {
        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
        return (e + 1) * this.stride + (t + 1);
      }
      _unpackMapbox(t, e, r) {
        return (256 * t * 256 + 256 * e + r) / 10 - 1e4;
      }
      _unpackTerrarium(t, e, r) {
        return 256 * t + e + r / 256 - 32768;
      }
      static pack(t, e) {
        const r = [0, 0, 0, 0],
          n = Kd.getUnpackVector(e);
        let i = Math.floor((t + n[3]) / n[2]);
        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
      }
      getPixels() {
        return new Qu({
          width: this.stride,
          height: this.stride
        }, this.pixels);
      }
      backfillBorder(t, e, r) {
        if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
        let n = e * this.dim,
          i = e * this.dim + this.dim,
          s = r * this.dim,
          a = r * this.dim + this.dim;
        switch (e) {
          case -1:
            n = i - 1;
            break;
          case 1:
            i = n + 1;
        }
        switch (r) {
          case -1:
            s = a - 1;
            break;
          case 1:
            a = s + 1;
        }
        const o = -e * this.dim,
          l = -r * this.dim;
        for (let e = s; e < a; e++) for (let r = n; r < i; r++) {
          const n = 4 * this._idx(r, e),
            i = 4 * this._idx(r + o, e + l);
          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];
        }
      }
      onDeserialize() {
        this._tree && (this._tree.dem = this);
      }
    }
    Oi(Kd, "DEMData"), Oi(Nd, "DemMinMaxQuadTree", {
      omit: ["dem"]
    });
    class Yd {
      constructor(t, e) {
        this.max = t, this.onRemove = e, this.reset();
      }
      reset() {
        for (const t in this.data) for (const e of this.data[t]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
        return this.data = {}, this.order = [], this;
      }
      add(t, e, r) {
        const n = t.wrapped().key;
        void 0 === this.data[n] && (this.data[n] = []);
        const i = {
          value: e,
          timeout: void 0
        };
        if (void 0 !== r && (i.timeout = setTimeout(() => {
          this.remove(t, i);
        }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {
          const t = this._getAndRemoveByKey(this.order[0]);
          t && this.onRemove(t);
        }
        return this;
      }
      has(t) {
        return t.wrapped().key in this.data;
      }
      getAndRemove(t) {
        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
      }
      _getAndRemoveByKey(t) {
        const e = this.data[t].shift();
        return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;
      }
      getByKey(t) {
        const e = this.data[t];
        return e ? e[0].value : null;
      }
      get(t) {
        return this.has(t) ? this.data[t.wrapped().key][0].value : null;
      }
      remove(t, e) {
        if (!this.has(t)) return this;
        const r = t.wrapped().key,
          n = void 0 === e ? 0 : this.data[r].indexOf(e),
          i = this.data[r][n];
        return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;
      }
      setMaxSize(t) {
        for (this.max = t; this.order.length > this.max;) {
          const t = this._getAndRemoveByKey(this.order[0]);
          t && this.onRemove(t);
        }
        return this;
      }
      filter(t) {
        const e = [];
        for (const r in this.data) for (const n of this.data[r]) t(n.value) || e.push(n);
        for (const t of e) this.remove(t.value.tileID, t);
      }
    }
    class Hd {
      constructor(t, e, r) {
        this.func = t, this.mask = e, this.range = r;
      }
    }
    Hd.ReadOnly = !1, Hd.ReadWrite = !0, Hd.disabled = new Hd(519, Hd.ReadOnly, [0, 1]);
    const Wd = 7680;
    class Jd {
      constructor(t, e, r, n, i, s) {
        this.test = t, this.ref = e, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;
      }
    }
    Jd.disabled = new Jd({
      func: 519,
      mask: 0
    }, 0, 0, Wd, Wd, Wd);
    class Qd {
      constructor(t, e, r) {
        this.blendFunction = t, this.blendColor = e, this.mask = r;
      }
    }
    Qd.Replace = [1, 0], Qd.disabled = new Qd(Qd.Replace, Me.transparent, [!1, !1, !1, !1]), Qd.unblended = new Qd(Qd.Replace, Me.transparent, [!0, !0, !0, !0]), Qd.alphaBlended = new Qd([1, 771], Me.transparent, [!0, !0, !0, !0]);
    const ty = 1029,
      ey = 2305;
    class ry {
      constructor(t, e, r) {
        this.enable = t, this.mode = e, this.frontFace = r;
      }
    }
    ry.disabled = new ry(!1, ty, ey), ry.backCCW = new ry(!0, ty, ey), ry.backCW = new ry(!0, ty, 2304), ry.frontCW = new ry(!0, 1028, 2304), ry.frontCCW = new ry(!0, 1028, ey);
    class ny extends Yt {
      constructor(t, e, r) {
        super(), this.id = t, this._onlySymbols = r, e.on("data", t => {
          "source" === t.dataType && "metadata" === t.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t.dataType && "content" === t.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
        }), e.on("error", () => {
          this._sourceErrored = !0;
        }), this._source = e, this._tiles = {}, this._cache = new Yd(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e.minTileCacheSize, this._maxTileCacheSize = e.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Rd(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
      }
      onAdd(t) {
        this.map = t, this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;
      }
      loaded() {
        if (this._sourceErrored) return !0;
        if (!this._sourceLoaded) return !1;
        if (!this._source.loaded()) return !1;
        for (const t in this._tiles) {
          const e = this._tiles[t];
          if ("loaded" !== e.state && "errored" !== e.state) return !1;
        }
        return !0;
      }
      getSource() {
        return this._source;
      }
      pause() {
        this._paused = !0;
      }
      resume() {
        if (!this._paused) return;
        const t = this._shouldReloadOnResume;
        this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
      }
      _loadTile(t, e) {
        return t.isSymbolTile = this._onlySymbols, this._source.loadTile(t, e);
      }
      _unloadTile(t) {
        if (this._source.unloadTile) return this._source.unloadTile(t, () => {});
      }
      _abortTile(t) {
        if (this._source.abortTile) return this._source.abortTile(t, () => {});
      }
      serialize() {
        return this._source.serialize();
      }
      prepare(t) {
        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
        for (const e in this._tiles) {
          const r = this._tiles[e];
          r.upload(t), r.prepare(this.map.style.imageManager);
        }
      }
      getIds() {
        return T(this._tiles).map(t => t.tileID).sort(iy).map(t => t.key);
      }
      getRenderableIds(t) {
        const e = [];
        for (const r in this._tiles) this._isIdRenderable(+r, t) && e.push(this._tiles[r]);
        return t ? e.sort((t, e) => {
          const r = t.tileID,
            n = e.tileID,
            i = new d(r.canonical.x, r.canonical.y)._rotate(this.transform.angle),
            s = new d(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);
          return r.overscaledZ - n.overscaledZ || s.y - i.y || s.x - i.x;
        }).map(t => t.tileID.key) : e.map(t => t.tileID).sort(iy).map(t => t.key);
      }
      hasRenderableParent(t) {
        const e = this.findLoadedParent(t, 0);
        return !!e && this._isIdRenderable(e.tileID.key);
      }
      _isIdRenderable(t, e) {
        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());
      }
      reload() {
        if (this._paused) this._shouldReloadOnResume = !0;else {
          this._cache.reset();
          for (const t in this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(+t, "reloading");
        }
      }
      _reloadTile(t, e) {
        const r = this._tiles[t];
        r && ("loading" !== r.state && (r.state = e), this._loadTile(r, this._tileLoaded.bind(this, r, t, e)));
      }
      _tileLoaded(t, e, r, n) {
        if (n) {
          if (t.state = "errored", 404 !== n.status) this._source.fire(new Kt(n, {
            tile: t
          }));else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
            const t = this.map.painter.terrain;
            this.update(this.transform, t.getScaledDemTileSize(), !0), t.resetTileLookupCache(this.id);
          } else this.update(this.transform);
        } else t.timeAdded = Nt.now(), "expired" === r && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), "raster-dem" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new Zt("data", {
          dataType: "source",
          tile: t,
          coord: t.tileID,
          sourceCacheId: this.id
        }));
      }
      _backfillDEM(t) {
        const e = this.getRenderableIds();
        for (let n = 0; n < e.length; n++) {
          const i = e[n];
          if (t.neighboringTiles && t.neighboringTiles[i]) {
            const e = this.getTileByID(i);
            r(t, e), r(e, t);
          }
        }
        function r(t, e) {
          if (!t.dem || t.dem.borderReady) return;
          t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0;
          let r = e.tileID.canonical.x - t.tileID.canonical.x;
          const n = e.tileID.canonical.y - t.tileID.canonical.y,
            i = Math.pow(2, t.tileID.canonical.z),
            s = e.tileID.key;
          0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, r, n), t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));
        }
      }
      getTile(t) {
        return this.getTileByID(t.key);
      }
      getTileByID(t) {
        return this._tiles[t];
      }
      _retainLoadedChildren(t, e, r, n) {
        for (const i in this._tiles) {
          let s = this._tiles[i];
          if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r) continue;
          let a = s.tileID;
          for (; s && s.tileID.overscaledZ > e + 1;) {
            const t = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
            s = this._tiles[t.key], s && s.hasData() && (a = t);
          }
          let o = a;
          for (; o.overscaledZ > e;) if (o = o.scaledTo(o.overscaledZ - 1), t[o.key]) {
            n[a.key] = a;
            break;
          }
        }
      }
      findLoadedParent(t, e) {
        if (t.key in this._loadedParentTiles) {
          const r = this._loadedParentTiles[t.key];
          return r && r.tileID.overscaledZ >= e ? r : null;
        }
        for (let r = t.overscaledZ - 1; r >= e; r--) {
          const e = t.scaledTo(r),
            n = this._getLoadedTile(e);
          if (n) return n;
        }
      }
      _getLoadedTile(t) {
        const e = this._tiles[t.key];
        return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
      }
      updateCacheSize(t, e) {
        e = e || this._source.tileSize;
        const r = Math.ceil(t.width / e) + 1,
          n = Math.ceil(t.height / e) + 1,
          i = Math.floor(r * n * 5),
          s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i,
          a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;
        this._cache.setMaxSize(a);
      }
      handleWrapJump(t) {
        const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);
        if (this._prevLng = t, e) {
          const t = {};
          for (const r in this._tiles) {
            const n = this._tiles[r];
            n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), t[n.tileID.key] = n;
          }
          this._tiles = t;
          for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];
          for (const t in this._tiles) this._setTileReloadTimer(+t, this._tiles[t]);
        }
      }
      update(t, e, r) {
        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
        if (this.usedForTerrain && !r) return;
        let n;
        this.updateCacheSize(t, e), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new Mh(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y)) : (n = t.coveringTiles({
          tileSize: e || this._source.tileSize,
          minzoom: this._source.minzoom,
          maxzoom: this._source.maxzoom,
          roundZoom: this._source.roundZoom && !r,
          reparseOverscaled: this._source.reparseOverscaled,
          isTerrainDEM: this.usedForTerrain
        }), this._source.hasTile && (n = n.filter(t => this._source.hasTile(t)))) : n = [];
        const i = this._updateRetainedTiles(n);
        if (sy(this._source.type) && 0 !== n.length) {
          const t = {},
            e = {},
            r = Object.keys(i);
          for (const n of r) {
            const r = i[n],
              s = this._tiles[n];
            if (!s || s.fadeEndTime && s.fadeEndTime <= Nt.now()) continue;
            const a = this.findLoadedParent(r, Math.max(r.overscaledZ - ny.maxOverzooming, this._source.minzoom));
            a && (this._addTile(a.tileID), t[a.tileID.key] = a.tileID), e[n] = r;
          }
          const s = n[n.length - 1].overscaledZ;
          for (const t in this._tiles) {
            const r = this._tiles[t];
            if (i[t] || !r.hasData()) continue;
            let n = r.tileID;
            for (; n.overscaledZ > s;) {
              n = n.scaledTo(n.overscaledZ - 1);
              const s = this._tiles[n.key];
              if (s && s.hasData() && e[n.key]) {
                i[t] = r.tileID;
                break;
              }
            }
          }
          for (const e in t) i[e] || (this._coveredTiles[e] = !0, i[e] = t[e]);
        }
        for (const t in i) this._tiles[t].clearFadeHold();
        const s = function (t, e) {
          const r = [];
          for (const n in t) n in e || r.push(n);
          return r;
        }(this._tiles, i);
        for (const t of s) {
          const e = this._tiles[t];
          e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t);
        }
        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
      }
      releaseSymbolFadeTiles() {
        for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);
      }
      _updateRetainedTiles(t) {
        const e = {};
        if (0 === t.length) return e;
        const r = {},
          n = t.reduce((t, e) => Math.min(t, e.overscaledZ), 1 / 0),
          i = t[0].overscaledZ,
          s = Math.max(i - ny.maxOverzooming, this._source.minzoom),
          a = Math.max(i + ny.maxUnderzooming, this._source.minzoom),
          o = {};
        for (const r of t) {
          const t = this._addTile(r);
          e[r.key] = r, t.hasData() || n < this._source.maxzoom && (o[r.key] = r);
        }
        this._retainLoadedChildren(o, n, a, e);
        for (const n of t) {
          let t = this._tiles[n.key];
          if (t.hasData()) continue;
          if (n.canonical.z >= this._source.maxzoom) {
            const t = n.children(this._source.maxzoom)[0],
              r = this.getTile(t);
            if (r && r.hasData()) {
              e[t.key] = t;
              continue;
            }
          } else {
            const t = n.children(this._source.maxzoom);
            if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key]) continue;
          }
          let i = t.wasRequested();
          for (let a = n.overscaledZ - 1; a >= s; --a) {
            const s = n.scaledTo(a);
            if (r[s.key]) break;
            if (r[s.key] = !0, t = this.getTile(s), !t && i && (t = this._addTile(s)), t && (e[s.key] = s, i = t.wasRequested(), t.hasData())) break;
          }
        }
        return e;
      }
      _updateLoadedParentTileCache() {
        this._loadedParentTiles = {};
        for (const t in this._tiles) {
          const e = [];
          let r,
            n = this._tiles[t].tileID;
          for (; n.overscaledZ > 0;) {
            if (n.key in this._loadedParentTiles) {
              r = this._loadedParentTiles[n.key];
              break;
            }
            e.push(n.key);
            const t = n.scaledTo(n.overscaledZ - 1);
            if (r = this._getLoadedTile(t), r) break;
            n = t;
          }
          for (const t of e) this._loadedParentTiles[t] = r;
        }
      }
      _addTile(t) {
        let e = this._tiles[t.key];
        if (e) return e;
        e = this._cache.getAndRemove(t), e && (this._setTileReloadTimer(t.key, e), e.tileID = t, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e)));
        const r = Boolean(e);
        if (!r) {
          const r = this.map ? this.map.painter : null;
          e = new Fd(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state));
        }
        return e ? (e.uses++, this._tiles[t.key] = e, r || this._source.fire(new Zt("dataloading", {
          tile: e,
          coord: e.tileID,
          dataType: "source"
        })), e) : null;
      }
      _setTileReloadTimer(t, e) {
        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
        const r = e.getExpiryTimeout();
        r && (this._timers[t] = setTimeout(() => {
          this._reloadTile(t, "expired"), delete this._timers[t];
        }, r));
      }
      _removeTile(t) {
        const e = this._tiles[t];
        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));
      }
      clearTiles() {
        this._shouldReloadOnResume = !1, this._paused = !1;
        for (const t in this._tiles) this._removeTile(+t);
        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
      }
      tilesIn(t, e, r) {
        const n = [],
          i = this.transform;
        if (!i) return n;
        const s = "globe" === i.projection.name,
          a = iu(i.center.lng);
        for (const o in this._tiles) {
          const l = this._tiles[o];
          if (r && l.clearQueryDebugViz(), l.holdingForFade()) continue;
          let u;
          if (s) {
            const t = l.tileID.canonical;
            if (0 === t.z) {
              const e = [Math.abs(S(a, ...ay(t, -1)) - a), Math.abs(S(a, ...ay(t, 1)) - a)];
              u = [0, 2 * e.indexOf(Math.min(...e)) - 1];
            } else {
              const e = [Math.abs(S(a, ...ay(t, -1)) - a), Math.abs(S(a, ...ay(t, 0)) - a), Math.abs(S(a, ...ay(t, 1)) - a)];
              u = [e.indexOf(Math.min(...e)) - 1];
            }
          } else u = [0];
          for (const r of u) {
            const s = t.containsTile(l, i, e, r);
            s && n.push(s);
          }
        }
        return n;
      }
      getVisibleCoordinates(t) {
        const e = this.getRenderableIds(t).map(t => this._tiles[t].tileID);
        for (const t of e) t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());
        return e;
      }
      hasTransition() {
        if (this._source.hasTransition()) return !0;
        if (sy(this._source.type)) for (const t in this._tiles) {
          const e = this._tiles[t];
          if (void 0 !== e.fadeEndTime && e.fadeEndTime >= Nt.now()) return !0;
        }
        return !1;
      }
      setFeatureState(t, e, r) {
        this._state.updateState(t = t || "_geojsonTileLayer", e, r);
      }
      removeFeatureState(t, e, r) {
        this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, r);
      }
      getFeatureState(t, e) {
        return this._state.getState(t = t || "_geojsonTileLayer", e);
      }
      setDependencies(t, e, r) {
        const n = this._tiles[t];
        n && n.setDependencies(e, r);
      }
      reloadTilesForDependencies(t, e) {
        for (const r in this._tiles) this._tiles[r].hasDependency(t, e) && this._reloadTile(+r, "reloading");
        this._cache.filter(r => !r.hasDependency(t, e));
      }
      _preloadTiles(t, e) {
        const r = new Map(),
          n = Array.isArray(t) ? t : [t],
          i = this.map.painter.terrain,
          s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;
        for (const t of n) {
          const e = t.coveringTiles({
            tileSize: s,
            minzoom: this._source.minzoom,
            maxzoom: this._source.maxzoom,
            roundZoom: this._source.roundZoom && !this.usedForTerrain,
            reparseOverscaled: this._source.reparseOverscaled,
            isTerrainDEM: this.usedForTerrain
          });
          for (const t of e) r.set(t.key, t);
          this.usedForTerrain && t.updateElevation(!1);
        }
        M(Array.from(r.values()), (t, e) => {
          const r = new Fd(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
          this._loadTile(r, t => {
            "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), e(t, r);
          });
        }, e);
      }
    }
    function iy(t, e) {
      const r = Math.abs(2 * t.wrap) - +(t.wrap < 0),
        n = Math.abs(2 * e.wrap) - +(e.wrap < 0);
      return t.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;
    }
    function sy(t) {
      return "raster" === t || "image" === t || "video" === t || "custom" === t;
    }
    function ay(t, e) {
      const r = 1 << t.z;
      return [t.x / r + e, (t.x + 1) / r + e];
    }
    ny.maxOverzooming = 10, ny.maxUnderzooming = 3;
    class oy {
      constructor(t, e, r) {
        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
      }
      static create(t, e, r) {
        const n = r || t.findDEMTileFor(e);
        if (!n || !n.dem) return;
        const i = n.dem,
          s = n.tileID,
          a = 1 << e.canonical.z - s.canonical.z;
        return new oy(n, n.tileSize / ko / a, [(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical.y / a - s.canonical.y) * i.dim]);
      }
      tileCoordToPixel(t, e) {
        const r = e * this._scale + this._offset[1],
          n = Math.floor(t * this._scale + this._offset[0]),
          i = Math.floor(r);
        return new d(n, i);
      }
      getElevationAt(t, e, r, n) {
        const i = t * this._scale + this._offset[0],
          s = e * this._scale + this._offset[1],
          a = Math.floor(i),
          o = Math.floor(s),
          l = this._dem;
        return n = !!n, r ? Mr(Mr(l.get(a, o, n), l.get(a, o + 1, n), s - o), Mr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
      }
      getElevationAtPixel(t, e, r) {
        return this._dem.get(t, e, !!r);
      }
      getMeterToDEM(t) {
        return (1 << this._demTile.tileID.canonical.z) * au(1, t) * this._dem.stride;
      }
    }
    class ly {
      constructor(t, e) {
        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ji(ko, 16, 0), this.featureIndexArray = new ja(), this.promoteId = e;
      }
      insert(t, e, r, n, i, s = 0) {
        const a = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(r, n, i, s);
        const o = this.grid;
        for (let t = 0; t < e.length; t++) {
          const r = e[t],
            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let t = 0; t < r.length; t++) {
            const e = r[t];
            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
          }
          n[0] < ko && n[1] < ko && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);
        }
      }
      loadVTLayers() {
        if (!this.vtLayers) {
          this.vtLayers = new sh(new op(this.rawTileData)).layers, this.sourceLayerCoder = new kd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
          for (const t in this.vtLayers) this.vtFeatures[t] = [];
        }
        return this.vtLayers;
      }
      query(t, e, r, n) {
        this.loadVTLayers();
        const i = t.params || {},
          s = ai(i.filter),
          a = t.tileResult,
          o = t.transform,
          l = a.bufferedTilespaceBounds,
          u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, r, n) => Vu(a.bufferedTilespaceGeometry, t, e, r, n));
        u.sort(cy);
        let c = null;
        o.elevation && u.length > 0 && (c = oy.create(o.elevation, this.tileID));
        const h = {};
        let p;
        for (let o = 0; o < u.length; o++) {
          const l = u[o];
          if (l === p) continue;
          p = l;
          const f = this.featureIndexArray.get(l);
          let d = null;
          this.loadMatchingFeature(h, f, s, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0) => (d || (d = bu(e, this.tileID.canonical, t.tileTransform)), r.queryIntersectsFeature(a, e, n, d, this.z, t.transform, t.pixelPosMatrix, c, i)));
        }
        return h;
      }
      loadMatchingFeature(t, e, r, n, i, s, a, o, l) {
        const {
            featureIndex: u,
            bucketIndex: c,
            sourceLayerIndex: h,
            layoutVertexArrayOffset: p
          } = e,
          f = this.bucketLayerIDs[c];
        if (n && !function (t, e) {
          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;
          return !1;
        }(n, f)) return;
        const d = this.sourceLayerCoder.decode(h),
          y = this.vtLayers[d].feature(u);
        if (r.needGeometry) {
          const t = wu(y, !0);
          if (!r.filter(new Us(this.tileID.overscaledZ), t, this.tileID.canonical)) return;
        } else if (!r.filter(new Us(this.tileID.overscaledZ), y)) return;
        const m = this.getId(y, d);
        for (let e = 0; e < f.length; e++) {
          const r = f[e];
          if (n && n.indexOf(r) < 0) continue;
          const c = s[r];
          if (!c) continue;
          let h = {};
          void 0 !== m && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", m));
          const d = z({}, a[r]);
          d.paint = uy(d.paint, c.paint, y, h, i), d.layout = uy(d.layout, c.layout, y, h, i);
          const g = !l || l(y, c, h, p);
          if (!g) continue;
          const x = new Md(y, this.z, this.x, this.y, m);
          x.layer = d;
          let v = t[r];
          void 0 === v && (v = t[r] = []), v.push({
            featureIndex: u,
            feature: x,
            intersectionZ: g
          });
        }
      }
      lookupSymbolFeatures(t, e, r, n, i, s, a, o) {
        const l = {};
        this.loadVTLayers();
        const u = ai(i);
        for (const i of t) this.loadMatchingFeature(l, {
          bucketIndex: r,
          sourceLayerIndex: n,
          featureIndex: i,
          layoutVertexArrayOffset: 0
        }, u, s, a, o, e);
        return l;
      }
      loadFeature(t) {
        const {
          featureIndex: e,
          sourceLayerIndex: r
        } = t;
        this.loadVTLayers();
        const n = this.sourceLayerCoder.decode(r),
          i = this.vtFeatures[n];
        if (i[e]) return i[e];
        const s = this.vtLayers[n].feature(e);
        return i[e] = s, s;
      }
      hasLayer(t) {
        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;
        return !1;
      }
      getId(t, e) {
        let r = t.id;
        if (this.promoteId) {
          const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];
          null != n && (r = t.properties[n]), "boolean" == typeof r && (r = Number(r));
        }
        return r;
      }
    }
    function uy(t, e, r, n, i) {
      return F(t, (t, s) => {
        const a = e instanceof Ks ? e.get(s) : null;
        return a && a.evaluate ? a.evaluate(r, n, i) : a;
      });
    }
    function cy(t, e) {
      return e - t;
    }
    Oi(ly, "FeatureIndex", {
      omit: ["rawTileData", "sourceLayerCoder"]
    });
    class hy {
      constructor(t, e) {
        this.width = t, this.height = e, this.nextRow = 0, this.image = new Ju({
          width: t,
          height: e
        }), this.positions = {}, this.uploaded = !1;
      }
      getDash(t, e) {
        const r = this.getKey(t, e);
        return this.positions[r];
      }
      trim() {
        const t = this.width,
          e = this.height = P(this.nextRow);
        this.image.resize({
          width: t,
          height: e
        });
      }
      getKey(t, e) {
        return t.join(",") + e;
      }
      getDashRanges(t, e, r) {
        const n = [];
        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,
          s = t[0] * r,
          a = !0;
        n.push({
          left: i,
          right: s,
          isDash: a,
          zeroLength: 0 === t[0]
        });
        let o = t[0];
        for (let e = 1; e < t.length; e++) {
          a = !a;
          const l = t[e];
          i = o * r, o += l, s = o * r, n.push({
            left: i,
            right: s,
            isDash: a,
            zeroLength: 0 === l
          });
        }
        return n;
      }
      addRoundDash(t, e, r) {
        const n = e / 2;
        for (let e = -r; e <= r; e++) {
          const i = this.width * (this.nextRow + r + e);
          let s = 0,
            a = t[s];
          for (let o = 0; o < this.width; o++) {
            o / a.right > 1 && (a = t[++s]);
            const l = Math.abs(o - a.left),
              u = Math.abs(o - a.right),
              c = Math.min(l, u);
            let h;
            const p = e / r * (n + 1);
            if (a.isDash) {
              const t = n - Math.abs(p);
              h = Math.sqrt(c * c + t * t);
            } else h = n - Math.sqrt(c * c + p * p);
            this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
          }
        }
      }
      addRegularDash(t, e) {
        for (let e = t.length - 1; e >= 0; --e) {
          const r = t[e],
            n = t[e + 1];
          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));
        }
        const r = t[0],
          n = t[t.length - 1];
        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
        const i = this.width * this.nextRow;
        let s = 0,
          a = t[s];
        for (let r = 0; r < this.width; r++) {
          r / a.right > 1 && (a = t[++s]);
          const n = Math.abs(r - a.left),
            o = Math.abs(r - a.right),
            l = Math.min(n, o);
          this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));
        }
      }
      addDash(t, e) {
        const r = this.getKey(t, e);
        if (this.positions[r]) return this.positions[r];
        const n = "round" === e,
          i = n ? 7 : 0,
          s = 2 * i + 1;
        if (this.nextRow + s > this.height) return $("LineAtlas out of space"), null;
        0 === t.length && t.push(1);
        let a = 0;
        for (let e = 0; e < t.length; e++) t[e] < 0 && ($("Negative value is found in line dasharray, replacing values with 0"), t[e] = 0), a += t[e];
        if (0 !== a) {
          const r = this.width / a,
            s = this.getDashRanges(t, this.width, r);
          n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
        }
        const o = this.nextRow + i;
        this.nextRow += s;
        const l = {
          tl: [o, i],
          br: [a, 0]
        };
        return this.positions[r] = l, l;
      }
    }
    Oi(hy, "LineAtlas");
    class py {
      constructor(t) {
        const e = {},
          r = [];
        for (const n in t) {
          const i = t[n],
            s = e[n] = {};
          for (const t in i.glyphs) {
            const e = i.glyphs[+t];
            if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;
            const n = e.metrics.localGlyph ? 2 : 1,
              a = {
                x: 0,
                y: 0,
                w: e.bitmap.width + 2 * n,
                h: e.bitmap.height + 2 * n
              };
            r.push(a), s[t] = a;
          }
        }
        const {
            w: n,
            h: i
          } = Cp(r),
          s = new Ju({
            width: n || 1,
            height: i || 1
          });
        for (const r in t) {
          const n = t[r];
          for (const t in n.glyphs) {
            const i = n.glyphs[+t];
            if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;
            const a = e[r][t],
              o = i.metrics.localGlyph ? 2 : 1;
            Ju.copy(i.bitmap, s, {
              x: 0,
              y: 0
            }, {
              x: a.x + o,
              y: a.y + o
            }, i.bitmap);
          }
        }
        this.image = s, this.positions = e;
      }
    }
    Oi(py, "GlyphAtlas");
    class fy {
      constructor(t) {
        this.tileID = new Mh(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.enableTerrain = !!t.enableTerrain, this.isSymbolTile = t.isSymbolTile, this.tileTransform = Vf(t.tileID.canonical, t.projection), this.projection = t.projection;
      }
      parse(t, e, r, n, i) {
        this.status = "parsing", this.data = t, this.collisionBoxArray = new Ea();
        const s = new kd(Object.keys(t.layers).sort()),
          a = new ly(this.tileID, this.promoteId);
        a.bucketLayerIDs = [];
        const o = {},
          l = new hy(256, 256),
          u = {
            featureIndex: a,
            iconDependencies: {},
            patternDependencies: {},
            glyphDependencies: {},
            lineAtlas: l,
            availableImages: r
          },
          c = e.familiesBySource[this.source];
        for (const e in c) {
          const n = t.layers[e];
          if (!n) continue;
          let i = !1,
            l = !1;
          for (const t of c[e]) "symbol" === t[0].type ? i = !0 : l = !0;
          if (!0 === this.isSymbolTile && !i) continue;
          if (!1 === this.isSymbolTile && !l) continue;
          1 === n.version && $(`Vector tile source "${this.source}" layer "${e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
          const h = s.encode(e),
            p = [];
          for (let t = 0; t < n.length; t++) {
            const r = n.feature(t),
              i = a.getId(r, e);
            p.push({
              feature: r,
              id: i,
              index: t,
              sourceLayerIndex: h
            });
          }
          for (const t of c[e]) {
            const e = t[0];
            void 0 !== this.isSymbolTile && "symbol" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || "none" !== e.visibility && (dy(t, this.zoom, r), (o[e.id] = e.createBucket({
              index: a.bucketLayerIDs.length,
              layers: t,
              zoom: this.zoom,
              canonical: this.canonical,
              pixelRatio: this.pixelRatio,
              overscaling: this.overscaling,
              collisionBoxArray: this.collisionBoxArray,
              sourceLayerIndex: h,
              sourceID: this.source,
              enableTerrain: this.enableTerrain,
              projection: this.projection.spec,
              availableImages: r
            })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t.map(t => t.id)));
          }
        }
        let h, p, f, d;
        l.trim();
        const y = {
            type: "maybePrepare",
            isSymbolTile: this.isSymbolTile,
            zoom: this.zoom
          },
          m = F(u.glyphDependencies, t => Object.keys(t).map(Number));
        Object.keys(m).length ? n.send("getGlyphs", {
          uid: this.uid,
          stacks: m
        }, (t, e) => {
          h || (h = t, p = e, v.call(this));
        }, void 0, !1, y) : p = {};
        const g = Object.keys(u.iconDependencies);
        g.length ? n.send("getImages", {
          icons: g,
          source: this.source,
          tileID: this.tileID,
          type: "icons"
        }, (t, e) => {
          h || (h = t, f = e, v.call(this));
        }, void 0, !1, y) : f = {};
        const x = Object.keys(u.patternDependencies);
        function v() {
          if (h) return i(h);
          if (p && f && d) {
            const t = new py(p),
              e = new Dp(f, d);
            for (const n in o) {
              const i = o[n];
              i instanceof hd ? (dy(i.layers, this.zoom, r), kf(i, p, t.positions, f, e.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof jh || i instanceof Uc || i instanceof fh) && (dy(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e.patternPositions, r, this.tileTransform));
            }
            this.status = "done", i(null, {
              buckets: T(o).filter(t => !t.isEmpty()),
              featureIndex: a,
              collisionBoxArray: this.collisionBoxArray,
              glyphAtlasImage: t.image,
              lineAtlas: l,
              imageAtlas: e,
              glyphMap: this.returnDependencies ? p : null,
              iconMap: this.returnDependencies ? f : null,
              glyphPositions: this.returnDependencies ? t.positions : null
            });
          }
        }
        x.length ? n.send("getImages", {
          icons: x,
          source: this.source,
          tileID: this.tileID,
          type: "patterns"
        }, (t, e) => {
          h || (h = t, d = e, v.call(this));
        }, void 0, !1, y) : d = {}, v.call(this);
      }
    }
    function dy(t, e, r) {
      const n = new Us(e);
      for (const e of t) e.recalculate(n, r);
    }
    class yy {
      constructor(t) {
        this.entries = {}, this.scheduler = t;
      }
      request(t, e, r, n) {
        const i = this.entries[t] = this.entries[t] || {
          callbacks: []
        };
        if (i.result) {
          const [t, r] = i.result;
          return this.scheduler ? this.scheduler.add(() => {
            n(t, r);
          }, e) : n(t, r), () => {};
        }
        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {
          i.result = [r, n];
          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {
            t(r, n);
          }, e) : t(r, n);
          setTimeout(() => delete this.entries[t], 3e3);
        })), () => {
          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));
        };
      }
    }
    function my(t, e, r) {
      const n = JSON.stringify(t.request);
      return t.data && (this.deduped.entries[n] = {
        result: [null, t.data]
      }), this.deduped.request(n, {
        type: "parseTile",
        isSymbolTile: t.isSymbolTile,
        zoom: t.tileZoom
      }, e => {
        const n = ut(t.request, (t, n, i, s) => {
          t ? e(t) : n && e(null, {
            vectorTile: r ? void 0 : new sh(new op(n)),
            rawData: n,
            cacheControl: i,
            expires: s
          });
        });
        return () => {
          n.cancel(), e();
        };
      }, e);
    }
    t.ARRAY_TYPE = To, t.AUTH_ERR_MSG = yt, t.Aabb = _l, t.Actor = class {
      constructor(t, r, n) {
        this.target = t, this.parent = r, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, V(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = N() ? t : e, this.scheduler = new Sd();
      }
      send(t, e, r, n, i = !1, s) {
        const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        r && (r.metadata = s, this.callbacks[a] = r);
        const o = Z(this.globalScope) ? void 0 : [];
        return this.target.postMessage({
          id: a,
          type: t,
          hasCallback: !!r,
          targetMapId: n,
          mustQueue: i,
          sourceMapId: this.mapId,
          data: Gi(e, o)
        }, o), {
          cancel: () => {
            r && delete this.callbacks[a], this.target.postMessage({
              id: a,
              type: "<cancel>",
              targetMapId: n,
              sourceMapId: this.mapId
            });
          }
        };
      }
      receive(t) {
        const e = t.data,
          r = e.id;
        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {
          const t = this.cancelCallbacks[r];
          delete this.cancelCallbacks[r], t && t.cancel();
        } else if (e.mustQueue || N()) {
          const t = this.callbacks[r];
          this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {
            type: "message"
          });
        } else this.processTask(r, e);
      }
      processTask(t, e) {
        if ("<response>" === e.type) {
          const r = this.callbacks[t];
          delete this.callbacks[t], r && (e.error ? r(Xi(e.error)) : r(null, Xi(e.data)));
        } else {
          const r = Z(this.globalScope) ? void 0 : [],
            n = e.hasCallback ? (e, n) => {
              delete this.cancelCallbacks[t], this.target.postMessage({
                id: t,
                type: "<response>",
                sourceMapId: this.mapId,
                error: e ? Gi(e) : null,
                data: Gi(n, r)
              }, r);
            } : t => {},
            i = Xi(e.data);
          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {
            const t = e.type.split(".");
            this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);
          } else n(new Error(`Could not find function ${e.type}`));
        }
      }
      remove() {
        this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
      }
    }, t.CanonicalTileID = kh, t.Color = Me, t.ColorMode = Qd, t.CullFaceMode = ry, t.DEMData = Kd, t.DataConstantProperty = Ys, t.DedupedRequest = yy, t.DepthMode = Hd, t.EXTENT = ko, t.Elevation = class {
      isDataAvailableAtPoint(t) {
        const e = this._source();
        if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;
        const r = e.getSource().maxzoom,
          n = 1 << r,
          i = Math.floor(t.x),
          s = Math.floor((t.x - i) * n),
          a = Math.floor(t.y * n),
          o = this.findDEMTileFor(new Mh(r, i, r, s, a));
        return !(!o || !o.dem);
      }
      getAtPointOrZero(t, e = 0) {
        return this.getAtPoint(t, e) || 0;
      }
      getAtPoint(t, e, r = !0) {
        if (this.isUsingMockSource()) return null;
        null == e && (e = null);
        const n = this._source();
        if (!n) return e;
        if (t.y < 0 || t.y > 1) return e;
        const i = n.getSource().maxzoom,
          s = 1 << i,
          a = Math.floor(t.x),
          o = t.x - a,
          l = new Mh(i, a, i, Math.floor(o * s), Math.floor(t.y * s)),
          u = this.findDEMTileFor(l);
        if (!u || !u.dem) return e;
        const c = u.dem,
          h = 1 << u.tileID.canonical.z,
          p = (o * h - u.tileID.canonical.x) * c.dim,
          f = (t.y * h - u.tileID.canonical.y) * c.dim,
          d = Math.floor(p),
          y = Math.floor(f);
        return (r ? this.exaggeration() : 1) * Mr(Mr(c.get(d, y), c.get(d, y + 1), f - y), Mr(c.get(d + 1, y), c.get(d + 1, y + 1), f - y), p - d);
      }
      getAtTileOffset(t, e, r) {
        const n = 1 << t.canonical.z;
        return this.getAtPointOrZero(new pu(t.wrap + (t.canonical.x + e / ko) / n, (t.canonical.y + r / ko) / n));
      }
      getAtTileOffsetFunc(t, e, r, n) {
        return i => {
          const s = this.getAtTileOffset(t, i.x, i.y),
            a = n.upVector(t.canonical, i.x, i.y);
          return Ho(a, a, s * n.upVectorScale(t.canonical, e, r).metersToTile), a;
        };
      }
      getForTilePoints(t, e, r, n) {
        if (this.isUsingMockSource()) return !1;
        const i = oy.create(this, t, n);
        return !!i && (e.forEach(t => {
          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);
        }), !0);
      }
      getMinMaxForTile(t) {
        if (this.isUsingMockSource()) return null;
        const e = this.findDEMTileFor(t);
        if (!e || !e.dem) return null;
        const r = e.dem.tree,
          n = e.tileID,
          i = 1 << t.canonical.z - n.canonical.z;
        let s = t.canonical.x / i - n.canonical.x,
          a = t.canonical.y / i - n.canonical.y,
          o = 0;
        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {
          s *= 2, a *= 2;
          const t = 2 * Math.floor(a) + Math.floor(s);
          o = r.childOffsets[o] + t, s %= 1, a %= 1;
        }
        return {
          min: this.exaggeration() * r.minimums[o],
          max: this.exaggeration() * r.maximums[o]
        };
      }
      getMinElevationBelowMSL() {
        throw new Error("Pure virtual method called.");
      }
      raycast(t, e, r) {
        throw new Error("Pure virtual method called.");
      }
      pointCoordinate(t) {
        throw new Error("Pure virtual method called.");
      }
      _source() {
        throw new Error("Pure virtual method called.");
      }
      isUsingMockSource() {
        throw new Error("Pure virtual method called.");
      }
      exaggeration() {
        throw new Error("Pure virtual method called.");
      }
      findDEMTileFor(t) {
        throw new Error("Pure virtual method called.");
      }
      get visibleDemTiles() {
        throw new Error("Getter must be implemented in subclass.");
      }
    }, t.ErrorEvent = Kt, t.EvaluationParameters = Us, t.Event = Zt, t.Evented = Yt, t.FillExtrusionBucket = fh, t.Frustum = wl, t.FrustumCorners = bl, t.GLOBE_RADIUS = Al, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = 6, t.GLOBE_ZOOM_THRESHOLD_MIN = 5, t.GlobeSharedBuffers = class {
      constructor(t) {
        this._createGrid(t), this._createPoles(t);
      }
      destroy() {
        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
        for (const t of this._poleSegments) t.destroy();
        for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();
        if (this._wireframeIndexBuffer) {
          this._wireframeIndexBuffer.destroy();
          for (const t of this._wireframeSegments) t.destroy();
        }
      }
      _fillGridMeshWithLods(t, e) {
        const r = new sa(),
          n = new wa(),
          i = [],
          s = t + 1 + 2,
          a = e[0] + 1,
          o = e[0] + 1 + (1 + e.length),
          l = (t, e, r) => {
            let n = t === s - 1 ? t - 2 : 0 === t ? t : t - 1;
            return n += r ? 24575 : 0, [n, e];
          };
        for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, 0, !0));
        for (let t = 0; t < a; ++t) for (let e = 0; e < s; ++e) r.emplaceBack(...l(e, t, (0 === e || e === s - 1) && !0));
        for (let t = 0; t < e.length; ++t) {
          const n = e[t];
          for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, n, !0));
        }
        for (let t = 0; t < e.length; ++t) {
          const a = n.length,
            l = e[t] + 1 + 2,
            u = new wa();
          for (let r = 0; r < l - 1; r++) {
            const i = r === l - 2,
              a = i ? s * (o - e.length + t - r) : s;
            for (let t = 0; t < s - 1; t++) {
              const e = r * s + t;
              0 === r || i || 0 === t || t === s - 2 ? (u.emplaceBack(e + 1, e, e + a), u.emplaceBack(e + a, e + a + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + a), n.emplaceBack(e + a, e + a + 1, e + 1));
            }
          }
          const c = So.simpleSegment(0, a, r.length, n.length - a);
          for (let t = 0; t < u.uint16.length; t += 3) n.emplaceBack(u.uint16[t], u.uint16[t + 1], u.uint16[t + 2]);
          const h = So.simpleSegment(0, a, r.length, n.length - a);
          i.push({
            withoutSkirts: c,
            withSkirts: h
          });
        }
        return {
          vertices: r,
          indices: n,
          segments: i
        };
      }
      _createGrid(t) {
        const e = this._fillGridMeshWithLods(Sl, kl);
        this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, xl.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);
      }
      _createPoles(t) {
        const e = new wa();
        for (let t = 0; t <= Sl; t++) e.emplaceBack(0, t + 1, t + 2);
        this._poleIndexBuffer = t.createIndexBuffer(e, !0);
        const r = new ka(),
          n = new ka();
        this._poleSegments = [];
        for (let t = 0, e = 0; t < 5; t++) {
          const i = 360 / (1 << t);
          r.emplaceBack(0, -Al, 0, .5, 0), n.emplaceBack(0, -Al, 0, .5, 1);
          for (let t = 0; t <= Sl; t++) {
            const e = t / Sl,
              s = Mr(0, i, e),
              [a, o, l] = Ul(Jl, Ql, s, Al);
            r.emplaceBack(a, o, l, e, 0), n.emplaceBack(a, o, l, e, 1);
          }
          this._poleSegments.push(So.simpleSegment(e, 0, 66, 64)), e += 66;
        }
        this._poleNorthVertexBuffer = t.createVertexBuffer(r, ml, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, ml, !1);
      }
      getGridBuffers(t, e) {
        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];
      }
      getPoleBuffers(t) {
        return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];
      }
      getWirefameBuffers(t, e) {
        if (!this._wireframeSegments) {
          const e = new Ma(),
            r = Sl,
            n = r + 1 + 2,
            i = 1;
          this._wireframeSegments = [];
          for (let t = 0, s = 0; t < kl.length; t++) {
            const a = kl[t];
            for (let t = i; t < a + i; t++) for (let s = i; s < r + i; s++) {
              const r = t * n + s;
              e.emplaceBack(r, r + 1), e.emplaceBack(r, r + n), e.emplaceBack(r, r + n + 1);
            }
            const o = a * r * 3;
            this._wireframeSegments.push(So.simpleSegment(0, s, (a + 1) * n, o)), s += o;
          }
          this._wireframeIndexBuffer = t.createIndexBuffer(e);
        }
        return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]];
      }
    }, t.GlyphManager = cf, t.ImagePosition = Pp, t.LivePerformanceUtils = Lt, t.LngLat = ru, t.LngLatBounds = Io, t.LocalGlyphMode = uf, t.MAX_MERCATOR_LATITUDE = cu, t.MercatorCoordinate = pu, t.ONE_EM = Wh, t.OverscaledTileID = Mh, t.PerformanceMarkers = Vt, t.Properties = Js, t.RGBAImage = Qu, t.Ray = vl, t.RequestManager = class {
      constructor(t, e, r) {
        this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();
      }
      _createSkuToken() {
        const t = function () {
          let t = "";
          for (let e = 0; e < 10; e++) t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
          return {
            token: ["1", h, t].join(""),
            tokenExpiresAt: Date.now() + 432e5
          };
        }();
        this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
      }
      _isSkuTokenExpired() {
        return Date.now() > this._skuTokenExpiresAt;
      }
      transformRequest(t, e) {
        return this._transformRequestFn && this._transformRequestFn(t, e) || {
          url: t
        };
      }
      normalizeStyleURL(t, e) {
        if (!mt(t)) return t;
        const r = _t(t);
        return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
      }
      normalizeGlyphsURL(t, e) {
        if (!mt(t)) return t;
        const r = _t(t);
        return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
      }
      normalizeSourceURL(t, e, r, n) {
        if (!mt(t)) return t;
        const i = _t(t);
        return i.path = `/v4/${i.authority}.json`, i.params.push("secure"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e);
      }
      normalizeSpriteURL(t, e, r, n) {
        const i = _t(t);
        return mt(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, At(i));
      }
      normalizeTileURL(t, e, r) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !mt(t)) return t;
        const n = _t(t);
        n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || r && "raster" !== n.authority && 512 === r ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`), "raster" === n.authority ? n.path = `/${i.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${i.TILE_URL_VERSION}${n.path}`);
        const a = this._customAccessToken || function (t) {
          for (const e of t) {
            const t = e.match(/^access_token=(.*)$/);
            if (t) return t[1];
          }
          return null;
        }(n.params) || i.ACCESS_TOKEN;
        return i.REQUIRE_ACCESS_TOKEN && a && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, a);
      }
      canonicalizeTileURL(t, e) {
        const r = _t(t);
        if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t;
        let n = "mapbox://";
        r.path.match(/^\/raster\/v1\//) ? n += `raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`;
        let s = r.params;
        return e && (s = s.filter(t => !t.match(/^access_token=/))), s.length && (n += `?${s.join("&")}`), n;
      }
      canonicalizeTileset(t, e) {
        const r = !!e && mt(e),
          n = [];
        for (const e of t.tiles || []) gt(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);
        return n;
      }
      _makeAPIURL(t, e) {
        const r = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
          n = _t(i.API_URL);
        if (t.protocol = n.protocol, t.authority = n.authority, "http" === t.protocol) {
          const e = t.params.indexOf("secure");
          e >= 0 && t.params.splice(e, 1);
        }
        if ("/" !== n.path && (t.path = `${n.path}${t.path}`), !i.REQUIRE_ACCESS_TOKEN) return At(t);
        if (e = e || i.ACCESS_TOKEN, !this._silenceAuthErrors) {
          if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);
          if ("s" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
        }
        return t.params = t.params.filter(t => -1 === t.indexOf("access_token")), t.params.push(`access_token=${e || ""}`), At(t);
      }
    }, t.ResourceType = st, t.SegmentVector = So, t.SourceCache = ny, t.StencilMode = Jd, t.StructArrayLayout1ui2 = Ta, t.StructArrayLayout2f1f2i16 = xa, t.StructArrayLayout2i4 = sa, t.StructArrayLayout2ui4 = Ma, t.StructArrayLayout3f12 = ba, t.StructArrayLayout3ui6 = wa, t.StructArrayLayout4i8 = oa, t.StructArrayLayout5f20 = ka, t.Texture = _d, t.Tile = Fd, t.Transitionable = qs, t.Uniform1f = to, t.Uniform1i = class extends Qa {
      constructor(t) {
        super(t), this.current = 0;
      }
      set(t, e, r) {
        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
      }
    }, t.Uniform2f = class extends Qa {
      constructor(t) {
        super(t), this.current = [0, 0];
      }
      set(t, e, r) {
        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
      }
    }, t.Uniform3f = class extends Qa {
      constructor(t) {
        super(t), this.current = [0, 0, 0];
      }
      set(t, e, r) {
        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
      }
    }, t.Uniform4f = eo, t.UniformColor = ro, t.UniformMatrix2f = class extends Qa {
      constructor(t) {
        super(t), this.current = so;
      }
      set(t, e, r) {
        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 4; t++) if (r[t] !== this.current[t]) {
          this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
          break;
        }
      }
    }, t.UniformMatrix3f = class extends Qa {
      constructor(t) {
        super(t), this.current = io;
      }
      set(t, e, r) {
        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 9; t++) if (r[t] !== this.current[t]) {
          this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
          break;
        }
      }
    }, t.UniformMatrix4f = class extends Qa {
      constructor(t) {
        super(t), this.current = no;
      }
      set(t, e, r) {
        if (this.fetchUniformLocation(t, e)) {
          if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
          for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {
            this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
            break;
          }
        }
      }
    }, t.UnwrappedTileID = Ih, t.ValidationError = Wn, t.VectorTileFeature = ah, t.VectorTileWorkerSource = class extends Yt {
      constructor(t, e, r, n, i) {
        super(), this.actor = t, this.layerIndex = e, this.availableImages = r, this.loadVectorData = i || my, this.loading = {}, this.loaded = {}, this.deduped = new yy(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;
      }
      loadTile(t, e) {
        const r = t.uid,
          n = t && t.request,
          i = n && n.collectResourceTiming,
          s = this.loading[r] = new fy(t);
        s.abort = this.loadVectorData(t, (a, o) => {
          const l = !this.loading[r];
          if (delete this.loading[r], l || a || !o) return s.status = "done", l || (this.loaded[r] = s), e(a);
          const u = o.rawData,
            c = {};
          o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new sh(new op(u));
          const h = () => {
            s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, r) => {
              if (t || !r) return e(t);
              const s = {};
              if (i) {
                const t = jt(n);
                t.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t)));
              }
              e(null, z({
                rawTileData: u.slice(0)
              }, r, c, s));
            });
          };
          this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", () => {
            this.scheduler ? this.scheduler.add(h, {
              type: "parseTile",
              isSymbolTile: t.isSymbolTile,
              zoom: t.tileZoom
            }) : h();
          }), this.loaded = this.loaded || {}, this.loaded[r] = s;
        });
      }
      reloadTile(t, e) {
        const r = this.loaded,
          n = t.uid,
          i = this;
        if (r && r[n]) {
          const s = r[n];
          s.showCollisionBoxes = t.showCollisionBoxes, s.enableTerrain = !!t.enableTerrain, s.projection = t.projection, s.tileTransform = Vf(t.tileID.canonical, t.projection);
          const a = (t, r) => {
            const n = s.reloadCallback;
            n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e(t, r);
          };
          "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());
        }
      }
      abortTile(t, e) {
        const r = t.uid,
          n = this.loading[r];
        n && (n.abort && n.abort(), delete this.loading[r]), e();
      }
      removeTile(t, e) {
        const r = this.loaded,
          n = t.uid;
        r && r[n] && delete r[n], e();
      }
    }, t.WritingMode = Vp, t.ZoomDependentExpression = Zn, t.add = Go, t.addDynamicAttributes = od, t.adjoint = function (t, e) {
      var r = e[0],
        n = e[1],
        i = e[2],
        s = e[3],
        a = e[4],
        o = e[5],
        l = e[6],
        u = e[7],
        c = e[8];
      return t[0] = a * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * a, t[3] = o * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * o, t[6] = s * u - a * l, t[7] = n * l - r * u, t[8] = r * a - n * s, t;
    }, t.asyncAll = M, t.bezier = _, t.bindAll = V, t.boundsAttributes = Vd, t.bufferConvexPolygon = function (t, e) {
      const r = [];
      for (let n = 0; n < t.length; n++) {
        const i = I(n - 1, -1, t.length - 1),
          s = I(n + 1, -1, t.length - 1),
          a = t[n],
          o = t[s],
          l = t[i].sub(a).unit(),
          u = o.sub(a).unit(),
          c = u.angleWithSep(l.x, l.y),
          h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
        r.push(a.add(h));
      }
      return r;
    }, t.cacheEntryPossiblyAdded = function (t) {
      it++, it > tt && (t.getActor().send("enforceCacheSizeLimit", Q), it = 0);
    }, t.calculateGlobeLabelMatrix = function (t, e) {
      const {
          x: r,
          y: n
        } = t.point,
        i = Zl(r, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);
      return Po(i, i, Xl(Pl(e)));
    }, t.calculateGlobeMatrix = function (t) {
      const {
          x: e,
          y: r
        } = t.point,
        {
          lng: n,
          lat: i
        } = t._center;
      return Zl(e, r, t.worldSize, n, i);
    }, t.calculateGlobeMercatorMatrix = function (t) {
      const e = t.pixelsPerMeter,
        r = e / au(1, t.center.lat),
        n = Eo(new Float64Array(16));
      return Do(n, n, [t.point.x, t.point.y, 0]), Vo(n, n, [r, r, e]), Float32Array.from(n);
    }, t.circumferenceAtLatitude = nu, t.clamp = S, t.clearTileCache = function (t) {
      if (!et()) return;
      const r = e.caches.delete(H);
      t && r.catch(t).then(() => t());
    }, t.clipLine = sf, t.clone = function (t) {
      var e = new To(16);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
    }, t.clone$1 = j, t.collisionCircleLayout = Hh, t.config = i, t.conjugate = function (t, e) {
      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
    }, t.create = function () {
      var t = new To(16);
      return To != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
    }, t.create$1 = zo, t.createExpression = Gn, t.createLayout = na, t.createStyleLayer = function (t) {
      return "custom" === t.type ? new xd(t) : new wd[t.type](t);
    }, t.cross = tl, t.degToRad = x, t.distance = function (t, e) {
      return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2]);
    }, t.div = function (t, e, r) {
      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;
    }, t.dot = Qo, t.earthRadius = tu, t.ease = A, t.easeCubicInOut = w, t.ecefToLatLng = function ([t, e, r]) {
      const n = Math.hypot(t, e, r),
        i = Math.atan2(t, r),
        s = .5 * Math.PI - Math.acos(-e / n);
      return new ru(v(i), v(s));
    }, t.emitValidationErrors = Ri, t.endsWith = L, t.enforceCacheSizeLimit = function (t) {
      rt(), W && W.then(e => {
        e.keys().then(r => {
          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);
        });
      });
    }, t.evaluateSizeForFeature = tp, t.evaluateSizeForZoom = ep, t.evaluateVariableOffset = Sf, t.evented = Ls, t.exactEquals = function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
    }, t.exactEquals$1 = function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
    }, t.exported = Nt, t.exported$1 = s, t.extend = z, t.extend$1 = Wt, t.fillExtrusionHeightLift = bh, t.filterObject = R, t.fromMat4 = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
    }, t.fromQuat = function (t, e) {
      var r = e[0],
        n = e[1],
        i = e[2],
        s = e[3],
        a = r + r,
        o = n + n,
        l = i + i,
        u = r * a,
        c = n * a,
        h = n * o,
        p = i * a,
        f = i * o,
        d = i * l,
        y = s * a,
        m = s * o,
        g = s * l;
      return t[0] = 1 - h - d, t[1] = c + g, t[2] = p - m, t[3] = 0, t[4] = c - g, t[5] = 1 - u - d, t[6] = f + y, t[7] = 0, t[8] = p + m, t[9] = f - y, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, t.fromRotation = function (t, e) {
      var r = Math.sin(e),
        n = Math.cos(e);
      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, t.fromScaling = Ro, t.furthestTileCorner = function (t) {
      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;
      return b[e];
    }, t.getAABBPointSquareDist = function (t, e, r) {
      let n = 0;
      for (let i = 0; i < 2; ++i) {
        const s = r ? r[i] : 0;
        t[i] > s && (n += (t[i] - s) * (t[i] - s)), e[i] < s && (n += (s - e[i]) * (s - e[i]));
      }
      return n;
    }, t.getAnchorAlignment = Xp, t.getAnchorJustification = If, t.getBounds = function (t) {
      let e = 1 / 0,
        r = 1 / 0,
        n = -1 / 0,
        i = -1 / 0;
      for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);
      return {
        min: new d(e, r),
        max: new d(n, i)
      };
    }, t.getColumn = Y, t.getGridMatrix = function (t, e, r, n) {
      const i = e.getNorth(),
        s = e.getSouth(),
        a = e.getWest(),
        o = e.getEast(),
        l = 1 << t.z,
        u = o - a,
        c = i - s,
        h = u / Sl,
        p = -c / kl[r],
        f = [0, h, 0, p, 0, 0, i, a, 0];
      if (t.z > 0) {
        const t = 180 / n;
        Bo(f, f, [t / u + 1, 0, 0, 0, t / c + 1, 0, -.5 * t / h, .5 * t / p, 1]);
      }
      return f[2] = l, f[5] = t.x, f[8] = t.y, f;
    }, t.getImage = dt, t.getJSON = function (t, e) {
      return lt(z(t, {
        type: "json"
      }), e);
    }, t.getLatitudinalLod = function (t) {
      const e = cu - 5;
      t = S(t, -e, e) / e * 90;
      const r = Math.pow(Math.abs(Math.sin(x(t))), 3);
      return Math.round(r * (kl.length - 1));
    }, t.getMapSessionAPI = Pt, t.getPerformanceMeasurement = jt, t.getProjection = rd, t.getRTLTextPluginStatus = Fs, t.getReferrer = ot, t.getTilePoint = function (t, {
      x: e,
      y: r
    }, n = 0) {
      return new d(((e - n) * t.scale - t.x) * ko, (r * t.scale - t.y) * ko);
    }, t.getTileVec3 = function (t, e, r = 0) {
      return No(((e.x - r) * t.scale - t.x) * ko, (e.y * t.scale - t.y) * ko, uu(e.z, e.y));
    }, t.getVideo = function (t, r) {
      const n = e.document.createElement("video");
      n.muted = !0, n.onloadstart = function () {
        r(null, n);
      };
      for (let r = 0; r < t.length; r++) {
        const i = e.document.createElement("source");
        ct(t[r]) || (n.crossOrigin = "Anonymous"), i.src = t[r], n.appendChild(i);
      }
      return {
        cancel: () => {}
      };
    }, t.globeCenterToScreenPoint = function (t) {
      const e = [0, 0, 0],
        r = Eo(new Float64Array(16));
      return Po(r, t.pixelMatrix, t.globeMatrix), el(e, e, r), new d(e[0], e[1]);
    }, t.globeDenormalizeECEF = Xl, t.globeECEFOrigin = function (t, e) {
      const r = [0, 0, 0];
      return el(r, r, Gl(Pl(e.canonical))), el(r, r, t), r;
    }, t.globeMetersToEcef = zl, t.globeNormalizeECEF = Gl, t.globePixelsToTileUnits = function (t, e) {
      return ko / (512 * Math.pow(2, t)) * ql(Pl(e));
    }, t.globePoleMatrixForTile = function (t, e, r) {
      const n = Eo(new Float64Array(16)),
        i = (e / (1 << t) - .5) * Math.PI * 2;
      return Fo(n, r.globeMatrix, i), Float32Array.from(n);
    }, t.globeTileBounds = Pl, t.globeTiltAtLngLat = Yl, t.globeToMercatorTransition = Kl, t.globeUseCustomAntiAliasing = function (t, e, r) {
      const n = Kl(r.zoom),
        i = t.style.map._antialias,
        s = !!e.extStandardDerivatives,
        a = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;
      return 0 === n && !i && !a && s;
    }, t.identity = Eo, t.identity$1 = hl, t.invert = Co, t.isFullscreen = function () {
      return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;
    }, t.isLngLatBehindGlobe = Hl, t.isMapAuthenticated = function (t) {
      return Dt.has(t);
    }, t.isMapboxURL = mt, t.isSafariWithAntialiasingBug = function (t) {
      const e = t.navigator ? t.navigator.userAgent : null;
      return !!Z(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
    }, t.latFromMercatorY = lu, t.latLngToECEF = $l, t.len = al, t.length = qo, t.length$1 = function (t) {
      return Math.hypot(t[0], t[1], t[2], t[3]);
    }, t.lngFromMercatorX = ou, t.loadVectorTile = my, t.makeRequest = lt, t.mapValue = function (t, e, r, n, i) {
      return S((t - e) / (r - e) * (i - n) + n, n, i);
    }, t.mercatorScale = hu, t.mercatorXfromLng = iu, t.mercatorYfromLat = su, t.mercatorZfromAltitude = au, t.mul = Uo, t.mul$1 = sl, t.multiply = Po, t.multiply$1 = Bo, t.multiply$2 = Zo, t.nextPowerOfTwo = P, t.normalize = Jo, t.normalize$1 = dl, t.normalize$2 = ll, t.number = Mr, t.ortho = function (t, e, r, n, i, s, a) {
      var o = 1 / (e - r),
        l = 1 / (n - i),
        u = 1 / (s - a);
      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;
    }, t.pbf = op, t.perspective = function (t, e, r, n, i) {
      var s,
        a = 1 / Math.tan(e / 2);
      return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;
    }, t.pick = function (t, e) {
      const r = {};
      for (let n = 0; n < e.length; n++) {
        const i = e[n];
        i in t && (r[i] = t[i]);
      }
      return r;
    }, t.plugin = js, t.pointGeometry = d, t.polesInViewport = function (t) {
      const e = Eo(new Float64Array(16));
      Po(e, t.pixelMatrix, t.globeMatrix);
      const r = [0, Il, 0],
        n = [0, Ml, 0];
      return el(r, r, e), el(n, n, e), [r[0] > 0 && r[0] <= t.width && r[1] > 0 && r[1] <= t.height && !Hl(t, new ru(t.center.lat, 90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Hl(t, new ru(t.center.lat, -90))];
    }, t.polygonContainsPoint = Du, t.polygonIntersectsBox = Vu, t.polygonIntersectsPolygon = ku, t.polygonizeBounds = function (t, e, r = 0, n = !0) {
      const i = new d(r, r),
        s = t.sub(i),
        a = e.add(i),
        o = [s, new d(a.x, s.y), a, new d(s.x, a.y)];
      return n && o.push(s.clone()), o;
    }, t.posAttributes = xl, t.postMapLoadEvent = zt, t.postPerformanceEvent = Et, t.postTurnstileEvent = Mt, t.potpack = Cp, t.prevPowerOfTwo = function (t) {
      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }, t.radToDeg = v, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function (t) {
      return t({
        pluginStatus: Cs,
        pluginURL: Ps
      }), Ls.on("pluginStateChange", t), t;
    }, t.removeAuthState = function (t) {
      Dt.delete(t);
    }, t.renderColorRamp = ec, t.resample = du, t.rotateX = Lo, t.rotateX$1 = pl, t.rotateY = Fo, t.rotateY$1 = fl, t.rotateZ = function (t, e, r) {
      var n = Math.sin(r),
        i = Math.cos(r),
        s = e[0],
        a = e[1],
        o = e[2],
        l = e[3],
        u = e[4],
        c = e[5],
        h = e[6],
        p = e[7];
      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;
    }, t.rotateZ$1 = function (t, e, r) {
      r *= .5;
      var n = e[0],
        i = e[1],
        s = e[2],
        a = e[3],
        o = Math.sin(r),
        l = Math.cos(r);
      return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = s * l + a * o, t[3] = a * l - s * o, t;
    }, t.scale = Vo, t.scale$1 = ol, t.scale$2 = Ho, t.scaleAndAdd = Wo, t.set = function (t, e, r, n) {
      return t[0] = e, t[1] = r, t[2] = n, t;
    }, t.setCacheLimits = function (t, e) {
      Q = t, tt = e;
    }, t.setColumn = function (t, e, r) {
      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];
    }, t.setRTLTextPlugin = function (t, e, r = !1) {
      if (Cs === Ts || Cs === zs || Cs === Bs) throw new Error("setRTLTextPlugin cannot be called multiple times.");
      Ps = Nt.resolveURL(t), Cs = Ts, Es = e, Vs(), r || Rs();
    }, t.smoothstep = k, t.spec = Ht, t.squaredLength = function (t) {
      var e = t[0],
        r = t[1],
        n = t[2];
      return e * e + r * r + n * n;
    }, t.storeAuthState = function (t, e) {
      e ? Dt.add(t) : Dt.delete(t);
    }, t.sub = il, t.subtract = Xo, t.symbolSize = rp, t.tileAABB = function (t, e, r, n, i, s, a, o, l) {
      if ("globe" === l.name) return Fl(t, e, new kh(r, n, i));
      const u = Vf({
        z: r,
        x: n,
        y: i
      }, l);
      return new _l([(s + u.x / u.scale) * e, e * (u.y / u.scale), a], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);
    }, t.tileCornersToBounds = Rl, t.tileTransform = Vf, t.transformMat3 = function (t, e, r) {
      var n = e[0],
        i = e[1],
        s = e[2];
      return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;
    }, t.transformMat4 = el, t.transformMat4$1 = ul, t.transformQuat = rl, t.transitionTileAABBinECEF = Vl, t.translate = Do, t.transpose = function (t, e) {
      if (t === e) {
        var r = e[1],
          n = e[2],
          i = e[5];
        t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;
      } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
      return t;
    }, t.triggerPluginCompletionEvent = Ds, t.uniqueId = E, t.updateGlobeVertexNormal = function (t, e, r, n, i) {
      const s = 5 * e + 2;
      t.float32[s + 0] = r, t.float32[s + 1] = n, t.float32[s + 2] = i;
    }, t.validateCustomStyleLayer = function (t) {
      const e = [],
        r = t.id;
      return void 0 === r && e.push({
        message: `layers.${r}: missing required property "id"`
      }), void 0 === t.render && e.push({
        message: `layers.${r}: missing required method "render"`
      }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({
        message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
      }), e;
    }, t.validateFilter = t => Fi(xi(t)), t.validateFog = t => Fi(Bi(t)), t.validateLayer = t => Fi(Ai(t)), t.validateLight = t => Fi(Ti(t)), t.validateSource = t => Fi(Ii(t)), t.validateStyle = Di, t.validateTerrain = t => Fi(zi(t)), t.values = T, t.vectorTile = Zc, t.version = r, t.warnOnce = $, t.window = e, t.wrap = I;
  });
  define(["./shared"], function (e) {
    "use strict";

    function t(e) {
      if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);
      if (Array.isArray(e)) {
        let r = "[";
        for (const o of e) r += `${t(o)},`;
        return `${r}]`;
      }
      let r = "{";
      for (const o of Object.keys(e).sort()) r += `${o}:${t(e[o])},`;
      return `${r}}`;
    }
    function r(r) {
      let o = "";
      for (const n of e.refProperties) o += `/${t(r[n])}`;
      return o;
    }
    class o {
      constructor(e) {
        this.keyCache = {}, e && this.replace(e);
      }
      replace(e) {
        this._layerConfigs = {}, this._layers = {}, this.update(e, []);
      }
      update(t, o) {
        for (const r of t) this._layerConfigs[r.id] = r, (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];
        for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
        this.familiesBySource = {};
        const n = function (e, t) {
          const o = {};
          for (let n = 0; n < e.length; n++) {
            const i = t && t[e[n].id] || r(e[n]);
            t && (t[e[n].id] = i);
            let s = o[i];
            s || (s = o[i] = []), s.push(e[n]);
          }
          const n = [];
          for (const e in o) n.push(o[e]);
          return n;
        }(e.values(this._layerConfigs), this.keyCache);
        for (const e of n) {
          const t = e.map(e => this._layers[e.id]),
            r = t[0];
          if ("none" === r.visibility) continue;
          const o = r.source || "";
          let n = this.familiesBySource[o];
          n || (n = this.familiesBySource[o] = {});
          const i = r.sourceLayer || "_geojsonTileLayer";
          let s = n[i];
          s || (s = n[i] = []), s.push(t);
        }
      }
    }
    class n {
      loadTile(t, r) {
        const {
            uid: o,
            encoding: n,
            rawImageData: i,
            padding: s,
            buildQuadTree: a
          } = t,
          l = e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? this.getImageData(i, s) : i;
        r(null, new e.DEMData(o, l, n, s < 1, a));
      }
      getImageData(e, t) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
          willReadFrequently: !0
        })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
        const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;
      }
    }
    var i = function e(t, r) {
      var o,
        n = t && t.type;
      if ("FeatureCollection" === n) for (o = 0; o < t.features.length; o++) e(t.features[o], r);else if ("GeometryCollection" === n) for (o = 0; o < t.geometries.length; o++) e(t.geometries[o], r);else if ("Feature" === n) e(t.geometry, r);else if ("Polygon" === n) s(t.coordinates, r);else if ("MultiPolygon" === n) for (o = 0; o < t.coordinates.length; o++) s(t.coordinates[o], r);
      return t;
    };
    function s(e, t) {
      if (0 !== e.length) {
        a(e[0], t);
        for (var r = 1; r < e.length; r++) a(e[r], !t);
      }
    }
    function a(e, t) {
      for (var r = 0, o = 0, n = 0, i = e.length, s = i - 1; n < i; s = n++) {
        var a = (e[n][0] - e[s][0]) * (e[s][1] + e[n][1]),
          l = r + a;
        o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;
      }
      r + o >= 0 != !!t && e.reverse();
    }
    const l = e.VectorTileFeature.prototype.toGeoJSON;
    class u {
      constructor(t) {
        this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));
      }
      loadGeometry() {
        if (1 === this._feature.type) {
          const t = [];
          for (const r of this._feature.geometry) t.push([new e.pointGeometry(r[0], r[1])]);
          return t;
        }
        {
          const t = [];
          for (const r of this._feature.geometry) {
            const o = [];
            for (const t of r) o.push(new e.pointGeometry(t[0], t[1]));
            t.push(o);
          }
          return t;
        }
      }
      toGeoJSON(e, t, r) {
        return l.call(this, e, t, r);
      }
    }
    class h {
      constructor(t) {
        this.layers = {
          _geojsonTileLayer: this
        }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t;
      }
      feature(e) {
        return new u(this._features[e]);
      }
    }
    var c = {},
      f = {
        get exports() {
          return c;
        },
        set exports(e) {
          c = e;
        }
      },
      p = e.pointGeometry,
      g = e.vectorTile.VectorTileFeature,
      d = m;
    function m(e, t) {
      this.options = t || {}, this.features = e, this.length = e.length;
    }
    function y(e, t) {
      this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;
    }
    m.prototype.feature = function (e) {
      return new y(this.features[e], this.options.extent);
    }, y.prototype.loadGeometry = function () {
      var e = this.rawGeometry;
      this.geometry = [];
      for (var t = 0; t < e.length; t++) {
        for (var r = e[t], o = [], n = 0; n < r.length; n++) o.push(new p(r[n][0], r[n][1]));
        this.geometry.push(o);
      }
      return this.geometry;
    }, y.prototype.bbox = function () {
      this.geometry || this.loadGeometry();
      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, o = 1 / 0, n = -1 / 0, i = 0; i < e.length; i++) for (var s = e[i], a = 0; a < s.length; a++) {
        var l = s[a];
        t = Math.min(t, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), n = Math.max(n, l.y);
      }
      return [t, o, r, n];
    }, y.prototype.toGeoJSON = g.prototype.toGeoJSON;
    var v = e.pbf,
      x = d;
    function w(e) {
      var t = new v();
      return function (e, t) {
        for (var r in e.layers) t.writeMessage(3, S, e.layers[r]);
      }(e, t), t.finish();
    }
    function S(e, t) {
      var r;
      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);
      var o = {
        keys: [],
        values: [],
        keycache: {},
        valuecache: {}
      };
      for (r = 0; r < e.length; r++) o.feature = e.feature(r), t.writeMessage(2, M, o);
      var n = o.keys;
      for (r = 0; r < n.length; r++) t.writeStringField(3, n[r]);
      var i = o.values;
      for (r = 0; r < i.length; r++) t.writeMessage(4, T, i[r]);
    }
    function M(e, t) {
      var r = e.feature;
      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, P, e), t.writeVarintField(3, r.type), t.writeMessage(4, I, r);
    }
    function P(e, t) {
      var r = e.feature,
        o = e.keys,
        n = e.values,
        i = e.keycache,
        s = e.valuecache;
      for (var a in r.properties) {
        var l = r.properties[a],
          u = i[a];
        if (null !== l) {
          void 0 === u && (o.push(a), i[a] = u = o.length - 1), t.writeVarint(u);
          var h = typeof l;
          "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
          var c = h + ":" + l,
            f = s[c];
          void 0 === f && (n.push(l), s[c] = f = n.length - 1), t.writeVarint(f);
        }
      }
    }
    function b(e, t) {
      return (t << 3) + (7 & e);
    }
    function k(e) {
      return e << 1 ^ e >> 31;
    }
    function I(e, t) {
      for (var r = e.loadGeometry(), o = e.type, n = 0, i = 0, s = r.length, a = 0; a < s; a++) {
        var l = r[a],
          u = 1;
        1 === o && (u = l.length), t.writeVarint(b(1, u));
        for (var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++) {
          1 === c && 1 !== o && t.writeVarint(b(2, h - 1));
          var f = l[c].x - n,
            p = l[c].y - i;
          t.writeVarint(k(f)), t.writeVarint(k(p)), n += f, i += p;
        }
        3 === o && t.writeVarint(b(7, 1));
      }
    }
    function T(e, t) {
      var r = typeof e;
      "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));
    }
    function _(e, t, r, o, n, i) {
      if (n - o <= r) return;
      const s = o + n >> 1;
      L(e, t, s, o, n, i % 2), _(e, t, r, o, s - 1, i + 1), _(e, t, r, s + 1, n, i + 1);
    }
    function L(e, t, r, o, n, i) {
      for (; n > o;) {
        if (n - o > 600) {
          const s = n - o + 1,
            a = r - o + 1,
            l = Math.log(s),
            u = .5 * Math.exp(2 * l / 3),
            h = .5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1);
          L(e, t, r, Math.max(o, Math.floor(r - a * u / s + h)), Math.min(n, Math.floor(r + (s - a) * u / s + h)), i);
        }
        const s = t[2 * r + i];
        let a = o,
          l = n;
        for (C(e, t, o, r), t[2 * n + i] > s && C(e, t, o, n); a < l;) {
          for (C(e, t, a, l), a++, l--; t[2 * a + i] < s;) a++;
          for (; t[2 * l + i] > s;) l--;
        }
        t[2 * o + i] === s ? C(e, t, o, l) : (l++, C(e, t, l, n)), l <= r && (o = l + 1), r <= l && (n = l - 1);
      }
    }
    function C(e, t, r, o) {
      O(e, r, o), O(t, 2 * r, 2 * o), O(t, 2 * r + 1, 2 * o + 1);
    }
    function O(e, t, r) {
      const o = e[t];
      e[t] = e[r], e[r] = o;
    }
    function z(e, t, r, o) {
      const n = e - r,
        i = t - o;
      return n * n + i * i;
    }
    f.exports = w, c.fromVectorTileJs = w, c.fromGeojsonVt = function (e, t) {
      t = t || {};
      var r = {};
      for (var o in e) r[o] = new x(e[o].features, t), r[o].name = o, r[o].version = t.version, r[o].extent = t.extent;
      return w({
        layers: r
      });
    }, c.GeoJSONWrapper = x;
    const E = e => e[0],
      F = e => e[1];
    class N {
      constructor(e, t = E, r = F, o = 64, n = Float64Array) {
        this.nodeSize = o, this.points = e;
        const i = e.length < 65536 ? Uint16Array : Uint32Array,
          s = this.ids = new i(e.length),
          a = this.coords = new n(2 * e.length);
        for (let o = 0; o < e.length; o++) s[o] = o, a[2 * o] = t(e[o]), a[2 * o + 1] = r(e[o]);
        _(s, a, o, 0, s.length - 1, 0);
      }
      range(e, t, r, o) {
        return function (e, t, r, o, n, i, s) {
          const a = [0, e.length - 1, 0],
            l = [];
          let u, h;
          for (; a.length;) {
            const c = a.pop(),
              f = a.pop(),
              p = a.pop();
            if (f - p <= s) {
              for (let s = p; s <= f; s++) u = t[2 * s], h = t[2 * s + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[s]);
              continue;
            }
            const g = Math.floor((p + f) / 2);
            u = t[2 * g], h = t[2 * g + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[g]);
            const d = (c + 1) % 2;
            (0 === c ? r <= u : o <= h) && (a.push(p), a.push(g - 1), a.push(d)), (0 === c ? n >= u : i >= h) && (a.push(g + 1), a.push(f), a.push(d));
          }
          return l;
        }(this.ids, this.coords, e, t, r, o, this.nodeSize);
      }
      within(e, t, r) {
        return function (e, t, r, o, n, i) {
          const s = [0, e.length - 1, 0],
            a = [],
            l = n * n;
          for (; s.length;) {
            const u = s.pop(),
              h = s.pop(),
              c = s.pop();
            if (h - c <= i) {
              for (let n = c; n <= h; n++) z(t[2 * n], t[2 * n + 1], r, o) <= l && a.push(e[n]);
              continue;
            }
            const f = Math.floor((c + h) / 2),
              p = t[2 * f],
              g = t[2 * f + 1];
            z(p, g, r, o) <= l && a.push(e[f]);
            const d = (u + 1) % 2;
            (0 === u ? r - n <= p : o - n <= g) && (s.push(c), s.push(f - 1), s.push(d)), (0 === u ? r + n >= p : o + n >= g) && (s.push(f + 1), s.push(h), s.push(d));
          }
          return a;
        }(this.ids, this.coords, e, t, r, this.nodeSize);
      }
    }
    const j = {
        minZoom: 0,
        maxZoom: 16,
        minPoints: 2,
        radius: 40,
        extent: 512,
        nodeSize: 64,
        log: !1,
        generateId: !1,
        reduce: null,
        map: e => e
      },
      Z = Math.fround || (G = new Float32Array(1), e => (G[0] = +e, G[0]));
    var G;
    class J {
      constructor(e) {
        this.options = B(Object.create(j), e), this.trees = new Array(this.options.maxZoom + 1);
      }
      load(e) {
        const {
          log: t,
          minZoom: r,
          maxZoom: o,
          nodeSize: n
        } = this.options;
        t && console.time("total time");
        const i = `prepare ${e.length} points`;
        t && console.time(i), this.points = e;
        let s = [];
        for (let t = 0; t < e.length; t++) e[t].geometry && s.push(Y(e[t], t));
        this.trees[o + 1] = new N(s, R, q, n, Float32Array), t && console.timeEnd(i);
        for (let e = o; e >= r; e--) {
          const r = +Date.now();
          s = this._cluster(s, e), this.trees[e] = new N(s, R, q, n, Float32Array), t && console.log("z%d: %d clusters in %dms", e, s.length, +Date.now() - r);
        }
        return t && console.timeEnd("total time"), this;
      }
      getClusters(e, t) {
        let r = ((e[0] + 180) % 360 + 360) % 360 - 180;
        const o = Math.max(-90, Math.min(90, e[1]));
        let n = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
        const i = Math.max(-90, Math.min(90, e[3]));
        if (e[2] - e[0] >= 360) r = -180, n = 180;else if (r > n) {
          const e = this.getClusters([r, o, 180, i], t),
            s = this.getClusters([-180, o, n, i], t);
          return e.concat(s);
        }
        const s = this.trees[this._limitZoom(t)],
          a = s.range(A(r), D(i), A(n), D(o)),
          l = [];
        for (const e of a) {
          const t = s.points[e];
          l.push(t.numPoints ? X(t) : this.points[t.index]);
        }
        return l;
      }
      getChildren(e) {
        const t = this._getOriginId(e),
          r = this._getOriginZoom(e),
          o = "No cluster with the specified id.",
          n = this.trees[r];
        if (!n) throw new Error(o);
        const i = n.points[t];
        if (!i) throw new Error(o);
        const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),
          a = n.within(i.x, i.y, s),
          l = [];
        for (const t of a) {
          const r = n.points[t];
          r.parentId === e && l.push(r.numPoints ? X(r) : this.points[r.index]);
        }
        if (0 === l.length) throw new Error(o);
        return l;
      }
      getLeaves(e, t, r) {
        const o = [];
        return this._appendLeaves(o, e, t = t || 10, r = r || 0, 0), o;
      }
      getTile(e, t, r) {
        const o = this.trees[this._limitZoom(e)],
          n = Math.pow(2, e),
          {
            extent: i,
            radius: s
          } = this.options,
          a = s / i,
          l = (r - a) / n,
          u = (r + 1 + a) / n,
          h = {
            features: []
          };
        return this._addTileFeatures(o.range((t - a) / n, l, (t + 1 + a) / n, u), o.points, t, r, n, h), 0 === t && this._addTileFeatures(o.range(1 - a / n, l, 1, u), o.points, n, r, n, h), t === n - 1 && this._addTileFeatures(o.range(0, l, a / n, u), o.points, -1, r, n, h), h.features.length ? h : null;
      }
      getClusterExpansionZoom(e) {
        let t = this._getOriginZoom(e) - 1;
        for (; t <= this.options.maxZoom;) {
          const r = this.getChildren(e);
          if (t++, 1 !== r.length) break;
          e = r[0].properties.cluster_id;
        }
        return t;
      }
      _appendLeaves(e, t, r, o, n) {
        const i = this.getChildren(t);
        for (const t of i) {
          const i = t.properties;
          if (i && i.cluster ? n + i.point_count <= o ? n += i.point_count : n = this._appendLeaves(e, i.cluster_id, r, o, n) : n < o ? n++ : e.push(t), e.length === r) break;
        }
        return n;
      }
      _addTileFeatures(e, t, r, o, n, i) {
        for (const s of e) {
          const e = t[s],
            a = e.numPoints;
          let l, u, h;
          if (a) l = V(e), u = e.x, h = e.y;else {
            const t = this.points[e.index];
            l = t.properties, u = A(t.geometry.coordinates[0]), h = D(t.geometry.coordinates[1]);
          }
          const c = {
            type: 1,
            geometry: [[Math.round(this.options.extent * (u * n - r)), Math.round(this.options.extent * (h * n - o))]],
            tags: l
          };
          let f;
          a ? f = e.id : this.options.generateId ? f = e.index : this.points[e.index].id && (f = this.points[e.index].id), void 0 !== f && (c.id = f), i.features.push(c);
        }
      }
      _limitZoom(e) {
        return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
      }
      _cluster(e, t) {
        const r = [],
          {
            radius: o,
            extent: n,
            reduce: i,
            minPoints: s
          } = this.options,
          a = o / (n * Math.pow(2, t));
        for (let o = 0; o < e.length; o++) {
          const n = e[o];
          if (n.zoom <= t) continue;
          n.zoom = t;
          const l = this.trees[t + 1],
            u = l.within(n.x, n.y, a),
            h = n.numPoints || 1;
          let c = h;
          for (const e of u) {
            const r = l.points[e];
            r.zoom > t && (c += r.numPoints || 1);
          }
          if (c > h && c >= s) {
            let e = n.x * h,
              s = n.y * h,
              a = i && h > 1 ? this._map(n, !0) : null;
            const f = (o << 5) + (t + 1) + this.points.length;
            for (const r of u) {
              const o = l.points[r];
              if (o.zoom <= t) continue;
              o.zoom = t;
              const u = o.numPoints || 1;
              e += o.x * u, s += o.y * u, o.parentId = f, i && (a || (a = this._map(n, !0)), i(a, this._map(o)));
            }
            n.parentId = f, r.push(W(e / c, s / c, f, c, a));
          } else if (r.push(n), c > 1) for (const e of u) {
            const o = l.points[e];
            o.zoom <= t || (o.zoom = t, r.push(o));
          }
        }
        return r;
      }
      _getOriginId(e) {
        return e - this.points.length >> 5;
      }
      _getOriginZoom(e) {
        return (e - this.points.length) % 32;
      }
      _map(e, t) {
        if (e.numPoints) return t ? B({}, e.properties) : e.properties;
        const r = this.points[e.index].properties,
          o = this.options.map(r);
        return t && o === r ? B({}, o) : o;
      }
    }
    function W(e, t, r, o, n) {
      return {
        x: Z(e),
        y: Z(t),
        zoom: 1 / 0,
        id: r,
        parentId: -1,
        numPoints: o,
        properties: n
      };
    }
    function Y(e, t) {
      const [r, o] = e.geometry.coordinates;
      return {
        x: Z(A(r)),
        y: Z(D(o)),
        zoom: 1 / 0,
        index: t,
        parentId: -1
      };
    }
    function X(e) {
      return {
        type: "Feature",
        id: e.id,
        properties: V(e),
        geometry: {
          type: "Point",
          coordinates: [(t = e.x, 360 * (t - .5)), $(e.y)]
        }
      };
      var t;
    }
    function V(e) {
      const t = e.numPoints,
        r = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;
      return B(B({}, e.properties), {
        cluster: !0,
        cluster_id: e.id,
        point_count: t,
        point_count_abbreviated: r
      });
    }
    function A(e) {
      return e / 360 + .5;
    }
    function D(e) {
      const t = Math.sin(e * Math.PI / 180),
        r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
      return r < 0 ? 0 : r > 1 ? 1 : r;
    }
    function $(e) {
      const t = (180 - 360 * e) * Math.PI / 180;
      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
    }
    function B(e, t) {
      for (const r in t) e[r] = t[r];
      return e;
    }
    function R(e) {
      return e.x;
    }
    function q(e) {
      return e.y;
    }
    function U(e, t, r, o) {
      for (var n, i = o, s = r - t >> 1, a = r - t, l = e[t], u = e[t + 1], h = e[r], c = e[r + 1], f = t + 3; f < r; f += 3) {
        var p = Q(e[f], e[f + 1], l, u, h, c);
        if (p > i) n = f, i = p;else if (p === i) {
          var g = Math.abs(f - s);
          g < a && (n = f, a = g);
        }
      }
      i > o && (n - t > 3 && U(e, t, n, o), e[n + 2] = i, r - n > 3 && U(e, n, r, o));
    }
    function Q(e, t, r, o, n, i) {
      var s = n - r,
        a = i - o;
      if (0 !== s || 0 !== a) {
        var l = ((e - r) * s + (t - o) * a) / (s * s + a * a);
        l > 1 ? (r = n, o = i) : l > 0 && (r += s * l, o += a * l);
      }
      return (s = e - r) * s + (a = t - o) * a;
    }
    function H(e, t, r, o) {
      var n = {
        id: void 0 === e ? null : e,
        type: t,
        geometry: r,
        tags: o,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      };
      return function (e) {
        var t = e.geometry,
          r = e.type;
        if ("Point" === r || "MultiPoint" === r || "LineString" === r) K(e, t);else if ("Polygon" === r || "MultiLineString" === r) for (var o = 0; o < t.length; o++) K(e, t[o]);else if ("MultiPolygon" === r) for (o = 0; o < t.length; o++) for (var n = 0; n < t[o].length; n++) K(e, t[o][n]);
      }(n), n;
    }
    function K(e, t) {
      for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);
    }
    function ee(e, t, r, o) {
      if (t.geometry) {
        var n = t.geometry.coordinates,
          i = t.geometry.type,
          s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),
          a = [],
          l = t.id;
        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = o || 0), "Point" === i) te(n, a);else if ("MultiPoint" === i) for (var u = 0; u < n.length; u++) te(n[u], a);else if ("LineString" === i) re(n, a, s, !1);else if ("MultiLineString" === i) {
          if (r.lineMetrics) {
            for (u = 0; u < n.length; u++) re(n[u], a = [], s, !1), e.push(H(l, "LineString", a, t.properties));
            return;
          }
          oe(n, a, s, !1);
        } else if ("Polygon" === i) oe(n, a, s, !0);else {
          if ("MultiPolygon" !== i) {
            if ("GeometryCollection" === i) {
              for (u = 0; u < t.geometry.geometries.length; u++) ee(e, {
                id: l,
                geometry: t.geometry.geometries[u],
                properties: t.properties
              }, r, o);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (u = 0; u < n.length; u++) {
            var h = [];
            oe(n[u], h, s, !0), a.push(h);
          }
        }
        e.push(H(l, i, a, t.properties));
      }
    }
    function te(e, t) {
      t.push(ne(e[0])), t.push(ie(e[1])), t.push(0);
    }
    function re(e, t, r, o) {
      for (var n, i, s = 0, a = 0; a < e.length; a++) {
        var l = ne(e[a][0]),
          u = ie(e[a][1]);
        t.push(l), t.push(u), t.push(0), a > 0 && (s += o ? (n * u - l * i) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - i, 2))), n = l, i = u;
      }
      var h = t.length - 3;
      t[2] = 1, U(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;
    }
    function oe(e, t, r, o) {
      for (var n = 0; n < e.length; n++) {
        var i = [];
        re(e[n], i, r, o), t.push(i);
      }
    }
    function ne(e) {
      return e / 360 + .5;
    }
    function ie(e) {
      var t = Math.sin(e * Math.PI / 180),
        r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
      return r < 0 ? 0 : r > 1 ? 1 : r;
    }
    function se(e, t, r, o, n, i, s, a) {
      if (o /= t, i >= (r /= t) && s < o) return e;
      if (s < r || i >= o) return null;
      for (var l = [], u = 0; u < e.length; u++) {
        var h = e[u],
          c = h.geometry,
          f = h.type,
          p = 0 === n ? h.minX : h.minY,
          g = 0 === n ? h.maxX : h.maxY;
        if (p >= r && g < o) l.push(h);else if (!(g < r || p >= o)) {
          var d = [];
          if ("Point" === f || "MultiPoint" === f) ae(c, d, r, o, n);else if ("LineString" === f) le(c, d, r, o, n, !1, a.lineMetrics);else if ("MultiLineString" === f) he(c, d, r, o, n, !1);else if ("Polygon" === f) he(c, d, r, o, n, !0);else if ("MultiPolygon" === f) for (var m = 0; m < c.length; m++) {
            var y = [];
            he(c[m], y, r, o, n, !0), y.length && d.push(y);
          }
          if (d.length) {
            if (a.lineMetrics && "LineString" === f) {
              for (m = 0; m < d.length; m++) l.push(H(h.id, f, d[m], h.tags));
              continue;
            }
            "LineString" !== f && "MultiLineString" !== f || (1 === d.length ? (f = "LineString", d = d[0]) : f = "MultiLineString"), "Point" !== f && "MultiPoint" !== f || (f = 3 === d.length ? "Point" : "MultiPoint"), l.push(H(h.id, f, d, h.tags));
          }
        }
      }
      return l.length ? l : null;
    }
    function ae(e, t, r, o, n) {
      for (var i = 0; i < e.length; i += 3) {
        var s = e[i + n];
        s >= r && s <= o && (t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2]));
      }
    }
    function le(e, t, r, o, n, i, s) {
      for (var a, l, u = ue(e), h = 0 === n ? fe : pe, c = e.start, f = 0; f < e.length - 3; f += 3) {
        var p = e[f],
          g = e[f + 1],
          d = e[f + 2],
          m = e[f + 3],
          y = e[f + 4],
          v = 0 === n ? p : g,
          x = 0 === n ? m : y,
          w = !1;
        s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : ce(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !i && w && (s && (u.end = c + a * l), t.push(u), u = ue(e)), s && (c += a);
      }
      var S = e.length - 3;
      p = e[S], g = e[S + 1], d = e[S + 2], (v = 0 === n ? p : g) >= r && v <= o && ce(u, p, g, d), S = u.length - 3, i && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && ce(u, u[0], u[1], u[2]), u.length && t.push(u);
    }
    function ue(e) {
      var t = [];
      return t.size = e.size, t.start = e.start, t.end = e.end, t;
    }
    function he(e, t, r, o, n, i) {
      for (var s = 0; s < e.length; s++) le(e[s], t, r, o, n, i, !1);
    }
    function ce(e, t, r, o) {
      e.push(t), e.push(r), e.push(o);
    }
    function fe(e, t, r, o, n, i) {
      var s = (i - t) / (o - t);
      return e.push(i), e.push(r + (n - r) * s), e.push(1), s;
    }
    function pe(e, t, r, o, n, i) {
      var s = (i - r) / (n - r);
      return e.push(t + (o - t) * s), e.push(i), e.push(1), s;
    }
    function ge(e, t) {
      for (var r = [], o = 0; o < e.length; o++) {
        var n,
          i = e[o],
          s = i.type;
        if ("Point" === s || "MultiPoint" === s || "LineString" === s) n = de(i.geometry, t);else if ("MultiLineString" === s || "Polygon" === s) {
          n = [];
          for (var a = 0; a < i.geometry.length; a++) n.push(de(i.geometry[a], t));
        } else if ("MultiPolygon" === s) for (n = [], a = 0; a < i.geometry.length; a++) {
          for (var l = [], u = 0; u < i.geometry[a].length; u++) l.push(de(i.geometry[a][u], t));
          n.push(l);
        }
        r.push(H(i.id, s, n, i.tags));
      }
      return r;
    }
    function de(e, t) {
      var r = [];
      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);
      for (var o = 0; o < e.length; o += 3) r.push(e[o] + t, e[o + 1], e[o + 2]);
      return r;
    }
    function me(e, t) {
      if (e.transformed) return e;
      var r,
        o,
        n,
        i = 1 << e.z,
        s = e.x,
        a = e.y;
      for (r = 0; r < e.features.length; r++) {
        var l = e.features[r],
          u = l.geometry,
          h = l.type;
        if (l.geometry = [], 1 === h) for (o = 0; o < u.length; o += 2) l.geometry.push(ye(u[o], u[o + 1], t, i, s, a));else for (o = 0; o < u.length; o++) {
          var c = [];
          for (n = 0; n < u[o].length; n += 2) c.push(ye(u[o][n], u[o][n + 1], t, i, s, a));
          l.geometry.push(c);
        }
      }
      return e.transformed = !0, e;
    }
    function ye(e, t, r, o, n, i) {
      return [Math.round(r * (e * o - n)), Math.round(r * (t * o - i))];
    }
    function ve(e, t, r, o, n) {
      for (var i = t === n.maxZoom ? 0 : n.tolerance / ((1 << t) * n.extent), s = {
          features: [],
          numPoints: 0,
          numSimplified: 0,
          numFeatures: 0,
          source: null,
          x: r,
          y: o,
          z: t,
          transformed: !1,
          minX: 2,
          minY: 1,
          maxX: -1,
          maxY: 0
        }, a = 0; a < e.length; a++) {
        s.numFeatures++, xe(s, e[a], i, n);
        var l = e[a].minX,
          u = e[a].minY,
          h = e[a].maxX,
          c = e[a].maxY;
        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);
      }
      return s;
    }
    function xe(e, t, r, o) {
      var n = t.geometry,
        i = t.type,
        s = [];
      if ("Point" === i || "MultiPoint" === i) for (var a = 0; a < n.length; a += 3) s.push(n[a]), s.push(n[a + 1]), e.numPoints++, e.numSimplified++;else if ("LineString" === i) we(s, n, e, r, !1, !1);else if ("MultiLineString" === i || "Polygon" === i) for (a = 0; a < n.length; a++) we(s, n[a], e, r, "Polygon" === i, 0 === a);else if ("MultiPolygon" === i) for (var l = 0; l < n.length; l++) {
        var u = n[l];
        for (a = 0; a < u.length; a++) we(s, u[a], e, r, !0, 0 === a);
      }
      if (s.length) {
        var h = t.tags || null;
        if ("LineString" === i && o.lineMetrics) {
          for (var c in h = {}, t.tags) h[c] = t.tags[c];
          h.mapbox_clip_start = n.start / n.size, h.mapbox_clip_end = n.end / n.size;
        }
        var f = {
          geometry: s,
          type: "Polygon" === i || "MultiPolygon" === i ? 3 : "LineString" === i || "MultiLineString" === i ? 2 : 1,
          tags: h
        };
        null !== t.id && (f.id = t.id), e.features.push(f);
      }
    }
    function we(e, t, r, o, n, i) {
      var s = o * o;
      if (o > 0 && t.size < (n ? s : o)) r.numPoints += t.length / 3;else {
        for (var a = [], l = 0; l < t.length; l += 3) (0 === o || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;
        n && function (e, t) {
          for (var r = 0, o = 0, n = e.length, i = n - 2; o < n; i = o, o += 2) r += (e[o] - e[i]) * (e[o + 1] + e[i + 1]);
          if (r > 0 === t) for (o = 0, n = e.length; o < n / 2; o += 2) {
            var s = e[o],
              a = e[o + 1];
            e[o] = e[n - 2 - o], e[o + 1] = e[n - 1 - o], e[n - 2 - o] = s, e[n - 1 - o] = a;
          }
        }(a, i), e.push(a);
      }
    }
    function Se(e, t) {
      var r = (t = this.options = function (e, t) {
        for (var r in t) e[r] = t[r];
        return e;
      }(Object.create(this.options), t)).debug;
      if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
      if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");
      var o = function (e, t) {
        var r = [];
        if ("FeatureCollection" === e.type) for (var o = 0; o < e.features.length; o++) ee(r, e.features[o], t, o);else ee(r, "Feature" === e.type ? e : {
          geometry: e
        }, t);
        return r;
      }(e, t);
      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o = function (e, t) {
        var r = t.buffer / t.extent,
          o = e,
          n = se(e, 1, -1 - r, r, 0, -1, 2, t),
          i = se(e, 1, 1 - r, 2 + r, 0, -1, 2, t);
        return (n || i) && (o = se(e, 1, -r, 1 + r, 0, -1, 2, t) || [], n && (o = ge(n, 1).concat(o)), i && (o = o.concat(ge(i, -1)))), o;
      }(o, t), o.length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
    }
    function Me(e, t, r) {
      return 32 * ((1 << e) * r + t) + e;
    }
    function Pe(e, t) {
      const r = e.tileID.canonical;
      if (!this._geoJSONIndex) return t(null, null);
      const o = this._geoJSONIndex.getTile(r.z, r.x, r.y);
      if (!o) return t(null, null);
      const n = new h(o.features);
      let i = c(n);
      0 === i.byteOffset && i.byteLength === i.buffer.byteLength || (i = new Uint8Array(i)), t(null, {
        vectorTile: n,
        rawData: i.buffer
      });
    }
    Se.prototype.options = {
      maxZoom: 14,
      indexMaxZoom: 5,
      indexMaxPoints: 1e5,
      tolerance: 3,
      extent: 4096,
      buffer: 64,
      lineMetrics: !1,
      promoteId: null,
      generateId: !1,
      debug: 0
    }, Se.prototype.splitTile = function (e, t, r, o, n, i, s) {
      for (var a = [e, t, r, o], l = this.options, u = l.debug; a.length;) {
        o = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();
        var h = 1 << t,
          c = Me(t, r, o),
          f = this.tiles[c];
        if (!f && (u > 1 && console.time("creation"), f = this.tiles[c] = ve(e, t, r, o, l), this.tileCoords.push({
          z: t,
          x: r,
          y: o
        }), u)) {
          u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd("creation"));
          var p = "z" + t;
          this.stats[p] = (this.stats[p] || 0) + 1, this.total++;
        }
        if (f.source = e, n) {
          if (t === l.maxZoom || t === n) continue;
          var g = 1 << n - t;
          if (r !== Math.floor(i / g) || o !== Math.floor(s / g)) continue;
        } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;
        if (f.source = null, 0 !== e.length) {
          u > 1 && console.time("clipping");
          var d,
            m,
            y,
            v,
            x,
            w,
            S = .5 * l.buffer / l.extent,
            M = .5 - S,
            P = .5 + S,
            b = 1 + S;
          d = m = y = v = null, x = se(e, h, r - S, r + P, 0, f.minX, f.maxX, l), w = se(e, h, r + M, r + b, 0, f.minX, f.maxX, l), e = null, x && (d = se(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = se(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = se(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = se(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(d || [], t + 1, 2 * r, 2 * o), a.push(m || [], t + 1, 2 * r, 2 * o + 1), a.push(y || [], t + 1, 2 * r + 1, 2 * o), a.push(v || [], t + 1, 2 * r + 1, 2 * o + 1);
        }
      }
    }, Se.prototype.getTile = function (e, t, r) {
      var o = this.options,
        n = o.extent,
        i = o.debug;
      if (e < 0 || e > 24) return null;
      var s = 1 << e,
        a = Me(e, t = (t % s + s) % s, r);
      if (this.tiles[a]) return me(this.tiles[a], n);
      i > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);
      for (var l, u = e, h = t, c = r; !l && u > 0;) u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[Me(u, h, c)];
      return l && l.source ? (i > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), i > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e, t, r), i > 1 && console.timeEnd("drilling down"), this.tiles[a] ? me(this.tiles[a], n) : null) : null;
    };
    class be extends e.VectorTileWorkerSource {
      constructor(e, t, r, o, n) {
        super(e, t, r, o, Pe), n && (this.loadGeoJSON = n);
      }
      loadData(t, r) {
        const o = t && t.request,
          n = o && o.collectResourceTiming;
        this.loadGeoJSON(t, (s, a) => {
          if (s || !a) return r(s);
          if ("object" != typeof a) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
          {
            i(a, !0);
            try {
              if (t.filter) {
                const r = e.createExpression(t.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if ("error" === r.result) throw new Error(r.value.map(e => `${e.key}: ${e.message}`).join(", "));
                const o = a.features.filter(e => r.value.evaluate({
                  zoom: 0
                }, e));
                a = {
                  type: "FeatureCollection",
                  features: o
                };
              }
              this._geoJSONIndex = t.cluster ? new J(function ({
                superclusterOptions: t,
                clusterProperties: r
              }) {
                if (!r || !t) return t;
                const o = {},
                  n = {},
                  i = {
                    accumulated: null,
                    zoom: 0
                  },
                  s = {
                    properties: null
                  },
                  a = Object.keys(r);
                for (const t of a) {
                  const [i, s] = r[t],
                    a = e.createExpression(s),
                    l = e.createExpression("string" == typeof i ? [i, ["accumulated"], ["get", t]] : i);
                  o[t] = a.value, n[t] = l.value;
                }
                return t.map = e => {
                  s.properties = e;
                  const t = {};
                  for (const e of a) t[e] = o[e].evaluate(i, s);
                  return t;
                }, t.reduce = (e, t) => {
                  s.properties = t;
                  for (const t of a) i.accumulated = e[t], e[t] = n[t].evaluate(i, s);
                }, t;
              }(t)).load(a.features) : function (e, t) {
                return new Se(e, t);
              }(a, t.geojsonVtOptions);
            } catch (s) {
              return r(s);
            }
            this.loaded = {};
            const l = {};
            if (n) {
              const r = e.getPerformanceMeasurement(o);
              r && (l.resourceTiming = {}, l.resourceTiming[t.source] = JSON.parse(JSON.stringify(r)));
            }
            r(null, l);
          }
        });
      }
      reloadTile(e, t) {
        const r = this.loaded;
        return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);
      }
      loadGeoJSON(t, r) {
        if (t.request) e.getJSON(t.request, r);else {
          if ("string" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
          try {
            return r(null, JSON.parse(t.data));
          } catch (e) {
            return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
          }
        }
      }
      getClusterExpansionZoom(e, t) {
        try {
          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
        } catch (e) {
          t(e);
        }
      }
      getClusterChildren(e, t) {
        try {
          t(null, this._geoJSONIndex.getChildren(e.clusterId));
        } catch (e) {
          t(e);
        }
      }
      getClusterLeaves(e, t) {
        try {
          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
        } catch (e) {
          t(e);
        }
      }
    }
    class ke {
      constructor(t) {
        this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({
          name: "mercator"
        }), this.workerSourceTypes = {
          vector: e.VectorTileWorkerSource,
          geojson: be
        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {
          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
          this.workerSourceTypes[e] = t;
        }, this.self.registerRTLTextPlugin = t => {
          if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
          e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;
        };
      }
      clearCaches(e, t, r) {
        delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r();
      }
      checkIfReady(e, t, r) {
        r();
      }
      setReferrer(e, t) {
        this.referrer = t;
      }
      spriteLoaded(t, r) {
        this.isSpriteLoaded[t] = r;
        for (const o in this.workerSources[t]) {
          const n = this.workerSources[t][o];
          for (const t in n) n[t] instanceof e.VectorTileWorkerSource && (n[t].isSpriteLoaded = r, n[t].fire(new e.Event("isSpriteLoaded")));
        }
      }
      setImages(e, t, r) {
        this.availableImages[e] = t;
        for (const r in this.workerSources[e]) {
          const o = this.workerSources[e][r];
          for (const e in o) o[e].availableImages = t;
        }
        r();
      }
      enableTerrain(e, t, r) {
        this.terrain = t, r();
      }
      setProjection(t, r) {
        this.projections[t] = e.getProjection(r);
      }
      setLayers(e, t, r) {
        this.getLayerIndex(e).replace(t), r();
      }
      updateLayers(e, t, r) {
        this.getLayerIndex(e).update(t.layers, t.removedIds), r();
      }
      loadTile(t, r, o) {
        const n = this.enableTerrain ? e.extend({
          enableTerrain: this.terrain
        }, r) : r;
        n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(n, o);
      }
      loadDEMTile(t, r, o) {
        const n = this.enableTerrain ? e.extend({
          buildQuadTree: this.terrain
        }, r) : r;
        this.getDEMWorkerSource(t, r.source).loadTile(n, o);
      }
      reloadTile(t, r, o) {
        const n = this.enableTerrain ? e.extend({
          enableTerrain: this.terrain
        }, r) : r;
        n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(n, o);
      }
      abortTile(e, t, r) {
        this.getWorkerSource(e, t.type, t.source).abortTile(t, r);
      }
      removeTile(e, t, r) {
        this.getWorkerSource(e, t.type, t.source).removeTile(t, r);
      }
      removeSource(e, t, r) {
        if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;
        const o = this.workerSources[e][t.type][t.source];
        delete this.workerSources[e][t.type][t.source], void 0 !== o.removeSource ? o.removeSource(t, r) : r();
      }
      loadWorkerSource(e, t, r) {
        try {
          this.self.importScripts(t.url), r();
        } catch (e) {
          r(e.toString());
        }
      }
      syncRTLPluginState(t, r, o) {
        try {
          e.plugin.setState(r);
          const t = e.plugin.getPluginURL();
          if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {
            this.self.importScripts(t);
            const r = e.plugin.isParsed();
            o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r);
          }
        } catch (e) {
          o(e.toString());
        }
      }
      getAvailableImages(e) {
        let t = this.availableImages[e];
        return t || (t = []), t;
      }
      getLayerIndex(e) {
        let t = this.layerIndexes[e];
        return t || (t = this.layerIndexes[e] = new o()), t;
      }
      getWorkerSource(e, t, r) {
        if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][r]) {
          const o = {
            send: (t, r, o, n, i, s) => {
              this.actor.send(t, r, o, e, i, s);
            },
            scheduler: this.actor.scheduler
          };
          this.workerSources[e][t][r] = new this.workerSourceTypes[t](o, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e]);
        }
        return this.workerSources[e][t][r];
      }
      getDEMWorkerSource(e, t) {
        return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n()), this.demWorkerSources[e][t];
      }
      enforceCacheSizeLimit(t, r) {
        e.enforceCacheSizeLimit(r);
      }
      getWorkerPerformanceMetrics(e, t, r) {
        r(void 0, void 0);
      }
    }
    return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new ke(self)), ke;
  });
  define(["./shared"], function (e) {
    "use strict";

    function t(e, i) {
      if (Array.isArray(e)) {
        if (!Array.isArray(i) || e.length !== i.length) return !1;
        for (let o = 0; o < e.length; o++) if (!t(e[o], i[o])) return !1;
        return !0;
      }
      if ("object" == typeof e && null !== e && null !== i) {
        if ("object" != typeof i) return !1;
        if (Object.keys(e).length !== Object.keys(i).length) return !1;
        for (const o in e) if (!t(e[o], i[o])) return !1;
        return !0;
      }
      return e === i;
    }
    var i = o;
    function o(e) {
      return !function (e) {
        return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {
          if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
          var e,
            t,
            i = new Blob([""], {
              type: "text/javascript"
            }),
            o = URL.createObjectURL(i);
          try {
            t = new Worker(o), e = !0;
          } catch (t) {
            e = !1;
          }
          return t && t.terminate(), URL.revokeObjectURL(o), e;
        }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {
          var e = document.createElement("canvas");
          e.width = e.height = 1;
          var t = e.getContext("2d");
          if (!t) return !1;
          var i = t.getImageData(0, 0, 1, 1);
          return i && i.width === e.width;
        }() ? (void 0 === r[t = e && e.failIfMajorPerformanceCaveat] && (r[t] = function (e) {
          var t,
            i = function (e) {
              var t = document.createElement("canvas"),
                i = Object.create(o.webGLContextAttributes);
              return i.failIfMajorPerformanceCaveat = e, t.getContext("webgl", i) || t.getContext("experimental-webgl", i);
            }(e);
          if (!i) return !1;
          try {
            t = i.createShader(i.VERTEX_SHADER);
          } catch (e) {
            return !1;
          }
          return !(!t || i.isContextLost()) && (i.shaderSource(t, "void main() {}"), i.compileShader(t), !0 === i.getShaderParameter(t, i.COMPILE_STATUS));
        }(t)), r[t] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
        var t;
      }(e);
    }
    var r = {};
    function n(t, i, o) {
      const r = e.window.document.createElement(t);
      return void 0 !== i && (r.className = i), o && o.appendChild(r), r;
    }
    function s(t, i, o) {
      const r = e.window.document.createElementNS("http://www.w3.org/2000/svg", t);
      for (const e of Object.keys(i)) r.setAttributeNS(null, e, i[e]);
      return o && o.appendChild(r), r;
    }
    o.webGLContextAttributes = {
      antialias: !1,
      alpha: !0,
      stencil: !0,
      depth: !0
    };
    const a = e.window.document && e.window.document.documentElement.style,
      l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
    let c;
    function h() {
      a && l && (c = a[l], a[l] = "none");
    }
    function u() {
      a && l && (a[l] = c);
    }
    function _(t) {
      t.preventDefault(), t.stopPropagation(), e.window.removeEventListener("click", _, !0);
    }
    function d() {
      e.window.addEventListener("click", _, !0), e.window.setTimeout(() => {
        e.window.removeEventListener("click", _, !0);
      }, 0);
    }
    function p(e, t) {
      const i = e.getBoundingClientRect();
      return g(e, i, t);
    }
    function m(e, t) {
      const i = e.getBoundingClientRect(),
        o = [];
      for (let r = 0; r < t.length; r++) o.push(g(e, i, t[r]));
      return o;
    }
    function f(t) {
      return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t.button;
    }
    function g(t, i, o) {
      const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;
      return new e.pointGeometry((o.clientX - i.left) * r, (o.clientY - i.top) * r);
    }
    function v(e, t) {
      var i = t[0],
        o = t[1],
        r = t[2],
        n = t[3],
        s = i * n - r * o;
      return s ? (e[0] = n * (s = 1 / s), e[1] = -o * s, e[2] = -r * s, e[3] = i * s, e) : null;
    }
    function x(e) {
      const {
        userImage: t
      } = e;
      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
    }
    class y extends e.Evented {
      constructor() {
        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({
          width: 1,
          height: 1
        }), this.dirty = !0;
      }
      isLoaded() {
        return this.loaded;
      }
      setLoaded(e) {
        if (this.loaded !== e && (this.loaded = e, e)) {
          for (const {
            ids: e,
            callback: t
          } of this.requestors) this._notify(e, t);
          this.requestors = [];
        }
      }
      hasImage(e) {
        return !!this.getImage(e);
      }
      getImage(e) {
        return this.images[e];
      }
      addImage(e, t) {
        this._validate(e, t) && (this.images[e] = t);
      }
      _validate(t, i) {
        let o = !0;
        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))), o = !1), o;
      }
      _validateStretch(e, t) {
        if (!e) return !0;
        let i = 0;
        for (const o of e) {
          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;
          i = o[1];
        }
        return !0;
      }
      _validateContent(e, t) {
        return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));
      }
      updateImage(e, t) {
        t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0;
      }
      removeImage(e) {
        const t = this.images[e];
        delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
      }
      listImages() {
        return Object.keys(this.images);
      }
      getImages(e, t) {
        let i = !0;
        if (!this.isLoaded()) for (const t of e) this.images[t] || (i = !1);
        this.isLoaded() || i ? this._notify(e, t) : this.requestors.push({
          ids: e,
          callback: t
        });
      }
      _notify(t, i) {
        const o = {};
        for (const i of t) {
          this.images[i] || this.fire(new e.Event("styleimagemissing", {
            id: i
          }));
          const t = this.images[i];
          t ? o[i] = {
            data: t.data.clone(),
            pixelRatio: t.pixelRatio,
            sdf: t.sdf,
            version: t.version,
            stretchX: t.stretchX,
            stretchY: t.stretchY,
            content: t.content,
            hasRenderCallback: Boolean(t.userImage && t.userImage.render)
          } : e.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
        }
        i(null, o);
      }
      getPixelSize() {
        const {
          width: e,
          height: t
        } = this.atlasImage;
        return {
          width: e,
          height: t
        };
      }
      getPattern(t) {
        const i = this.patterns[t],
          o = this.getImage(t);
        if (!o) return null;
        if (i && i.position.version === o.version) return i.position;
        if (i) i.position.version = o.version;else {
          const i = {
              w: o.data.width + 2,
              h: o.data.height + 2,
              x: 0,
              y: 0
            },
            r = new e.ImagePosition(i, o);
          this.patterns[t] = {
            bin: i,
            position: r
          };
        }
        return this._updatePatternAtlas(), this.patterns[t].position;
      }
      bind(t) {
        const i = t.gl;
        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
      }
      _updatePatternAtlas() {
        const t = [];
        for (const e in this.patterns) t.push(this.patterns[e].bin);
        const {
            w: i,
            h: o
          } = e.potpack(t),
          r = this.atlasImage;
        r.resize({
          width: i || 1,
          height: o || 1
        });
        for (const t in this.patterns) {
          const {
              bin: i
            } = this.patterns[t],
            o = i.x + 1,
            n = i.y + 1,
            s = this.images[t].data,
            a = s.width,
            l = s.height;
          e.RGBAImage.copy(s, r, {
            x: 0,
            y: 0
          }, {
            x: o,
            y: n
          }, {
            width: a,
            height: l
          }), e.RGBAImage.copy(s, r, {
            x: 0,
            y: l - 1
          }, {
            x: o,
            y: n - 1
          }, {
            width: a,
            height: 1
          }), e.RGBAImage.copy(s, r, {
            x: 0,
            y: 0
          }, {
            x: o,
            y: n + l
          }, {
            width: a,
            height: 1
          }), e.RGBAImage.copy(s, r, {
            x: a - 1,
            y: 0
          }, {
            x: o - 1,
            y: n
          }, {
            width: 1,
            height: l
          }), e.RGBAImage.copy(s, r, {
            x: 0,
            y: 0
          }, {
            x: o + a,
            y: n
          }, {
            width: 1,
            height: l
          });
        }
        this.dirty = !0;
      }
      beginFrame() {
        this.callbackDispatchedThisFrame = {};
      }
      dispatchRenderCallbacks(e) {
        for (const t of e) {
          if (this.callbackDispatchedThisFrame[t]) continue;
          this.callbackDispatchedThisFrame[t] = !0;
          const e = this.images[t];
          x(e) && this.updateImage(t, e);
        }
      }
    }
    const b = new e.Properties({
        anchor: new e.DataConstantProperty(e.spec.light.anchor),
        position: new class {
          constructor() {
            this.specification = e.spec.light.position;
          }
          possiblyEvaluate(t, i) {
            return function ([t, i, o]) {
              const r = e.degToRad(i + 90),
                n = e.degToRad(o);
              return {
                x: t * Math.cos(r) * Math.sin(n),
                y: t * Math.sin(r) * Math.sin(n),
                z: t * Math.cos(n),
                azimuthal: i,
                polar: o
              };
            }(t.expression.evaluate(i));
          }
          interpolate(t, i, o) {
            return {
              x: e.number(t.x, i.x, o),
              y: e.number(t.y, i.y, o),
              z: e.number(t.z, i.z, o),
              azimuthal: e.number(t.azimuthal, i.azimuthal, o),
              polar: e.number(t.polar, i.polar, o)
            };
          }
        }(),
        color: new e.DataConstantProperty(e.spec.light.color),
        intensity: new e.DataConstantProperty(e.spec.light.intensity)
      }),
      w = "-transition";
    class T extends e.Evented {
      constructor(t) {
        super(), this._transitionable = new e.Transitionable(b), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
      }
      getLight() {
        return this._transitionable.serialize();
      }
      setLight(t, i = {}) {
        if (!this._validate(e.validateLight, t, i)) for (const i in t) {
          const o = t[i];
          e.endsWith(i, w) ? this._transitionable.setTransition(i.slice(0, -w.length), o) : this._transitionable.setValue(i, o);
        }
      }
      updateTransitions(e) {
        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
      }
      hasTransition() {
        return this._transitioning.hasTransition();
      }
      recalculate(e) {
        this.properties = this._transitioning.possiblyEvaluate(e);
      }
      _validate(t, i, o) {
        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({
          value: i,
          style: {
            glyphs: !0,
            sprite: !0
          },
          styleSpec: e.spec
        })));
      }
    }
    const E = new e.Properties({
        source: new e.DataConstantProperty(e.spec.terrain.source),
        exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration)
      }),
      C = "-transition";
    class M extends e.Evented {
      constructor(t, i) {
        super(), this._transitionable = new e.Transitionable(E), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
      }
      get() {
        return this._transitionable.serialize();
      }
      set(t) {
        for (const i in t) {
          const o = t[i];
          e.endsWith(i, C) ? this._transitionable.setTransition(i.slice(0, -C.length), o) : this._transitionable.setValue(i, o);
        }
      }
      updateTransitions(e) {
        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
      }
      hasTransition() {
        return this._transitioning.hasTransition();
      }
      recalculate(e) {
        this.properties = this._transitioning.possiblyEvaluate(e);
      }
    }
    function I(t, i, o, r) {
      const n = e.smoothstep(45, 65, o),
        [s, a] = S(t, r),
        l = e.length(i);
      let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));
      return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t.alpha;
    }
    function S(e, t) {
      const i = .5 / Math.tan(.5 * t);
      return [e.range[0] + i, e.range[1] + i];
    }
    const D = new e.Properties({
        range: new e.DataConstantProperty(e.spec.fog.range),
        color: new e.DataConstantProperty(e.spec.fog.color),
        "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]),
        "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]),
        "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]),
        "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"])
      }),
      L = "-transition";
    class A extends e.Evented {
      constructor(t, i) {
        super(), this._transitionable = new e.Transitionable(D), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = i;
      }
      get state() {
        const t = this._transform,
          i = "globe" === t.projection.name,
          o = e.globeToMercatorTransition(t.zoom),
          r = this.properties.get("range"),
          n = [.5, 3];
        return {
          range: i ? [e.number(n[0], r[0], o), e.number(n[1], r[1], o)] : r,
          horizonBlend: this.properties.get("horizon-blend"),
          alpha: this.properties.get("color").a
        };
      }
      get() {
        return this._transitionable.serialize();
      }
      set(t, i = {}) {
        if (!this._validate(e.validateFog, t, i)) {
          for (const i of Object.keys(e.spec.fog)) t && void 0 === t[i] && (t[i] = e.spec.fog[i].default);
          for (const i in t) {
            const o = t[i];
            e.endsWith(i, L) ? this._transitionable.setTransition(i.slice(0, -L.length), o) : this._transitionable.setValue(i, o);
          }
        }
      }
      getOpacity(t) {
        if (!this._transform.projection.supportsFog) return 0;
        const i = this.properties && this.properties.get("color") || 1;
        return ("globe" === this._transform.projection.name ? 1 : e.smoothstep(45, 65, t)) * i.a;
      }
      getOpacityAtLatLng(t, i) {
        return this._transform.projection.supportsFog ? function (t, i, o) {
          const r = e.MercatorCoordinate.fromLngLat(i),
            n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0,
            s = [r.x, r.y, n];
          return e.transformMat4(s, s, o.mercatorFogMatrix), I(t, s, o.pitch, o._fov);
        }(this.state, t, i) : 0;
      }
      getFovAdjustedRange(e) {
        return this._transform.projection.supportsFog ? S(this.state, e) : [0, 1];
      }
      updateTransitions(e) {
        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
      }
      hasTransition() {
        return this._transitioning.hasTransition();
      }
      recalculate(e) {
        this.properties = this._transitioning.possiblyEvaluate(e);
      }
      _validate(t, i, o) {
        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({
          value: i,
          style: {
            glyphs: !0,
            sprite: !0
          },
          styleSpec: e.spec
        })));
      }
    }
    class z {
      constructor(t, i) {
        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
        const o = this.workerPool.acquire(this.id);
        for (let e = 0; e < o.length; e++) {
          const t = new z.Actor(o[e], i, this.id);
          t.name = `Worker ${e}`, this.actors.push(t);
        }
        this.ready = !1, this.broadcast("checkIfReady", null, () => {
          this.ready = !0;
        });
      }
      broadcast(t, i, o) {
        e.asyncAll(this.actors, (e, o) => {
          e.send(t, i, o);
        }, o = o || function () {});
      }
      getActor() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }
      remove() {
        this.actors.forEach(e => {
          e.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }
    }
    function P(t, i, o) {
      return i * (e.EXTENT / (t.tileSize * Math.pow(2, o - t.tileID.overscaledZ)));
    }
    z.Actor = e.Actor;
    class R {
      constructor(e, t, i, o) {
        this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);
      }
      static createFromScreenPoints(t, i) {
        let o, r;
        if (t instanceof e.pointGeometry || "number" == typeof t[0]) {
          const n = e.pointGeometry.convert(t);
          o = [n], r = i.isPointAboveHorizon(n);
        } else {
          const n = e.pointGeometry.convert(t[0]),
            s = e.pointGeometry.convert(t[1]);
          o = [n, s], r = e.polygonizeBounds(n, s).every(e => i.isPointAboveHorizon(e));
        }
        return new R(o, i.getCameraPoint(), r, i);
      }
      isPointQuery() {
        return 1 === this.screenBounds.length;
      }
      bufferedScreenGeometry(t) {
        return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);
      }
      bufferedCameraGeometry(t) {
        const i = this.screenBounds[0],
          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],
          r = e.polygonizeBounds(i, o, 0, !1);
        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t);
      }
      bufferedCameraGeometryGlobe(t) {
        const i = this.screenBounds[0],
          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],
          r = e.polygonizeBounds(i, o, t),
          n = this.cameraPoint.clone();
        switch (3 * ((n.y > i.y) + (n.y > o.y)) + ((n.x > i.x) + (n.x > o.x))) {
          case 0:
            r[0] = n, r[4] = n.clone();
            break;
          case 1:
            r.splice(1, 0, n);
            break;
          case 2:
            r[1] = n;
            break;
          case 3:
            r.splice(4, 0, n);
            break;
          case 5:
            r.splice(2, 0, n);
            break;
          case 6:
            r[3] = n;
            break;
          case 7:
            r.splice(3, 0, n);
            break;
          case 8:
            r[2] = n;
        }
        return r;
      }
      containsTile(t, i, o, r = 0) {
        const n = t.queryPadding / i._pixelsPerMercatorPixel + 1,
          s = o ? this._bufferedCameraMercator(n, i) : this._bufferedScreenMercator(n, i);
        let a = t.tileID.wrap + (s.unwrapped ? r : 0);
        const l = s.polygon.map(i => e.getTilePoint(t.tileTransform, i, a));
        if (!e.polygonIntersectsBox(l, 0, 0, e.EXTENT, e.EXTENT)) return;
        a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
        const c = this.screenGeometryMercator.polygon.map(i => e.getTileVec3(t.tileTransform, i, a)),
          h = c.map(t => new e.pointGeometry(t[0], t[1])),
          u = i.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0),
          _ = e.getTileVec3(t.tileTransform, u, a),
          d = c.map(t => {
            const i = e.sub(t, t, _);
            return e.normalize(i, i), new e.Ray(_, i);
          }),
          p = P(t, 1, i.zoom) * i._pixelsPerMercatorPixel;
        return {
          queryGeometry: this,
          tilespaceGeometry: h,
          tilespaceRays: d,
          bufferedTilespaceGeometry: l,
          bufferedTilespaceBounds: (m = e.getBounds(l), m.min.x = e.clamp(m.min.x, 0, e.EXTENT), m.min.y = e.clamp(m.min.y, 0, e.EXTENT), m.max.x = e.clamp(m.max.x, 0, e.EXTENT), m.max.y = e.clamp(m.max.y, 0, e.EXTENT), m),
          tile: t,
          tileID: t.tileID,
          pixelToTileUnitsFactor: p
        };
        var m;
      }
      _bufferedScreenMercator(e, t) {
        const i = k(e);
        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
        {
          let o;
          return o = "globe" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : {
            polygon: this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e)),
            unwrapped: !0
          }, this._screenRaycastCache[i] = o, o;
        }
      }
      _bufferedCameraMercator(e, t) {
        const i = k(e);
        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
        {
          let o;
          return o = "globe" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : {
            polygon: this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e)),
            unwrapped: !0
          }, this._cameraRaycastCache[i] = o, o;
        }
      }
      _projectAndResample(t, i) {
        const o = function (t, i) {
          const o = e.multiply([], i.pixelMatrix, i.globeMatrix),
            r = [0, -e.GLOBE_RADIUS, 0, 1],
            n = [0, e.GLOBE_RADIUS, 0, 1],
            s = [0, 0, 0, 1];
          e.transformMat4$1(r, r, o), e.transformMat4$1(n, n, o), e.transformMat4$1(s, s, o);
          const a = new e.pointGeometry(r[0] / r[3], r[1] / r[3]),
            l = new e.pointGeometry(n[0] / n[3], n[1] / n[3]),
            c = e.polygonContainsPoint(t, a) && r[3] < s[3],
            h = e.polygonContainsPoint(t, l) && n[3] < s[3];
          if (!c && !h) return null;
          const u = function (e, t, i) {
            for (let o = 1; o < e.length; o++) {
              const r = B(t.pointCoordinate3D(e[o - 1]).x),
                n = B(t.pointCoordinate3D(e[o]).x);
              if (i < 0) {
                if (r < n) return {
                  idx: o,
                  t: -r / (n - 1 - r)
                };
              } else if (n < r) return {
                idx: o,
                t: (1 - r) / (n + 1 - r)
              };
            }
            return null;
          }(t, i, c ? -1 : 1);
          if (!u) return null;
          const {
            idx: _,
            t: d
          } = u;
          let p = _ > 1 ? O(t.slice(0, _), i) : [],
            m = _ < t.length ? O(t.slice(_), i) : [];
          p = p.map(t => new e.pointGeometry(B(t.x), t.y)), m = m.map(t => new e.pointGeometry(B(t.x), t.y));
          const f = [...p];
          0 === f.length && f.push(m[m.length - 1]);
          const g = e.number(f[f.length - 1].y, (0 === m.length ? p[0] : m[0]).y, d);
          let v;
          return v = c ? [new e.pointGeometry(0, g), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, g)] : [new e.pointGeometry(1, g), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, g)], f.push(...v), 0 === m.length ? f.push(p[0]) : f.push(...m), {
            polygon: f.map(t => new e.MercatorCoordinate(t.x, t.y)),
            unwrapped: !1
          };
        }(t, i);
        if (o) return o;
        const r = function (t, i) {
          let o = !1,
            r = -1 / 0,
            n = 0;
          for (let e = 0; e < t.length - 1; e++) t[e].x > r && (r = t[e].x, n = e);
          for (let e = 0; e < t.length - 1; e++) {
            const i = (n + e) % (t.length - 1),
              r = t[i],
              s = t[i + 1];
            Math.abs(r.x - s.x) > .5 && (r.x < s.x ? (r.x += 1, 0 === i && (t[t.length - 1].x += 1)) : (s.x += 1, i + 1 === t.length - 1 && (t[0].x += 1)), o = !0);
          }
          const s = e.mercatorXfromLng(i.center.lng);
          return o && s < Math.abs(s - 1) && t.forEach(e => {
            e.x -= 1;
          }), {
            polygon: t,
            unwrapped: o
          };
        }(O(t, i).map(t => new e.pointGeometry(B(t.x), t.y)), i);
        return {
          polygon: r.polygon.map(t => new e.MercatorCoordinate(t.x, t.y)),
          unwrapped: r.unwrapped
        };
      }
    }
    function O(t, i) {
      return e.resample(t, e => {
        const t = i.pointCoordinate3D(e);
        e.x = t.x, e.y = t.y;
      }, 1 / 256);
    }
    function B(e) {
      return e < 0 ? 1 + e % 1 : e % 1;
    }
    function k(e) {
      return 100 * e | 0;
    }
    function F(t, i, o, r, n) {
      const s = function (o, r) {
        if (o) return n(o);
        if (r) {
          t.url && r.tiles && t.tiles && delete t.tiles;
          const o = e.pick(e.extend(r, t), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
          r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map(e => e.id)), o.tiles = i.canonicalizeTileset(o, t.url), n(null, o);
        }
      };
      return t.url ? e.getJSON(i.transformRequest(i.normalizeSourceURL(t.url, null, o, r), e.ResourceType.Source), s) : e.exported.frame(() => s(null, t));
    }
    class U {
      constructor(t, i, o) {
        this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;
      }
      validateBounds(e) {
        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
      }
      contains(t) {
        const i = Math.pow(2, t.z),
          o = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i),
          r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i),
          n = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i),
          s = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i);
        return t.x >= o && t.x < n && t.y >= r && t.y < s;
      }
    }
    class N {
      constructor(e, t, i) {
        this.context = e;
        const o = e.gl;
        this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t.destroy();
      }
      bind() {
        this.context.bindElementBuffer.set(this.buffer);
      }
      updateData(e) {
        const t = this.context.gl;
        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
      }
      destroy() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      }
    }
    const G = {
      Int8: "BYTE",
      Uint8: "UNSIGNED_BYTE",
      Int16: "SHORT",
      Uint16: "UNSIGNED_SHORT",
      Int32: "INT",
      Uint32: "UNSIGNED_INT",
      Float32: "FLOAT"
    };
    class j {
      constructor(e, t, i, o) {
        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.context = e;
        const r = e.gl;
        this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t.destroy();
      }
      bind() {
        this.context.bindVertexBuffer.set(this.buffer);
      }
      updateData(e) {
        const t = this.context.gl;
        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
      }
      enableAttributes(e, t) {
        for (let i = 0; i < this.attributes.length; i++) {
          const o = t.attributes[this.attributes[i].name];
          void 0 !== o && e.enableVertexAttribArray(o);
        }
      }
      setVertexAttribPointers(e, t, i) {
        for (let o = 0; o < this.attributes.length; o++) {
          const r = this.attributes[o],
            n = t.attributes[r.name];
          void 0 !== n && e.vertexAttribPointer(n, r.components, e[G[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
        }
      }
      destroy() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      }
    }
    class Z {
      constructor(e) {
        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
      }
      get() {
        return this.current;
      }
      set(e) {}
      getDefault() {
        return this.default;
      }
      setDefault() {
        this.set(this.default);
      }
    }
    class V extends Z {
      getDefault() {
        return e.Color.transparent;
      }
      set(e) {
        const t = this.current;
        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
      }
    }
    class W extends Z {
      getDefault() {
        return 1;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
      }
    }
    class X extends Z {
      getDefault() {
        return 0;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
      }
    }
    class q extends Z {
      getDefault() {
        return [!0, !0, !0, !0];
      }
      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
      }
    }
    class $ extends Z {
      getDefault() {
        return !0;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
      }
    }
    class H extends Z {
      getDefault() {
        return 255;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
      }
    }
    class Y extends Z {
      getDefault() {
        return {
          func: this.gl.ALWAYS,
          ref: 0,
          mask: 255
        };
      }
      set(e) {
        const t = this.current;
        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
      }
    }
    class K extends Z {
      getDefault() {
        const e = this.gl;
        return [e.KEEP, e.KEEP, e.KEEP];
      }
      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
      }
    }
    class J extends Z {
      getDefault() {
        return !1;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;
      }
    }
    class Q extends Z {
      getDefault() {
        return [0, 1];
      }
      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
      }
    }
    class ee extends Z {
      getDefault() {
        return !1;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;
      }
    }
    class te extends Z {
      getDefault() {
        return this.gl.LESS;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
      }
    }
    class ie extends Z {
      getDefault() {
        return !1;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;
      }
    }
    class oe extends Z {
      getDefault() {
        const e = this.gl;
        return [e.ONE, e.ZERO];
      }
      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
      }
    }
    class re extends Z {
      getDefault() {
        return e.Color.transparent;
      }
      set(e) {
        const t = this.current;
        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
      }
    }
    class ne extends Z {
      getDefault() {
        return this.gl.FUNC_ADD;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
      }
    }
    class se extends Z {
      getDefault() {
        return !1;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;
      }
    }
    class ae extends Z {
      getDefault() {
        return this.gl.BACK;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
      }
    }
    class le extends Z {
      getDefault() {
        return this.gl.CCW;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
      }
    }
    class ce extends Z {
      getDefault() {
        return null;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
      }
    }
    class he extends Z {
      getDefault() {
        return this.gl.TEXTURE0;
      }
      set(e) {
        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
      }
    }
    class ue extends Z {
      getDefault() {
        const e = this.gl;
        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
      }
      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
      }
    }
    class _e extends Z {
      getDefault() {
        return null;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
      }
    }
    class de extends Z {
      getDefault() {
        return null;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
      }
    }
    class pe extends Z {
      getDefault() {
        return null;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;
      }
    }
    class me extends Z {
      getDefault() {
        return null;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
      }
    }
    class fe extends Z {
      getDefault() {
        return null;
      }
      set(e) {
        const t = this.gl;
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
      }
    }
    class ge extends Z {
      constructor(e) {
        super(e), this.vao = e.extVertexArrayObject;
      }
      getDefault() {
        return null;
      }
      set(e) {
        this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1);
      }
    }
    class ve extends Z {
      getDefault() {
        return 4;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
      }
    }
    class xe extends Z {
      getDefault() {
        return !1;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
      }
    }
    class ye extends Z {
      getDefault() {
        return !1;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
      }
    }
    class be extends Z {
      constructor(e, t) {
        super(e), this.context = e, this.parent = t;
      }
      getDefault() {
        return null;
      }
    }
    class we extends be {
      setDirty() {
        this.dirty = !0;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        this.context.bindFramebuffer.set(this.parent);
        const t = this.gl;
        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
      }
    }
    class Te extends be {
      attachment() {
        return this.gl.DEPTH_ATTACHMENT;
      }
      set(e) {
        if (e === this.current && !this.dirty) return;
        this.context.bindFramebuffer.set(this.parent);
        const t = this.gl;
        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
      }
    }
    class Ee extends Te {
      attachment() {
        return this.gl.DEPTH_STENCIL_ATTACHMENT;
      }
    }
    class Ce {
      constructor(e, t, i, o) {
        this.context = e, this.width = t, this.height = i;
        const r = this.framebuffer = e.gl.createFramebuffer();
        this.colorAttachment = new we(e, r), o && (this.depthAttachment = new Te(e, r));
      }
      destroy() {
        const e = this.context.gl,
          t = this.colorAttachment.get();
        if (t && e.deleteTexture(t), this.depthAttachment) {
          const t = this.depthAttachment.get();
          t && e.deleteRenderbuffer(t);
        }
        e.deleteFramebuffer(this.framebuffer);
      }
    }
    class Me {
      constructor(e, t = !1) {
        if (this.gl = e, this.isWebGL2 = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t) {
          const t = e;
          this.extVertexArrayObject = {
            createVertexArrayOES: t.createVertexArray.bind(e),
            deleteVertexArrayOES: t.deleteVertexArray.bind(e),
            bindVertexArrayOES: t.bindVertexArray.bind(e)
          };
        }
        this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t || (this.extTextureHalfFloat = e.getExtension("OES_texture_half_float")), (t || this.extTextureHalfFloat && e.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t || e.getExtension("OES_standard_derivatives"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE);
      }
      setDefault() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }
      setDirty() {
        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
      }
      createIndexBuffer(e, t) {
        return new N(this, e, t);
      }
      createVertexBuffer(e, t, i) {
        return new j(this, e, t, i);
      }
      createRenderbuffer(e, t, i) {
        const o = this.gl,
          r = o.createRenderbuffer();
        return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r;
      }
      createFramebuffer(e, t, i) {
        return new Ce(this, e, t, i);
      }
      clear({
        color: e,
        depth: t,
        stencil: i
      }) {
        const o = this.gl;
        let r = 0;
        e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);
      }
      setCullFace(e) {
        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
      }
      setDepthMode(e) {
        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
      }
      setStencilMode(e) {
        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
          func: e.test.func,
          ref: e.ref,
          mask: e.test.mask
        })) : this.stencilTest.set(!1);
      }
      setColorMode(i) {
        t(i.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor)), this.colorMask.set(i.mask);
      }
      unbindVAO() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      }
    }
    class Ie extends e.Evented {
      constructor(t, i, o, r) {
        if (super(), this.id = t, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({
          type: "vector"
        }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
        this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
      }
      load(t) {
        this._loaded = !1, this.fire(new e.Event("dataloading", {
          dataType: "source"
        }));
        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,
          o = this.map._worldview;
        this._tileJSONRequest = F(this._options, this.map._requestManager, i, o, (r, n) => {
          this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.ErrorEvent(r))) : n && (e.extend(this, n), n.bounds && (this.tileBounds = new U(n.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "metadata"
          })), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "content"
          }))), t && t(r);
        });
      }
      loaded() {
        return this._loaded;
      }
      hasTile(e) {
        return !this.tileBounds || this.tileBounds.contains(e.canonical);
      }
      onAdd(e) {
        this.map = e, this.load();
      }
      reload() {
        this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
      }
      setTiles(e) {
        return this._options.tiles = e, this.reload(), this;
      }
      setUrl(e) {
        return this.url = e, this._options.url = e, this.reload(), this;
      }
      onRemove() {
        this.cancelTileJSONRequest();
      }
      serialize() {
        return e.extend({}, this._options);
      }
      loadTile(t, i) {
        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),
          r = {
            request: this.map._requestManager.transformRequest(o, e.ResourceType.Tile),
            data: void 0,
            uid: t.uid,
            tileID: t.tileID,
            tileZoom: t.tileZoom,
            zoom: t.tileID.overscaledZ,
            tileSize: this.tileSize * t.tileID.overscaleFactor(),
            type: this.type,
            source: this.id,
            pixelRatio: e.exported.devicePixelRatio,
            showCollisionBoxes: this.map.showCollisionBoxes,
            promoteId: this.promoteId,
            isSymbolTile: t.isSymbolTile
          };
        if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && "expired" !== t.state) "loading" === t.state ? t.reloadCallback = i : t.request = t.actor.send("reloadTile", r, n.bind(this));else if (t.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", r, n.bind(this), void 0, !0);else {
          const i = e.loadVectorTile.call({
            deduped: this._deduped
          }, r, (e, i) => {
            e || !i ? n.call(this, e) : (r.data = {
              cacheControl: i.cacheControl,
              expires: i.expires,
              rawData: i.rawData.slice(0)
            }, t.actor && t.actor.send("loadTile", r, n.bind(this), void 0, !0));
          }, !0);
          t.request = {
            cancel: i
          };
        }
        function n(o, r) {
          return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
        }
      }
      abortTile(e) {
        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
          uid: e.uid,
          type: this.type,
          source: this.id
        });
      }
      unloadTile(e) {
        e.unloadVectorData(), e.actor && e.actor.send("removeTile", {
          uid: e.uid,
          type: this.type,
          source: this.id
        });
      }
      hasTransition() {
        return !1;
      }
      afterUpdate() {
        this._tileWorkers = {};
      }
      cancelTileJSONRequest() {
        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
      }
    }
    class Se extends e.Evented {
      constructor(t, i, o, r) {
        super(), this.id = t, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.extend({
          type: "raster"
        }, i), e.extend(this, e.pick(i, ["url", "scheme", "tileSize"]));
      }
      load(t) {
        this._loaded = !1, this.fire(new e.Event("dataloading", {
          dataType: "source"
        })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (i, o) => {
          this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.ErrorEvent(i)) : o && (e.extend(this, o), o.bounds && (this.tileBounds = new U(o.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o.tiles), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "metadata"
          })), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "content"
          }))), t && t(i);
        });
      }
      loaded() {
        return this._loaded;
      }
      onAdd(e) {
        this.map = e, this.load();
      }
      reload() {
        this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
      }
      setTiles(e) {
        return this._options.tiles = e, this.reload(), this;
      }
      setUrl(e) {
        return this.url = e, this._options.url = e, this.reload(), this;
      }
      onRemove() {
        this.cancelTileJSONRequest();
      }
      serialize() {
        return e.extend({}, this._options);
      }
      hasTile(e) {
        return !this.tileBounds || this.tileBounds.contains(e.canonical);
      }
      loadTile(t, i) {
        const o = e.exported.devicePixelRatio >= 2,
          r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
        t.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (o, r, n, s) => (delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : o ? (t.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t.setExpiryData({
          cacheControl: n,
          expires: s
        }), t.setTexture(r, this.map.painter), t.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));
      }
      static loadTileData(e, t, i) {
        e.setTexture(t, i);
      }
      static unloadTileData(e, t) {
        e.texture && t.saveTileTexture(e.texture);
      }
      abortTile(e, t) {
        e.request && (e.request.cancel(), delete e.request), t();
      }
      unloadTile(e, t) {
        e.texture && this.map.painter.saveTileTexture(e.texture), t();
      }
      hasTransition() {
        return !1;
      }
      cancelTileJSONRequest() {
        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
      }
    }
    let De;
    function Le(t, i, o, r, n, s, a, l) {
      const c = [t, o, n, i, r, s, 1, 1, 1],
        h = [a, l, 1],
        u = e.adjoint([], c),
        [_, d, p] = e.transformMat3(h, h, e.transpose(u, u));
      return e.multiply$1(c, [_, 0, 0, 0, d, 0, 0, 0, p], c);
    }
    class Ae extends e.Evented {
      constructor(e, t, i, o) {
        super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t, this._dirty = !1;
      }
      load(t, i) {
        this._loaded = i || !1, this.fire(new e.Event("dataloading", {
          dataType: "source"
        })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i, o) => {
          if (this._imageRequest = null, this._loaded = !0, i) this.fire(new e.ErrorEvent(i));else if (o) {
            const {
              HTMLImageElement: i
            } = e.window;
            this.image = o instanceof i ? e.exported.getImageData(o) : o, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading();
          }
        });
      }
      loaded() {
        return this._loaded;
      }
      updateImage(e) {
        return this.image && e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
      }
      _finishLoading() {
        this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", {
          dataType: "source",
          sourceDataType: "metadata"
        })));
      }
      onAdd(e) {
        this.map = e, this.load();
      }
      onRemove() {
        this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
      }
      setCoordinates(t) {
        this.coordinates = t, this._boundsArray = void 0;
        const i = t.map(e.MercatorCoordinate.fromLngLat);
        return this.tileID = function (t) {
          let i = 1 / 0,
            o = 1 / 0,
            r = -1 / 0,
            n = -1 / 0;
          for (const e of t) i = Math.min(i, e.x), o = Math.min(o, e.y), r = Math.max(r, e.x), n = Math.max(n, e.y);
          const s = Math.max(r - i, n - o),
            a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)),
            l = Math.pow(2, a);
          return new e.CanonicalTileID(a, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));
        }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", {
          dataType: "source",
          sourceDataType: "content"
        })), this;
      }
      _clear() {
        this._boundsArray = void 0;
      }
      _prepareData(t) {
        for (const e in this.tiles) {
          const t = this.tiles[e];
          "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture);
        }
        if (this._boundsArray) return;
        const i = e.tileTransform(this.tileID, this.map.transform.projection),
          [o, r, n, s] = this.coordinates.map(t => {
            const o = i.projection.project(t[0], t[1]);
            return e.getTilePoint(i, o)._round();
          });
        this.perspectiveTransform = function (t, i, o, r, n, s, a, l, c, h) {
          const u = Le(0, 0, t, 0, 0, i, t, i),
            _ = Le(o, r, n, s, a, l, c, h);
          return e.multiply$1(_, e.adjoint(u, u), _), [_[6] / _[8] * t / e.EXTENT, _[7] / _[8] * i / e.EXTENT];
        }(this.width, this.height, o.x, o.y, r.x, r.y, s.x, s.y, n.x, n.y);
        const a = this._boundsArray = new e.StructArrayLayout4i8();
        a.emplaceBack(o.x, o.y, 0, 0), a.emplaceBack(r.x, r.y, e.EXTENT, 0), a.emplaceBack(s.x, s.y, 0, e.EXTENT), a.emplaceBack(n.x, n.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(a, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
      }
      prepare() {
        if (0 === Object.keys(this.tiles).length || !this.image) return;
        const t = this.map.painter.context,
          i = t.gl;
        this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t);
      }
      loadTile(e, t) {
        this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = "errored", t(null));
      }
      serialize() {
        return {
          type: "image",
          url: this.options.url,
          coordinates: this.coordinates
        };
      }
      hasTransition() {
        return !1;
      }
    }
    const ze = {
        vector: Ie,
        raster: Se,
        "raster-dem": class extends Se {
          constructor(t, i, o, r) {
            super(t, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({
              type: "raster-dem"
            }, i), this.encoding = i.encoding || "mapbox";
          }
          loadTile(t, i) {
            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
            function r(e, o) {
              e && (t.state = "errored", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = "loaded", i(null));
            }
            t.request = e.getImage(this.map._requestManager.transformRequest(o, e.ResourceType.Tile), function (o, n, s, a) {
              if (delete t.request, t.aborted) t.state = "unloaded", i(null);else if (o) t.state = "errored", i(o);else if (n) {
                this.map._refreshExpiredTiles && t.setExpiryData({
                  cacheControl: s,
                  expires: a
                });
                const i = e.window.ImageBitmap && n instanceof e.window.ImageBitmap && (null == De && (De = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), De),
                  o = 1 - (n.width - e.prevPowerOfTwo(n.width)) / 2;
                o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));
                const l = i ? n : e.exported.getImageData(n, o),
                  c = {
                    uid: t.uid,
                    coord: t.tileID,
                    source: this.id,
                    rawImageData: l,
                    encoding: this.encoding,
                    padding: o
                  };
                t.actor && "expired" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send("loadDEMTile", c, r.bind(this), void 0, !0));
              }
            }.bind(this));
          }
          _getNeighboringTiles(t) {
            const i = t.canonical,
              o = Math.pow(2, i.z),
              r = (i.x - 1 + o) % o,
              n = 0 === i.x ? t.wrap - 1 : t.wrap,
              s = (i.x + 1 + o) % o,
              a = i.x + 1 === o ? t.wrap + 1 : t.wrap,
              l = {};
            return l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y).key] = {
              backfilled: !1
            }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y).key] = {
              backfilled: !1
            }, i.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y - 1).key] = {
              backfilled: !1
            }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {
              backfilled: !1
            }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y - 1).key] = {
              backfilled: !1
            }), i.y + 1 < o && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y + 1).key] = {
              backfilled: !1
            }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {
              backfilled: !1
            }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y + 1).key] = {
              backfilled: !1
            }), l;
          }
          unloadTile(e) {
            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded";
          }
        },
        geojson: class extends e.Evented {
          constructor(t, i, o, r) {
            super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
            const n = e.EXTENT / this.tileSize;
            this.workerOptions = e.extend({
              source: this.id,
              cluster: i.cluster || !1,
              geojsonVtOptions: {
                buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,
                tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,
                extent: e.EXTENT,
                maxZoom: this.maxzoom,
                lineMetrics: i.lineMetrics || !1,
                generateId: i.generateId || !1
              },
              superclusterOptions: {
                maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                minPoints: Math.max(2, i.clusterMinPoints || 2),
                extent: e.EXTENT,
                radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,
                log: !1,
                generateId: i.generateId || !1
              },
              clusterProperties: i.clusterProperties,
              filter: i.filter
            }, i.workerOptions);
          }
          onAdd(e) {
            this.map = e, this.setData(this._data);
          }
          setData(e) {
            return this._data = e, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e, t) {
            return this.actor.send("geojson.getClusterExpansionZoom", {
              clusterId: e,
              source: this.id
            }, t), this;
          }
          getClusterChildren(e, t) {
            return this.actor.send("geojson.getClusterChildren", {
              clusterId: e,
              source: this.id
            }, t), this;
          }
          getClusterLeaves(e, t, i, o) {
            return this.actor.send("geojson.getClusterLeaves", {
              source: this.id,
              clusterId: e,
              limit: t,
              offset: i
            }, o), this;
          }
          _updateWorkerData() {
            if (this._pendingLoad) return void (this._coalesce = !0);
            this.fire(new e.Event("dataloading", {
              dataType: "source"
            })), this._loaded = !1;
            const t = e.extend({}, this.workerOptions),
              i = this._data;
            "string" == typeof i ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (t, i) => {
              if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t));else {
                const t = {
                  dataType: "source",
                  sourceDataType: this._metadataFired ? "content" : "metadata"
                };
                this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t.resourceTiming = i.resourceTiming[this.id]), this.fire(new e.Event("data", t)), this._metadataFired = !0;
              }
              this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t, i) {
            const o = t.actor ? "reloadTile" : "loadTile";
            t.actor = this.actor, t.request = this.actor.send(o, {
              type: this.type,
              uid: t.uid,
              tileID: t.tileID,
              tileZoom: t.tileZoom,
              zoom: t.tileID.overscaledZ,
              maxZoom: this.maxzoom,
              tileSize: this.tileSize,
              source: this.id,
              pixelRatio: e.exported.devicePixelRatio,
              showCollisionBoxes: this.map.showCollisionBoxes,
              promoteId: this.promoteId
            }, (e, r) => (delete t.request, t.unloadVectorData(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
          }
          abortTile(e) {
            e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
          }
          unloadTile(e) {
            e.unloadVectorData(), this.actor.send("removeTile", {
              uid: e.uid,
              type: this.type,
              source: this.id
            });
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e.extend({}, this._options, {
              type: this.type,
              data: this._data
            });
          }
          hasTransition() {
            return !1;
          }
        },
        video: class extends Ae {
          constructor(e, t, i, o) {
            super(e, t, i, o), this.roundZoom = !0, this.type = "video", this.options = t;
          }
          load() {
            this._loaded = !1;
            const t = this.options;
            this.urls = [];
            for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.ResourceType.Source).url);
            e.getVideo(this.urls, (t, i) => {
              this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t) {
            if (this.video) {
              const i = this.video.seekable;
              t < i.start(0) || t > i.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const t = this.map.painter.context,
              i = t.gl;
            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);
          }
          serialize() {
            return {
              type: "video",
              urls: this.urls,
              coordinates: this.coordinates
            };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        },
        image: Ae,
        canvas: class extends Ae {
          constructor(t, i, o, r) {
            super(t, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => "number" != typeof e)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
          }
          load() {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function () {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i = this.map.painter.context;
            this.texture ? (t || this._playing) && this.texture.update(this.canvas, {
              premultiply: !0
            }) : this.texture = new e.Texture(i, this.canvas, i.gl.RGBA, {
              premultiply: !0
            }), this._prepareData(i);
          }
          serialize() {
            return {
              type: "canvas",
              coordinates: this.coordinates
            };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
            return !1;
          }
        },
        custom: class extends e.Evented {
          constructor(t, i, o, r) {
            super(), this.id = t, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = !0, this.fire(new e.Event("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })), this.fire(new e.Event("data", {
              dataType: "source",
              sourceDataType: "content"
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            this._map = t, this._loaded = !1, this.fire(new e.Event("dataloading", {
              dataType: "source"
            })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();
          }
          onRemove(e) {
            this._implementation.onRemove && this._implementation.onRemove(e);
          }
          hasTile(e) {
            if (this._implementation.hasTile) {
              const {
                x: t,
                y: i,
                z: o
              } = e.canonical;
              return this._implementation.hasTile({
                x: t,
                y: i,
                z: o
              });
            }
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(t, i) {
            const {
                x: o,
                y: r,
                z: n
              } = t.tileID.canonical,
              s = new e.window.AbortController();
            t.request = Promise.resolve(this._implementation.loadTile({
              x: o,
              y: r,
              z: n
            }, {
              signal: s.signal
            })).then(function (o) {
              return delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : void 0 === o ? (t.state = "errored", i(null)) : null === o ? (this.loadTileData(t, {
                width: this.tileSize,
                height: this.tileSize,
                data: null
              }), t.state = "loaded", i(null)) : function (t) {
                return t instanceof e.window.ImageData || t instanceof e.window.HTMLCanvasElement || t instanceof e.window.ImageBitmap || t instanceof e.window.HTMLImageElement;
              }(o) ? (this.loadTileData(t, o), t.state = "loaded", void i(null)) : (t.state = "errored", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }.bind(this)).catch(e => {
              20 !== e.code && (t.state = "errored", i(e));
            }), t.request.cancel = () => s.abort();
          }
          loadTileData(e, t) {
            Se.loadTileData(e, t, this._map.painter);
          }
          unloadTileData(e) {
            Se.unloadTileData(e, this._map.painter);
          }
          unloadTile(e, t) {
            if (this.unloadTileData(e), this._implementation.unloadTile) {
              const {
                x: t,
                y: i,
                z: o
              } = e.tileID.canonical;
              this._implementation.unloadTile({
                x: t,
                y: i,
                z: o
              });
            }
            t();
          }
          abortTile(e, t) {
            e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();
          }
          hasTransition() {
            return !1;
          }
          _coveringTiles() {
            return this._map.transform.coveringTiles({
              tileSize: this.tileSize,
              minzoom: this.minzoom,
              maxzoom: this.maxzoom,
              roundZoom: this.roundZoom
            }).map(e => ({
              x: e.canonical.x,
              y: e.canonical.y,
              z: e.canonical.z
            }));
          }
          _clearTiles() {
            this._map.style._clearSource(this.id);
          }
          _update() {
            this.fire(new e.Event("data", {
              dataType: "source",
              sourceDataType: "content"
            }));
          }
        }
      },
      Pe = function (t, i, o, r) {
        const n = new ze[i.type](t, i, o, r);
        if (n.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);
        return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n), n;
      };
    function Re(t, i) {
      const o = e.identity([]);
      return e.scale(o, o, [.5 * t.width, .5 * -t.height, 1]), e.translate(o, o, [1, -1, 0]), e.multiply(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
    }
    function Oe(e, t, i, o, r, n, s, a = !1) {
      const l = e.tilesIn(o, s, a);
      l.sort(ke);
      const c = [];
      for (const o of l) c.push({
        wrappedTileID: o.tile.tileID.wrapped().key,
        queryResults: o.tile.queryRenderedFeatures(t, i, e._state, o, r, n, Re(e.transform, o.tile.tileID), a)
      });
      const h = function (e) {
        const t = {},
          i = {};
        for (const o of e) {
          const e = o.queryResults,
            r = o.wrappedTileID,
            n = i[r] = i[r] || {};
          for (const i in e) {
            const o = e[i],
              r = n[i] = n[i] || {},
              s = t[i] = t[i] || [];
            for (const e of o) r[e.featureIndex] || (r[e.featureIndex] = !0, s.push(e));
          }
        }
        return t;
      }(c);
      for (const t in h) h[t].forEach(t => {
        const i = t.feature,
          o = i.layer;
        o && "background" !== o.type && "sky" !== o.type && (i.source = o.source, o["source-layer"] && (i.sourceLayer = o["source-layer"]), i.state = void 0 !== i.id ? e.getFeatureState(o["source-layer"], i.id) : {});
      });
      return h;
    }
    function Be(e, t) {
      const i = e.getRenderableIds().map(t => e.getTileByID(t)),
        o = [],
        r = {};
      for (let e = 0; e < i.length; e++) {
        const n = i[e],
          s = n.tileID.canonical.key;
        r[s] || (r[s] = !0, n.querySourceFeatures(o, t));
      }
      return o;
    }
    function ke(e, t) {
      const i = e.tileID,
        o = t.tileID;
      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
    }
    function Fe() {
      return null != fn.workerClass ? new fn.workerClass() : new e.window.Worker(fn.workerUrl);
    }
    const Ue = "mapboxgl_preloaded_worker_pool";
    class Ne {
      constructor() {
        this.active = {};
      }
      acquire(e) {
        if (!this.workers) for (this.workers = []; this.workers.length < Ne.workerCount;) this.workers.push(new Fe());
        return this.active[e] = !0, this.workers.slice();
      }
      release(e) {
        delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {
          e.terminate();
        }), this.workers = null);
      }
      isPreloaded() {
        return !!this.active[Ue];
      }
      numActive() {
        return Object.keys(this.active).length;
      }
    }
    let Ge;
    function je() {
      return Ge || (Ge = new Ne()), Ge;
    }
    function Ze(t, i) {
      const o = {};
      for (const e in t) "ref" !== e && (o[e] = t[e]);
      return e.refProperties.forEach(e => {
        e in i && (o[e] = i[e]);
      }), o;
    }
    function Ve(e) {
      e = e.slice();
      const t = Object.create(null);
      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];
      for (let i = 0; i < e.length; i++) "ref" in e[i] && (e[i] = Ze(e[i], t[e[i].ref]));
      return e;
    }
    Ne.workerCount = 2;
    const We = {
      setStyle: "setStyle",
      addLayer: "addLayer",
      removeLayer: "removeLayer",
      setPaintProperty: "setPaintProperty",
      setLayoutProperty: "setLayoutProperty",
      setFilter: "setFilter",
      addSource: "addSource",
      removeSource: "removeSource",
      setGeoJSONSourceData: "setGeoJSONSourceData",
      setLayerZoomRange: "setLayerZoomRange",
      setLayerProperty: "setLayerProperty",
      setCenter: "setCenter",
      setZoom: "setZoom",
      setBearing: "setBearing",
      setPitch: "setPitch",
      setSprite: "setSprite",
      setGlyphs: "setGlyphs",
      setTransition: "setTransition",
      setLight: "setLight",
      setTerrain: "setTerrain",
      setFog: "setFog",
      setProjection: "setProjection"
    };
    function Xe(e, t, i) {
      i.push({
        command: We.addSource,
        args: [e, t[e]]
      });
    }
    function qe(e, t, i) {
      t.push({
        command: We.removeSource,
        args: [e]
      }), i[e] = !0;
    }
    function $e(e, t, i, o) {
      qe(e, i, o), Xe(e, t, i);
    }
    function He(e, i, o) {
      let r;
      for (r in e[o]) if (e[o].hasOwnProperty(r) && "data" !== r && !t(e[o][r], i[o][r])) return !1;
      for (r in i[o]) if (i[o].hasOwnProperty(r) && "data" !== r && !t(e[o][r], i[o][r])) return !1;
      return !0;
    }
    function Ye(e, i, o, r, n, s) {
      let a;
      for (a in i = i || {}, e = e || {}) e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({
        command: s,
        args: [r, a, i[a], n]
      }));
      for (a in i) i.hasOwnProperty(a) && !e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({
        command: s,
        args: [r, a, i[a], n]
      }));
    }
    function Ke(e) {
      return e.id;
    }
    function Je(e, t) {
      return e[t.id] = t, e;
    }
    class Qe {
      constructor(e, t) {
        this.reset(e, t);
      }
      reset(e, t) {
        this.points = e || [], this._distances = [0];
        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }
      lerp(t) {
        if (1 === this.points.length) return this.points[0];
        t = e.clamp(t, 0, 1);
        let i = 1,
          o = this._distances[i];
        const r = t * this.paddedLength + this.padding;
        for (; o < r && i < this._distances.length;) o = this._distances[++i];
        const n = i - 1,
          s = this._distances[n],
          a = o - s,
          l = a > 0 ? (r - s) / a : 0;
        return this.points[n].mult(1 - l).add(this.points[i].mult(l));
      }
    }
    class et {
      constructor(e, t, i) {
        const o = this.boxCells = [],
          r = this.circleCells = [];
        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);
        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), r.push([]);
        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
      }
      keysLength() {
        return this.boxKeys.length + this.circleKeys.length;
      }
      insert(e, t, i, o, r) {
        this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
      }
      insertCircle(e, t, i, o) {
        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);
      }
      _insertBoxCell(e, t, i, o, r, n) {
        this.boxCells[r].push(n);
      }
      _insertCircleCell(e, t, i, o, r, n) {
        this.circleCells[r].push(n);
      }
      _query(e, t, i, o, r, n) {
        if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];
        const s = [];
        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {
          if (r) return !0;
          for (let e = 0; e < this.boxKeys.length; e++) s.push({
            key: this.boxKeys[e],
            x1: this.bboxes[4 * e],
            y1: this.bboxes[4 * e + 1],
            x2: this.bboxes[4 * e + 2],
            y2: this.bboxes[4 * e + 3]
          });
          for (let e = 0; e < this.circleKeys.length; e++) {
            const t = this.circles[3 * e],
              i = this.circles[3 * e + 1],
              o = this.circles[3 * e + 2];
            s.push({
              key: this.circleKeys[e],
              x1: t - o,
              y1: i - o,
              x2: t + o,
              y2: i + o
            });
          }
          return n ? s.filter(n) : s;
        }
        return this._forEachCell(e, t, i, o, this._queryCell, s, {
          hitTest: r,
          seenUids: {
            box: {},
            circle: {}
          }
        }, n), r ? s.length > 0 : s;
      }
      _queryCircle(e, t, i, o, r) {
        const n = e - i,
          s = e + i,
          a = t - i,
          l = t + i;
        if (s < 0 || n > this.width || l < 0 || a > this.height) return !o && [];
        const c = [];
        return this._forEachCell(n, a, s, l, this._queryCellCircle, c, {
          hitTest: o,
          circle: {
            x: e,
            y: t,
            radius: i
          },
          seenUids: {
            box: {},
            circle: {}
          }
        }, r), o ? c.length > 0 : c;
      }
      query(e, t, i, o, r) {
        return this._query(e, t, i, o, !1, r);
      }
      hitTest(e, t, i, o, r) {
        return this._query(e, t, i, o, !0, r);
      }
      hitTestCircle(e, t, i, o) {
        return this._queryCircle(e, t, i, !0, o);
      }
      _queryCell(e, t, i, o, r, n, s, a) {
        const l = s.seenUids,
          c = this.boxCells[r];
        if (null !== c) {
          const r = this.bboxes;
          for (const h of c) if (!l.box[h]) {
            l.box[h] = !0;
            const c = 4 * h;
            if (e <= r[c + 2] && t <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {
              if (s.hitTest) return n.push(!0), !0;
              n.push({
                key: this.boxKeys[h],
                x1: r[c],
                y1: r[c + 1],
                x2: r[c + 2],
                y2: r[c + 3]
              });
            }
          }
        }
        const h = this.circleCells[r];
        if (null !== h) {
          const r = this.circles;
          for (const c of h) if (!l.circle[c]) {
            l.circle[c] = !0;
            const h = 3 * c;
            if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t, i, o) && (!a || a(this.circleKeys[c]))) {
              if (s.hitTest) return n.push(!0), !0;
              {
                const e = r[h],
                  t = r[h + 1],
                  i = r[h + 2];
                n.push({
                  key: this.circleKeys[c],
                  x1: e - i,
                  y1: t - i,
                  x2: e + i,
                  y2: t + i
                });
              }
            }
          }
        }
      }
      _queryCellCircle(e, t, i, o, r, n, s, a) {
        const l = s.circle,
          c = s.seenUids,
          h = this.boxCells[r];
        if (null !== h) {
          const e = this.bboxes;
          for (const t of h) if (!c.box[t]) {
            c.box[t] = !0;
            const i = 4 * t;
            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t]))) return n.push(!0), !0;
          }
        }
        const u = this.circleCells[r];
        if (null !== u) {
          const e = this.circles;
          for (const t of u) if (!c.circle[t]) {
            c.circle[t] = !0;
            const i = 3 * t;
            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t]))) return n.push(!0), !0;
          }
        }
      }
      _forEachCell(e, t, i, o, r, n, s, a) {
        const l = this._convertToXCellCoord(e),
          c = this._convertToYCellCoord(t),
          h = this._convertToXCellCoord(i),
          u = this._convertToYCellCoord(o);
        for (let _ = l; _ <= h; _++) for (let l = c; l <= u; l++) if (r.call(this, e, t, i, o, this.xCellCount * l + _, n, s, a)) return;
      }
      _convertToXCellCoord(e) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
      }
      _convertToYCellCoord(e) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
      }
      _circlesCollide(e, t, i, o, r, n) {
        const s = o - e,
          a = r - t,
          l = i + n;
        return l * l > s * s + a * a;
      }
      _circleAndRectCollide(e, t, i, o, r, n, s) {
        const a = (n - o) / 2,
          l = Math.abs(e - (o + a));
        if (l > a + i) return !1;
        const c = (s - r) / 2,
          h = Math.abs(t - (r + c));
        if (h > c + i) return !1;
        if (l <= a || h <= c) return !0;
        const u = l - a,
          _ = h - c;
        return u * u + _ * _ <= i * i;
      }
    }
    const tt = Math.tan(85 * Math.PI / 180);
    function it(t, i, o, r, n, s, a) {
      const l = e.create();
      if (o) {
        if ("globe" === s.name) {
          const t = e.calculateGlobeLabelMatrix(n, i);
          e.multiply(l, l, t);
        } else {
          const t = v([], a);
          l[0] = t[0], l[1] = t[1], l[4] = t[2], l[5] = t[3], r || e.rotateZ(l, l, n.angle);
        }
      } else e.multiply(l, n.labelPlaneMatrix, t);
      return l;
    }
    function ot(e, t, i, o, r, n, s) {
      const a = it(e, t, i, o, r, n, s);
      return "globe" === n.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;
    }
    function rt(t, i, o, r, n, s, a) {
      if (o) {
        if ("globe" === s.name) {
          const l = it(t, i, o, r, n, s, a);
          return e.invert(l, l), e.multiply(l, t, l), l;
        }
        {
          const i = e.clone(t),
            o = e.identity([]);
          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.multiply(i, i, o), r || e.rotateZ(i, i, -n.angle), i;
        }
      }
      return n.glCoordMatrix;
    }
    function nt(t, i, o, r) {
      const n = [t, i, o, 1];
      o ? e.transformMat4$1(n, n, r) : ft(n, n, r);
      const s = n[3];
      return n[0] /= s, n[1] /= s, n[2] /= s, n;
    }
    function st(e, t) {
      return Math.min(.5 + e / t * .5, 1.5);
    }
    function at(e, t) {
      const i = e[0] / e[3],
        o = e[1] / e[3];
      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];
    }
    function lt(t, i, o, r, n, s, a, l, c, h) {
      const u = o.transform,
        _ = r ? t.textSizeData : t.iconSizeData,
        d = e.evaluateSizeForZoom(_, o.transform.zoom),
        p = "globe" === u.projection.name,
        m = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],
        f = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;
      f.clear();
      let g = null;
      p && (g = r ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray);
      const v = t.lineVertexArray,
        x = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,
        y = o.transform.width / o.transform.height;
      let b,
        w = !1;
      for (let r = 0; r < x.length; r++) {
        const p = x.get(r),
          {
            numGlyphs: T,
            writingMode: E
          } = p;
        if (E !== e.WritingMode.vertical || w || b === e.WritingMode.horizontal || (w = !0), b = E, (p.hidden || E === e.WritingMode.vertical) && !w) {
          mt(T, f);
          continue;
        }
        w = !1;
        const C = new e.pointGeometry(p.tileAnchorX, p.tileAnchorY);
        let {
          x: M,
          y: I,
          z: S
        } = u.projection.projectTilePoint(C.x, C.y, h.canonical);
        if (c) {
          const [e, t, i] = c(C);
          M += e, I += t, S += i;
        }
        const D = [M, I, S, 1];
        if (e.transformMat4$1(D, D, i), !at(D, m)) {
          mt(T, f);
          continue;
        }
        const L = st(o.transform.cameraToCenterDistance, D[3]),
          A = e.evaluateSizeForFeature(_, d, p),
          z = a ? A / L : A * L,
          P = nt(M, I, S, n);
        if (P[3] <= 0) {
          mt(T, f);
          continue;
        }
        let R = {};
        const O = a ? null : c,
          B = ut(p, z, !1, l, i, n, s, t.glyphOffsetArray, v, f, g, P, C, R, y, O, u.projection, h, a);
        w = B.useVertical, O && B.needsFlipping && (R = {}), (B.notEnoughRoom || w || B.needsFlipping && ut(p, z, !0, l, i, n, s, t.glyphOffsetArray, v, f, g, P, C, R, y, O, u.projection, h, a).notEnoughRoom) && mt(T, f);
      }
      r ? (t.text.dynamicLayoutVertexBuffer.updateData(f), g && t.text.globeExtVertexBuffer.updateData(g)) : (t.icon.dynamicLayoutVertexBuffer.updateData(f), g && t.icon.globeExtVertexBuffer.updateData(g));
    }
    function ct(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
      const {
          lineStartIndex: f,
          glyphStartIndex: g,
          segment: v
        } = a,
        x = g + a.numGlyphs,
        y = f + a.lineLength,
        b = t.getoffsetX(g),
        w = t.getoffsetX(x - 1),
        T = pt(e * b, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);
      if (!T) return null;
      const E = pt(e * w, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);
      return E ? {
        first: T,
        last: E
      } : null;
    }
    function ht(t, i, o, r) {
      return t === e.WritingMode.horizontal && Math.abs(r) > Math.abs(o) ? {
        useVertical: !0
      } : t === e.WritingMode.vertical ? r > 0 ? {
        needsFlipping: !0
      } : null : 0 !== i && function (e, t) {
        return 0 === e || Math.abs(t / e) > tt;
      }(o, r) ? 1 === i ? {
        needsFlipping: !0
      } : null : o < 0 ? {
        needsFlipping: !0
      } : null;
    }
    function ut(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v, x) {
      const y = i / 24,
        b = t.lineOffsetX * y,
        w = t.lineOffsetY * y,
        {
          lineStartIndex: T,
          glyphStartIndex: E,
          numGlyphs: C,
          segment: M,
          writingMode: I,
          flipState: S
        } = t,
        D = T + t.lineLength,
        L = t => {
          if (u) {
            const [i, o, r] = t.up,
              n = h.length;
            e.updateGlobeVertexNormal(u, n + 0, i, o, r), e.updateGlobeVertexNormal(u, n + 1, i, o, r), e.updateGlobeVertexNormal(u, n + 2, i, o, r), e.updateGlobeVertexNormal(u, n + 3, i, o, r);
          }
          const [i, o, r] = t.point;
          e.addDynamicAttributes(h, i, o, r, t.angle);
        };
      if (C > 1) {
        const e = ct(y, l, b, w, o, _, d, t, c, s, p, f, !1, g, v, x);
        if (!e) return {
          notEnoughRoom: !0
        };
        if (r && !o) {
          let [i, o, r] = e.first.point,
            [n, s, l] = e.last.point;
          [i, o] = nt(i, o, r, a), [n, s] = nt(n, s, l, a);
          const c = ht(I, S, (n - i) * m, s - o);
          if (t.flipState = c && c.needsFlipping ? 1 : 2, c) return c;
        }
        L(e.first);
        for (let e = E + 1; e < E + C - 1; e++) {
          const t = pt(y * l.getoffsetX(e), b, w, o, _, d, M, T, D, c, s, p, f, !1, !1, g, v, x);
          if (!t) return h.length -= 4 * (e - E), {
            notEnoughRoom: !0
          };
          L(t);
        }
        L(e.last);
      } else {
        if (r && !o) {
          const i = nt(d.x, d.y, 0, n),
            o = T + M + 1,
            r = new e.pointGeometry(c.getx(o), c.gety(o)),
            s = nt(r.x, r.y, 0, n),
            a = s[3] > 0 ? s : dt(d, r, i, 1, n, void 0, g, v.canonical),
            l = ht(I, S, (a[0] - i[0]) * m, a[1] - i[1]);
          if (t.flipState = l && l.needsFlipping ? 1 : 2, l) return l;
        }
        const i = pt(y * l.getoffsetX(E), b, w, o, _, d, M, T, D, c, s, p, f, !1, !1, g, v, x);
        if (!i) return {
          notEnoughRoom: !0
        };
        L(i);
      }
      return {};
    }
    function _t(e, t, i, o, r) {
      const {
        x: n,
        y: s,
        z: a
      } = o.projectTilePoint(e.x, e.y, t);
      if (!r) return nt(n, s, a, i);
      const [l, c, h] = r(e);
      return nt(n + l, s + c, a + h, i);
    }
    function dt(t, i, o, r, n, s, a, l) {
      const c = _t(t.sub(i)._unit()._add(t), l, n, a, s);
      return e.sub(c, o, c), e.normalize(c, c), e.scaleAndAdd(c, o, c, r);
    }
    function pt(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v) {
      const x = r ? t - i : t + i;
      let y = x > 0 ? 1 : -1,
        b = 0;
      r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);
      let w = l + a + (y > 0 ? 0 : 1) | 0,
        T = n,
        E = n,
        C = 0,
        M = 0;
      const I = Math.abs(x),
        S = [],
        D = [];
      let L = s,
        A = L;
      const z = () => dt(A, L, E, I - C + 1, u, d, f, g.canonical);
      for (; C + M <= I;) {
        if (w += y, w < l || w >= c) return null;
        if (E = T, A = L, S.push(E), p && D.push(A), L = new e.pointGeometry(h.getx(w), h.gety(w)), T = _[w], !T) {
          const e = _t(L, g.canonical, u, f, d);
          T = e[3] > 0 ? _[w] = e : z();
        }
        C += M, M = e.distance(E, T);
      }
      m && d && (_[w] && (T = z(), M = e.distance(E, T)), _[w] = T);
      const P = (I - C) / M,
        R = L.sub(A)._mult(P)._add(A),
        O = e.sub([], T, E),
        B = e.scaleAndAdd([], E, O, P);
      let k = [0, 0, 1],
        F = O[0],
        U = O[1];
      if (v && (k = f.upVector(g.canonical, R.x, R.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
        const t = [k[2], 0, -k[0]],
          i = e.cross([], k, t);
        e.normalize(t, t), e.normalize(i, i), F = e.dot(O, t), U = e.dot(O, i);
      }
      if (o) {
        const t = e.cross([], k, O);
        e.normalize(t, t), e.scaleAndAdd(B, B, t, o * y);
      }
      const N = b + Math.atan2(U, F);
      return S.push(B), p && D.push(R), {
        point: B,
        angle: N,
        path: S,
        tilePath: D,
        up: k
      };
    }
    function mt(e, t) {
      const i = t.length,
        o = i + 4 * e;
      t.resize(o), t.float32.fill(-1 / 0, 4 * i, 4 * o);
    }
    function ft(e, t, i) {
      const o = t[0],
        r = t[1];
      return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;
    }
    const gt = 100;
    class vt {
      constructor(e, t, i = new et(e.width + 200, e.height + 200, 25), o = new et(e.width + 200, e.height + 200, 25)) {
        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + gt, this.screenBottomBoundary = e.height + gt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;
      }
      placeCollisionBox(e, t, i, o, r, n, s, a) {
        let l = i.projectedAnchorX,
          c = i.projectedAnchorY,
          h = i.projectedAnchorZ;
        const u = i.elevation,
          _ = i.tileID,
          d = e.getProjection();
        if (u && _) {
          const [e, t, o] = d.upVector(_.canonical, i.tileAnchorX, i.tileAnchorY),
            r = d.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
          l += e * u * r, c += t * u * r, h += o * u * r;
        }
        const p = this.projectAndGetPerspectiveRatio(s, l, c, h, i.tileID, "globe" === d.name || !!u || this.transform.pitch > 0, d),
          m = n * p.perspectiveRatio,
          f = (i.x1 * t + o.x - i.padding) * m + p.point.x,
          g = (i.y1 * t + o.y - i.padding) * m + p.point.y,
          v = (i.x2 * t + o.x + i.padding) * m + p.point.x,
          x = (i.y2 * t + o.y + i.padding) * m + p.point.y,
          y = p.perspectiveRatio <= .55 || p.occluded;
        return !this.isInsideGrid(f, g, v, x) || !r && this.grid.hitTest(f, g, v, x, a) || y ? {
          box: [],
          offscreen: !1,
          occluded: p.occluded
        } : {
          box: [f, g, v, x],
          offscreen: this.isOffscreen(f, g, v, x),
          occluded: !1
        };
      }
      placeCollisionCircles(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
        const f = [],
          g = this.transform.elevation,
          v = t.getProjection(),
          x = g ? g.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, v) : null,
          y = new e.pointGeometry(o.tileAnchorX, o.tileAnchorY);
        let {
          x: b,
          y: w,
          z: T
        } = v.projectTilePoint(y.x, y.y, m.canonical);
        if (x) {
          const [e, t, i] = x(y);
          b += e, w += t, T += i;
        }
        const E = "globe" === v.name,
          C = this.projectAndGetPerspectiveRatio(a, b, w, T, m, E || !!g || this.transform.pitch > 0, v),
          {
            perspectiveRatio: M
          } = C,
          I = (u ? s / M : s * M) / e.ONE_EM,
          S = nt(b, w, T, l),
          D = C.signedDistanceFromCamera > 0 ? ct(I, n, o.lineOffsetX * I, o.lineOffsetY * I, !1, S, y, o, r, l, {}, g && !u ? x : null, u && !!g, v, m, u) : null;
        let L = !1,
          A = !1,
          z = !0;
        if (D && !C.occluded) {
          const t = .5 * d * M + p,
            o = new e.pointGeometry(-100, -100),
            r = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary),
            n = new Qe(),
            {
              first: s,
              last: a
            } = D,
            l = s.path.length;
          let u = [];
          for (let e = l - 1; e >= 1; e--) u.push(s.path[e]);
          for (let e = 1; e < a.path.length; e++) u.push(a.path[e]);
          const m = 2.5 * t;
          c && (u = u.map(([e, t, i], o) => (x && !E && (i = x(o < l - 1 ? s.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), nt(e, t, i, c))), u.some(e => e[3] <= 0) && (u = []));
          let g = [];
          if (u.length > 0) {
            let t = 1 / 0,
              i = -1 / 0,
              n = 1 / 0,
              s = -1 / 0;
            for (const e of u) t = Math.min(t, e[0]), n = Math.min(n, e[1]), i = Math.max(i, e[0]), s = Math.max(s, e[1]);
            i >= o.x && t <= r.x && s >= o.y && n <= r.y && (g = [u.map(t => new e.pointGeometry(t[0], t[1]))], (t < o.x || i > r.x || n < o.y || s > r.y) && (g = e.clipLine(g, o.x, o.y, r.x, r.y)));
          }
          for (const e of g) {
            n.reset(e, .25 * t);
            let o = 0;
            o = n.length <= .5 * t ? 1 : Math.ceil(n.paddedLength / m) + 1;
            for (let e = 0; e < o; e++) {
              const r = e / Math.max(o - 1, 1),
                s = n.lerp(r),
                a = s.x + gt,
                l = s.y + gt;
              f.push(a, l, t, 0);
              const c = a - t,
                u = l - t,
                d = a + t,
                p = l + t;
              if (z = z && this.isOffscreen(c, u, d, p), A = A || this.isInsideGrid(c, u, d, p), !i && this.grid.hitTestCircle(a, l, t, _) && (L = !0, !h)) return {
                circles: [],
                offscreen: !1,
                collisionDetected: L,
                occluded: !1
              };
            }
          }
        }
        return {
          circles: !h && L || !A ? [] : f,
          offscreen: z,
          collisionDetected: L,
          occluded: C.occluded
        };
      }
      queryRenderedSymbols(t) {
        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
        const i = [];
        let o = 1 / 0,
          r = 1 / 0,
          n = -1 / 0,
          s = -1 / 0;
        for (const a of t) {
          const t = new e.pointGeometry(a.x + gt, a.y + gt);
          o = Math.min(o, t.x), r = Math.min(r, t.y), n = Math.max(n, t.x), s = Math.max(s, t.y), i.push(t);
        }
        const a = this.grid.query(o, r, n, s).concat(this.ignoredGrid.query(o, r, n, s)),
          l = {},
          c = {};
        for (const t of a) {
          const o = t.key;
          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
          const r = [new e.pointGeometry(t.x1, t.y1), new e.pointGeometry(t.x2, t.y1), new e.pointGeometry(t.x2, t.y2), new e.pointGeometry(t.x1, t.y2)];
          e.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
        }
        return c;
      }
      insertCollisionBox(e, t, i, o, r) {
        (t ? this.ignoredGrid : this.grid).insert({
          bucketInstanceId: i,
          featureIndex: o,
          collisionGroupID: r
        }, e[0], e[1], e[2], e[3]);
      }
      insertCollisionCircles(e, t, i, o, r) {
        const n = t ? this.ignoredGrid : this.grid,
          s = {
            bucketInstanceId: i,
            featureIndex: o,
            collisionGroupID: r
          };
        for (let t = 0; t < e.length; t += 4) n.insertCircle(s, e[t], e[t + 1], e[t + 2]);
      }
      projectAndGetPerspectiveRatio(t, i, o, r, n, s, a) {
        const l = [i, o, r, 1];
        let c = !1;
        if (r || this.transform.pitch > 0) {
          e.transformMat4$1(l, l, t);
          const s = "globe" === a.name;
          if (this.fogState && n && !s) {
            const t = function (t, i, o, r, n, s) {
              const a = s.calculateFogTileMatrix(n),
                l = [i, o, r];
              return e.transformMat4(l, l, a), I(t, l, s.pitch, s._fov);
            }(this.fogState, i, o, r, n.toUnwrapped(), this.transform);
            c = t > .9;
          }
        } else ft(l, l, t);
        const h = l[3];
        return {
          point: new e.pointGeometry((l[0] / h + 1) / 2 * this.transform.width + gt, (-l[1] / h + 1) / 2 * this.transform.height + gt),
          perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),
          signedDistanceFromCamera: h,
          occluded: s && l[2] > h || c
        };
      }
      isOffscreen(e, t, i, o) {
        return i < gt || e >= this.screenRightBoundary || o < gt || t > this.screenBottomBoundary;
      }
      isInsideGrid(e, t, i, o) {
        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;
      }
      getViewportMatrix() {
        const t = e.identity([]);
        return e.translate(t, t, [-100, -100, 0]), t;
      }
    }
    function xt(t, i, o) {
      const r = i.createTileMatrix(t, t.worldSize, o.toUnwrapped());
      return e.multiply(new Float32Array(16), t.projMatrix, r);
    }
    function yt(e, t, i) {
      if (t.projection.name === i.projection.name) return e.projMatrix;
      const o = i.clone();
      return o.setProjection(t.projection), xt(o, t.getProjection(), e);
    }
    function bt(e, t, i) {
      return t.name === i.projection.name ? e.projMatrix : xt(i, t, e);
    }
    class wt {
      constructor(e, t, i, o) {
        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;
      }
      isHidden() {
        return 0 === this.opacity && !this.placed;
      }
    }
    class Tt {
      constructor(e, t, i, o, r, n = !1) {
        this.text = new wt(e ? e.text : null, t, i, r), this.icon = new wt(e ? e.icon : null, t, o, r), this.clipped = n;
      }
      isHidden() {
        return this.text.isHidden() && this.icon.isHidden();
      }
    }
    class Et {
      constructor(e, t, i, o = !1) {
        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;
      }
    }
    class Ct {
      constructor() {
        this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
      }
    }
    class Mt {
      constructor(e, t, i, o, r) {
        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
      }
    }
    class It {
      constructor(e) {
        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
      }
      get(e) {
        if (this.crossSourceCollisions) return {
          ID: 0,
          predicate: null
        };
        if (!this.collisionGroups[e]) {
          const t = ++this.maxGroupID;
          this.collisionGroups[e] = {
            ID: t,
            predicate: e => e.collisionGroupID === t
          };
        }
        return this.collisionGroups[e];
      }
    }
    function St(t, i, o, r, n) {
      const {
          horizontalAlign: s,
          verticalAlign: a
        } = e.getAnchorAlignment(t),
        l = -(s - .5) * i,
        c = -(a - .5) * o,
        h = e.evaluateVariableOffset(t, r);
      return new e.pointGeometry(l + h[0] * n, c + h[1] * n);
    }
    function Dt(t, i, o, r, n) {
      const s = new e.pointGeometry(t, i);
      return o && s._rotate(r ? n : -n), s;
    }
    class Lt {
      constructor(e, t, i, o, r) {
        this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new vt(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new It(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
      }
      getBucketParts(t, i, o, r) {
        const n = o.getBucket(i),
          s = o.latestFeatureIndex;
        if (!n || !s || i.id !== n.layerIds[0]) return;
        const a = n.layers[0].layout,
          l = o.collisionBoxArray,
          c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),
          h = o.tileSize / e.EXTENT,
          u = o.tileID.toUnwrapped();
        this.transform.setProjection(n.projection);
        const _ = (d = o.tileID, p = n.getProjection(), m = this.transform, p.name === this.projection ? m.calculateProjMatrix(d.toUnwrapped()) : xt(m, p, d));
        var d, p, m;
        const f = "map" === a.get("text-pitch-alignment"),
          g = "map" === a.get("text-rotation-alignment");
        i.compileFilter();
        const v = i.dynamicFilter(),
          x = i.dynamicFilterNeedsFeature(),
          y = this.transform.calculatePixelsToTileUnitsMatrix(o),
          b = ot(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);
        let w = null;
        if (f) {
          const t = rt(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);
          w = e.multiply([], this.transform.labelPlaneMatrix, t);
        }
        let T = null;
        v && o.latestFeatureIndex && (T = {
          unwrappedTileID: u,
          dynamicFilter: v,
          dynamicFilterNeedsFeature: x,
          featureIndex: o.latestFeatureIndex
        }), this.retainedQueryData[n.bucketInstanceId] = new Mt(n.bucketInstanceId, s, n.sourceLayerIndex, n.index, o.tileID);
        const E = {
          bucket: n,
          layout: a,
          posMatrix: _,
          textLabelPlaneMatrix: b,
          labelToScreenMatrix: w,
          clippingData: T,
          scale: c,
          textPixelRatio: h,
          holdingForFade: o.holdingForFade(),
          collisionBoxArray: l,
          partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),
          partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),
          collisionGroup: this.collisionGroups.get(n.sourceID)
        };
        if (r) for (const e of n.sortKeyRanges) {
          const {
            sortKey: i,
            symbolInstanceStart: o,
            symbolInstanceEnd: r
          } = e;
          t.push({
            sortKey: i,
            symbolInstanceStart: o,
            symbolInstanceEnd: r,
            parameters: E
          });
        } else t.push({
          symbolInstanceStart: 0,
          symbolInstanceEnd: n.symbolInstances.length,
          parameters: E
        });
      }
      attemptAnchorPlacement(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) {
        const {
            textOffset0: v,
            textOffset1: x,
            crossTileID: y
          } = u,
          b = [v, x],
          w = St(e, i, o, b, r),
          T = this.collisionIndex.placeCollisionBox(d, r, t, Dt(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate);
        if (m) {
          const e = d.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);
          if (0 === this.collisionIndex.placeCollisionBox(d, e, m, Dt(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) return;
        }
        if (T.box.length > 0) {
          let t;
          return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = {
            textOffset: b,
            width: i,
            height: o,
            anchor: e,
            textScale: r,
            prevAnchor: t
          }, this.markUsedJustification(d, e, u, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, u), this.placedOrientations[y] = p), {
            shift: w,
            placedGlyphBoxes: T
          };
        }
      }
      placeLayerBucketPart(t, i, o, r) {
        const {
            bucket: n,
            layout: s,
            posMatrix: a,
            textLabelPlaneMatrix: l,
            labelToScreenMatrix: c,
            clippingData: h,
            textPixelRatio: u,
            holdingForFade: _,
            collisionBoxArray: d,
            partiallyEvaluatedTextSize: p,
            partiallyEvaluatedIconSize: m,
            collisionGroup: f
          } = t.parameters,
          g = s.get("text-optional"),
          v = s.get("icon-optional"),
          x = s.get("text-allow-overlap"),
          y = s.get("icon-allow-overlap"),
          b = "map" === s.get("text-rotation-alignment"),
          w = "map" === s.get("text-pitch-alignment"),
          T = "none" !== s.get("icon-text-fit"),
          E = "viewport-y" === s.get("symbol-z-order");
        this.transform.setProjection(n.projection);
        let C = x && (y || !n.hasIconData() || v),
          M = y && (x || !n.hasTextData() || g);
        !n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);
        const I = (t, r, d) => {
          const {
            crossTileID: E,
            numVerticalGlyphVertices: I
          } = t;
          if (h) {
            const o = {
              zoom: this.transform.zoom,
              pitch: this.transform.pitch
            };
            let r = null;
            if (h.dynamicFilterNeedsFeature) {
              const e = this.retainedQueryData[n.bucketInstanceId];
              r = h.featureIndex.loadFeature({
                featureIndex: t.featureIndex,
                bucketIndex: e.bucketIndex,
                sourceLayerIndex: e.sourceLayerIndex,
                layoutVertexArrayOffset: 0
              });
            }
            if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.pointGeometry(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[E] = new Et(!1, !1, !1, !0), void (i[E] = !0);
          }
          if (i[E]) return;
          if (_) return void (this.placements[E] = new Et(!1, !1, !1));
          let S = !1,
            D = !1,
            L = !0,
            A = !1,
            z = !1,
            P = null,
            R = {
              box: null,
              offscreen: null,
              occluded: null
            },
            O = {
              box: null,
              offscreen: null,
              occluded: null
            },
            B = null,
            k = null,
            F = null,
            U = 0,
            N = 0,
            G = 0;
          d.textFeatureIndex ? U = d.textFeatureIndex : t.useRuntimeCollisionCircles && (U = t.featureIndex), d.verticalTextFeatureIndex && (N = d.verticalTextFeatureIndex);
          const j = e => {
              e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;
              const t = this.transform.elevation;
              (t || e.elevation) && (e.elevation = t ? t.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0);
            },
            Z = d.textBox;
          if (Z) {
            j(Z);
            const i = i => {
                let o = e.WritingMode.horizontal;
                if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                  const e = this.prevPlacement.placedOrientations[E];
                  e && (this.placedOrientations[E] = e, o = e, this.markUsedOrientation(n, o, t));
                }
                return o;
              },
              o = (t, i) => {
                if (n.allowVerticalPlacement && I > 0 && d.verticalTextBox) {
                  for (const o of n.writingModes) if (o === e.WritingMode.vertical ? (R = i(), O = R) : R = t(), R && R.box && R.box.length) break;
                } else R = t();
              };
            if (s.get("text-variable-anchor")) {
              let l = s.get("text-variable-anchor");
              if (this.prevPlacement && this.prevPlacement.variableOffsets[E]) {
                const e = this.prevPlacement.variableOffsets[E];
                l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor));
              }
              const c = (e, i, o) => {
                const s = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),
                  c = (e.x2 - e.x1) * s + 2 * e.padding,
                  h = (e.y2 - e.y1) * s + 2 * e.padding,
                  _ = T && !y ? i : null;
                _ && j(_);
                let d = {
                  box: [],
                  offscreen: !1,
                  occluded: !1
                };
                const g = x ? 2 * l.length : l.length;
                for (let i = 0; i < g; ++i) {
                  const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, s, b, w, u, a, f, i >= l.length, t, r, n, o, _, p, m);
                  if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {
                    S = !0, P = g.shift;
                    break;
                  }
                }
                return d;
              };
              o(() => c(Z, d.iconBox, e.WritingMode.horizontal), () => {
                const t = d.verticalTextBox;
                return t && j(t), n.allowVerticalPlacement && !(R && R.box && R.box.length) && I > 0 && t ? c(t, d.verticalIconBox, e.WritingMode.vertical) : {
                  box: null,
                  offscreen: null,
                  occluded: null
                };
              }), R && (S = R.box, L = R.offscreen, A = R.occluded);
              const h = i(R && R.box);
              if (!S && this.prevPlacement) {
                const e = this.prevPlacement.variableOffsets[E];
                e && (this.variableOffsets[E] = e, this.markUsedJustification(n, e.anchor, t, h));
              }
            } else {
              const s = (i, o) => {
                const s = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),
                  l = this.collisionIndex.placeCollisionBox(n, s, i, new e.pointGeometry(0, 0), x, u, a, f.predicate);
                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[E] = o), l;
              };
              o(() => s(Z, e.WritingMode.horizontal), () => {
                const t = d.verticalTextBox;
                return n.allowVerticalPlacement && I > 0 && t ? (j(t), s(t, e.WritingMode.vertical)) : {
                  box: null,
                  offscreen: null,
                  occluded: null
                };
              }), i(R && R.box && R.box.length);
            }
          }
          if (B = R, S = B && B.box && B.box.length > 0, L = B && B.offscreen, A = B && B.occluded, t.useRuntimeCollisionCircles) {
            const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),
              r = e.evaluateSizeForFeature(n.textSizeData, p, i),
              h = s.get("text-padding");
            k = this.collisionIndex.placeCollisionCircles(n, x, i, n.lineVertexArray, n.glyphOffsetArray, r, a, l, c, o, w, f.predicate, t.collisionCircleDiameter * r / e.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), S = x || k.circles.length > 0 && !k.collisionDetected, L = L && k.offscreen, A = k.occluded;
          }
          if (d.iconFeatureIndex && (G = d.iconFeatureIndex), d.iconBox) {
            const i = i => {
              j(i);
              const o = T && P ? Dt(P.x, P.y, b, w, this.transform.angle) : new e.pointGeometry(0, 0),
                r = n.getSymbolInstanceIconSize(m, this.transform.zoom, t.placedIconSymbolIndex);
              return this.collisionIndex.placeCollisionBox(n, r, i, o, y, u, a, f.predicate);
            };
            O && O.box && O.box.length && d.verticalIconBox ? (F = i(d.verticalIconBox), D = F.box.length > 0) : (F = i(d.iconBox), D = F.box.length > 0), L = L && F.offscreen, z = F.occluded;
          }
          const V = g || 0 === t.numHorizontalGlyphVertices && 0 === I,
            W = v || 0 === t.numIconVertices;
          if (V || W ? W ? V || (D = D && S) : S = D && S : D = S = D && S, S && B && B.box && this.collisionIndex.insertCollisionBox(B.box, s.get("text-ignore-placement"), n.bucketInstanceId, O && O.box && N ? N : U, f.ID), D && F && this.collisionIndex.insertCollisionBox(F.box, s.get("icon-ignore-placement"), n.bucketInstanceId, G, f.ID), k && (S && this.collisionIndex.insertCollisionCircles(k.circles, s.get("text-ignore-placement"), n.bucketInstanceId, U, f.ID), o)) {
            const e = n.bucketInstanceId;
            let t = this.collisionCircleArrays[e];
            void 0 === t && (t = this.collisionCircleArrays[e] = new Ct());
            for (let e = 0; e < k.circles.length; e += 4) t.circles.push(k.circles[e + 0]), t.circles.push(k.circles[e + 1]), t.circles.push(k.circles[e + 2]), t.circles.push(k.collisionDetected ? 1 : 0);
          }
          const X = "globe" !== n.projection.name;
          C = C && (X || !A), M = M && (X || !z), this.placements[E] = new Et(S || C, D || M, L || n.justReloaded), i[E] = !0;
        };
        if (E) {
          const e = n.getSortedSymbolIndexes(this.transform.angle);
          for (let t = e.length - 1; t >= 0; --t) {
            const i = e[t];
            I(n.symbolInstances.get(i), i, n.collisionArrays[i]);
          }
        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) I(n.symbolInstances.get(e), e, n.collisionArrays[e]);
        if (o && n.bucketInstanceId in this.collisionCircleArrays) {
          const t = this.collisionCircleArrays[n.bucketInstanceId];
          e.invert(t.invProjMatrix, a), t.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }
        n.justReloaded = !1;
      }
      markUsedJustification(t, i, o, r) {
        const {
            leftJustifiedTextSymbolIndex: n,
            centerJustifiedTextSymbolIndex: s,
            rightJustifiedTextSymbolIndex: a,
            verticalPlacedTextSymbolIndex: l,
            crossTileID: c
          } = o,
          h = e.getAnchorJustification(i),
          u = r === e.WritingMode.vertical ? l : "left" === h ? n : "center" === h ? s : "right" === h ? a : -1;
        n >= 0 && (t.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);
      }
      markUsedOrientation(t, i, o) {
        const r = i === e.WritingMode.horizontal || i === e.WritingMode.horizontalOnly ? i : 0,
          n = i === e.WritingMode.vertical ? i : 0,
          {
            leftJustifiedTextSymbolIndex: s,
            centerJustifiedTextSymbolIndex: a,
            rightJustifiedTextSymbolIndex: l,
            verticalPlacedTextSymbolIndex: c
          } = o,
          h = t.text.placedSymbolArray;
        s >= 0 && (h.get(s).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = n);
      }
      commit(e) {
        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
        const t = this.prevPlacement;
        let i = !1;
        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
        const o = t ? t.symbolFadeChange(e) : 1,
          r = t ? t.opacities : {},
          n = t ? t.variableOffsets : {},
          s = t ? t.placedOrientations : {};
        for (const e in this.placements) {
          const t = this.placements[e],
            n = r[e];
          n ? (this.opacities[e] = new Tt(n, o, t.text, t.icon, null, t.clipped), i = i || t.text !== n.text.placed || t.icon !== n.icon.placed) : (this.opacities[e] = new Tt(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);
        }
        for (const e in r) {
          const t = r[e];
          if (!this.opacities[e]) {
            const r = new Tt(t, o, !1, !1);
            r.isHidden() || (this.opacities[e] = r, i = i || t.text.placed || t.icon.placed);
          }
        }
        for (const e in n) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = n[e]);
        for (const e in s) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = s[e]);
        i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
      }
      updateLayerOpacities(e, t) {
        const i = {};
        for (const o of t) {
          const t = o.getBucket(e);
          t && o.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, i, o.collisionBoxArray);
        }
      }
      updateBucketOpacities(t, i, o) {
        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
        const r = t.layers[0].layout,
          n = !!t.layers[0].dynamicFilter(),
          s = new Tt(null, 0, !1, !1, !0),
          a = r.get("text-allow-overlap"),
          l = r.get("icon-allow-overlap"),
          c = r.get("text-variable-anchor"),
          h = "map" === r.get("text-rotation-alignment"),
          u = "map" === r.get("text-pitch-alignment"),
          _ = "none" !== r.get("icon-text-fit"),
          d = new Tt(null, 0, a && (l || !t.hasIconData() || r.get("icon-optional")), l && (a || !t.hasTextData() || r.get("text-optional")), !0);
        !t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);
        const p = (e, t, i) => {
          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);
        };
        let m = 0;
        for (let o = 0; o < t.symbolInstances.length; o++) {
          const r = t.symbolInstances.get(o),
            {
              numHorizontalGlyphVertices: a,
              numVerticalGlyphVertices: l,
              crossTileID: f,
              numIconVertices: g
            } = r;
          let v = this.opacities[f];
          i[f] ? v = s : v || (v = d, this.opacities[f] = v), i[f] = !0;
          const x = a > 0 || l > 0,
            y = g > 0,
            b = this.placedOrientations[f],
            w = b === e.WritingMode.vertical,
            T = b === e.WritingMode.horizontal || b === e.WritingMode.horizontalOnly;
          if (!x && !y || v.isHidden() || m++, x) {
            const e = Ut(v.text);
            p(t.text, a, w ? Nt : e), p(t.text, l, T ? Nt : e);
            const i = v.text.isHidden(),
              {
                leftJustifiedTextSymbolIndex: o,
                centerJustifiedTextSymbolIndex: n,
                rightJustifiedTextSymbolIndex: s,
                verticalPlacedTextSymbolIndex: c
              } = r,
              h = t.text.placedSymbolArray,
              u = i || w ? 1 : 0;
            o >= 0 && (h.get(o).hidden = u), n >= 0 && (h.get(n).hidden = u), s >= 0 && (h.get(s).hidden = u), c >= 0 && (h.get(c).hidden = i || T ? 1 : 0);
            const _ = this.variableOffsets[f];
            _ && this.markUsedJustification(t, _.anchor, r, b);
            const d = this.placedOrientations[f];
            d && (this.markUsedJustification(t, "left", r, d), this.markUsedOrientation(t, d, r));
          }
          if (y) {
            const e = Ut(v.icon),
              {
                placedIconSymbolIndex: i,
                verticalPlacedIconSymbolIndex: o
              } = r,
              n = t.icon.placedSymbolArray,
              s = v.icon.isHidden() ? 1 : 0;
            i >= 0 && (p(t.icon, g, w ? Nt : e), n.get(i).hidden = s), o >= 0 && (p(t.icon, r.numVerticalIconVertices, T ? Nt : e), n.get(o).hidden = s);
          }
          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
            const i = t.collisionArrays[o];
            if (i) {
              let o = new e.pointGeometry(0, 0),
                r = !0;
              if (i.textBox || i.verticalTextBox) {
                if (c) {
                  const e = this.variableOffsets[f];
                  e ? (o = St(e.anchor, e.width, e.height, e.textOffset, e.textScale), h && o._rotate(u ? this.transform.angle : -this.transform.angle)) : r = !1;
                }
                n && (r = !v.clipped), i.textBox && At(t.textCollisionBox.collisionVertexArray, v.text.placed, !r || w, o.x, o.y), i.verticalTextBox && At(t.textCollisionBox.collisionVertexArray, v.text.placed, !r || T, o.x, o.y);
              }
              const s = r && Boolean(!T && i.verticalIconBox);
              i.iconBox && At(t.iconCollisionBox.collisionVertexArray, v.icon.placed, s, _ ? o.x : 0, _ ? o.y : 0), i.verticalIconBox && At(t.iconCollisionBox.collisionVertexArray, v.icon.placed, !s, _ ? o.x : 0, _ ? o.y : 0);
            }
          }
        }
        if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
          const e = this.collisionCircleArrays[t.bucketInstanceId];
          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
        }
      }
      symbolFadeChange(e) {
        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }
      zoomAdjustment(e) {
        return Math.max(0, (this.transform.zoom - e) / 1.5);
      }
      hasTransitions(e) {
        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
      }
      stillRecent(e, t) {
        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;
      }
      setStale() {
        this.stale = !0;
      }
    }
    function At(e, t, i, o, r) {
      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0);
    }
    const zt = Math.pow(2, 25),
      Pt = Math.pow(2, 24),
      Rt = Math.pow(2, 17),
      Ot = Math.pow(2, 16),
      Bt = Math.pow(2, 9),
      kt = Math.pow(2, 8),
      Ft = Math.pow(2, 1);
    function Ut(e) {
      if (0 === e.opacity && !e.placed) return 0;
      if (1 === e.opacity && e.placed) return 4294967295;
      const t = e.placed ? 1 : 0,
        i = Math.floor(127 * e.opacity);
      return i * zt + t * Pt + i * Rt + t * Ot + i * Bt + t * kt + i * Ft + t;
    }
    const Nt = 0;
    class Gt {
      constructor(e) {
        this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      }
      continuePlacement(e, t, i, o, r) {
        const n = this._bucketParts;
        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;
        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {
          const e = n[this._currentPartIndex];
          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
        }
        return !1;
      }
    }
    class jt {
      constructor(e, t, i, o, r, n, s, a) {
        this.placement = new Lt(e, r, n, s, a), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
      }
      isDone() {
        return this._done;
      }
      continuePlacement(t, i, o) {
        const r = e.exported.now(),
          n = () => {
            const t = e.exported.now() - r;
            return !this._forceFullPlacement && t > 2;
          };
        for (; this._currentPlacementIndex >= 0;) {
          const e = i[t[this._currentPlacementIndex]],
            r = this.placement.collisionIndex.transform.zoom;
          if ("symbol" === e.type && (!e.minzoom || e.minzoom <= r) && (!e.maxzoom || e.maxzoom > r)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Gt(e)), this._inProgressLayer.continuePlacement(o[e.source], this.placement, this._showCollisionBoxes, e, n)) return;
            delete this._inProgressLayer;
          }
          this._currentPlacementIndex--;
        }
        this._done = !0;
      }
      commit(e) {
        return this.placement.commit(e), this.placement;
      }
    }
    const Zt = 512 / e.EXTENT / 2;
    class Vt {
      constructor(e, t, i) {
        this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;
        for (let i = 0; i < t.length; i++) {
          const o = t.get(i),
            r = o.key;
          this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({
            crossTileID: o.crossTileID,
            coord: this.getScaledCoordinates(o, e)
          });
        }
      }
      getScaledCoordinates(t, i) {
        const o = Zt / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
        return {
          x: Math.floor((i.canonical.x * e.EXTENT + t.tileAnchorX) * o),
          y: Math.floor((i.canonical.y * e.EXTENT + t.tileAnchorY) * o)
        };
      }
      findMatches(e, t, i) {
        const o = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);
        for (let r = 0; r < e.length; r++) {
          const n = e.get(r);
          if (n.crossTileID) continue;
          const s = this.indexedSymbolInstances[n.key];
          if (!s) continue;
          const a = this.getScaledCoordinates(n, t);
          for (const e of s) if (Math.abs(e.coord.x - a.x) <= o && Math.abs(e.coord.y - a.y) <= o && !i[e.crossTileID]) {
            i[e.crossTileID] = !0, n.crossTileID = e.crossTileID;
            break;
          }
        }
      }
    }
    class Wt {
      constructor() {
        this.maxCrossTileID = 0;
      }
      generate() {
        return ++this.maxCrossTileID;
      }
    }
    class Xt {
      constructor() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      }
      handleWrapJump(e) {
        const t = Math.round((e - this.lng) / 360);
        if (0 !== t) for (const e in this.indexes) {
          const i = this.indexes[e],
            o = {};
          for (const e in i) {
            const r = i[e];
            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), o[r.tileID.key] = r;
          }
          this.indexes[e] = o;
        }
        this.lng = e;
      }
      addBucket(e, t, i) {
        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
        }
        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;
        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
        const o = this.usedCrossTileIDs[e.overscaledZ];
        for (const i in this.indexes) {
          const r = this.indexes[i];
          if (Number(i) > e.overscaledZ) for (const i in r) {
            const n = r[i];
            n.tileID.isChildOf(e) && n.findMatches(t.symbolInstances, e, o);
          } else {
            const n = r[e.scaledTo(Number(i)).key];
            n && n.findMatches(t.symbolInstances, e, o);
          }
        }
        for (let e = 0; e < t.symbolInstances.length; e++) {
          const r = t.symbolInstances.get(e);
          r.crossTileID || (r.crossTileID = i.generate(), o[r.crossTileID] = !0);
        }
        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Vt(e, t.symbolInstances, t.bucketInstanceId), !0;
      }
      removeBucketCrossTileIDs(e, t) {
        for (const i in t.indexedSymbolInstances) for (const o of t.indexedSymbolInstances[i]) delete this.usedCrossTileIDs[e][o.crossTileID];
      }
      removeStaleBuckets(e) {
        let t = !1;
        for (const i in this.indexes) {
          const o = this.indexes[i];
          for (const r in o) e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t = !0);
        }
        return t;
      }
    }
    class qt {
      constructor() {
        this.layerIndexes = {}, this.crossTileIDs = new Wt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      }
      addLayer(e, t, i, o) {
        let r = this.layerIndexes[e.id];
        void 0 === r && (r = this.layerIndexes[e.id] = new Xt());
        let n = !1;
        const s = {};
        "globe" !== o.name && r.handleWrapJump(i);
        for (const i of t) {
          const t = i.getBucket(e);
          t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (n = !0), s[t.bucketInstanceId] = !0);
        }
        return r.removeStaleBuckets(s) && (n = !0), n;
      }
      pruneUnusedLayers(e) {
        const t = {};
        e.forEach(e => {
          t[e] = !0;
        });
        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];
      }
    }
    const $t = (t, i) => e.emitValidationErrors(t, i && i.filter(e => "source.canvas" !== e.identifier)),
      Ht = e.pick(We, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]),
      Yt = e.pick(We, ["setCenter", "setZoom", "setBearing", "setPitch"]),
      Kt = {
        version: 8,
        layers: [],
        sources: {}
      },
      Jt = {
        fill: !0,
        line: !0,
        background: !0,
        hillshade: !0,
        raster: !0
      };
    class Qt extends e.Evented {
      constructor(t, i = {}) {
        super(), this.map = t, this.dispatcher = new z(je(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, i.localFontFamily ? e.LocalGlyphMode.all : i.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.crossTileSymbolIndex = new qt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
        const o = this;
        this._rtlTextPluginCallback = Qt.registerForPluginStateChange(t => {
          o.dispatcher.broadcast("syncRTLPluginState", {
            pluginStatus: t.pluginStatus,
            pluginURL: t.pluginURL
          }, (t, i) => {
            if (e.triggerPluginCompletionEvent(t), i && i.every(e => e)) for (const e in o._sourceCaches) {
              const t = o._sourceCaches[e],
                i = t.getSource().type;
              "vector" !== i && "geojson" !== i || t.reload();
            }
          });
        }), this.on("data", e => {
          if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
          const t = this.getSource(e.sourceId);
          if (t && t.vectorLayerIds) for (const e in this._layers) {
            const i = this._layers[e];
            i.source === t.id && this._validateLayer(i);
          }
        });
      }
      loadURL(t, i = {}) {
        this.fire(new e.Event("dataloading", {
          dataType: "style"
        }));
        const o = "boolean" == typeof i.validate ? i.validate : !e.isMapboxURL(t);
        t = this.map._requestManager.normalizeStyleURL(t, i.accessToken);
        const r = this.map._requestManager.transformRequest(t, e.ResourceType.Style);
        this._request = e.getJSON(r, (t, i) => {
          this._request = null, t ? this.fire(new e.ErrorEvent(t)) : i && this._load(i, o);
        });
      }
      loadJSON(t, i = {}) {
        this.fire(new e.Event("dataloading", {
          dataType: "style"
        })), this._request = e.exported.frame(() => {
          this._request = null, this._load(t, !1 !== i.validate);
        });
      }
      loadEmpty() {
        this.fire(new e.Event("dataloading", {
          dataType: "style"
        })), this._load(Kt, !1);
      }
      _updateLayerCount(e, t) {
        const i = t ? 1 : -1;
        e.is3D() && (this._num3DLayers += i), "circle" === e.type && (this._numCircleLayers += i), "symbol" === e.type && (this._numSymbolLayers += i);
      }
      _load(t, i) {
        if (i && $t(this, e.validateStyle(t))) return;
        this._loaded = !0, this.stylesheet = e.clone$1(t), this._updateMapProjection();
        for (const e in t.sources) this.addSource(e, t.sources[e], {
          validate: !1
        });
        this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t.glyphs);
        const o = Ve(this.stylesheet.layers);
        this._order = o.map(e => e.id), this._layers = {}, this._serializedLayers = {};
        for (let t of o) t = e.createStyleLayer(t), t.setEventedParent(this, {
          layer: {
            id: t.id
          }
        }), this._layers[t.id] = t, this._serializedLayers[t.id] = t.serialize(), this._updateLayerCount(t, !0);
        this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", {
          dataType: "style"
        })), this.fire(new e.Event("style.load"));
      }
      terrainSetForDrapingOnly() {
        return !!this.terrain && 0 === this.terrain.drapeRenderMode;
      }
      setProjection(e) {
        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this._updateMapProjection();
      }
      applyProjectionUpdate() {
        this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
      }
      _updateMapProjection() {
        this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
      }
      _loadSprite(t) {
        this._spriteRequest = function (t, i, o) {
          let r, n, s;
          const a = e.exported.devicePixelRatio > 1 ? "@2x" : "";
          let l = e.getJSON(i.transformRequest(i.normalizeSpriteURL(t, a, ".json"), e.ResourceType.SpriteJSON), (e, t) => {
              l = null, s || (s = e, r = t, h());
            }),
            c = e.getImage(i.transformRequest(i.normalizeSpriteURL(t, a, ".png"), e.ResourceType.SpriteImage), (e, t) => {
              c = null, s || (s = e, n = t, h());
            });
          function h() {
            if (s) o(s);else if (r && n) {
              const t = e.exported.getImageData(n),
                i = {};
              for (const o in r) {
                const {
                    width: n,
                    height: s,
                    x: a,
                    y: l,
                    sdf: c,
                    pixelRatio: h,
                    stretchX: u,
                    stretchY: _,
                    content: d
                  } = r[o],
                  p = new e.RGBAImage({
                    width: n,
                    height: s
                  });
                e.RGBAImage.copy(t, p, {
                  x: a,
                  y: l
                }, {
                  x: 0,
                  y: 0
                }, {
                  width: n,
                  height: s
                }), i[o] = {
                  data: p,
                  pixelRatio: h,
                  sdf: c,
                  stretchX: u,
                  stretchY: _,
                  content: d
                };
              }
              o(null, i);
            }
          }
          return {
            cancel() {
              l && (l.cancel(), l = null), c && (c.cancel(), c = null);
            }
          };
        }(t, this.map._requestManager, (t, i) => {
          if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t));else if (i) for (const e in i) this.imageManager.addImage(e, i[e]);
          this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e.Event("data", {
            dataType: "style"
          }));
        });
      }
      _validateLayer(t) {
        const i = this.getSource(t.source);
        if (!i) return;
        const o = t.sourceLayer;
        o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`)));
      }
      loaded() {
        if (!this._loaded) return !1;
        if (Object.keys(this._updatedSources).length) return !1;
        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;
        return !!this.imageManager.isLoaded();
      }
      _serializeLayers(e) {
        const t = [];
        for (const i of e) {
          const e = this._layers[i];
          "custom" !== e.type && t.push(e.serialize());
        }
        return t;
      }
      hasTransitions() {
        if (this.light && this.light.hasTransition()) return !0;
        if (this.fog && this.fog.hasTransition()) return !0;
        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;
        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;
        return !1;
      }
      get order() {
        return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
      }
      isLayerDraped(e) {
        return !!this.terrain && ("function" == typeof e.isLayerDraped ? e.isLayerDraped() : Jt[e.type]);
      }
      _checkLoaded() {
        if (!this._loaded) throw new Error("Style is not done loading");
      }
      update(t) {
        if (!this._loaded) return;
        const i = this._changed;
        if (this._changed) {
          const e = Object.keys(this._updatedLayers),
            i = Object.keys(this._removedLayers);
          (e.length || i.length) && this._updateWorkerLayers(e, i);
          for (const e in this._updatedSources) {
            const t = this._updatedSources[e];
            "reload" === t ? this._reloadSource(e) : "clear" === t && this._clearSource(e);
          }
          this._updateTilesForChangedImages();
          for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);
          this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates();
        }
        const o = {};
        for (const e in this._sourceCaches) {
          const t = this._sourceCaches[e];
          o[e] = t.used, t.used = !1;
        }
        for (const e of this._order) {
          const i = this._layers[e];
          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {
            const e = this._getLayerSourceCache(i);
            e && (e.used = !0);
          }
          const o = this.map.painter;
          if (o) {
            const e = i.getProgramIds();
            if (!e) continue;
            const r = i.getProgramConfiguration(t.zoom);
            for (const t of e) o.useProgram(t, r);
          }
        }
        for (const t in o) {
          const i = this._sourceCaches[t];
          o[t] !== i.used && i.getSource().fire(new e.Event("data", {
            sourceDataType: "visibility",
            dataType: "source",
            sourceId: i.getSource().id
          }));
        }
        this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e.Event("data", {
          dataType: "style"
        }));
      }
      _updateTilesForChangedImages() {
        const e = Object.keys(this._changedImages);
        if (e.length) {
          for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e);
          this._changedImages = {};
        }
      }
      _updateWorkerLayers(e, t) {
        this.dispatcher.broadcast("updateLayers", {
          layers: this._serializeLayers(e),
          removedIds: t
        });
      }
      _resetUpdates() {
        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
      }
      setState(i) {
        if (this._checkLoaded(), $t(this, e.validateStyle(i))) return !1;
        (i = e.clone$1(i)).layers = Ve(i.layers);
        const o = function (e, i) {
          if (!e) return [{
            command: We.setStyle,
            args: [i]
          }];
          let o = [];
          try {
            if (!t(e.version, i.version)) return [{
              command: We.setStyle,
              args: [i]
            }];
            t(e.center, i.center) || o.push({
              command: We.setCenter,
              args: [i.center]
            }), t(e.zoom, i.zoom) || o.push({
              command: We.setZoom,
              args: [i.zoom]
            }), t(e.bearing, i.bearing) || o.push({
              command: We.setBearing,
              args: [i.bearing]
            }), t(e.pitch, i.pitch) || o.push({
              command: We.setPitch,
              args: [i.pitch]
            }), t(e.sprite, i.sprite) || o.push({
              command: We.setSprite,
              args: [i.sprite]
            }), t(e.glyphs, i.glyphs) || o.push({
              command: We.setGlyphs,
              args: [i.glyphs]
            }), t(e.transition, i.transition) || o.push({
              command: We.setTransition,
              args: [i.transition]
            }), t(e.light, i.light) || o.push({
              command: We.setLight,
              args: [i.light]
            }), t(e.fog, i.fog) || o.push({
              command: We.setFog,
              args: [i.fog]
            }), t(e.projection, i.projection) || o.push({
              command: We.setProjection,
              args: [i.projection]
            });
            const r = {},
              n = [];
            !function (e, i, o, r) {
              let n;
              for (n in i = i || {}, e = e || {}) e.hasOwnProperty(n) && (i.hasOwnProperty(n) || qe(n, o, r));
              for (n in i) i.hasOwnProperty(n) && (e.hasOwnProperty(n) ? t(e[n], i[n]) || ("geojson" === e[n].type && "geojson" === i[n].type && He(e, i, n) ? o.push({
                command: We.setGeoJSONSourceData,
                args: [n, i[n].data]
              }) : $e(n, i, o, r)) : Xe(n, i, o));
            }(e.sources, i.sources, n, r);
            const s = [];
            e.layers && e.layers.forEach(e => {
              e.source && r[e.source] ? o.push({
                command: We.removeLayer,
                args: [e.id]
              }) : s.push(e);
            });
            let a = e.terrain;
            a && r[a.source] && (o.push({
              command: We.setTerrain,
              args: [void 0]
            }), a = void 0), o = o.concat(n), t(a, i.terrain) || o.push({
              command: We.setTerrain,
              args: [i.terrain]
            }), function (e, i, o) {
              i = i || [];
              const r = (e = e || []).map(Ke),
                n = i.map(Ke),
                s = e.reduce(Je, {}),
                a = i.reduce(Je, {}),
                l = r.slice(),
                c = Object.create(null);
              let h, u, _, d, p, m, f;
              for (h = 0, u = 0; h < r.length; h++) _ = r[h], a.hasOwnProperty(_) ? u++ : (o.push({
                command: We.removeLayer,
                args: [_]
              }), l.splice(l.indexOf(_, u), 1));
              for (h = 0, u = 0; h < n.length; h++) _ = n[n.length - 1 - h], l[l.length - 1 - h] !== _ && (s.hasOwnProperty(_) ? (o.push({
                command: We.removeLayer,
                args: [_]
              }), l.splice(l.lastIndexOf(_, l.length - u), 1)) : u++, m = l[l.length - h], o.push({
                command: We.addLayer,
                args: [a[_], m]
              }), l.splice(l.length - h, 0, _), c[_] = !0);
              for (h = 0; h < n.length; h++) if (_ = n[h], d = s[_], p = a[_], !c[_] && !t(d, p)) if (t(d.source, p.source) && t(d["source-layer"], p["source-layer"]) && t(d.type, p.type)) {
                for (f in Ye(d.layout, p.layout, o, _, null, We.setLayoutProperty), Ye(d.paint, p.paint, o, _, null, We.setPaintProperty), t(d.filter, p.filter) || o.push({
                  command: We.setFilter,
                  args: [_, p.filter]
                }), t(d.minzoom, p.minzoom) && t(d.maxzoom, p.maxzoom) || o.push({
                  command: We.setLayerZoomRange,
                  args: [_, p.minzoom, p.maxzoom]
                }), d) d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Ye(d[f], p[f], o, _, f.slice(6), We.setPaintProperty) : t(d[f], p[f]) || o.push({
                  command: We.setLayerProperty,
                  args: [_, f, p[f]]
                }));
                for (f in p) p.hasOwnProperty(f) && !d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Ye(d[f], p[f], o, _, f.slice(6), We.setPaintProperty) : t(d[f], p[f]) || o.push({
                  command: We.setLayerProperty,
                  args: [_, f, p[f]]
                }));
              } else o.push({
                command: We.removeLayer,
                args: [_]
              }), m = l[l.lastIndexOf(_) + 1], o.push({
                command: We.addLayer,
                args: [p, m]
              });
            }(s, i.layers, o);
          } catch (e) {
            console.warn("Unable to compute style diff:", e), o = [{
              command: We.setStyle,
              args: [i]
            }];
          }
          return o;
        }(this.serialize(), i).filter(e => !(e.command in Yt));
        if (0 === o.length) return !1;
        const r = o.filter(e => !(e.command in Ht));
        if (r.length > 0) throw new Error(`Unimplemented: ${r.map(e => e.command).join(", ")}.`);
        return o.forEach(e => {
          "setTransition" !== e.command && "setProjection" !== e.command && this[e.command].apply(this, e.args);
        }), this.stylesheet = i, this._updateMapProjection(), !0;
      }
      addImage(t, i) {
        return this.getImage(t) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, i), this._afterImageUpdated(t), this);
      }
      updateImage(e, t) {
        this.imageManager.updateImage(e, t);
      }
      getImage(e) {
        return this.imageManager.getImage(e);
      }
      removeImage(t) {
        return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
      }
      _afterImageUpdated(t) {
        this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", {
          dataType: "style"
        }));
      }
      listImages() {
        return this._checkLoaded(), this._availableImages.slice();
      }
      addSource(t, i, o = {}) {
        if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error("There is already a source with this ID");
        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
        if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(e.validateSource, `sources.${t}`, i, null, o)) return;
        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
        const r = Pe(t, i, this.dispatcher, this);
        r.setEventedParent(this, () => ({
          isSourceLoaded: this._isSourceCacheLoaded(t),
          source: r.serialize(),
          sourceId: t
        }));
        const n = i => {
          const o = (i ? "symbol:" : "other:") + t,
            n = this._sourceCaches[o] = new e.SourceCache(o, r, i);
          (i ? this._symbolSourceCaches : this._otherSourceCaches)[t] = n, n.style = this, n.onAdd(this.map);
        };
        n(!1), "vector" !== i.type && "geojson" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;
      }
      removeSource(t) {
        this._checkLoaded();
        const i = this.getSource(t);
        if (!i) throw new Error("There is no source with this ID");
        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`)));
        if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
        const o = this._getSourceCaches(t);
        for (const t of o) delete this._sourceCaches[t.id], delete this._updatedSources[t.id], t.fire(new e.Event("data", {
          sourceDataType: "metadata",
          dataType: "source",
          sourceId: t.getSource().id
        })), t.setEventedParent(null), t.clearTiles();
        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;
      }
      setGeoJSONSourceData(e, t) {
        this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0;
      }
      getSource(e) {
        const t = this._getSourceCache(e);
        return t && t.getSource();
      }
      _getSources() {
        const e = [];
        for (const t in this._otherSourceCaches) {
          const i = this._getSourceCache(t);
          i && e.push(i.getSource());
        }
        return e;
      }
      addLayer(t, i, o = {}) {
        this._checkLoaded();
        const r = t.id;
        if (this.getLayer(r)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
        let n;
        if ("custom" === t.type) {
          if ($t(this, e.validateCustomStyleLayer(t))) return;
          n = e.createStyleLayer(t);
        } else {
          if ("object" == typeof t.source && (this.addSource(r, t.source), t = e.clone$1(t), t = e.extend(t, {
            source: r
          })), this._validate(e.validateLayer, `layers.${r}`, t, {
            arrayIndex: -1
          }, o)) return;
          n = e.createStyleLayer(t), this._validateLayer(n), n.setEventedParent(this, {
            layer: {
              id: r
            }
          }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);
        }
        const s = i ? this._order.indexOf(i) : this._order.length;
        if (i && -1 === s) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
        this._order.splice(s, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;
        const a = this._getLayerSourceCache(n);
        if (this._removedLayers[r] && n.source && a && "custom" !== n.type) {
          const e = this._removedLayers[r];
          delete this._removedLayers[r], e.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload", a.pause());
        }
        this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();
      }
      moveLayer(t, i) {
        if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
        if (t === i) return;
        const o = this._order.indexOf(t);
        this._order.splice(o, 1);
        const r = i ? this._order.indexOf(i) : this._order.length;
        i && -1 === r ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
      }
      removeLayer(t) {
        this._checkLoaded();
        const i = this._layers[t];
        if (!i) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));
        i.setEventedParent(null), this._updateLayerCount(i, !1);
        const o = this._order.indexOf(t);
        this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = i, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();
      }
      getLayer(e) {
        return this._layers[e];
      }
      hasLayer(e) {
        return e in this._layers;
      }
      hasLayerType(e) {
        for (const t in this._layers) if (this._layers[t].type === e) return !0;
        return !1;
      }
      setLayerZoomRange(t, i, o) {
        this._checkLoaded();
        const r = this.getLayer(t);
        r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));
      }
      setFilter(i, o, r = {}) {
        this._checkLoaded();
        const n = this.getLayer(i);
        if (n) {
          if (!t(n.filter, o)) return null == o ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e.validateFilter, `layers.${n.id}.filter`, o, {
            layerType: n.type
          }, r) || (n.filter = e.clone$1(o), this._updateLayer(n)));
        } else this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));
      }
      getFilter(t) {
        const i = this.getLayer(t);
        return i && e.clone$1(i.filter);
      }
      setLayoutProperty(i, o, r, n = {}) {
        this._checkLoaded();
        const s = this.getLayer(i);
        s ? t(s.getLayoutProperty(o), r) || (s.setLayoutProperty(o, r, n), this._updateLayer(s)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
      }
      getLayoutProperty(t, i) {
        const o = this.getLayer(t);
        if (o) return o.getLayoutProperty(i);
        this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));
      }
      setPaintProperty(i, o, r, n = {}) {
        this._checkLoaded();
        const s = this.getLayer(i);
        s ? t(s.getPaintProperty(o), r) || (s.setPaintProperty(o, r, n) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[i] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
      }
      getPaintProperty(e, t) {
        const i = this.getLayer(e);
        return i && i.getPaintProperty(t);
      }
      setFeatureState(t, i) {
        this._checkLoaded();
        const o = t.source,
          r = t.sourceLayer,
          n = this.getSource(o);
        if (!n) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
        const s = n.type;
        if ("geojson" === s && r) return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
        if ("vector" === s && !r) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
        const a = this._getSourceCaches(o);
        for (const e of a) e.setFeatureState(r, t.id, i);
      }
      removeFeatureState(t, i) {
        this._checkLoaded();
        const o = t.source,
          r = this.getSource(o);
        if (!r) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
        const n = r.type,
          s = "vector" === n ? t.sourceLayer : void 0;
        if ("vector" === n && !s) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        if (i && "string" != typeof t.id && "number" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
        const a = this._getSourceCaches(o);
        for (const e of a) e.removeFeatureState(s, t.id, i);
      }
      getFeatureState(t) {
        this._checkLoaded();
        const i = t.source,
          o = t.sourceLayer,
          r = this.getSource(i);
        if (r) {
          if ("vector" !== r.type || o) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i)[0].getFeatureState(o, t.id);
          this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        } else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
      }
      getTransition() {
        return e.extend({
          duration: 300,
          delay: 0
        }, this.stylesheet && this.stylesheet.transition);
      }
      serialize() {
        const t = {};
        for (const e in this._sourceCaches) {
          const i = this._sourceCaches[e].getSource();
          t[i.id] || (t[i.id] = i.serialize());
        }
        return e.filterObject({
          version: this.stylesheet.version,
          name: this.stylesheet.name,
          metadata: this.stylesheet.metadata,
          light: this.stylesheet.light,
          terrain: this.getTerrain() || void 0,
          fog: this.stylesheet.fog,
          center: this.stylesheet.center,
          zoom: this.stylesheet.zoom,
          bearing: this.stylesheet.bearing,
          pitch: this.stylesheet.pitch,
          sprite: this.stylesheet.sprite,
          glyphs: this.stylesheet.glyphs,
          transition: this.stylesheet.transition,
          projection: this.stylesheet.projection,
          sources: t,
          layers: this._serializeLayers(this._order)
        }, e => void 0 !== e);
      }
      _updateLayer(e) {
        this._updatedLayers[e.id] = !0;
        const t = this._getLayerSourceCache(e);
        e.source && !this._updatedSources[e.source] && t && "raster" !== t.getSource().type && (this._updatedSources[e.source] = "reload", t.pause()), this._changed = !0, e.invalidateCompiledFilter();
      }
      _flattenAndSortRenderedFeatures(e) {
        const t = e => "fill-extrusion" === this._layers[e].type,
          i = {},
          o = [];
        for (let r = this._order.length - 1; r >= 0; r--) {
          const n = this._order[r];
          if (t(n)) {
            i[n] = r;
            for (const t of e) {
              const e = t[n];
              if (e) for (const t of e) o.push(t);
            }
          }
        }
        o.sort((e, t) => t.intersectionZ - e.intersectionZ);
        const r = [];
        for (let n = this._order.length - 1; n >= 0; n--) {
          const s = this._order[n];
          if (t(s)) for (let e = o.length - 1; e >= 0; e--) {
            const t = o[e].feature;
            if (i[t.layer.id] < n) break;
            r.push(t), o.pop();
          } else for (const t of e) {
            const e = t[s];
            if (e) for (const t of e) r.push(t.feature);
          }
        }
        return r;
      }
      queryRenderedFeatures(t, i, o) {
        i && i.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
        const r = {};
        if (i && i.layers) {
          if (!Array.isArray(i.layers)) return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
          for (const t of i.layers) {
            const i = this._layers[t];
            if (!i) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];
            r[i.source] = !0;
          }
        }
        const n = [];
        i.availableImages = this._availableImages;
        const s = i && i.layers ? i.layers.some(e => {
            const t = this.getLayer(e);
            return t && t.is3D();
          }) : this.has3DLayers(),
          a = R.createFromScreenPoints(t, o);
        for (const e in this._sourceCaches) {
          const t = this._sourceCaches[e].getSource().id;
          i.layers && !r[t] || n.push(Oe(this._sourceCaches[e], this._layers, this._serializedLayers, a, i, o, s, !!this.map._showQueryGeometry));
        }
        return this.placement && n.push(function (e, t, i, o, r, n, s) {
          const a = {},
            l = n.queryRenderedSymbols(o),
            c = [];
          for (const e of Object.keys(l).map(Number)) c.push(s[e]);
          c.sort(ke);
          for (const i of c) {
            const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);
            for (const e in o) {
              const t = a[e] = a[e] || [],
                r = o[e];
              r.sort((e, t) => {
                const o = i.featureSortOrder;
                if (o) {
                  const i = o.indexOf(e.featureIndex);
                  return o.indexOf(t.featureIndex) - i;
                }
                return t.featureIndex - e.featureIndex;
              });
              for (const e of r) t.push(e);
            }
          }
          for (const t in a) a[t].forEach(o => {
            const r = o.feature,
              n = i(e[t]).getFeatureState(r.layer["source-layer"], r.id);
            r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = n;
          });
          return a;
        }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);
      }
      querySourceFeatures(t, i) {
        i && i.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
        const o = this._getSourceCaches(t);
        let r = [];
        for (const e of o) r = r.concat(Be(e, i));
        return r;
      }
      addSourceType(e, t, i) {
        return Qt.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (Qt.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
          name: e,
          url: t.workerSourceURL
        }, i) : i(null, null));
      }
      getLight() {
        return this.light.getLight();
      }
      setLight(e, i = {}) {
        this._checkLoaded();
        const o = this.light.getLight();
        let r = !1;
        for (const i in e) if (!t(e[i], o[i])) {
          r = !0;
          break;
        }
        if (!r) return;
        const n = this._setTransitionParameters({
          duration: 300,
          delay: 0
        });
        this.light.setLight(e, i), this.light.updateTransitions(n);
      }
      getTerrain() {
        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
      }
      setTerrainForDraping() {
        this.setTerrain({
          source: "",
          exaggeration: 0
        }, 0);
      }
      setTerrain(i, o = 1) {
        if (this._checkLoaded(), !i) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
        if (1 === o) {
          if ("object" == typeof i.source) {
            const t = "terrain-dem-src";
            this.addSource(t, i.source), i = e.clone$1(i), i = e.extend(i, {
              source: t
            });
          }
          if (this._validate(e.validateTerrain, "terrain", i)) return;
        }
        if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) this._createTerrain(i, o);else {
          const o = this.terrain,
            r = o.get();
          for (const t of Object.keys(e.spec.terrain)) !i.hasOwnProperty(t) && e.spec.terrain[t].default && (i[t] = e.spec.terrain[t].default);
          for (const e in i) if (!t(i[e], r[e])) {
            o.set(i), this.stylesheet.terrain = i;
            const e = this._setTransitionParameters({
              duration: 0
            });
            o.updateTransitions(e);
            break;
          }
        }
        this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
      }
      _createFog(e) {
        const t = this.fog = new A(e, this.map.transform);
        this.stylesheet.fog = e;
        const i = this._setTransitionParameters({
          duration: 0
        });
        t.updateTransitions(i);
      }
      _updateMarkersOpacity() {
        0 !== this.map._markers.length && this.map._requestDomTask(() => {
          for (const e of this.map._markers) e._evaluateOpacity();
        });
      }
      getFog() {
        return this.fog ? this.fog.get() : null;
      }
      setFog(e) {
        if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
        if (this.fog) {
          const i = this.fog,
            o = i.get();
          0 === Object.keys(e).length && i.set(e);
          for (const r in e) if (!t(e[r], o[r])) {
            i.set(e), this.stylesheet.fog = e;
            const t = this._setTransitionParameters({
              duration: 0
            });
            i.updateTransitions(t);
            break;
          }
        } else this._createFog(e);
        this._markersNeedUpdate = !0;
      }
      _setTransitionParameters(t) {
        return {
          now: e.exported.now(),
          transition: e.extend(t, this.stylesheet.transition)
        };
      }
      _updateDrapeFirstLayers() {
        if (!this.map._optimizeForTerrain || !this.terrain) return;
        const e = this._order.filter(e => this.isLayerDraped(this._layers[e])),
          t = this._order.filter(e => !this.isLayerDraped(this._layers[e]));
        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);
      }
      _createTerrain(e, t) {
        const i = this.terrain = new M(e, t);
        this.stylesheet.terrain = e, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
        const o = this._setTransitionParameters({
          duration: 0
        });
        i.updateTransitions(o);
      }
      _force3DLayerUpdate() {
        for (const e in this._layers) {
          const t = this._layers[e];
          "fill-extrusion" === t.type && this._updateLayer(t);
        }
      }
      _forceSymbolLayerUpdate() {
        for (const e in this._layers) {
          const t = this._layers[e];
          "symbol" === t.type && this._updateLayer(t);
        }
      }
      _validate(t, i, o, r, n = {}) {
        return (!n || !1 !== n.validate) && $t(this, t.call(e.validateStyle, e.extend({
          key: i,
          style: this.serialize(),
          value: o,
          styleSpec: e.spec
        }, r)));
      }
      _remove() {
        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
        for (const e in this._layers) this._layers[e].setEventedParent(null);
        for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null);
        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
      }
      _clearSource(e) {
        const t = this._getSourceCaches(e);
        for (const e of t) e.clearTiles();
      }
      _reloadSource(e) {
        const t = this._getSourceCaches(e);
        for (const e of t) e.resume(), e.reload();
      }
      _reloadSources() {
        for (const e of this._getSources()) e.reload && e.reload();
      }
      _updateSources(e) {
        for (const t in this._sourceCaches) this._sourceCaches[t].update(e);
      }
      _generateCollisionBoxes() {
        for (const e in this._sourceCaches) {
          const t = this._sourceCaches[e];
          t.resume(), t.reload();
        }
      }
      _updatePlacement(t, i, o, r, n = !1) {
        let s = !1,
          a = !1;
        const l = {};
        for (const e of this._order) {
          const i = this._layers[e];
          if ("symbol" !== i.type) continue;
          if (!l[i.source]) {
            const e = this._getLayerSourceCache(i);
            if (!e) continue;
            l[i.source] = e.getRenderableIds(!0).map(t => e.getTileByID(t)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));
          }
          const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t.center.lng, t.projection);
          s = s || o;
        }
        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new jt(t, this._order, n, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a = !0), s && this.pauseablePlacement.placement.setStale()), a || s) for (const e of this._order) {
          const t = this._layers[e];
          "symbol" === t.type && this.placement.updateLayerOpacities(t, l[t.source]);
        }
        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
      }
      _releaseSymbolFadeTiles() {
        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();
      }
      getImages(e, t, i) {
        this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();
        const o = e => {
          e && e.setDependencies(t.tileID.key, t.type, t.icons);
        };
        o(this._otherSourceCaches[t.source]), o(this._symbolSourceCaches[t.source]);
      }
      getGlyphs(e, t, i) {
        this.glyphManager.getGlyphs(t.stacks, i);
      }
      getResource(t, i, o) {
        return e.makeRequest(i, o);
      }
      _getSourceCache(e) {
        return this._otherSourceCaches[e];
      }
      _getLayerSourceCache(e) {
        return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
      }
      _getSourceCaches(e) {
        const t = [];
        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;
      }
      _isSourceCacheLoaded(t) {
        const i = this._getSourceCaches(t);
        return 0 === i.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());
      }
      has3DLayers() {
        return this._num3DLayers > 0;
      }
      hasSymbolLayers() {
        return this._numSymbolLayers > 0;
      }
      hasCircleLayers() {
        return this._numCircleLayers > 0;
      }
      _clearWorkerCaches() {
        this.dispatcher.broadcast("clearCaches");
      }
      destroy() {
        this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
      }
    }
    Qt.getSourceType = function (e) {
      return ze[e];
    }, Qt.setSourceType = function (e, t) {
      ze[e] = t;
    }, Qt.registerForPluginStateChange = e.registerForPluginStateChange;
    var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0",
      ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
      ii = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",
      oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",
      ri = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
    let ni = {},
      si = {};
    const ai = [];
    _i(ei, ai), _i(ii, ai), _i(oi, ai), _i(ri, ai), ni = di("", ii), si = di(ri, oi);
    const li = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."),
      ci = ei,
      hi = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
    var ui = {
      background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
      clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
      heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
      collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
      collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
      debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
      fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
      hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
      hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
      symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
      symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
      terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
      terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
      skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
      skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
      skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
      globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
      globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")
    };
    function _i(e, t) {
      const i = e.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
      for (let e of i) if (e = e.trim(), "#" === e[0] && e.includes("if") && !e.includes("endif")) {
        e = e.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
        const i = e.split(" ");
        for (const e of i) t.includes(e) || t.push(e);
      }
    }
    function di(e, t) {
      const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
        o = t.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g),
        r = {},
        n = [...ai];
      return _i(e, n), _i(t, n), {
        fragmentSource: e = e.replace(i, (e, t, i, o, n) => (r[n] = !0, "define" === t ? `\n#ifndef HAS_UNIFORM_u_${n}\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = u_${n};\n#endif\n`)),
        vertexSource: t = t.replace(i, (e, t, i, o, n) => {
          const s = "float" === o ? "vec2" : "vec4",
            a = n.match(/color/) ? "color" : s;
          return r[n] ? "define" === t ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\nvarying ${i} ${o} ${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : "define" === t ? `\n#ifndef HAS_UNIFORM_u_${n}\nuniform lowp float u_${n}_t;\nattribute ${i} ${s} a_${n};\n#else\nuniform ${i} ${o} u_${n};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = a_${n};\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n}\n    ${i} ${o} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\n#else\n    ${i} ${o} ${n} = u_${n};\n#endif\n`;
        }),
        staticAttributes: o,
        usedDefines: n
      };
    }
    class pi {
      constructor() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
      }
      bind(e, t, i, o, r, n, s) {
        this.context = e;
        let a = this.boundPaintVertexBuffers.length !== o.length;
        for (let e = 0; !a && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (a = !0);
        let l = this.boundDynamicVertexBuffers.length !== s.length;
        for (let e = 0; !l && e < s.length; e++) this.boundDynamicVertexBuffers[e] !== s[e] && (l = !0);
        if (!e.extVertexArrayObject || !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== n) this.freshBind(t, i, o, r, n, s);else {
          e.bindVertexArrayOES.set(this.vao);
          for (const e of s) e && e.bind();
          r && r.dynamicDraw && r.bind();
        }
      }
      freshBind(e, t, i, o, r, n) {
        let s;
        const a = e.numAttributes,
          l = this.context,
          c = l.gl;
        if (l.extVertexArrayObject) this.vao && this.destroy(), this.vao = l.extVertexArrayObject.createVertexArrayOES(), l.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n;else {
          s = l.currentNumAttributes || 0;
          for (let e = a; e < s; e++) c.disableVertexAttribArray(e);
        }
        t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);
        for (const t of i) t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);
        for (const t of n) t && (t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r));
        o && o.bind(), l.currentNumAttributes = a;
      }
      destroy() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      }
    }
    function mi(t, i) {
      const o = Math.pow(2, i.canonical.z),
        r = i.canonical.y;
      return [new e.MercatorCoordinate(0, r / o).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat];
    }
    function fi(t, i, o, r, n, s, a) {
      const l = t.context,
        c = l.gl,
        h = o.fbo;
      if (!h) return;
      t.prepareDrawTile();
      const u = t.useProgram("hillshade");
      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
      const _ = ((e, t, i, o) => {
        const r = i.paint.get("hillshade-shadow-color"),
          n = i.paint.get("hillshade-highlight-color"),
          s = i.paint.get("hillshade-accent-color");
        let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
        "viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= e.transform.angle);
        const l = !e.options.moving;
        return {
          u_matrix: o || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), l),
          u_image: 0,
          u_latrange: mi(0, t.tileID),
          u_light: [i.paint.get("hillshade-exaggeration"), a],
          u_shadow: r,
          u_highlight: n,
          u_accent: s
        };
      })(t, o, r, t.terrain ? i.projMatrix : null);
      t.prepareDrawProgram(l, u, i.toUnwrapped());
      const {
        tileBoundsBuffer: d,
        tileBoundsIndexBuffer: p,
        tileBoundsSegments: m
      } = t.getTileBoundsBuffers(o);
      u.draw(l, c.TRIANGLES, n, s, a, e.CullFaceMode.disabled, _, r.id, d, p, m);
    }
    function gi(t, i, o) {
      if (!i.needsDEMTextureUpload) return;
      const r = t.context,
        n = r.gl;
      r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);
      const s = o.getPixels();
      i.demTexture ? i.demTexture.update(s, {
        premultiply: !1
      }) : i.demTexture = new e.Texture(r, s, n.RGBA, {
        premultiply: !1
      }), i.needsDEMTextureUpload = !1;
    }
    function vi(t, i, o, r, n, s) {
      const a = t.context,
        l = a.gl;
      if (!i.dem) return;
      const c = i.dem;
      if (a.activeTexture.set(l.TEXTURE1), gi(t, i, c), !i.demTexture) return;
      i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
      const h = c.dim;
      a.activeTexture.set(l.TEXTURE0);
      let u = i.fbo;
      if (!u) {
        const t = new e.Texture(a, {
          width: h,
          height: h,
          data: null
        }, l.RGBA);
        t.bind(l.LINEAR, l.CLAMP_TO_EDGE), u = i.fbo = a.createFramebuffer(h, h, !0), u.colorAttachment.set(t.texture);
      }
      a.bindFramebuffer.set(u.framebuffer), a.viewport.set([0, 0, h, h]);
      const {
        tileBoundsBuffer: _,
        tileBoundsIndexBuffer: d,
        tileBoundsSegments: p
      } = t.getMercatorTileBoundsBuffers();
      t.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, r, n, s, e.CullFaceMode.disabled, ((t, i) => {
        const o = i.stride,
          r = e.create();
        return e.ortho(r, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r, r, [0, -e.EXTENT, 0]), {
          u_matrix: r,
          u_image: 1,
          u_dimension: [o, o],
          u_zoom: t.overscaledZ,
          u_unpack: i.unpackVector
        };
      })(i.tileID, c), o.id, _, d, p), i.needsHillshadePrepare = !1;
    }
    const xi = t => ({
        u_matrix: new e.UniformMatrix4f(t),
        u_image0: new e.Uniform1i(t),
        u_skirt_height: new e.Uniform1f(t)
      }),
      yi = (e, t) => ({
        u_matrix: e,
        u_image0: 0,
        u_skirt_height: t
      }),
      bi = (e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) => ({
        u_proj_matrix: Float32Array.from(e),
        u_globe_matrix: t,
        u_normalize_matrix: Float32Array.from(o),
        u_merc_matrix: i,
        u_zoom_transition: r,
        u_merc_center: n,
        u_image0: 0,
        u_frustum_tl: s,
        u_frustum_tr: a,
        u_frustum_br: l,
        u_frustum_bl: c,
        u_globe_pos: h,
        u_globe_radius: u,
        u_viewport: _,
        u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9),
        u_skirt_height: d
      });
    function wi(e, t) {
      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;
    }
    const Ti = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e, t, i, o, r) {
          if (e in this.operations) {
            const t = this.operations[e];
            t.to.tileID.key !== i.tileID.key && (t.queued = i);
          } else this.operations[e] = {
            startTime: o,
            phase: 0,
            duration: r,
            from: t,
            to: i,
            queued: null
          };
        }
        getMorphValuesForProxy(e) {
          if (!(e in this.operations)) return null;
          const t = this.operations[e];
          return {
            from: t.from,
            to: t.to,
            phase: t.phase
          };
        }
        update(e) {
          for (const t in this.operations) {
            const i = this.operations[t];
            for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {
              delete this.operations[t];
              break;
            }
          }
        }
        _nextOp(e, t) {
          return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);
        }
        _validOp(e) {
          return e.from.hasData() && e.to.hasData();
        }
      }(),
      Ei = {
        0: null,
        1: "TERRAIN_VERTEX_MORPHING",
        2: "TERRAIN_WIREFRAME"
      };
    function Ci(e) {
      return 6 * Math.pow(1.5, 22 - e);
    }
    function Mi(e, t) {
      const i = 1 << e.z;
      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
    }
    const Ii = e => ({
      u_matrix: e
    });
    function Si(t, i, o, r, n) {
      if (n > 0) {
        const s = e.exported.now(),
          a = (s - t.timeAdded) / n,
          l = i ? (s - i.timeAdded) / n : -1,
          c = o.getSource(),
          h = r.coveringZoomLevel({
            tileSize: c.tileSize,
            roundZoom: c.roundZoom
          }),
          u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),
          _ = u && t.refreshedUponExpiration ? 1 : e.clamp(u ? a : 1 - l, 0, 1);
        return t.refreshedUponExpiration && a >= 1 && (t.refreshedUponExpiration = !1), i ? {
          opacity: 1,
          mix: 1 - _
        } : {
          opacity: _,
          mix: 0
        };
      }
      return {
        opacity: 1,
        mix: 0
      };
    }
    class Di extends e.SourceCache {
      constructor(e) {
        const t = {
            type: "raster-dem",
            maxzoom: e.transform.maxZoom
          },
          i = new z(je(), null),
          o = Pe("mock-dem", t, i, e.style);
        super("mock-dem", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;
      }
      _loadTile(e, t) {
        e.state = "loaded", t(null);
      }
    }
    class Li extends e.SourceCache {
      constructor(e) {
        const t = Pe("proxy", {
          type: "geojson",
          maxzoom: e.transform.maxZoom
        }, new z(je(), null), e.style);
        super("proxy", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
      }
      update(t, i, o) {
        if (t.freezeTileCoverage) return;
        this.transform = t;
        const r = t.coveringTiles({
          tileSize: this._source.tileSize,
          minzoom: this._source.minzoom,
          maxzoom: this._source.maxzoom,
          roundZoom: this._source.roundZoom,
          reparseOverscaled: this._source.reparseOverscaled
        }).reduce((i, o) => {
          if (i[o.key] = "", !this._tiles[o.key]) {
            const i = new e.Tile(o, this._source.tileSize * o.overscaleFactor(), t.tileZoom);
            i.state = "loaded", this._tiles[o.key] = i;
          }
          return i;
        }, {});
        for (const e in this._tiles) e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
      }
      freeFBO(e) {
        const t = this.proxyCachedFBO[e];
        if (void 0 !== t) {
          const i = Object.values(t);
          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
        }
      }
      deallocRenderCache() {
        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
      }
    }
    class Ai extends e.OverscaledTileID {
      constructor(e, t, i) {
        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;
      }
    }
    class zi extends e.Elevation {
      constructor(t, i) {
        super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
        const [o, r, n] = function (t) {
            const i = new e.StructArrayLayout2i4(),
              o = new e.StructArrayLayout3ui6(),
              r = 131;
            i.reserve(17161), o.reserve(33800);
            const n = e.EXTENT / 128,
              s = e.EXTENT + n / 2,
              a = s + n;
            for (let t = -n; t < a; t += n) for (let o = -n; o < a; o += n) {
              const r = o < 0 || o > s || t < 0 || t > s ? 24575 : 0,
                n = e.clamp(Math.round(o), 0, e.EXTENT),
                a = e.clamp(Math.round(t), 0, e.EXTENT);
              i.emplaceBack(n + r, a);
            }
            const l = (e, t) => {
              const i = t * r + e;
              o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
            };
            for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);
            return [0, 129].forEach(e => {
              for (let t = 0; t < 130; t++) l(t, e), l(e, t);
            }), [i, o, 32768];
          }(),
          s = t.context;
        this.gridBuffer = s.createVertexBuffer(o, e.posAttributes.members), this.gridIndexBuffer = s.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Li(i.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);
        const a = s.gl;
        this._overlapStencilMode = new e.StencilMode({
          func: a.GEQUAL,
          mask: 255
        }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Di(i.map);
      }
      set style(e) {
        e.on("data", this._onStyleDataEvent.bind(this)), e.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
          this._clearLineLayersFromRenderCache();
        });
      }
      update(t, i, o) {
        if (t && t.terrain) {
          this._style !== t && (this.style = t), this.enabled = !0;
          const r = t.terrain.properties;
          this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");
          const n = () => {
            this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
            const t = this.getScaledDemTileSize();
            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);
          };
          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;
        } else this._disable();
      }
      resetTileLookupCache(e) {
        this._findCoveringTileCache[e] = {};
      }
      getScaledDemTileSize() {
        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
      }
      _checkRenderCacheEfficiency() {
        const t = this.renderCacheEfficiency(this._style);
        this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
      }
      _onStyleDataEvent(e) {
        e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this._invalidateRenderCache = !0);
      }
      _disable() {
        if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1;
      }
      destroy() {
        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
      }
      _source() {
        return this.enabled ? this.sourceCache : null;
      }
      isUsingMockSource() {
        return this.sourceCache === this._mockSourceCache;
      }
      exaggeration() {
        return this._exaggeration;
      }
      get visibleDemTiles() {
        return this._visibleDemTiles;
      }
      get drapeBufferSize() {
        const e = 2 * this.proxySourceCache.getSource().tileSize;
        return [e, e];
      }
      set useVertexMorphing(e) {
        this._useVertexMorphing = e;
      }
      updateTileBinding(t) {
        if (!this.enabled) return;
        this.prevTerrainTileForTile = this.terrainTileForTile;
        const i = this.proxySourceCache,
          o = this.painter.transform;
        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
        const r = this.proxyCoords = i.getIds().map(e => {
          const t = i.getTileByID(e).tileID;
          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;
        });
        !function (t, i) {
          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),
            r = new e.pointGeometry(o.x, o.y);
          t.sort((t, i) => {
            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;
            const o = new e.pointGeometry(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),
              n = new e.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),
              s = r.mult(1 << t.canonical.z);
            return s.x -= .5, s.y -= .5, s.distSqr(o) - s.distSqr(n);
          });
        }(r, this.painter), this._previousZoom = o.zoom;
        const n = this.proxyToSource || {};
        this.proxyToSource = {}, r.forEach(e => {
          this.proxyToSource[e.key] = {};
        }), this.terrainTileForTile = {};
        const s = this._style._sourceCaches;
        for (const e in s) {
          const i = s[e];
          if (!i.used) continue;
          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], n), i.usedForTerrain) continue;
          const o = t[e];
          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
        }
        this.proxiedCoords[i.id] = r.map(e => new Ai(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now();
        const a = {};
        this._visibleDemTiles = [];
        for (const e of this.proxyCoords) {
          const t = this.terrainTileForTile[e.key];
          if (!t) continue;
          const i = t.tileID.key;
          i in a || (this._visibleDemTiles.push(t), a[i] = i);
        }
      }
      _assignTerrainTiles(e) {
        this._initializing || e.forEach(e => {
          if (this.terrainTileForTile[e.key]) return;
          const t = this._findTileCoveringTileID(e, this.sourceCache);
          t && (this.terrainTileForTile[e.key] = t);
        });
      }
      _prepareDEMTextures() {
        const e = this.painter.context,
          t = e.gl;
        for (const i in this.terrainTileForTile) {
          const o = this.terrainTileForTile[i],
            r = o.dem;
          !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), gi(this.painter, o, r));
        }
      }
      _prepareDemTileUniforms(e, t, i, o) {
        if (!t || null == t.demTexture) return !1;
        const r = e.tileID.canonical,
          n = Math.pow(2, t.tileID.canonical.z - r.z),
          s = o || "";
        return i[`u_dem_tl${s}`] = [r.x * n % 1, r.y * n % 1], i[`u_dem_scale${s}`] = n, !0;
      }
      get emptyDEMTexture() {
        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
      }
      get emptyDepthBufferTexture() {
        const t = this.painter.context,
          i = t.gl;
        if (!this._emptyDepthBufferTexture) {
          const o = new e.RGBAImage({
            width: 1,
            height: 1
          }, Uint8Array.of(255, 255, 255, 255));
          this._emptyDepthBufferTexture = new e.Texture(t, o, i.RGBA, {
            premultiply: !1
          });
        }
        return this._emptyDepthBufferTexture;
      }
      _getLoadedAreaMinimum() {
        let e = 0;
        const t = this._visibleDemTiles.reduce((t, i) => {
          if (!i.dem) return t;
          const o = i.dem.tree.minimums[0];
          return o > 0 && e++, t + o;
        }, 0);
        return e ? t / e : 0;
      }
      _updateEmptyDEMTexture() {
        const t = this.painter.context,
          i = t.gl;
        t.activeTexture.set(i.TEXTURE2);
        const o = this._getLoadedAreaMinimum(),
          r = new e.RGBAImage({
            width: 1,
            height: 1
          }, new Uint8Array(e.DEMData.pack(o, this.sourceCache.getSource().encoding)));
        this._emptyDEMTextureDirty = !1;
        let n = this._emptyDEMTexture;
        return n ? n.update(r, {
          premultiply: !1
        }) : n = this._emptyDEMTexture = new e.Texture(t, r, i.RGBA, {
          premultiply: !1
        }), n;
      }
      setupElevationDraw(t, i, o) {
        const r = this.painter.context,
          n = r.gl,
          s = (a = this.sourceCache.getSource().encoding, {
            u_dem: 2,
            u_dem_prev: 4,
            u_dem_unpack: e.DEMData.getUnpackVector(a),
            u_dem_tl: [0, 0],
            u_dem_tl_prev: [0, 0],
            u_dem_scale: 0,
            u_dem_scale_prev: 0,
            u_dem_size: 0,
            u_dem_lerp: 1,
            u_depth: 3,
            u_depth_size_inv: [0, 0],
            u_exaggeration: 0
          });
        var a;
        s.u_dem_size = this.sourceCache.getSource().tileSize, s.u_exaggeration = this.exaggeration();
        let l = null,
          c = null,
          h = 1;
        if (o && o.morphing && this._useVertexMorphing) {
          const e = o.morphing.srcDemTile,
            i = o.morphing.dstDemTile;
          h = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, s, "_prev") && (c = e), this._prepareDemTileUniforms(t, i, s) && (l = i));
        }
        if (c && l ? (r.activeTexture.set(n.TEXTURE2), l.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), c.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), s.u_dem_lerp = h) : (l = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t, l, s) ? l.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), s.u_depth_size_inv = [1, 1]), o && o.useMeterToDem && l) {
          const t = (1 << l.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
          s.u_meter_to_dem = t;
        }
        if (o && o.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, s), "globe" === this.painter.transform.projection.name) {
          const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);
          i.setGlobeUniformValues(r, e);
        }
      }
      globeUniformValues(t, i, o) {
        const r = t.projection;
        return {
          u_tile_tl_up: r.upVector(i, 0, 0),
          u_tile_tr_up: r.upVector(i, e.EXTENT, 0),
          u_tile_br_up: r.upVector(i, e.EXTENT, e.EXTENT),
          u_tile_bl_up: r.upVector(i, 0, e.EXTENT),
          u_tile_up_scale: o ? e.globeMetersToEcef(1) : r.upVectorScale(i, t.center.lat, t.worldSize).metersToTile
        };
      }
      renderToBackBuffer(t) {
        const i = this.painter,
          o = this.painter.context;
        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, i, o, r, n) {
          if ("globe" === t.transform.projection.name) !function (t, i, o, r, n) {
            const s = t.context,
              a = s.gl;
            let l, c;
            const h = t.options.showTerrainWireframe ? 2 : 0,
              u = t.transform,
              _ = e.globeUseCustomAntiAliasing(t, s, u),
              d = (e, i) => {
                if (c === e) return;
                const o = [Ei[e], "PROJECTION_GLOBE_VIEW"];
                _ && o.push("CUSTOM_ANTIALIASING"), i && o.push(Ei[h]), l = t.useProgram("globeRaster", null, o), c = e;
              },
              p = t.colorModeForRenderPass(),
              m = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
            Ti.update(n);
            const f = e.calculateGlobeMercatorMatrix(u),
              g = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)],
              v = h ? [!1, !0] : [!1],
              x = t.globeSharedBuffers,
              y = [u.width * e.exported.devicePixelRatio, u.height * e.exported.devicePixelRatio],
              b = Float32Array.from(u.globeMatrix),
              w = {
                useDenormalizedUpVectorScale: !0
              };
            if (v.forEach(h => {
              const u = t.transform,
                _ = Ci(u.zoom) * i.exaggeration();
              c = -1;
              const v = h ? a.LINES : a.TRIANGLES;
              for (const c of r) {
                const r = o.getTile(c),
                  T = e.StencilMode.disabled,
                  E = i.prevTerrainTileForTile[c.key],
                  C = i.terrainTileForTile[c.key];
                wi(E, C) && Ti.newMorphing(c.key, E, C, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                const M = Ti.getMorphValuesForProxy(c.key),
                  I = M ? 1 : 0;
                M && e.extend$1(w, {
                  morphing: {
                    srcDemTile: M.from,
                    dstDemTile: M.to,
                    phase: e.easeCubicInOut(M.phase)
                  }
                });
                const S = e.tileCornersToBounds(c.canonical),
                  D = e.getLatitudinalLod(S.getCenter().lat),
                  L = e.getGridMatrix(c.canonical, S, D, u.worldSize / u._pixelsPerMercatorPixel),
                  A = e.globeNormalizeECEF(e.globeTileBounds(c.canonical)),
                  z = bi(u.projMatrix, b, f, A, e.globeToMercatorTransition(u.zoom), g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, _, L);
                if (d(I, h), i.setupElevationDraw(r, l, w), t.prepareDrawProgram(s, l, c.toUnwrapped()), x) {
                  const [i, o, r] = h ? x.getWirefameBuffers(t.context, D) : x.getGridBuffers(D, 0 !== _);
                  l.draw(s, v, m, T, p, e.CullFaceMode.backCCW, z, "globe_raster", i, o, r);
                }
              }
            }), x) {
              const n = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
              _ && n.push("CUSTOM_ANTIALIASING"), l = t.useProgram("globeRaster", null, n);
              for (const n of r) {
                const {
                    x: r,
                    y: c,
                    z: h
                  } = n.canonical,
                  _ = 0 === c,
                  d = c === (1 << h) - 1,
                  [f, v, b, T] = x.getPoleBuffers(h);
                if (T && (_ || d)) {
                  const c = o.getTile(n);
                  s.activeTexture.set(a.TEXTURE0), c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                  let x = e.globePoleMatrixForTile(h, r, u);
                  const E = e.globeNormalizeECEF(e.globeTileBounds(n.canonical)),
                    C = (t, i) => t.draw(s, a.TRIANGLES, m, e.StencilMode.disabled, p, e.CullFaceMode.disabled, bi(u.projMatrix, x, x, E, 0, g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, 0), "globe_pole_raster", i, b, T);
                  i.setupElevationDraw(c, l, w), t.prepareDrawProgram(s, l, n.toUnwrapped()), _ && C(l, f), d && (x = e.scale(e.create(), x, [1, -1, 1]), C(l, v));
                }
              }
            }
          }(t, i, o, r, n);else {
            const s = t.context,
              a = s.gl;
            let l, c;
            const h = t.options.showTerrainWireframe ? 2 : 0,
              u = (e, i) => {
                if (c === e) return;
                const o = [Ei[e]];
                i && o.push(Ei[h]), l = t.useProgram("terrainRaster", null, o), c = e;
              },
              _ = t.colorModeForRenderPass(),
              d = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
            Ti.update(n);
            const p = t.transform,
              m = Ci(p.zoom) * i.exaggeration();
            (h ? [!1, !0] : [!1]).forEach(h => {
              c = -1;
              const f = h ? a.LINES : a.TRIANGLES,
                [g, v] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];
              for (const c of r) {
                const r = o.getTile(c),
                  x = e.StencilMode.disabled,
                  y = i.prevTerrainTileForTile[c.key],
                  b = i.terrainTileForTile[c.key];
                wi(y, b) && Ti.newMorphing(c.key, y, b, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);
                const w = Ti.getMorphValuesForProxy(c.key),
                  T = w ? 1 : 0;
                let E;
                w && (E = {
                  morphing: {
                    srcDemTile: w.from,
                    dstDemTile: w.to,
                    phase: e.easeCubicInOut(w.phase)
                  }
                });
                const C = yi(c.projMatrix, Mi(c.canonical, p.renderWorldCopies) ? m / 10 : m);
                u(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(s, l, c.toUnwrapped()), l.draw(s, f, d, x, _, e.CullFaceMode.backCCW, C, "terrain_raster", i.gridBuffer, g, v);
              }
            });
          }
        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
      }
      renderBatch(t) {
        if (0 === this._drapedRenderBatches.length) return t + 1;
        this.renderingToTexture = !0;
        const i = this.painter,
          o = this.painter.context,
          r = this.proxySourceCache,
          n = this.proxiedCoords[r.id],
          s = this._drapedRenderBatches.shift(),
          a = [],
          l = i.style.order;
        let c = 0;
        for (const h of n) {
          const n = r.getTileByID(h.proxyTileKey),
            u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t] : void 0,
            _ = void 0 !== u ? r.renderCache[u] : this.pool[c++],
            d = void 0 !== u;
          if (n.texture = _.tex, d && !_.dirty) {
            a.push(n.tileID);
            continue;
          }
          let p;
          o.bindFramebuffer.set(_.fb.framebuffer), this.renderedToTile = !1, _.dirty && (o.clear({
            color: e.Color.transparent,
            stencil: 0
          }), _.dirty = !1);
          for (let e = s.start; e <= s.end; ++e) {
            const t = i.style._layers[l[e]];
            if (t.isHidden(i.transform.zoom)) continue;
            const r = i.style._getLayerSourceCache(t),
              n = r ? this.proxyToSource[h.key][r.id] : [h];
            if (!n) continue;
            const s = n;
            o.viewport.set([0, 0, _.fb.width, _.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(_, n, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, s);
          }
          this.renderedToTile ? (_.dirty = !0, a.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(a));
        }
        return this.renderToBackBuffer(a), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), s.end + 1;
      }
      postRender() {}
      renderCacheEfficiency(e) {
        const t = e.order.length;
        if (0 === t) return {
          efficiency: 100
        };
        let i,
          o = 0,
          r = 0,
          n = !1;
        for (let s = 0; s < t; ++s) {
          const t = e._layers[e.order[s]];
          this._style.isLayerDraped(t) ? (n && ++o, ++r) : n || (n = !0, i = t.id);
        }
        return 0 === r ? {
          efficiency: 100
        } : {
          efficiency: 100 * (1 - o / r),
          firstUndrapedLayer: i
        };
      }
      getMinElevationBelowMSL() {
        let e = 0;
        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {
          e = Math.min(e, t.dem.tree.minimums[0]);
        }), 0 === e ? e : (e - 30) * this._exaggeration;
      }
      raycast(e, t, i) {
        if (!this._visibleDemTiles) return null;
        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {
          const r = o.tileID,
            n = 1 << r.overscaledZ,
            {
              x: s,
              y: a
            } = r.canonical,
            l = s / n,
            c = (s + 1) / n,
            h = a / n,
            u = (a + 1) / n;
          return {
            minx: l,
            miny: h,
            maxx: c,
            maxy: u,
            t: o.dem.tree.raycastRoot(l, h, c, u, e, t, i),
            tile: o
          };
        });
        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));
        for (const r of o) {
          if (null == r.t) return null;
          const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, i);
          if (null != o) return o;
        }
        return null;
      }
      _createFBO() {
        const t = this.painter.context,
          i = t.gl,
          o = this.drapeBufferSize;
        t.activeTexture.set(i.TEXTURE0);
        const r = new e.Texture(t, {
          width: o[0],
          height: o[1],
          data: null
        }, i.RGBA);
        r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
        const n = t.createFramebuffer(o[0], o[1], !1);
        return n.colorAttachment.set(r.texture), n.depthAttachment = new Ee(t, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t.clear({
          stencil: 0
        })) : n.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {
          fb: n,
          tex: r,
          dirty: !1
        };
      }
      _initFBOPool() {
        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());
      }
      _shouldDisableRenderCache() {
        if (this._style.light && this._style.light.hasTransition()) return !0;
        for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0;
        return this._style.order.some(e => {
          const t = this._style._layers[e],
            i = t.isHidden(this.painter.transform.zoom);
          return "custom" === t.type ? !i && t.shouldRedrape() : !i && t.hasTransition();
        });
      }
      _clearLineLayersFromRenderCache() {
        let t = !1;
        for (const e of this._style._getSources()) if (e instanceof Ie) {
          t = !0;
          break;
        }
        if (!t) return;
        const i = {};
        for (let t = 0; t < this._style.order.length; ++t) {
          const o = this._style._layers[this._style.order[t]],
            r = this._style._getLayerSourceCache(o);
          if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e.ZoomDependentExpression) {
            i[r.id] = !0;
            for (const e of this.proxyCoords) {
              const t = this.proxyToSource[e.key][r.id];
              if (t) for (const e of t) this._clearRenderCacheForTile(r.id, e);
            }
          }
        }
      }
      _clearRasterLayersFromRenderCache() {
        let e = !1;
        for (const t in this._style._sourceCaches) if (this._style._sourceCaches[t]._source instanceof Se) {
          e = !0;
          break;
        }
        if (!e) return;
        const t = {};
        for (let e = 0; e < this._style.order.length; ++e) {
          const i = this._style._layers[this._style.order[e]],
            o = this._style._getLayerSourceCache(i);
          if (!o || t[o.id]) continue;
          if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
          const r = i.paint.get("raster-fade-duration");
          for (const e of this.proxyCoords) {
            const t = this.proxyToSource[e.key][o.id];
            if (t) for (const e of t) {
              const t = Si(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);
              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);
            }
          }
        }
      }
      _setupDrapedRenderBatches() {
        const e = this._style.order,
          t = e.length;
        if (0 === t) return;
        const i = [];
        let o,
          r = 0,
          n = this._style._layers[e[r]];
        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t;) n = this._style._layers[e[r]];
        for (; r < t; ++r) {
          const t = this._style._layers[e[r]];
          t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === o && (o = r) : void 0 !== o && (i.push({
            start: o,
            end: r - 1
          }), o = void 0));
        }
        void 0 !== o && i.push({
          start: o,
          end: r - 1
        }), this._drapedRenderBatches = i;
      }
      _setupRenderCache(e) {
        const t = this.proxySourceCache;
        if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
          if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {
            const e = Object.values(t.proxyCachedFBO);
            t.proxyCachedFBO = {};
            for (let i = 0; i < e.length; ++i) {
              const o = Object.values(e[i]);
              t.renderCachePool.push(...o);
            }
          }
          return;
        }
        this._clearRasterLayersFromRenderCache();
        const i = this.proxyCoords,
          o = this._tilesDirty;
        for (let r = i.length - 1; r >= 0; r--) {
          const n = i[r];
          if (t.getTileByID(n.key), void 0 !== t.proxyCachedFBO[n.key]) {
            const i = e[n.key],
              r = this.proxyToSource[n.key];
            let s = 0;
            for (const e in r) {
              const t = r[e],
                n = i[e];
              if (!n || n.length !== t.length || t.some((t, i) => t !== n[i] || o[e] && o[e].hasOwnProperty(t.key))) {
                s = -1;
                break;
              }
              ++s;
            }
            for (const e in t.proxyCachedFBO[n.key]) t.renderCache[t.proxyCachedFBO[n.key][e]].dirty = s < 0 || s !== Object.values(i).length;
          }
        }
        const r = [...this._drapedRenderBatches];
        r.sort((e, t) => t.end - t.start - (e.end - e.start));
        for (const e of r) for (const o of i) {
          if (t.proxyCachedFBO[o.key]) continue;
          let i = t.renderCachePool.pop();
          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);
        }
        this._tilesDirty = {};
      }
      _setupStencil(e, t, i, o) {
        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
        const r = this.painter.context,
          n = r.gl;
        if (t.length <= 1) return void (this._overlapStencilType = !1);
        let s;
        if (i.isTileClipped()) s = t.length, this._overlapStencilMode.test = {
          func: n.EQUAL,
          mask: 255
        }, this._overlapStencilType = "Clip";else {
          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
          s = 1, this._overlapStencilMode.test = {
            func: n.GREATER,
            mask: 255
          }, this._overlapStencilType = "Mask";
        }
        this._stencilRef + s > 255 && (r.clear({
          stencil: 0
        }), this._stencilRef = 0), this._stencilRef += s, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);
      }
      clipOrMaskOverlapStencilType() {
        return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
      }
      stencilModeForRTTOverlap(t) {
        return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : e.StencilMode.disabled;
      }
      _renderTileClippingMasks(t, i) {
        const o = this.painter,
          r = this.painter.context,
          n = r.gl;
        o._tileClippingMaskIDs = {}, r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
        const s = o.useProgram("clippingMask");
        for (const a of t) {
          const t = o._tileClippingMaskIDs[a.key] = --i;
          s.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({
            func: n.ALWAYS,
            mask: 0
          }, t, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(a.projMatrix), "$clipping", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);
        }
      }
      pointCoordinate(t) {
        const i = this.painter.transform;
        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;
        const o = [t.x, t.y, 1, 1];
        e.transformMat4$1(o, o, i.pixelMatrixInverse), e.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
        const r = i._camera.position,
          n = e.mercatorZfromAltitude(1, i.center.lat),
          s = [r[0], r[1], r[2] / n, 0],
          a = e.subtract([], o.slice(0, 3), s);
        e.normalize(a, a);
        const l = this.raycast(s, a, this._exaggeration);
        return null !== l && l ? (e.scaleAndAdd(s, s, a, l), s[3] = s[2], s[2] *= n, s) : null;
      }
      drawDepth() {
        const t = this.painter,
          i = t.context,
          o = this.proxySourceCache,
          r = Math.ceil(t.width),
          n = Math.ceil(t.height);
        if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
          const t = i.gl,
            o = i.createFramebuffer(r, n, !0);
          i.activeTexture.set(t.TEXTURE0);
          const s = new e.Texture(i, {
            width: r,
            height: n,
            data: null
          }, t.RGBA);
          s.bind(t.NEAREST, t.CLAMP_TO_EDGE), o.colorAttachment.set(s.texture);
          const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);
          o.depthAttachment.set(a), this._depthFBO = o, this._depthTexture = s;
        }
        i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([0, 0, r, n]), function (t, i, o, r) {
          if ("globe" === t.transform.projection.name) return;
          const n = t.context,
            s = n.gl;
          n.clear({
            depth: 1
          });
          const a = t.useProgram("terrainDepth"),
            l = new e.DepthMode(s.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D);
          for (const t of r) {
            const r = o.getTile(t),
              c = yi(t.projMatrix, 0);
            i.setupElevationDraw(r, a), a.draw(n, s.TRIANGLES, l, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);
          }
        }(t, this, o, this.proxyCoords);
      }
      _setupProxiedCoordsForOrtho(e, t, i) {
        if (e.getSource() instanceof Ae) return this._setupProxiedCoordsForImageSource(e, t, i);
        this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};
        const o = this.proxiedCoords[e.id] = [],
          r = this.proxyCoords;
        for (let t = 0; t < r.length; t++) {
          const n = r[t],
            s = this._findTileCoveringTileID(n, e);
          if (s) {
            const t = this._createProxiedId(n, s, i[n.key] && i[n.key][e.id]);
            o.push(t), this.proxyToSource[n.key][e.id] = [t];
          }
        }
        let n = !1;
        for (let r = 0; r < t.length; r++) {
          const s = e.getTile(t[r]);
          if (!s || !s.hasData()) continue;
          const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);
          if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
            const t = this.proxyToSource[a.tileID.key][e.id],
              r = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][e.id]);
            t ? t.splice(t.length - 1, 0, r) : this.proxyToSource[a.tileID.key][e.id] = [r], o.push(r), n = !0;
          }
        }
        this._sourceTilesOverlap[e.id] = n;
      }
      _setupProxiedCoordsForImageSource(t, i, o) {
        if (!t.getSource().loaded()) return;
        const r = this.proxiedCoords[t.id] = [],
          n = this.proxyCoords,
          s = t.getSource(),
          a = new e.pointGeometry(s.tileID.x, s.tileID.y)._div(1 << s.tileID.z),
          l = s.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - a.x), e.min.y = Math.min(e.min.y, t.y - a.y), e.max.x = Math.max(e.max.x, t.x - a.x), e.max.y = Math.max(e.max.y, t.y - a.y), e), {
            min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE),
            max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE)
          }),
          c = (t, i) => {
            const o = t.wrap + t.canonical.x / (1 << t.canonical.z),
              r = t.canonical.y / (1 << t.canonical.z),
              n = e.EXTENT / (1 << t.canonical.z),
              s = i.wrap + i.canonical.x / (1 << i.canonical.z),
              a = i.canonical.y / (1 << i.canonical.z);
            return o + n < s + l.min.x || o > s + l.max.x || r + n < a + l.min.y || r > a + l.max.y;
          };
        for (let e = 0; e < n.length; e++) {
          const s = n[e];
          for (let e = 0; e < i.length; e++) {
            const n = t.getTile(i[e]);
            if (!n || !n.hasData()) continue;
            if (c(s, n.tileID)) continue;
            const a = this._createProxiedId(s, n, o[s.key] && o[s.key][t.id]),
              l = this.proxyToSource[s.key][t.id];
            l ? l.push(a) : this.proxyToSource[s.key][t.id] = [a], r.push(a);
          }
        }
      }
      _createProxiedId(t, i, o) {
        let r = this.orthoMatrix;
        if (o) {
          const e = o.find(e => e.key === i.tileID.key);
          if (e) return e;
        }
        if (i.tileID.key !== t.key) {
          const o = t.canonical.z - i.tileID.canonical.z;
          let n, s, a;
          r = e.create();
          const l = i.tileID.wrap - t.wrap << t.overscaledZ;
          o > 0 ? (n = e.EXTENT >> o, s = n * ((i.tileID.canonical.x << o) - t.canonical.x + l), a = n * ((i.tileID.canonical.y << o) - t.canonical.y)) : (n = e.EXTENT << -o, s = e.EXTENT * (i.tileID.canonical.x - (t.canonical.x + l << -o)), a = e.EXTENT * (i.tileID.canonical.y - (t.canonical.y << -o))), e.ortho(r, 0, n, 0, n, 0, 1), e.translate(r, r, [s, a, 0]);
        }
        return new Ai(i.tileID, t.key, r);
      }
      _findTileCoveringTileID(t, i) {
        let o = i.getTile(t);
        if (o && o.hasData()) return o;
        const r = this._findCoveringTileCache[i.id],
          n = r[t.key];
        if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;
        let s = o ? o.tileID : t,
          a = s.overscaledZ;
        const l = i.getSource().minzoom,
          c = [];
        if (!n) {
          const r = i.getSource().maxzoom;
          if (t.canonical.z >= r) {
            const o = t.canonical.z - r;
            i.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, i.transform.tileZoom), s = new e.OverscaledTileID(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (a = r, s = new e.OverscaledTileID(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o));
          }
          s.key !== t.key && (c.push(s.key), o = i.getTile(s));
        }
        const h = e => {
          c.forEach(t => {
            r[t] = e;
          }), c.length = 0;
        };
        for (a -= 1; a >= l && (!o || !o.hasData()); a--) {
          o && h(o.tileID.key);
          const e = s.calculateScaledKey(a);
          if (o = i.getTileByID(e), o && o.hasData()) break;
          const t = r[e];
          if (null === t) break;
          void 0 === t ? c.push(e) : o = i.getTileByID(t);
        }
        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
      }
      findDEMTileFor(e) {
        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
      }
      prepareDrawTile() {
        this.renderedToTile = !0;
      }
      _clearRenderCacheForTile(e, t) {
        let i = this._tilesDirty[e];
        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;
      }
      getWirefameBuffer() {
        if (!this.wireframeSegments) {
          const t = function (t) {
            let i = 0;
            const o = new e.StructArrayLayout2ui4(),
              r = 131;
            for (let e = 1; e < 129; e++) {
              for (let t = 1; t < 129; t++) i = e * r + t, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e && o.emplaceBack(i + r, i + r + 1);
              o.emplaceBack(i + 1, i + 1 + r);
            }
            return o;
          }();
          this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length);
        }
        return [this.wireframeIndexBuffer, this.wireframeSegments];
      }
    }
    class Pi {
      static cacheKey(e, t, i, o) {
        let r = `${t}${o ? o.cacheKey : ""}`;
        for (const t of i) e.usedDefines.includes(t) && (r += `/${t}`);
        return r;
      }
      constructor(t, i, o, r, n, s) {
        const a = t.gl;
        this.program = a.createProgram();
        const l = function (e) {
            const t = [];
            for (let i = 0; i < e.length; i++) {
              if (null === e[i]) continue;
              const o = e[i].split(" ");
              t.push(o.pop());
            }
            return t;
          }(o.staticAttributes),
          c = r ? r.getBinderAttributes() : [],
          h = l.concat(c);
        let u = r ? r.defines() : [];
        u = u.concat(s.map(e => `#define ${e}`));
        const _ = t.isWebGL2 ? "#version 300 es\n" : "",
          d = _ + u.concat(t.extStandardDerivatives && 0 === _.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(hi) : hi, hi, ci, li.fragmentSource, si.fragmentSource, o.fragmentSource).join("\n"),
          p = _ + u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ci, li.vertexSource, si.vertexSource, ni.vertexSource, o.vertexSource).join("\n"),
          m = a.createShader(a.FRAGMENT_SHADER);
        if (a.isContextLost()) return void (this.failedToCreate = !0);
        a.shaderSource(m, d), a.compileShader(m), a.attachShader(this.program, m);
        const f = a.createShader(a.VERTEX_SHADER);
        if (a.isContextLost()) this.failedToCreate = !0;else {
          a.shaderSource(f, p), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = h.length;
          for (let e = 0; e < this.numAttributes; e++) h[e] && (a.bindAttribLocation(this.program, e, h[e]), this.attributes[h[e]] = e);
          a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(m), this.fixedUniforms = n(t), this.binderUniforms = r ? r.getUniforms(t) : [], s.includes("TERRAIN") && (this.terrainUniforms = (t => ({
            u_dem: new e.Uniform1i(t),
            u_dem_prev: new e.Uniform1i(t),
            u_dem_unpack: new e.Uniform4f(t),
            u_dem_tl: new e.Uniform2f(t),
            u_dem_scale: new e.Uniform1f(t),
            u_dem_tl_prev: new e.Uniform2f(t),
            u_dem_scale_prev: new e.Uniform1f(t),
            u_dem_size: new e.Uniform1f(t),
            u_dem_lerp: new e.Uniform1f(t),
            u_exaggeration: new e.Uniform1f(t),
            u_depth: new e.Uniform1i(t),
            u_depth_size_inv: new e.Uniform2f(t),
            u_meter_to_dem: new e.Uniform1f(t),
            u_label_plane_matrix_inv: new e.UniformMatrix4f(t)
          }))(t)), s.includes("GLOBE") && (this.globeUniforms = (t => ({
            u_tile_tl_up: new e.Uniform3f(t),
            u_tile_tr_up: new e.Uniform3f(t),
            u_tile_br_up: new e.Uniform3f(t),
            u_tile_bl_up: new e.Uniform3f(t),
            u_tile_up_scale: new e.Uniform1f(t)
          }))(t)), s.includes("FOG") && (this.fogUniforms = (t => ({
            u_fog_matrix: new e.UniformMatrix4f(t),
            u_fog_range: new e.Uniform2f(t),
            u_fog_color: new e.Uniform4f(t),
            u_fog_horizon_blend: new e.Uniform1f(t),
            u_fog_temporal_offset: new e.Uniform1f(t),
            u_frustum_tl: new e.Uniform3f(t),
            u_frustum_tr: new e.Uniform3f(t),
            u_frustum_br: new e.Uniform3f(t),
            u_frustum_bl: new e.Uniform3f(t),
            u_globe_pos: new e.Uniform3f(t),
            u_globe_radius: new e.Uniform1f(t),
            u_globe_transition: new e.Uniform1f(t),
            u_is_globe: new e.Uniform1i(t),
            u_viewport: new e.Uniform2f(t)
          }))(t));
        }
      }
      setTerrainUniformValues(e, t) {
        if (!this.terrainUniforms) return;
        const i = this.terrainUniforms;
        if (!this.failedToCreate) {
          e.program.set(this.program);
          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);
        }
      }
      setGlobeUniformValues(e, t) {
        if (!this.globeUniforms) return;
        const i = this.globeUniforms;
        if (!this.failedToCreate) {
          e.program.set(this.program);
          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);
        }
      }
      setFogUniformValues(e, t) {
        if (!this.fogUniforms) return;
        const i = this.fogUniforms;
        if (!this.failedToCreate) {
          e.program.set(this.program);
          for (const e in t) i[e].set(this.program, e, t[e]);
        }
      }
      draw(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) {
        const m = e.gl;
        if (this.failedToCreate) return;
        e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(o), e.setColorMode(r), e.setCullFace(n);
        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(this.program, e, s[e]);
        d && d.setUniforms(this.program, e, this.binderUniforms, u, {
          zoom: _
        });
        const f = {
          [m.LINES]: 2,
          [m.TRIANGLES]: 3,
          [m.LINE_STRIP]: 1
        }[t];
        for (const i of h.get()) {
          const o = i.vaos || (i.vaos = {});
          (o[a] || (o[a] = new pi())).bind(e, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p || []), m.drawElements(t, i.primitiveLength * f, m.UNSIGNED_SHORT, i.primitiveOffset * f * 2);
        }
      }
    }
    function Ri(e, t) {
      const i = Math.pow(2, t.tileID.overscaledZ),
        o = t.tileSize * Math.pow(2, e.transform.tileZoom) / i,
        r = o * (t.tileID.canonical.x + t.tileID.wrap * i),
        n = o * t.tileID.canonical.y;
      return {
        u_image: 0,
        u_texsize: t.imageAtlasTexture.size,
        u_tile_units_to_pixels: 1 / P(t, 1, e.transform.tileZoom),
        u_pixel_coord_upper: [r >> 16, n >> 16],
        u_pixel_coord_lower: [65535 & r, 65535 & n]
      };
    }
    const Oi = e.create(),
      Bi = (t, i, o, r, n, s, a, l, c, h, u) => {
        const _ = i.style.light,
          d = _.properties.get("position"),
          p = [d.x, d.y, d.z],
          m = e.create$1();
        "viewport" === _.properties.get("anchor") && (e.fromRotation(m, -i.transform.angle), e.transformMat3(p, p, m));
        const f = _.properties.get("color"),
          g = i.transform,
          v = {
            u_matrix: t,
            u_lightpos: p,
            u_lightintensity: _.properties.get("intensity"),
            u_lightcolor: [f.r, f.g, f.b],
            u_vertical_gradient: +o,
            u_opacity: r,
            u_tile_id: [0, 0, 0],
            u_zoom_transition: 0,
            u_inv_rot_matrix: Oi,
            u_merc_center: [0, 0],
            u_up_dir: [0, 0, 0],
            u_height_lift: 0,
            u_ao: n,
            u_edge_radius: s
          };
        return "globe" === g.projection.name && (v.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z], v.u_zoom_transition = c, v.u_inv_rot_matrix = u, v.u_merc_center = h, v.u_up_dir = g.projection.upVector(new e.CanonicalTileID(0, 0, 0), h[0] * e.EXTENT, h[1] * e.EXTENT), v.u_height_lift = l), v;
      },
      ki = (t, i, o, r, n, s, a, l, c, h, u, _) => {
        const d = Bi(t, i, o, r, n, s, a, c, h, u, _),
          p = {
            u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8
          };
        return e.extend(d, Ri(i, l), p);
      },
      Fi = e => ({
        u_matrix: e
      }),
      Ui = (t, i, o) => e.extend(Fi(t), Ri(i, o)),
      Ni = (e, t) => ({
        u_matrix: e,
        u_world: t
      }),
      Gi = (t, i, o, r) => e.extend(Ui(t, i, o), {
        u_world: r
      }),
      ji = e.create(),
      Zi = (t, i, o, r, n, s) => {
        const a = t.transform,
          l = "globe" === a.projection.name;
        let c;
        if ("map" === s.paint.get("circle-pitch-alignment")) {
          if (l) {
            const t = e.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;
            c = Float32Array.from([t, 0, 0, t]);
          } else c = a.calculatePixelsToTileUnitsMatrix(o);
        } else c = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);
        const h = {
          u_camera_to_center_distance: a.cameraToCenterDistance,
          u_matrix: t.translatePosMatrix(i.projMatrix, o, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
          u_device_pixel_ratio: e.exported.devicePixelRatio,
          u_extrude_scale: c,
          u_inv_rot_matrix: ji,
          u_merc_center: [0, 0],
          u_tile_id: [0, 0, 0],
          u_zoom_transition: 0,
          u_up_dir: [0, 0, 0]
        };
        if (l) {
          h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], h.u_zoom_transition = e.globeToMercatorTransition(a.zoom);
          const t = n[0] * e.EXTENT,
            o = n[1] * e.EXTENT;
          h.u_up_dir = a.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, o);
        }
        return h;
      },
      Vi = e => {
        const t = [];
        return "map" === e.paint.get("circle-pitch-alignment") && t.push("PITCH_WITH_MAP"), "map" === e.paint.get("circle-pitch-scale") && t.push("SCALE_WITH_MAP"), t;
      },
      Wi = (t, i, o, r) => {
        const n = e.EXTENT / o.tileSize;
        return {
          u_matrix: t,
          u_camera_to_center_distance: i.getCameraToCenterDistance(r),
          u_extrude_scale: [i.pixelsToGLUnits[0] / n, i.pixelsToGLUnits[1] / n]
        };
      },
      Xi = (e, t, i = 1) => ({
        u_matrix: e,
        u_color: t,
        u_overlay: 0,
        u_overlay_scale: i
      }),
      qi = e.create(),
      $i = (t, i, o, r, n, s, a) => {
        const l = t.transform,
          c = "globe" === l.projection.name,
          h = c ? e.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : P(o, 1, s),
          u = {
            u_matrix: i.projMatrix,
            u_extrude_scale: h,
            u_intensity: a,
            u_inv_rot_matrix: qi,
            u_merc_center: [0, 0],
            u_tile_id: [0, 0, 0],
            u_zoom_transition: 0,
            u_up_dir: [0, 0, 0]
          };
        if (c) {
          u.u_inv_rot_matrix = r, u.u_merc_center = n, u.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], u.u_zoom_transition = e.globeToMercatorTransition(l.zoom);
          const t = n[0] * e.EXTENT,
            o = n[1] * e.EXTENT;
          u.u_up_dir = l.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, o);
        }
        return u;
      },
      Hi = (e, t, i, o, r, n, s) => {
        const a = e.transform,
          l = a.calculatePixelsToTileUnitsMatrix(t);
        return {
          u_matrix: Ji(e, t, i, o),
          u_pixels_to_tile_units: l,
          u_device_pixel_ratio: n,
          u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],
          u_dash_image: 0,
          u_gradient_image: 1,
          u_image_height: r,
          u_texsize: Qi(i) ? t.lineAtlasTexture.size : [0, 0],
          u_tile_units_to_pixels: Ki(t, e.transform),
          u_alpha_discard_threshold: 0,
          u_trim_offset: s
        };
      },
      Yi = (e, t, i, o, r) => {
        const n = e.transform;
        return {
          u_matrix: Ji(e, t, i, o),
          u_texsize: t.imageAtlasTexture.size,
          u_pixels_to_tile_units: n.calculatePixelsToTileUnitsMatrix(t),
          u_device_pixel_ratio: r,
          u_image: 0,
          u_tile_units_to_pixels: Ki(t, n),
          u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]],
          u_alpha_discard_threshold: 0
        };
      };
    function Ki(e, t) {
      return 1 / P(e, 1, t.tileZoom);
    }
    function Ji(e, t, i, o) {
      return e.translatePosMatrix(o || t.tileID.projMatrix, t, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
    }
    function Qi(e) {
      const t = e.paint.get("line-dasharray").value;
      return t.value || "constant" !== t.kind;
    }
    const eo = (e, t, i, o, r, n) => {
      return {
        u_matrix: e,
        u_tl_parent: t,
        u_scale_parent: i,
        u_fade_t: o.mix,
        u_opacity: o.opacity * r.paint.get("raster-opacity"),
        u_image0: 0,
        u_image1: 1,
        u_brightness_low: r.paint.get("raster-brightness-min"),
        u_brightness_high: r.paint.get("raster-brightness-max"),
        u_saturation_factor: (a = r.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a),
        u_contrast_factor: (s = r.paint.get("raster-contrast"), s > 0 ? 1 / (1 - s) : 1 + s),
        u_spin_weights: to(r.paint.get("raster-hue-rotate")),
        u_perspective_transform: n
      };
      var s, a;
    };
    function to(e) {
      e *= Math.PI / 180;
      const t = Math.sin(e),
        i = Math.cos(e);
      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];
    }
    const io = e.create(),
      oo = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f) => {
        const g = n.transform,
          v = {
            u_is_size_zoom_constant: +("constant" === t || "source" === t),
            u_is_size_feature_constant: +("constant" === t || "camera" === t),
            u_size_t: i ? i.uSizeT : 0,
            u_size: i ? i.uSize : 0,
            u_camera_to_center_distance: g.cameraToCenterDistance,
            u_rotate_symbol: +o,
            u_aspect_ratio: g.width / g.height,
            u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,
            u_matrix: s,
            u_label_plane_matrix: a,
            u_coord_matrix: l,
            u_is_text: +c,
            u_pitch_with_map: +r,
            u_texsize: h,
            u_texture: 0,
            u_tile_id: [0, 0, 0],
            u_zoom_transition: 0,
            u_inv_rot_matrix: io,
            u_merc_center: [0, 0],
            u_camera_forward: [0, 0, 0],
            u_ecef_origin: [0, 0, 0],
            u_tile_matrix: io,
            u_up_vector: [0, -1, 0]
          };
        return "globe" === f.name && (v.u_tile_id = [u.canonical.x, u.canonical.y, 1 << u.canonical.z], v.u_zoom_transition = _, v.u_inv_rot_matrix = p, v.u_merc_center = d, v.u_camera_forward = g._camera.forward(), v.u_ecef_origin = e.globeECEFOrigin(g.globeMatrix, u.toUnwrapped()), v.u_tile_matrix = Float32Array.from(g.globeMatrix), v.u_up_vector = m), v;
      },
      ro = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) => e.extend(oo(t, i, o, r, n, s, a, l, c, h, _, d, p, m, f, g), {
        u_gamma_scale: r ? n.transform.cameraToCenterDistance * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1,
        u_device_pixel_ratio: e.exported.devicePixelRatio,
        u_is_halo: +u
      }),
      no = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f) => e.extend(ro(t, i, o, r, n, s, a, l, !0, c, !0, u, _, d, p, m, f), {
        u_texsize_icon: h,
        u_texture_icon: 1
      }),
      so = (e, t, i) => ({
        u_matrix: e,
        u_opacity: t,
        u_color: i
      }),
      ao = (t, i, o, r, n) => e.extend(function (e, t, i) {
        const o = t.imageManager.getPattern(e.toString()),
          {
            width: r,
            height: n
          } = t.imageManager.getPixelSize(),
          s = Math.pow(2, i.tileID.overscaledZ),
          a = i.tileSize * Math.pow(2, t.transform.tileZoom) / s,
          l = a * (i.tileID.canonical.x + i.tileID.wrap * s),
          c = a * i.tileID.canonical.y;
        return {
          u_image: 0,
          u_pattern_tl: o.tl,
          u_pattern_br: o.br,
          u_texsize: [r, n],
          u_pattern_size: o.displaySize,
          u_tile_units_to_pixels: 1 / P(i, 1, t.transform.tileZoom),
          u_pixel_coord_upper: [l >> 16, c >> 16],
          u_pixel_coord_lower: [65535 & l, 65535 & c]
        };
      }(r, o, n), {
        u_matrix: t,
        u_opacity: i
      }),
      lo = {
        fillExtrusion: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_lightpos: new e.Uniform3f(t),
          u_lightintensity: new e.Uniform1f(t),
          u_lightcolor: new e.Uniform3f(t),
          u_vertical_gradient: new e.Uniform1f(t),
          u_opacity: new e.Uniform1f(t),
          u_edge_radius: new e.Uniform1f(t),
          u_ao: new e.Uniform2f(t),
          u_tile_id: new e.Uniform3f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_inv_rot_matrix: new e.UniformMatrix4f(t),
          u_merc_center: new e.Uniform2f(t),
          u_up_dir: new e.Uniform3f(t),
          u_height_lift: new e.Uniform1f(t)
        }),
        fillExtrusionPattern: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_lightpos: new e.Uniform3f(t),
          u_lightintensity: new e.Uniform1f(t),
          u_lightcolor: new e.Uniform3f(t),
          u_vertical_gradient: new e.Uniform1f(t),
          u_height_factor: new e.Uniform1f(t),
          u_edge_radius: new e.Uniform1f(t),
          u_ao: new e.Uniform2f(t),
          u_tile_id: new e.Uniform3f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_inv_rot_matrix: new e.UniformMatrix4f(t),
          u_merc_center: new e.Uniform2f(t),
          u_up_dir: new e.Uniform3f(t),
          u_height_lift: new e.Uniform1f(t),
          u_image: new e.Uniform1i(t),
          u_texsize: new e.Uniform2f(t),
          u_pixel_coord_upper: new e.Uniform2f(t),
          u_pixel_coord_lower: new e.Uniform2f(t),
          u_tile_units_to_pixels: new e.Uniform1f(t),
          u_opacity: new e.Uniform1f(t)
        }),
        fill: t => ({
          u_matrix: new e.UniformMatrix4f(t)
        }),
        fillPattern: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_image: new e.Uniform1i(t),
          u_texsize: new e.Uniform2f(t),
          u_pixel_coord_upper: new e.Uniform2f(t),
          u_pixel_coord_lower: new e.Uniform2f(t),
          u_tile_units_to_pixels: new e.Uniform1f(t)
        }),
        fillOutline: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_world: new e.Uniform2f(t)
        }),
        fillOutlinePattern: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_world: new e.Uniform2f(t),
          u_image: new e.Uniform1i(t),
          u_texsize: new e.Uniform2f(t),
          u_pixel_coord_upper: new e.Uniform2f(t),
          u_pixel_coord_lower: new e.Uniform2f(t),
          u_tile_units_to_pixels: new e.Uniform1f(t)
        }),
        circle: t => ({
          u_camera_to_center_distance: new e.Uniform1f(t),
          u_extrude_scale: new e.UniformMatrix2f(t),
          u_device_pixel_ratio: new e.Uniform1f(t),
          u_matrix: new e.UniformMatrix4f(t),
          u_inv_rot_matrix: new e.UniformMatrix4f(t),
          u_merc_center: new e.Uniform2f(t),
          u_tile_id: new e.Uniform3f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_up_dir: new e.Uniform3f(t)
        }),
        collisionBox: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_camera_to_center_distance: new e.Uniform1f(t),
          u_extrude_scale: new e.Uniform2f(t)
        }),
        collisionCircle: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_inv_matrix: new e.UniformMatrix4f(t),
          u_camera_to_center_distance: new e.Uniform1f(t),
          u_viewport_size: new e.Uniform2f(t)
        }),
        debug: t => ({
          u_color: new e.UniformColor(t),
          u_matrix: new e.UniformMatrix4f(t),
          u_overlay: new e.Uniform1i(t),
          u_overlay_scale: new e.Uniform1f(t)
        }),
        clippingMask: t => ({
          u_matrix: new e.UniformMatrix4f(t)
        }),
        heatmap: t => ({
          u_extrude_scale: new e.Uniform1f(t),
          u_intensity: new e.Uniform1f(t),
          u_matrix: new e.UniformMatrix4f(t),
          u_inv_rot_matrix: new e.UniformMatrix4f(t),
          u_merc_center: new e.Uniform2f(t),
          u_tile_id: new e.Uniform3f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_up_dir: new e.Uniform3f(t)
        }),
        heatmapTexture: t => ({
          u_image: new e.Uniform1i(t),
          u_color_ramp: new e.Uniform1i(t),
          u_opacity: new e.Uniform1f(t)
        }),
        hillshade: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_image: new e.Uniform1i(t),
          u_latrange: new e.Uniform2f(t),
          u_light: new e.Uniform2f(t),
          u_shadow: new e.UniformColor(t),
          u_highlight: new e.UniformColor(t),
          u_accent: new e.UniformColor(t)
        }),
        hillshadePrepare: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_image: new e.Uniform1i(t),
          u_dimension: new e.Uniform2f(t),
          u_zoom: new e.Uniform1f(t),
          u_unpack: new e.Uniform4f(t)
        }),
        line: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_pixels_to_tile_units: new e.UniformMatrix2f(t),
          u_device_pixel_ratio: new e.Uniform1f(t),
          u_units_to_pixels: new e.Uniform2f(t),
          u_dash_image: new e.Uniform1i(t),
          u_gradient_image: new e.Uniform1i(t),
          u_image_height: new e.Uniform1f(t),
          u_texsize: new e.Uniform2f(t),
          u_tile_units_to_pixels: new e.Uniform1f(t),
          u_alpha_discard_threshold: new e.Uniform1f(t),
          u_trim_offset: new e.Uniform2f(t)
        }),
        linePattern: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_texsize: new e.Uniform2f(t),
          u_pixels_to_tile_units: new e.UniformMatrix2f(t),
          u_device_pixel_ratio: new e.Uniform1f(t),
          u_image: new e.Uniform1i(t),
          u_units_to_pixels: new e.Uniform2f(t),
          u_tile_units_to_pixels: new e.Uniform1f(t),
          u_alpha_discard_threshold: new e.Uniform1f(t)
        }),
        raster: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_tl_parent: new e.Uniform2f(t),
          u_scale_parent: new e.Uniform1f(t),
          u_fade_t: new e.Uniform1f(t),
          u_opacity: new e.Uniform1f(t),
          u_image0: new e.Uniform1i(t),
          u_image1: new e.Uniform1i(t),
          u_brightness_low: new e.Uniform1f(t),
          u_brightness_high: new e.Uniform1f(t),
          u_saturation_factor: new e.Uniform1f(t),
          u_contrast_factor: new e.Uniform1f(t),
          u_spin_weights: new e.Uniform3f(t),
          u_perspective_transform: new e.Uniform2f(t)
        }),
        symbolIcon: t => ({
          u_is_size_zoom_constant: new e.Uniform1i(t),
          u_is_size_feature_constant: new e.Uniform1i(t),
          u_size_t: new e.Uniform1f(t),
          u_size: new e.Uniform1f(t),
          u_camera_to_center_distance: new e.Uniform1f(t),
          u_rotate_symbol: new e.Uniform1i(t),
          u_aspect_ratio: new e.Uniform1f(t),
          u_fade_change: new e.Uniform1f(t),
          u_matrix: new e.UniformMatrix4f(t),
          u_label_plane_matrix: new e.UniformMatrix4f(t),
          u_coord_matrix: new e.UniformMatrix4f(t),
          u_is_text: new e.Uniform1i(t),
          u_pitch_with_map: new e.Uniform1i(t),
          u_texsize: new e.Uniform2f(t),
          u_tile_id: new e.Uniform3f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_inv_rot_matrix: new e.UniformMatrix4f(t),
          u_merc_center: new e.Uniform2f(t),
          u_camera_forward: new e.Uniform3f(t),
          u_tile_matrix: new e.UniformMatrix4f(t),
          u_up_vector: new e.Uniform3f(t),
          u_ecef_origin: new e.Uniform3f(t),
          u_texture: new e.Uniform1i(t)
        }),
        symbolSDF: t => ({
          u_is_size_zoom_constant: new e.Uniform1i(t),
          u_is_size_feature_constant: new e.Uniform1i(t),
          u_size_t: new e.Uniform1f(t),
          u_size: new e.Uniform1f(t),
          u_camera_to_center_distance: new e.Uniform1f(t),
          u_rotate_symbol: new e.Uniform1i(t),
          u_aspect_ratio: new e.Uniform1f(t),
          u_fade_change: new e.Uniform1f(t),
          u_matrix: new e.UniformMatrix4f(t),
          u_label_plane_matrix: new e.UniformMatrix4f(t),
          u_coord_matrix: new e.UniformMatrix4f(t),
          u_is_text: new e.Uniform1i(t),
          u_pitch_with_map: new e.Uniform1i(t),
          u_texsize: new e.Uniform2f(t),
          u_texture: new e.Uniform1i(t),
          u_gamma_scale: new e.Uniform1f(t),
          u_device_pixel_ratio: new e.Uniform1f(t),
          u_tile_id: new e.Uniform3f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_inv_rot_matrix: new e.UniformMatrix4f(t),
          u_merc_center: new e.Uniform2f(t),
          u_camera_forward: new e.Uniform3f(t),
          u_tile_matrix: new e.UniformMatrix4f(t),
          u_up_vector: new e.Uniform3f(t),
          u_ecef_origin: new e.Uniform3f(t),
          u_is_halo: new e.Uniform1i(t)
        }),
        symbolTextAndIcon: t => ({
          u_is_size_zoom_constant: new e.Uniform1i(t),
          u_is_size_feature_constant: new e.Uniform1i(t),
          u_size_t: new e.Uniform1f(t),
          u_size: new e.Uniform1f(t),
          u_camera_to_center_distance: new e.Uniform1f(t),
          u_rotate_symbol: new e.Uniform1i(t),
          u_aspect_ratio: new e.Uniform1f(t),
          u_fade_change: new e.Uniform1f(t),
          u_matrix: new e.UniformMatrix4f(t),
          u_label_plane_matrix: new e.UniformMatrix4f(t),
          u_coord_matrix: new e.UniformMatrix4f(t),
          u_is_text: new e.Uniform1i(t),
          u_pitch_with_map: new e.Uniform1i(t),
          u_texsize: new e.Uniform2f(t),
          u_texsize_icon: new e.Uniform2f(t),
          u_texture: new e.Uniform1i(t),
          u_texture_icon: new e.Uniform1i(t),
          u_gamma_scale: new e.Uniform1f(t),
          u_device_pixel_ratio: new e.Uniform1f(t),
          u_is_halo: new e.Uniform1i(t)
        }),
        background: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_opacity: new e.Uniform1f(t),
          u_color: new e.UniformColor(t)
        }),
        backgroundPattern: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_opacity: new e.Uniform1f(t),
          u_image: new e.Uniform1i(t),
          u_pattern_tl: new e.Uniform2f(t),
          u_pattern_br: new e.Uniform2f(t),
          u_texsize: new e.Uniform2f(t),
          u_pattern_size: new e.Uniform2f(t),
          u_pixel_coord_upper: new e.Uniform2f(t),
          u_pixel_coord_lower: new e.Uniform2f(t),
          u_tile_units_to_pixels: new e.Uniform1f(t)
        }),
        terrainRaster: xi,
        terrainDepth: xi,
        skybox: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_sun_direction: new e.Uniform3f(t),
          u_cubemap: new e.Uniform1i(t),
          u_opacity: new e.Uniform1f(t),
          u_temporal_offset: new e.Uniform1f(t)
        }),
        skyboxGradient: t => ({
          u_matrix: new e.UniformMatrix4f(t),
          u_color_ramp: new e.Uniform1i(t),
          u_center_direction: new e.Uniform3f(t),
          u_radius: new e.Uniform1f(t),
          u_opacity: new e.Uniform1f(t),
          u_temporal_offset: new e.Uniform1f(t)
        }),
        skyboxCapture: t => ({
          u_matrix_3f: new e.UniformMatrix3f(t),
          u_sun_direction: new e.Uniform3f(t),
          u_sun_intensity: new e.Uniform1f(t),
          u_color_tint_r: new e.Uniform4f(t),
          u_color_tint_m: new e.Uniform4f(t),
          u_luminance: new e.Uniform1f(t)
        }),
        globeRaster: t => ({
          u_proj_matrix: new e.UniformMatrix4f(t),
          u_globe_matrix: new e.UniformMatrix4f(t),
          u_normalize_matrix: new e.UniformMatrix4f(t),
          u_merc_matrix: new e.UniformMatrix4f(t),
          u_zoom_transition: new e.Uniform1f(t),
          u_merc_center: new e.Uniform2f(t),
          u_image0: new e.Uniform1i(t),
          u_grid_matrix: new e.UniformMatrix3f(t),
          u_skirt_height: new e.Uniform1f(t),
          u_frustum_tl: new e.Uniform3f(t),
          u_frustum_tr: new e.Uniform3f(t),
          u_frustum_br: new e.Uniform3f(t),
          u_frustum_bl: new e.Uniform3f(t),
          u_globe_pos: new e.Uniform3f(t),
          u_globe_radius: new e.Uniform1f(t),
          u_viewport: new e.Uniform2f(t)
        }),
        globeAtmosphere: t => ({
          u_frustum_tl: new e.Uniform3f(t),
          u_frustum_tr: new e.Uniform3f(t),
          u_frustum_br: new e.Uniform3f(t),
          u_frustum_bl: new e.Uniform3f(t),
          u_horizon: new e.Uniform1f(t),
          u_transition: new e.Uniform1f(t),
          u_fadeout_range: new e.Uniform1f(t),
          u_color: new e.Uniform4f(t),
          u_high_color: new e.Uniform4f(t),
          u_space_color: new e.Uniform4f(t),
          u_star_intensity: new e.Uniform1f(t),
          u_star_density: new e.Uniform1f(t),
          u_star_size: new e.Uniform1f(t),
          u_temporal_offset: new e.Uniform1f(t),
          u_horizon_angle: new e.Uniform1f(t),
          u_rotation_matrix: new e.UniformMatrix4f(t)
        })
      };
    let co;
    function ho(t, i, o, r, n, s, a) {
      const l = t.context,
        c = l.gl,
        h = t.transform,
        u = t.useProgram("collisionBox"),
        _ = [];
      let d = 0,
        p = 0;
      for (let m = 0; m < r.length; m++) {
        const f = r[m],
          g = i.getTile(f),
          v = g.getBucket(o);
        if (!v) continue;
        const x = yt(f, v, h);
        let y = x;
        0 === n[0] && 0 === n[1] || (y = t.translatePosMatrix(x, g, n, s));
        const b = a ? v.textCollisionBox : v.iconCollisionBox,
          w = v.collisionCircleArray;
        if (w.length > 0) {
          const t = e.create(),
            i = y;
          e.mul(t, v.placementInvProjMatrix, h.glCoordMatrix), e.mul(t, t, v.placementViewportMatrix), _.push({
            circleArray: w,
            circleOffset: p,
            transform: i,
            invTransform: t,
            projection: v.getProjection()
          }), d += w.length / 4, p = d;
        }
        b && (t.terrain && t.terrain.setupElevationDraw(g, u), u.draw(l, c.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, Wi(y, h, g, v.getProjection()), o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, h.zoom, null, [b.collisionVertexBuffer, b.collisionVertexBufferExt]));
      }
      if (!a || !_.length) return;
      const m = t.useProgram("collisionCircle"),
        f = new e.StructArrayLayout2f1f2i16();
      f.resize(4 * d), f._trim();
      let g = 0;
      for (const e of _) for (let t = 0; t < e.circleArray.length / 4; t++) {
        const i = 4 * t,
          o = e.circleArray[i + 0],
          r = e.circleArray[i + 1],
          n = e.circleArray[i + 2],
          s = e.circleArray[i + 3];
        f.emplace(g++, o, r, n, s, 0), f.emplace(g++, o, r, n, s, 1), f.emplace(g++, o, r, n, s, 2), f.emplace(g++, o, r, n, s, 3);
      }
      (!co || co.length < 2 * d) && (co = function (t) {
        const i = 2 * t,
          o = new e.StructArrayLayout3ui6();
        o.resize(i), o._trim();
        for (let e = 0; e < i; e++) {
          const t = 6 * e;
          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;
        }
        return o;
      }(d));
      const v = l.createIndexBuffer(co, !0),
        x = l.createVertexBuffer(f, e.collisionCircleLayout.members, !0);
      for (const i of _) {
        const r = {
          u_matrix: i.transform,
          u_inv_matrix: i.invTransform,
          u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection),
          u_viewport_size: [y.width, y.height]
        };
        m.draw(l, c.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, o.id, x, v, e.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
      }
      var y;
      x.destroy(), v.destroy();
    }
    const uo = e.create();
    function _o({
      width: t,
      height: i,
      anchor: o,
      textOffset: r,
      textScale: n
    }, s) {
      const {
          horizontalAlign: a,
          verticalAlign: l
        } = e.getAnchorAlignment(o),
        c = -(a - .5) * t,
        h = -(l - .5) * i,
        u = e.evaluateVariableOffset(o, r);
      return new e.pointGeometry((c / n + u[0]) * s, (h / n + u[1]) * s);
    }
    function po(t, i, o, r, n, s, a, l, c, h, u) {
      const _ = t.text.placedSymbolArray,
        d = t.text.dynamicLayoutVertexArray,
        p = t.icon.dynamicLayoutVertexArray,
        m = {},
        f = t.getProjection(),
        g = bt(l, f, s),
        v = s.elevation,
        x = f.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;
      d.clear();
      for (let p = 0; p < _.length; p++) {
        const y = _.get(p),
          {
            tileAnchorX: b,
            tileAnchorY: w,
            numGlyphs: T
          } = y,
          E = t.allowVerticalPlacement && !y.placedOrientation,
          C = y.hidden || !y.crossTileID || E ? null : r[y.crossTileID];
        if (C) {
          let r = 0,
            _ = 0,
            p = 0;
          if (v) {
            const e = v ? v.getAtTileOffset(l, b, w) : 0,
              [t, i, o] = f.upVector(l.canonical, b, w);
            r = e * t * x, _ = e * i * x, p = e * o * x;
          }
          let [E, M, I, S] = nt(y.projectedAnchorX + r, y.projectedAnchorY + _, y.projectedAnchorZ + p, o ? g : a);
          const D = st(s.getCameraToCenterDistance(f), S);
          let L = n.evaluateSizeForFeature(t.textSizeData, h, y) * D / e.ONE_EM;
          o && (L *= t.tilePixelRatio / c);
          const A = _o(C, L);
          o ? (({
            x: E,
            y: M,
            z: I
          } = f.projectTilePoint(b + A.x, w + A.y, l.canonical)), [E, M, I] = nt(E + r, M + _, I + p, a)) : (i && A._rotate(-s.angle), E += A.x, M += A.y, I = 0);
          const z = t.allowVerticalPlacement && y.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
          for (let t = 0; t < T; t++) e.addDynamicAttributes(d, E, M, I, z);
          u && y.associatedIconIndex >= 0 && (m[y.associatedIconIndex] = {
            x: E,
            y: M,
            z: I,
            angle: z
          });
        } else mt(T, d);
      }
      if (u) {
        p.clear();
        const i = t.icon.placedSymbolArray;
        for (let t = 0; t < i.length; t++) {
          const o = i.get(t),
            {
              numGlyphs: r
            } = o,
            n = m[t];
          if (o.hidden || !n) mt(r, p);else {
            const {
              x: t,
              y: i,
              z: o,
              angle: s
            } = n;
            for (let n = 0; n < r; n++) e.addDynamicAttributes(p, t, i, o, s);
          }
        }
        t.icon.dynamicLayoutVertexBuffer.updateData(p);
      }
      t.text.dynamicLayoutVertexBuffer.updateData(d);
    }
    function mo(e, t, i) {
      return i.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon";
    }
    function fo(t, i, o, r, n, s, a, l, c, h, u, _) {
      const d = t.context,
        p = d.gl,
        m = t.transform,
        f = "map" === l,
        g = "map" === c,
        v = f && "point" !== o.layout.get("symbol-placement"),
        x = f && !g && !v,
        y = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
      let b = !1;
      const w = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
        T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)],
        E = o.layout.get("text-variable-anchor"),
        C = "globe" === m.projection.name,
        M = [],
        I = [0, -1, 0];
      let S = I;
      !C && !m.mercatorFromTransition || f || (S = function (t) {
        const i = t._camera.getWorldToCamera(t.worldSize, 1),
          o = e.multiply([], i, t.globeMatrix);
        e.invert(o, o);
        const r = [0, 0, 0],
          n = [0, 1, 0, 0];
        return e.transformMat4$1(n, n, o), r[0] = n[0], r[1] = n[1], r[2] = n[2], e.normalize(r, r), r;
      }(m));
      for (const l of r) {
        const r = i.getTile(l),
          c = r.getBucket(o);
        if (!c) continue;
        if ("mercator" === c.projection.name && C) continue;
        const u = n ? c.text : c.icon;
        if (!u || c.fullyClipped || !u.segments.get().length) continue;
        const _ = u.programConfigurations.get(o.id),
          d = n || c.sdfIcons,
          w = n ? c.textSizeData : c.iconSizeData,
          D = g || 0 !== m.pitch,
          L = e.evaluateSizeForZoom(w, m.zoom);
        let A,
          z,
          P,
          R,
          O = [0, 0],
          B = null;
        if (n) {
          if (z = r.glyphAtlasTexture, P = p.LINEAR, A = r.glyphAtlasTexture.size, c.iconsInText) {
            O = r.imageAtlasTexture.size, B = r.imageAtlasTexture;
            const e = "composite" === w.kind || "camera" === w.kind;
            R = D || t.options.rotating || t.options.zooming || e ? p.LINEAR : p.NEAREST;
          }
        } else {
          const e = 1 !== o.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
          z = r.imageAtlasTexture, P = d || t.options.rotating || t.options.zooming || e || D ? p.LINEAR : p.NEAREST, A = r.imageAtlasTexture.size;
        }
        const k = "globe" === c.projection.name,
          F = k ? S : I,
          U = k ? e.globeToMercatorTransition(m.zoom) : 0,
          N = bt(l, c.getProjection(), m),
          G = m.calculatePixelsToTileUnitsMatrix(r),
          j = it(N, r.tileID.canonical, g, f, m, c.getProjection(), G),
          Z = t.terrain && g && v ? e.invert(e.create(), j) : uo,
          V = rt(N, r.tileID.canonical, g, f, m, c.getProjection(), G),
          W = E && c.hasTextData(),
          X = "none" !== o.layout.get("icon-text-fit") && W && c.hasIconData();
        if (v) {
          const e = m.elevation,
            i = e ? e.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, c.getProjection()) : null,
            o = ot(N, r.tileID.canonical, g, f, m, c.getProjection(), G);
          lt(c, N, t, n, o, V, g, h, i, l);
        }
        const q = v || n && E || X,
          $ = t.translatePosMatrix(N, r, s, a),
          H = q ? uo : j,
          Y = t.translatePosMatrix(V, r, s, a, !0),
          K = c.getProjection().createInversionMatrix(m, l.canonical),
          J = [];
        t.terrainRenderModeElevated() && g && J.push("PITCH_WITH_MAP_TERRAIN"), k && J.push("PROJECTION_GLOBE_VIEW"), q && J.push("PROJECTED_POS_ON_VIEWPORT");
        const Q = d && 0 !== o.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1);
        let ee;
        ee = d ? c.iconsInText ? no(w.kind, L, x, g, t, $, H, Y, A, O, l, U, T, K, F, c.getProjection()) : ro(w.kind, L, x, g, t, $, H, Y, n, A, !0, l, U, T, K, F, c.getProjection()) : oo(w.kind, L, x, g, t, $, H, Y, n, A, l, U, T, K, F, c.getProjection());
        const te = {
          program: t.useProgram(mo(d, n, c), _, J),
          buffers: u,
          uniformValues: ee,
          atlasTexture: z,
          atlasTextureIcon: B,
          atlasInterpolation: P,
          atlasInterpolationIcon: R,
          isSDF: d,
          hasHalo: Q,
          tile: r,
          labelPlaneMatrixInv: Z
        };
        if (y && c.canOverlap) {
          b = !0;
          const t = u.segments.get();
          for (const i of t) M.push({
            segments: new e.SegmentVector([i]),
            sortKey: i.sortKey,
            state: te
          });
        } else M.push({
          segments: u.segments,
          sortKey: 0,
          state: te
        });
      }
      b && M.sort((e, t) => e.sortKey - t.sortKey);
      for (const e of M) {
        const i = e.state;
        if (t.terrain && t.terrain.setupElevationDraw(i.tile, i.program, {
          useDepthForOcclusion: !C,
          labelPlaneMatrixInv: i.labelPlaneMatrixInv
        }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {
          const r = i.uniformValues;
          i.hasHalo && (r.u_is_halo = 1, go(i.buffers, e.segments, o, t, i.program, w, u, _, r)), r.u_is_halo = 0;
        }
        go(i.buffers, e.segments, o, t, i.program, w, u, _, i.uniformValues);
      }
    }
    function go(t, i, o, r, n, s, a, l, c) {
      const h = r.context,
        u = [t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer, t.globeExtVertexBuffer];
      n.draw(h, h.gl.TRIANGLES, s, a, l, e.CullFaceMode.disabled, c, o.id, t.layoutVertexBuffer, t.indexBuffer, i, o.paint, r.transform.zoom, t.programConfigurations.get(o.id), u);
    }
    function vo(t, i, o, r, n, s, a) {
      const l = t.context.gl,
        c = o.paint.get("fill-pattern"),
        h = c && c.constantOr(1);
      let u, _, d, p, m;
      a ? (_ = h && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u = l.LINES) : (_ = h ? "fillPattern" : "fill", u = l.TRIANGLES);
      for (const f of r) {
        const r = i.getTile(f);
        if (h && !r.patternsLoaded()) continue;
        const g = r.getBucket(o);
        if (!g) continue;
        t.prepareDrawTile();
        const v = g.programConfigurations.get(o.id),
          x = t.useProgram(_, v);
        h && (t.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers());
        const y = c.constantOr(null);
        if (y && r.imageAtlas) {
          const e = r.imageAtlas.patternPositions[y.toString()];
          e && v.setConstantPatternPositions(e);
        }
        const b = t.translatePosMatrix(f.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));
        if (a) {
          p = g.indexBuffer2, m = g.segments2;
          const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];
          d = "fillOutlinePattern" === _ && h ? Gi(b, t, r, e) : Ni(b, e);
        } else p = g.indexBuffer, m = g.segments, d = h ? Ui(b, t, r) : Fi(b);
        t.prepareDrawProgram(t.context, x, f.toUnwrapped()), x.draw(t.context, u, n, t.stencilModeForClipping(f), s, e.CullFaceMode.disabled, d, o.id, g.layoutVertexBuffer, p, m, o.paint, t.transform.zoom, v);
      }
    }
    function xo(t, i, o, r, n, s, a) {
      const l = t.context,
        c = l.gl,
        h = t.transform,
        u = o.paint.get("fill-extrusion-pattern"),
        _ = u.constantOr(1),
        d = o.paint.get("fill-extrusion-opacity"),
        p = [o.paint.get("fill-extrusion-ambient-occlusion-intensity"), o.paint.get("fill-extrusion-ambient-occlusion-radius")],
        m = o.layout.get("fill-extrusion-edge-radius"),
        f = "globe" === h.projection.name ? e.fillExtrusionHeightLift() : 0,
        g = "globe" === h.projection.name,
        v = g ? e.globeToMercatorTransition(h.zoom) : 0,
        x = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)],
        y = [];
      g && y.push("PROJECTION_GLOBE_VIEW"), p[0] > 0 && y.push("FAUX_AO");
      for (const b of r) {
        const r = i.getTile(b),
          w = r.getBucket(o);
        if (!w || w.projection.name !== h.projection.name) continue;
        const T = w.programConfigurations.get(o.id),
          E = t.useProgram(_ ? "fillExtrusionPattern" : "fillExtrusion", T, y);
        if (t.terrain) {
          const e = t.terrain;
          if (t.style.terrainSetForDrapingOnly()) e.setupElevationDraw(r, E, {
            useMeterToDem: !0
          });else {
            if (!w.enableTerrain) continue;
            if (e.setupElevationDraw(r, E, {
              useMeterToDem: !0
            }), yo(l, i, b, w, o, e), !w.centroidVertexBuffer) {
              const e = E.attributes.a_centroid_pos;
              void 0 !== e && c.vertexAttrib2f(e, 0, 0);
            }
          }
        }
        _ && (t.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), T.updatePaintBuffers());
        const C = u.constantOr(null);
        if (C && r.imageAtlas) {
          const e = r.imageAtlas.patternPositions[C.toString()];
          e && T.setConstantPatternPositions(e);
        }
        const M = t.translatePosMatrix(b.projMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")),
          I = h.projection.createInversionMatrix(h, b.canonical),
          S = o.paint.get("fill-extrusion-vertical-gradient"),
          D = _ ? ki(M, t, S, d, p, m, b, r, f, v, x, I) : Bi(M, t, S, d, p, m, b, f, v, x, I);
        t.prepareDrawProgram(l, E, b.toUnwrapped());
        const L = [];
        t.terrain && L.push(w.centroidVertexBuffer), g && L.push(w.layoutVertexExtBuffer), E.draw(l, l.gl.TRIANGLES, n, s, a, e.CullFaceMode.backCCW, D, o.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, o.paint, t.transform.zoom, T, L);
      }
    }
    function yo(t, i, o, r, n, s) {
      const a = [t => {
          let i = t.canonical.x - 1,
            o = t.wrap;
          return i < 0 && (i = (1 << t.canonical.z) - 1, o--), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);
        }, t => {
          let i = t.canonical.x + 1,
            o = t.wrap;
          return i === 1 << t.canonical.z && (i = 0, o++), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);
        }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)],
        l = e => {
          const t = i.getSource().minzoom,
            o = e => {
              const t = i.getTileByID(e);
              if (t && t.hasData()) return t.getBucket(n);
            },
            r = [0, -1, 1];
          for (const i of r) {
            if (e.overscaledZ + i < t) continue;
            const r = o(e.calculateScaledKey(e.overscaledZ + i));
            if (r) return r;
          }
        },
        c = [0, 0, 0],
        h = (t, i) => (c[0] = Math.min(t.min.y, i.min.y), c[1] = Math.max(t.max.y, i.max.y), c[2] = e.EXTENT - i.min.x > t.max.x ? i.min.x - e.EXTENT : t.max.x, c),
        u = (t, i) => (c[0] = Math.min(t.min.x, i.min.x), c[1] = Math.max(t.max.x, i.max.x), c[2] = e.EXTENT - i.min.y > t.max.y ? i.min.y - e.EXTENT : t.max.y, c),
        _ = [(e, t) => h(e, t), (e, t) => h(t, e), (e, t) => u(e, t), (e, t) => u(t, e)],
        d = new e.pointGeometry(0, 0);
      let p, m, f;
      const g = (t, i, r, n, a) => {
        const l = [[n ? r : t, n ? t : r, 0], [n ? r : i, n ? i : r, 0]],
          c = a < 0 ? e.EXTENT + a : a,
          h = [n ? c : (t + i) / 2, n ? (t + i) / 2 : c, 0];
        return 0 === r && a < 0 || 0 !== r && a > 0 ? s.getForTilePoints(f, [h], !0, m) : l.push(h), s.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration();
      };
      for (let t = 0; t < 4; t++) {
        const i = (t < 2 ? 1 : 5) - t,
          n = r.borders[t];
        if (0 === n.length) continue;
        const c = f = a[t](o),
          h = l(c);
        if (!(h && h instanceof e.FillExtrusionBucket && h.enableTerrain)) continue;
        if (r.borderDoneWithNeighborZ[t] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;
        if (m = s.findDEMTileFor(c), !m || !m.dem) continue;
        if (!p) {
          const e = s.findDEMTileFor(o);
          if (!e || !e.dem) return;
          p = e;
        }
        const u = h.borders[i];
        let v = 0;
        const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;
        if (r.canonical.z === h.canonical.z) {
          for (let o = 0; o < n.length; o++) {
            const s = r.featuresOnBorder[n[o]],
              a = s.borders[t];
            let l;
            for (; v < u.length && (l = h.featuresOnBorder[u[v]], !(l.borders[i][1] > a[0] + 3));) x && h.encodeCentroid(void 0, l, !1), v++;
            if (l && v < u.length) {
              const o = v;
              let n = 0;
              for (; !(l.borders[i][0] > a[1] - 3) && (n++, ++v !== u.length);) l = h.featuresOnBorder[u[v]];
              if (l = h.featuresOnBorder[u[o]], s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {
                1 !== n && (v = o), r.encodeCentroid(void 0, s, !1), x && h.encodeCentroid(void 0, l, !1);
                continue;
              }
              const c = _[t](s, l),
                p = t % 2 ? e.EXTENT - 1 : 0;
              d.x = g(c[0], Math.min(e.EXTENT - 1, c[1]), p, t < 2, c[2]), d.y = 0, r.encodeCentroid(d, s, !1), x && h.encodeCentroid(d, l, !1);
            } else r.encodeCentroid(void 0, s, !1);
          }
          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);
        } else {
          for (const e of n) r.encodeCentroid(void 0, r.featuresOnBorder[e], !1);
          if (x) {
            for (const e of u) h.encodeCentroid(void 0, h.featuresOnBorder[e], !1);
            h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;
          }
          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0;
        }
      }
      (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t);
    }
    const bo = new e.Color(1, 0, 0, 1),
      wo = new e.Color(0, 1, 0, 1),
      To = new e.Color(0, 0, 1, 1),
      Eo = new e.Color(1, 0, 1, 1),
      Co = new e.Color(0, 1, 1, 1);
    function Mo(t, i, o) {
      const r = t.context,
        n = t.transform,
        s = r.gl,
        a = "globe" === n.projection.name,
        l = a ? ["PROJECTION_GLOBE_VIEW"] : null;
      let c = o.projMatrix;
      if (a && e.globeToMercatorTransition(n.zoom) > 0) {
        const t = e.transitionTileAABBinECEF(o.canonical, n),
          i = e.globeDenormalizeECEF(t);
        c = e.multiply(new Float32Array(16), n.globeMatrix, i), e.multiply(c, n.projMatrix, c);
      }
      const h = t.useProgram("debug", null, l),
        u = i.getTileByID(o.key);
      t.terrain && t.terrain.setupElevationDraw(u, h);
      const _ = e.DepthMode.disabled,
        d = e.StencilMode.disabled,
        p = t.colorModeForRenderPass(),
        m = "$debug";
      r.activeTexture.set(s.TEXTURE0), t.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), a ? u._makeGlobeTileDebugBuffers(t.context, n) : u._makeDebugTileBoundsBuffers(t.context, n.projection);
      const f = u._tileDebugBuffer || t.debugBuffer,
        g = u._tileDebugIndexBuffer || t.debugIndexBuffer,
        v = u._tileDebugSegments || t.debugSegments;
      h.draw(r, s.LINE_STRIP, _, d, p, e.CullFaceMode.disabled, Xi(c, e.Color.red), m, f, g, v, null, null, null, [u._globeTileDebugBorderBuffer]);
      const x = u.latestRawTileData,
        y = Math.floor((x && x.byteLength || 0) / 1024),
        b = i.getTile(o).tileSize,
        w = 512 / Math.min(b, 512) * (o.overscaledZ / n.zoom) * .5;
      let T = o.canonical.toString();
      o.overscaledZ !== o.canonical.z && (T += ` => ${o.overscaledZ}`), T += ` ${y}kb`, function (e, t) {
        e.initDebugOverlayCanvas();
        const i = e.debugOverlayCanvas,
          o = e.context.gl,
          r = e.debugOverlayCanvas.getContext("2d");
        r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
      }(t, T);
      const E = u._tileDebugTextBuffer || t.debugBuffer,
        C = u._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,
        M = u._tileDebugTextSegments || t.debugSegments;
      h.draw(r, s.TRIANGLES, _, d, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Xi(c, e.Color.transparent, w), m, E, C, M, null, null, null, [u._globeTileDebugTextBuffer]);
    }
    function Io(e, t, i, o) {
      Do(e, 0, t + i / 2, e.transform.width, i, o);
    }
    function So(e, t, i, o) {
      Do(e, t - i / 2, 0, i, e.transform.height, o);
    }
    function Do(t, i, o, r, n, s) {
      const a = t.context,
        l = a.gl;
      l.enable(l.SCISSOR_TEST), l.scissor(i * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, n * e.exported.devicePixelRatio), a.clear({
        color: s
      }), l.disable(l.SCISSOR_TEST);
    }
    const Lo = e.createLayout([{
        name: "a_pos_3f",
        components: 3,
        type: "Float32"
      }]),
      {
        members: Ao
      } = Lo;
    function zo(e, t, i, o) {
      e.emplaceBack(t, i, o);
    }
    class Po {
      constructor(t) {
        this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), zo(this.vertexArray, -1, -1, 1), zo(this.vertexArray, 1, -1, 1), zo(this.vertexArray, -1, 1, 1), zo(this.vertexArray, 1, 1, 1), zo(this.vertexArray, -1, -1, -1), zo(this.vertexArray, 1, -1, -1), zo(this.vertexArray, -1, 1, -1), zo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, Ao), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
      }
    }
    function Ro(t, i, o, r, n, s) {
      const a = t.gl,
        l = i.paint.get("sky-atmosphere-color"),
        c = i.paint.get("sky-atmosphere-halo-color"),
        h = i.paint.get("sky-atmosphere-sun-intensity"),
        u = ((e, t, i, o, r) => ({
          u_matrix_3f: e,
          u_sun_direction: t,
          u_sun_intensity: i,
          u_color_tint_r: [o.r, o.g, o.b, o.a],
          u_color_tint_m: [r.r, r.g, r.b, r.a],
          u_luminance: 5e-5
        }))(e.fromMat4(e.create$1(), r), n, h, l, c);
      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0), o.draw(t, a.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
    }
    const Oo = e.createLayout([{
      type: "Float32",
      name: "a_pos",
      components: 3
    }, {
      type: "Float32",
      name: "a_uv",
      components: 2
    }]);
    class Bo {
      constructor(t) {
        const i = new e.StructArrayLayout5f20();
        i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
        const o = new e.StructArrayLayout3ui6();
        o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(i, Oo.members), this.indexBuffer = t.createIndexBuffer(o), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
      }
      destroy() {
        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
      }
    }
    const ko = {
      symbol: function (t, i, o, r, n) {
        if ("translucent" !== t.renderPass) return;
        const s = e.StencilMode.disabled,
          a = t.colorModeForRenderPass();
        o.layout.get("text-variable-anchor") && function (t, i, o, r, n, s, a) {
          const l = i.transform,
            c = "map" === n,
            h = "map" === s;
          for (const i of t) {
            const t = r.getTile(i),
              n = t.getBucket(o);
            if (!n || !n.text || !n.text.segments.get().length) continue;
            const s = e.evaluateSizeForZoom(n.textSizeData, l.zoom),
              u = bt(i, n.getProjection(), l),
              _ = l.calculatePixelsToTileUnitsMatrix(t),
              d = it(u, t.tileID.canonical, h, c, l, n.getProjection(), _),
              p = "none" !== o.layout.get("icon-text-fit") && n.hasIconData();
            if (s) {
              const o = Math.pow(2, l.zoom - t.tileID.overscaledZ);
              po(n, c, h, a, e.symbolSize, l, d, i, o, s, p);
            }
          }
        }(r, t, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), n), 0 !== o.paint.get("icon-opacity").constantOr(1) && fo(t, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), s, a), 0 !== o.paint.get("text-opacity").constantOr(1) && fo(t, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), s, a), i.map.showCollisionBoxes && (ho(t, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), ho(t, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
      },
      circle: function (t, i, o, r) {
        if ("translucent" !== t.renderPass) return;
        const n = o.paint.get("circle-opacity"),
          s = o.paint.get("circle-stroke-width"),
          a = o.paint.get("circle-stroke-opacity"),
          l = void 0 !== o.layout.get("circle-sort-key").constantOr(1);
        if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1))) return;
        const c = t.context,
          h = c.gl,
          u = t.transform,
          _ = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
          d = e.StencilMode.disabled,
          p = t.colorModeForRenderPass(),
          m = "globe" === u.projection.name,
          f = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)],
          g = [];
        for (let n = 0; n < r.length; n++) {
          const s = r[n],
            a = i.getTile(s),
            c = a.getBucket(o);
          if (!c || c.projection.name !== u.projection.name) continue;
          const h = c.programConfigurations.get(o.id),
            _ = Vi(o);
          m && _.push("PROJECTION_GLOBE_VIEW");
          const d = t.useProgram("circle", h, _),
            p = c.layoutVertexBuffer,
            v = c.globeExtVertexBuffer,
            x = c.indexBuffer,
            y = u.projection.createInversionMatrix(u, s.canonical),
            b = {
              programConfiguration: h,
              program: d,
              layoutVertexBuffer: p,
              globeExtVertexBuffer: v,
              indexBuffer: x,
              uniformValues: Zi(t, s, a, y, f, o),
              tile: a
            };
          if (l) {
            const t = c.segments.get();
            for (const i of t) g.push({
              segments: new e.SegmentVector([i]),
              sortKey: i.sortKey,
              state: b
            });
          } else g.push({
            segments: c.segments,
            sortKey: 0,
            state: b
          });
        }
        l && g.sort((e, t) => e.sortKey - t.sortKey);
        const v = {
          useDepthForOcclusion: !m
        };
        for (const i of g) {
          const {
              programConfiguration: r,
              program: n,
              layoutVertexBuffer: s,
              globeExtVertexBuffer: a,
              indexBuffer: l,
              uniformValues: m,
              tile: f
            } = i.state,
            g = i.segments;
          t.terrain && t.terrain.setupElevationDraw(f, n, v), t.prepareDrawProgram(c, n, f.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, _, d, p, e.CullFaceMode.disabled, m, o.id, s, l, g, o.paint, u.zoom, r, [a]);
        }
      },
      heatmap: function (t, i, o, r) {
        if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) {
          const n = t.context,
            s = n.gl,
            a = e.StencilMode.disabled,
            l = new e.ColorMode([s.ONE, s.ONE], e.Color.transparent, [!0, !0, !0, !0]);
          !function (e, t, i, o) {
            const r = e.gl,
              n = t.width * o,
              s = t.height * o;
            e.activeTexture.set(r.TEXTURE1), e.viewport.set([0, 0, n, s]);
            let a = i.heatmapFbo;
            if (!a || a && (a.width !== n || a.height !== s)) {
              a && a.destroy();
              const t = r.createTexture();
              r.bindTexture(r.TEXTURE_2D, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e.createFramebuffer(n, s, !1), function (e, t, i, o, r, n) {
                const s = e.gl;
                s.texImage2D(s.TEXTURE_2D, 0, e.isWebGL2 && e.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, r, n, 0, s.RGBA, e.extRenderToTextureHalfFloat ? e.isWebGL2 ? s.HALF_FLOAT : e.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
              }(e, 0, t, a, n, s);
            } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);
          }(n, t, o, "globe" === t.transform.projection.name ? .5 : .25), n.clear({
            color: e.Color.transparent
          });
          const c = t.transform,
            h = "globe" === c.projection.name,
            u = h ? ["PROJECTION_GLOBE_VIEW"] : null,
            _ = h ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled,
            d = [e.mercatorXfromLng(c.center.lng), e.mercatorYfromLat(c.center.lat)];
          for (let p = 0; p < r.length; p++) {
            const m = r[p];
            if (i.hasRenderableParent(m)) continue;
            const f = i.getTile(m),
              g = f.getBucket(o);
            if (!g || g.projection.name !== c.projection.name) continue;
            const v = g.programConfigurations.get(o.id),
              x = t.useProgram("heatmap", v, u),
              {
                zoom: y
              } = t.transform;
            t.terrain && t.terrain.setupElevationDraw(f, x), t.prepareDrawProgram(n, x, m.toUnwrapped());
            const b = c.projection.createInversionMatrix(c, m.canonical);
            x.draw(n, s.TRIANGLES, e.DepthMode.disabled, a, l, _, $i(t, m, f, b, d, y, o.paint.get("heatmap-intensity")), o.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, o.paint, t.transform.zoom, v, h ? [g.globeExtVertexBuffer] : null);
          }
          n.viewport.set([0, 0, t.width, t.height]);
        } else "translucent" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {
          const o = t.context,
            r = o.gl,
            n = i.heatmapFbo;
          if (!n) return;
          o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);
          let s = i.colorRampTexture;
          s || (s = i.colorRampTexture = new e.Texture(o, i.colorRamp, r.RGBA)), s.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.useProgram("heatmapTexture").draw(o, r.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, i, o) => ({
            u_image: 0,
            u_color_ramp: 1,
            u_opacity: t.paint.get("heatmap-opacity")
          }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);
        }(t, o));
      },
      line: function (t, i, o, r) {
        if ("translucent" !== t.renderPass) return;
        const n = o.paint.get("line-opacity"),
          s = o.paint.get("line-width");
        if (0 === n.constantOr(1) || 0 === s.constantOr(1)) return;
        const a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
          l = t.colorModeForRenderPass(),
          c = t.terrain && t.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio,
          h = o.paint.get("line-dasharray"),
          u = h.constantOr(1),
          _ = o.layout.get("line-cap"),
          d = o.paint.get("line-pattern"),
          p = d.constantOr(1),
          m = o.paint.get("line-gradient"),
          f = p ? "linePattern" : "line",
          g = t.context,
          v = g.gl,
          x = (e => {
            const t = [];
            Qi(e) && t.push("RENDER_LINE_DASH"), e.paint.get("line-gradient") && t.push("RENDER_LINE_GRADIENT");
            const i = e.paint.get("line-trim-offset");
            0 === i[0] && 0 === i[1] || t.push("RENDER_LINE_TRIM_OFFSET");
            const o = e.paint.get("line-pattern").constantOr(1),
              r = 1 !== e.paint.get("line-opacity").constantOr(1);
            return !o && r && t.push("RENDER_LINE_ALPHA_DISCARD"), t;
          })(o);
        let y = x.includes("RENDER_LINE_ALPHA_DISCARD");
        t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (y = !1);
        for (const n of r) {
          const r = i.getTile(n);
          if (p && !r.patternsLoaded()) continue;
          const s = r.getBucket(o);
          if (!s) continue;
          t.prepareDrawTile();
          const b = s.programConfigurations.get(o.id),
            w = t.useProgram(f, b, x),
            T = d.constantOr(null);
          if (T && r.imageAtlas) {
            const e = r.imageAtlas.patternPositions[T.toString()];
            e && b.setConstantPatternPositions(e);
          }
          const E = h.constantOr(null),
            C = _.constantOr(null);
          if (!p && E && C && r.lineAtlas) {
            const e = r.lineAtlas.getDash(E, C);
            e && b.setConstantPatternPositions(e);
          }
          let [M, I] = o.paint.get("line-trim-offset");
          if ("round" === C || "square" === C) {
            const e = 1;
            M !== I && (0 === M && (M -= e), 1 === I && (I += e));
          }
          const S = t.terrain ? n.projMatrix : null,
            D = p ? Yi(t, r, o, S, c) : Hi(t, r, o, S, s.lineClipsArray.length, c, [M, I]);
          if (m) {
            const r = s.gradients[o.id];
            let a = r.texture;
            if (o.gradientVersion !== r.version) {
              let l = 256;
              if (o.stepInterpolant) {
                const o = i.getSource().maxzoom,
                  r = n.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - n.canonical.z) : 1;
                l = e.clamp(e.nextPowerOfTwo(s.maxLineLength / e.EXTENT * 1024 * r), 256, g.maxTextureSize);
              }
              r.gradient = e.renderColorRamp({
                expression: o.gradientExpression(),
                evaluationKey: "lineProgress",
                resolution: l,
                image: r.gradient || void 0,
                clips: s.lineClipsArray
              }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.Texture(g, r.gradient, v.RGBA), r.version = o.gradientVersion, a = r.texture;
            }
            g.activeTexture.set(v.TEXTURE1), a.bind(o.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE);
          }
          u && (g.activeTexture.set(v.TEXTURE0), r.lineAtlasTexture.bind(v.LINEAR, v.REPEAT), b.updatePaintBuffers()), p && (g.activeTexture.set(v.TEXTURE0), r.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), b.updatePaintBuffers()), t.prepareDrawProgram(g, w, n.toUnwrapped());
          const L = i => {
            w.draw(g, v.TRIANGLES, a, i, l, e.CullFaceMode.disabled, D, o.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, o.paint, t.transform.zoom, b, [s.layoutVertexBuffer2]);
          };
          if (y) {
            const i = t.stencilModeForClipping(n).ref;
            0 === i && t.terrain && g.clear({
              stencil: 0
            });
            const o = {
              func: v.EQUAL,
              mask: 255
            };
            D.u_alpha_discard_threshold = .8, L(new e.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.INVERT)), D.u_alpha_discard_threshold = 0, L(new e.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.KEEP));
          } else L(t.stencilModeForClipping(n));
        }
        y && (t.resetStencilClippingMasks(), t.terrain && g.clear({
          stencil: 0
        }));
      },
      fill: function (t, i, o, r) {
        const n = o.paint.get("fill-color"),
          s = o.paint.get("fill-opacity");
        if (0 === s.constantOr(1)) return;
        const a = t.colorModeForRenderPass(),
          l = o.paint.get("fill-pattern"),
          c = t.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";
        if (t.renderPass === c) {
          const n = t.depthModeForSublayer(1, "opaque" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
          vo(t, i, o, r, n, a, !1);
        }
        if ("translucent" === t.renderPass && o.paint.get("fill-antialias")) {
          const n = t.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
          vo(t, i, o, r, n, a, !0);
        }
      },
      "fill-extrusion": function (t, i, o, r) {
        const n = o.paint.get("fill-extrusion-opacity");
        if (0 !== n && "translucent" === t.renderPass) {
          const s = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
          if (1 !== n || o.paint.get("fill-extrusion-pattern").constantOr(1)) xo(t, i, o, r, s, e.StencilMode.disabled, e.ColorMode.disabled), xo(t, i, o, r, s, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks();else {
            const n = t.colorModeForRenderPass();
            xo(t, i, o, r, s, e.StencilMode.disabled, n);
          }
        }
      },
      hillshade: function (t, i, o, r) {
        if ("offscreen" !== t.renderPass && "translucent" !== t.renderPass) return;
        const n = t.context,
          s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
          a = t.colorModeForRenderPass(),
          l = t.terrain && t.terrain.renderingToTexture,
          [c, h] = "translucent" !== t.renderPass || l ? [{}, r] : t.stencilConfigForOverlap(r);
        for (const r of h) {
          const n = i.getTile(r);
          if (n.needsHillshadePrepare && "offscreen" === t.renderPass) vi(t, n, o, s, e.StencilMode.disabled, a);else if ("translucent" === t.renderPass) {
            const e = l && t.terrain ? t.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];
            fi(t, r, n, o, s, e, a);
          }
        }
        n.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks();
      },
      raster: function (t, i, o, r, n, s) {
        if ("translucent" !== t.renderPass) return;
        if (0 === o.paint.get("raster-opacity")) return;
        if (!r.length) return;
        const a = t.context,
          l = a.gl,
          c = i.getSource(),
          h = t.useProgram("raster"),
          u = t.colorModeForRenderPass(),
          _ = t.terrain && t.terrain.renderingToTexture,
          [d, p] = c instanceof Ae || _ ? [{}, r] : t.stencilConfigForOverlap(r),
          m = p[p.length - 1].overscaledZ,
          f = !t.options.moving;
        for (const r of p) {
          const n = _ ? e.DepthMode.disabled : t.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l.LESS),
            p = r.toUnwrapped(),
            g = i.getTile(r);
          if (_ && (!g || !g.hasData())) continue;
          const v = _ ? r.projMatrix : t.transform.calculateProjMatrix(p, f),
            x = t.terrain && _ ? t.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ],
            y = s ? 0 : o.paint.get("raster-fade-duration");
          g.registerFadeDuration(y);
          const b = i.findLoadedParent(r, 0),
            w = Si(g, b, i, t.transform, y);
          let T, E;
          t.terrain && t.terrain.prepareDrawTile();
          const C = "nearest" === o.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
          a.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), a.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [g.tileID.canonical.x * T % 1, g.tileID.canonical.y * T % 1]) : g.texture.bind(C, l.CLAMP_TO_EDGE);
          const M = eo(v, E || [0, 0], T || 1, w, o, c instanceof Ae ? c.perspectiveTransform : [0, 0]);
          if (t.prepareDrawProgram(a, h, p), c instanceof Ae) c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, n, e.StencilMode.disabled, u, e.CullFaceMode.disabled, M, o.id, c.boundsBuffer, t.quadTriangleIndexBuffer, c.boundsSegments);else {
            const {
              tileBoundsBuffer: i,
              tileBoundsIndexBuffer: r,
              tileBoundsSegments: s
            } = t.getTileBoundsBuffers(g);
            h.draw(a, l.TRIANGLES, n, x, u, e.CullFaceMode.disabled, M, o.id, i, r, s);
          }
        }
        t.resetStencilClippingMasks();
      },
      background: function (t, i, o, r) {
        const n = o.paint.get("background-color"),
          s = o.paint.get("background-opacity");
        if (0 === s) return;
        const a = t.context,
          l = a.gl,
          c = t.transform,
          h = c.tileSize,
          u = o.paint.get("background-pattern");
        if (t.isPatternMissing(u)) return;
        const _ = !u && 1 === n.a && 1 === s && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t.renderPass !== _) return;
        const d = e.StencilMode.disabled,
          p = t.depthModeForSublayer(0, "opaque" === _ ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly),
          m = t.colorModeForRenderPass(),
          f = t.useProgram(u ? "backgroundPattern" : "background");
        let g,
          v = r;
        v || (g = t.getBackgroundTiles(), v = Object.values(g).map(e => e.tileID)), u && (a.activeTexture.set(l.TEXTURE0), t.imageManager.bind(t.context));
        for (const _ of v) {
          const v = _.toUnwrapped(),
            x = r ? _.projMatrix : t.transform.calculateProjMatrix(v);
          t.prepareDrawTile();
          const y = i ? i.getTile(_) : g ? g[_.key] : new e.Tile(_, h, c.zoom, t),
            b = u ? ao(x, s, t, u, {
              tileID: _,
              tileSize: h
            }) : so(x, s, n);
          t.prepareDrawProgram(a, f, v);
          const {
            tileBoundsBuffer: w,
            tileBoundsIndexBuffer: T,
            tileBoundsSegments: E
          } = t.getTileBoundsBuffers(y);
          f.draw(a, l.TRIANGLES, p, d, m, e.CullFaceMode.disabled, b, o.id, w, T, E);
        }
      },
      sky: function (t, i, o) {
        const r = t.transform,
          n = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : e.smoothstep(7, 8, r.zoom),
          s = o.paint.get("sky-opacity") * n;
        if (0 === s) return;
        const a = t.context,
          l = o.paint.get("sky-type"),
          c = new e.DepthMode(a.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
          h = t.frameCounter / 1e3 % 1;
        "atmosphere" === l ? "offscreen" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, r) {
          const n = t.context,
            s = n.gl;
          let a = i.skyboxFbo;
          if (!a) {
            a = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new Po(n), i.skyboxTexture = n.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
            for (let e = 0; e < 6; ++e) s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);
          }
          n.bindFramebuffer.set(a.framebuffer), n.viewport.set([0, 0, 32, 32]);
          const l = i.getCenter(t, !0),
            c = t.useProgram("skyboxCapture"),
            h = new Float64Array(16);
          e.identity(h), e.rotateY(h, h, .5 * -Math.PI), Ro(n, i, c, h, l, 0), e.identity(h), e.rotateY(h, h, .5 * Math.PI), Ro(n, i, c, h, l, 1), e.identity(h), e.rotateX(h, h, .5 * -Math.PI), Ro(n, i, c, h, l, 2), e.identity(h), e.rotateX(h, h, .5 * Math.PI), Ro(n, i, c, h, l, 3), e.identity(h), Ro(n, i, c, h, l, 4), e.identity(h), e.rotateY(h, h, Math.PI), Ro(n, i, c, h, l, 5), n.viewport.set([0, 0, t.width, t.height]);
        }(t, o), o.markSkyboxValid(t)) : "sky" === t.renderPass && function (t, i, o, r, n) {
          const s = t.context,
            a = s.gl,
            l = t.transform,
            c = t.useProgram("skybox");
          s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);
          const h = ((e, t, i, o, r) => ({
            u_matrix: e,
            u_sun_direction: t,
            u_cubemap: 0,
            u_opacity: o,
            u_temporal_offset: r
          }))(l.skyboxMatrix, i.getCenter(t, !1), 0, r, n);
          t.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }(t, o, c, s, h) : "gradient" === l && "sky" === t.renderPass && function (t, i, o, r, n) {
          const s = t.context,
            a = s.gl,
            l = t.transform,
            c = t.useProgram("skyboxGradient");
          i.skyboxGeometry || (i.skyboxGeometry = new Po(s)), s.activeTexture.set(a.TEXTURE0);
          let h = i.colorRampTexture;
          h || (h = i.colorRampTexture = new e.Texture(s, i.colorRamp, a.RGBA)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          const u = ((t, i, o, r, n) => ({
            u_matrix: t,
            u_color_ramp: 0,
            u_center_direction: i,
            u_radius: e.degToRad(o),
            u_opacity: r,
            u_temporal_offset: n
          }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get("sky-gradient-radius"), r, n);
          t.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }(t, o, c, s, h);
      },
      debug: function (e, t, i) {
        for (let o = 0; o < i.length; o++) Mo(e, t, i[o]);
      },
      custom: function (t, i, o, r) {
        const n = t.context,
          s = o.implementation;
        if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes("custom") || t.terrain && (t.terrain.renderingToTexture || "offscreen" === t.renderPass) && o.isLayerDraped()) {
          if ("offscreen" === t.renderPass) {
            const i = s.prerender;
            if (i) {
              if (t.setCustomLayerDefaults(), n.setColorMode(t.colorModeForRenderPass()), "globe" === t.transform.projection.name) {
                const o = t.transform.pointMerc;
                i.call(s, n.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [o.x, o.y], t.transform.pixelsPerMeterRatio);
              } else i.call(s, n.gl, t.transform.customLayerMatrix());
              n.setDirty(), t.setBaseState();
            }
          } else if ("translucent" === t.renderPass) {
            if (t.terrain && t.terrain.renderingToTexture) {
              const i = s.renderToTile;
              if (i) {
                const o = r[0].canonical,
                  a = new e.MercatorCoordinate(o.x + r[0].wrap * (1 << o.z), o.y, o.z);
                n.setDepthMode(e.DepthMode.disabled), n.setStencilMode(e.StencilMode.disabled), n.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), i.call(s, n.gl, a), n.setDirty(), t.setBaseState();
              }
              return;
            }
            t.setCustomLayerDefaults(), n.setColorMode(t.colorModeForRenderPass()), n.setStencilMode(e.StencilMode.disabled);
            const i = "3d" === s.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly);
            if (n.setDepthMode(i), "globe" === t.transform.projection.name) {
              const i = t.transform.pointMerc;
              s.render(n.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [i.x, i.y], t.transform.pixelsPerMeterRatio);
            } else s.render(n.gl, t.transform.customLayerMatrix());
            n.setDirty(), t.setBaseState(), n.bindFramebuffer.set(null);
          }
        } else e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }
    };
    class Fo {
      constructor(t, i, o = !1) {
        this.context = new Me(t, o), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new qt(), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
      }
      updateTerrain(e, t) {
        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
        if (!(i || this._terrain && this._terrain.enabled)) return;
        this._terrain || (this._terrain = new zi(this, e));
        const o = this._terrain;
        this.transform.elevation = i ? o : null, o.update(e, this.transform, t);
      }
      _updateFog(e) {
        const t = e.fog;
        if (!t || "globe" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
        const [i, o] = t.getFovAdjustedRange(this.transform._fov);
        if (i > o) return void (this.transform.fogCullDistSq = null);
        const r = i + .78 * (o - i);
        this.transform.fogCullDistSq = r * r;
      }
      get terrain() {
        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
      }
      resize(t, i) {
        if (this.width = t * e.exported.devicePixelRatio, this.height = i * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize();
      }
      setup() {
        const t = this.context,
          i = new e.StructArrayLayout2i4();
        i.emplaceBack(0, 0), i.emplaceBack(e.EXTENT, 0), i.emplaceBack(0, e.EXTENT), i.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        const o = new e.StructArrayLayout2i4();
        o.emplaceBack(0, 0), o.emplaceBack(e.EXTENT, 0), o.emplaceBack(0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(o, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
        const r = new e.StructArrayLayout2i4();
        r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        const n = new e.StructArrayLayout4i8();
        n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(n, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        const s = new e.StructArrayLayout3ui6();
        s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(s);
        const a = new e.StructArrayLayout1ui2();
        for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e);
        this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.Texture(t, new e.RGBAImage({
          width: 1,
          height: 1
        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.create();
        const l = this.context.gl;
        this.stencilClearMode = new e.StencilMode({
          func: l.ALWAYS,
          mask: 0
        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Bo(this.context);
      }
      getMercatorTileBoundsBuffers() {
        return {
          tileBoundsBuffer: this.mercatorBoundsBuffer,
          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
          tileBoundsSegments: this.mercatorBoundsSegments
        };
      }
      getTileBoundsBuffers(e) {
        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
          tileBoundsBuffer: e._tileBoundsBuffer,
          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
          tileBoundsSegments: e._tileBoundsSegments
        } : this.getMercatorTileBoundsBuffers();
      }
      clearStencil() {
        const t = this.context,
          i = t.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t, i.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }
      resetStencilClippingMasks() {
        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
      }
      _renderTileClippingMasks(t, i, o) {
        if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !o || 0 === o.length) return;
        if (this._tileClippingMaskIDs && !this.terrain) {
          let e = !1;
          for (const t of o) if (void 0 === this._tileClippingMaskIDs[t.key]) {
            e = !0;
            break;
          }
          if (!e) return;
        }
        this.currentStencilSource = i.id;
        const r = this.context,
          n = r.gl;
        this.nextStencilID + o.length > 256 && this.clearStencil(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
        const s = this.useProgram("clippingMask");
        this._tileClippingMaskIDs = {};
        for (const t of o) {
          const o = i.getTile(t),
            a = this._tileClippingMaskIDs[t.key] = this.nextStencilID++,
            {
              tileBoundsBuffer: l,
              tileBoundsIndexBuffer: c,
              tileBoundsSegments: h
            } = this.getTileBoundsBuffers(o);
          s.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({
            func: n.ALWAYS,
            mask: 0
          }, a, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ii(t.projMatrix), "$clipping", l, c, h);
        }
      }
      stencilModeFor3D() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        const t = this.nextStencilID++,
          i = this.context.gl;
        return new e.StencilMode({
          func: i.NOTEQUAL,
          mask: 255
        }, t, 255, i.KEEP, i.KEEP, i.REPLACE);
      }
      stencilModeForClipping(t) {
        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
        const i = this.context.gl;
        return new e.StencilMode({
          func: i.EQUAL,
          mask: 255
        }, this._tileClippingMaskIDs[t.key], 0, i.KEEP, i.KEEP, i.REPLACE);
      }
      stencilConfigForOverlap(t) {
        const i = this.context.gl,
          o = t.sort((e, t) => t.overscaledZ - e.overscaledZ),
          r = o[o.length - 1].overscaledZ,
          n = o[0].overscaledZ - r + 1;
        if (n > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();
          const t = {};
          for (let o = 0; o < n; o++) t[o + r] = new e.StencilMode({
            func: i.GEQUAL,
            mask: 255
          }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
          return this.nextStencilID += n, [t, o];
        }
        return [{
          [r]: e.StencilMode.disabled
        }, o];
      }
      colorModeForRenderPass() {
        const t = this.context.gl;
        if (this._showOverdrawInspector) {
          const i = 1 / 8;
          return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(i, i, i, 0), [!0, !0, !0, !0]);
        }
        return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
      }
      depthModeForSublayer(t, i, o) {
        if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;
        const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
        return new e.DepthMode(o || this.context.gl.LEQUAL, i, [r, r]);
      }
      opaquePassEnabledForLayer() {
        return this.currentLayer < this.opaquePassCutoff;
      }
      render(t, i) {
        this.style = t, this.options = i, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
        const o = this.style.order,
          r = this.style._sourceCaches;
        for (const e in r) {
          const t = r[e];
          t.used && t.prepare(this.context);
        }
        const n = {},
          s = {},
          a = {};
        for (const e in r) {
          const t = r[e];
          n[e] = t.getVisibleCoordinates(), s[e] = n[e].slice().reverse(), a[e] = t.getVisibleCoordinates(!0).reverse();
        }
        this.opaquePassCutoff = 1 / 0;
        for (let e = 0; e < o.length; e++) if (this.style._layers[o[e]].is3D()) {
          this.opaquePassCutoff = e;
          break;
        }
        if (this.terrain && (this.terrain.updateTileBinding(a), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), e.isMapAuthenticated(this.context.gl)) {
          this.renderPass = "offscreen";
          for (const e of o) {
            const i = this.style._layers[e],
              o = t._getLayerSourceCache(i);
            if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;
            const r = o ? s[o.id] : void 0;
            ("custom" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);
          }
          if (this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({
            color: i.showOverdrawInspector ? e.Color.black : e.Color.transparent,
            depth: 1
          }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const e = this.style._layers[o[this.currentLayer]],
              i = t._getLayerSourceCache(e);
            if (e.isSky()) continue;
            const r = i ? s[i.id] : void 0;
            this._renderTileClippingMasks(e, i, r), this.renderLayer(this, i, e, r);
          }
          if (this.style.fog && this.transform.projection.supportsFog && function (t, i) {
            const o = t.context,
              r = o.gl,
              n = t.transform,
              s = new e.DepthMode(r.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
              a = t.useProgram("globeAtmosphere", null, "globe" === n.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]),
              l = e.globeToMercatorTransition(n.zoom),
              c = i.properties.get("color").toArray01(),
              h = i.properties.get("high-color").toArray01(),
              u = i.properties.get("space-color").toArray01PremultipliedAlpha(),
              _ = e.identity$1([]);
            e.rotateY$1(_, _, -e.degToRad(n._center.lng)), e.rotateX$1(_, _, e.degToRad(n._center.lat)), e.rotateZ$1(_, _, n.angle), e.rotateX$1(_, _, -n._pitch);
            const d = e.fromQuat(new Float32Array(16), _),
              p = e.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25),
              m = 5e-4,
              f = e.mapValue(i.properties.get("horizon-blend"), 0, 1, m, .25),
              g = e.globeUseCustomAntiAliasing(t, o, n) && f === m ? n.worldSize / (2 * Math.PI * 1.025) - 1 : n.globeRadius,
              v = t.frameCounter / 1e3 % 1,
              x = e.length(n.globeCenterInViewSpace),
              y = Math.sqrt(Math.pow(x, 2) - Math.pow(g, 2)),
              b = Math.acos(y / x),
              w = ((t, i, o, r, n, s, a, l, c, h, u, _, d, p) => ({
                u_frustum_tl: t,
                u_frustum_tr: i,
                u_frustum_br: o,
                u_frustum_bl: r,
                u_horizon: n,
                u_transition: s,
                u_fadeout_range: a,
                u_color: l,
                u_high_color: c,
                u_space_color: h,
                u_star_intensity: u,
                u_star_size: 5 * e.exported.devicePixelRatio,
                u_star_density: 0,
                u_temporal_offset: _,
                u_horizon_angle: d,
                u_rotation_matrix: p
              }))(n.frustumCorners.TL, n.frustumCorners.TR, n.frustumCorners.BR, n.frustumCorners.BL, n.frustumCorners.horizon, l, f, c, h, u, p, v, b, d);
            t.prepareDrawProgram(o, a);
            const T = t.atmosphereBuffer;
            T && a.draw(o, r.TRIANGLES, s, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w, "skybox", T.vertexBuffer, T.indexBuffer, T.segments);
          }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {
            const e = this.style._layers[o[this.currentLayer]],
              i = t._getLayerSourceCache(e);
            e.isSky() && this.renderLayer(this, i, e, i ? s[i.id] : void 0);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length;) {
            const e = this.style._layers[o[this.currentLayer]],
              i = t._getLayerSourceCache(e);
            if (e.isSky()) {
              ++this.currentLayer;
              continue;
            }
            if (this.terrain && this.style.isLayerDraped(e)) {
              if (e.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer);
              continue;
            }
            const r = i ? ("symbol" === e.type ? a : s)[i.id] : void 0;
            this._renderTileClippingMasks(e, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e, r), ++this.currentLayer;
          }
          if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let i = null;
            e.values(this.style._layers).forEach(e => {
              const o = t._getLayerSourceCache(e);
              o && !e.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
            }), i && this.options.showTileBoundaries && ko.debug(this, i, i.getVisibleCoordinates());
          }
          this.options.showPadding && function (e) {
            const t = e.transform.padding;
            Io(e, e.transform.height - (t.top || 0), 3, bo), Io(e, t.bottom || 0, 3, wo), So(e, t.left || 0, 3, To), So(e, e.transform.width - (t.right || 0), 3, Eo);
            const i = e.transform.centerPoint;
            !function (e, t, i, o) {
              Do(e, t - 1, i - 10, 2, 20, o), Do(e, t - 10, i - 1, 20, 2, o);
            }(e, i.x, e.transform.height - i.y, Co);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
        }
      }
      renderLayer(e, t, i, o) {
        i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes(i.type) || e.terrain && "custom" === i.type) && ko[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
      }
      gpuTimingStart(e) {
        if (!this.options.gpuTiming) return;
        const t = this.context.extTimerQuery;
        let i = this.gpuTimers[e.id];
        i || (i = this.gpuTimers[e.id] = {
          calls: 0,
          cpuTime: 0,
          query: t.createQueryEXT()
        }), i.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, i.query);
      }
      gpuTimingDeferredRenderStart() {
        if (this.options.gpuTimingDeferredRender) {
          const e = this.context.extTimerQuery,
            t = e.createQueryEXT();
          this.deferredRenderGpuTimeQueries.push(t), e.beginQueryEXT(e.TIME_ELAPSED_EXT, t);
        }
      }
      gpuTimingDeferredRenderEnd() {
        if (!this.options.gpuTimingDeferredRender) return;
        const e = this.context.extTimerQuery;
        e.endQueryEXT(e.TIME_ELAPSED_EXT);
      }
      gpuTimingEnd() {
        if (!this.options.gpuTiming) return;
        const e = this.context.extTimerQuery;
        e.endQueryEXT(e.TIME_ELAPSED_EXT);
      }
      collectGpuTimers() {
        const e = this.gpuTimers;
        return this.gpuTimers = {}, e;
      }
      collectDeferredRenderGpuQueries() {
        const e = this.deferredRenderGpuTimeQueries;
        return this.deferredRenderGpuTimeQueries = [], e;
      }
      queryGpuTimers(e) {
        const t = {};
        for (const i in e) {
          const o = e[i],
            r = this.context.extTimerQuery,
            n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;
          r.deleteQueryEXT(o.query), t[i] = n;
        }
        return t;
      }
      queryGpuTimeDeferredRender(e) {
        if (!this.options.gpuTimingDeferredRender) return 0;
        const t = this.context.extTimerQuery;
        let i = 0;
        for (const o of e) i += t.getQueryObjectEXT(o, t.QUERY_RESULT_EXT) / 1e6, t.deleteQueryEXT(o);
        return i;
      }
      translatePosMatrix(t, i, o, r, n) {
        if (!o[0] && !o[1]) return t;
        const s = n ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
        if (s) {
          const e = Math.sin(s),
            t = Math.cos(s);
          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];
        }
        const a = [n ? o[0] : P(i, o[0], this.transform.zoom), n ? o[1] : P(i, o[1], this.transform.zoom), 0],
          l = new Float32Array(16);
        return e.translate(l, t, a), l;
      }
      saveTileTexture(e) {
        const t = this._tileTextures[e.size[0]];
        t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
      }
      getTileTexture(e) {
        const t = this._tileTextures[e];
        return t && t.length > 0 ? t.pop() : null;
      }
      isPatternMissing(e) {
        return null === e || void 0 !== e && !this.imageManager.getPattern(e.toString());
      }
      terrainRenderModeElevated() {
        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
      }
      currentGlobalDefines() {
        const e = this.terrain && this.terrain.renderingToTexture,
          t = this.terrain && 0 === this.terrain.exaggeration(),
          i = this.style && this.style.fog,
          o = [];
        return this.terrainRenderModeElevated() && o.push("TERRAIN"), "globe" === this.transform.projection.name && o.push("GLOBE"), t && o.push("ZERO_EXAGGERATION"), i && !e && 0 !== i.getOpacity(this.transform.pitch) && o.push("FOG"), e && o.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o.push("OVERDRAW_INSPECTOR"), o;
      }
      useProgram(e, t, i) {
        this.cache = this.cache || {};
        const o = i || [],
          r = this.currentGlobalDefines().concat(o),
          n = Pi.cacheKey(ui[e], e, r, t);
        return this.cache[n] || (this.cache[n] = new Pi(this.context, e, ui[e], t, lo[e], r)), this.cache[n];
      }
      setCustomLayerDefaults() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }
      setBaseState() {
        const e = this.context.gl;
        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
      }
      initDebugOverlayCanvas() {
        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }
      destroy() {
        this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
      }
      prepareDrawTile() {
        this.terrain && this.terrain.prepareDrawTile();
      }
      prepareDrawProgram(t, i, o) {
        if (this.terrain && this.terrain.renderingToTexture) return;
        const r = this.style.fog;
        if (r) {
          const n = r.getOpacity(this.transform.pitch),
            s = ((t, i, o, r, n, s, a, l, c, h, u) => {
              const _ = t.transform,
                d = i.properties.get("color").toArray01();
              d[3] = r;
              const p = t.frameCounter / 1e3 % 1;
              return {
                u_fog_matrix: o ? _.calculateFogTileMatrix(o) : t.identityMat,
                u_fog_range: i.getFovAdjustedRange(_._fov),
                u_fog_color: d,
                u_fog_horizon_blend: i.properties.get("horizon-blend"),
                u_fog_temporal_offset: p,
                u_frustum_tl: n,
                u_frustum_tr: s,
                u_frustum_br: a,
                u_frustum_bl: l,
                u_globe_pos: c,
                u_globe_radius: h,
                u_viewport: u,
                u_globe_transition: e.globeToMercatorTransition(_.zoom),
                u_is_globe: +("globe" === _.projection.name)
              };
            })(this, r, o, n, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);
          i.setFogUniformValues(t, s);
        }
      }
      setTileLoadedFlag(e) {
        this.tileLoaded = e;
      }
      saveCanvasCopy() {
        const e = this.canvasCopy();
        e && (this.frameCopies.push(e), this.tileLoaded = !1);
      }
      canvasCopy() {
        const e = this.context.gl,
          t = e.createTexture();
        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;
      }
      getCanvasCopiesAndTimestamps() {
        return {
          canvasCopies: this.frameCopies,
          timeStamps: this.loadTimeStamps
        };
      }
      averageElevationNeedsEasing() {
        if (!this.transform._elevation) return !1;
        const e = this.style && this.style.fog;
        return !!e && 0 !== e.getOpacity(this.transform.pitch);
      }
      getBackgroundTiles() {
        const t = this._backgroundTiles,
          i = this._backgroundTiles = {},
          o = this.transform.coveringTiles({
            tileSize: 512
          });
        for (const r of o) i[r.key] = t[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);
        return i;
      }
      clearBackgroundTiles() {
        this._backgroundTiles = {};
      }
    }
    class Uo {
      constructor(e = 0, t = 0, i = 0, o = 0) {
        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = e, this.bottom = t, this.left = i, this.right = o;
      }
      interpolate(t, i, o) {
        return null != i.top && null != t.top && (this.top = e.number(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.number(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.number(t.right, i.right, o)), this;
      }
      getCenter(t, i) {
        const o = e.clamp((this.left + t - this.right) / 2, 0, t),
          r = e.clamp((this.top + i - this.bottom) / 2, 0, i);
        return new e.pointGeometry(o, r);
      }
      equals(e) {
        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
      }
      clone() {
        return new Uo(this.top, this.bottom, this.left, this.right);
      }
      toJSON() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
    }
    function No(t, i) {
      const o = e.getColumn(t, 3);
      e.fromQuat(t, i), e.setColumn(t, 3, o);
    }
    function Go(t, i) {
      const o = e.identity$1([]);
      return e.rotateZ$1(o, o, -i), e.rotateX$1(o, o, -t), o;
    }
    function jo(t, i) {
      const o = [t[0], t[1], 0],
        r = [i[0], i[1], 0];
      if (e.length(o) >= 1e-15) {
        const t = e.normalize([], o);
        e.scale$2(r, t, e.dot(r, t)), i[0] = r[0], i[1] = r[1];
      }
      const n = e.cross([], i, t);
      if (e.len(n) < 1e-15) return null;
      const s = Math.atan2(-n[1], n[0]);
      return Go(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), s);
    }
    class Zo {
      constructor(e, t) {
        this.position = e, this.orientation = t;
      }
      get position() {
        return this._position;
      }
      set position(t) {
        if (t) {
          const i = t instanceof e.MercatorCoordinate ? t : new e.MercatorCoordinate(t[0], t[1], t[2]);
          this._renderWorldCopies && (i.x = e.wrap(i.x, 0, 1)), this._position = i;
        } else this._position = null;
      }
      lookAtPoint(t, i) {
        if (this.orientation = null, !this.position) return;
        const o = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0,
          r = this.position,
          n = e.MercatorCoordinate.fromLngLat(t, o),
          s = [n.x - r.x, n.y - r.y, n.z - r.z];
        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = jo(s, i);
      }
      setPitchBearing(t, i) {
        this.orientation = Go(e.degToRad(t), e.degToRad(-i));
      }
    }
    class Vo {
      constructor(t, i) {
        this._transform = e.identity([]), this.orientation = i, this.position = t;
      }
      get mercatorPosition() {
        const t = this.position;
        return new e.MercatorCoordinate(t[0], t[1], t[2]);
      }
      get position() {
        const t = e.getColumn(this._transform, 3);
        return [t[0], t[1], t[2]];
      }
      set position(t) {
        var i;
        t && e.setColumn(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);
      }
      get orientation() {
        return this._orientation;
      }
      set orientation(t) {
        this._orientation = t || e.identity$1([]), t && No(this._transform, this._orientation);
      }
      getPitchBearing() {
        const e = this.forward(),
          t = this.right();
        return {
          bearing: Math.atan2(-t[1], t[0]),
          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
        };
      }
      setPitchBearing(e, t) {
        this._orientation = Go(e, t), No(this._transform, this._orientation);
      }
      forward() {
        const t = e.getColumn(this._transform, 2);
        return [-t[0], -t[1], -t[2]];
      }
      up() {
        const t = e.getColumn(this._transform, 1);
        return [-t[0], -t[1], -t[2]];
      }
      right() {
        const t = e.getColumn(this._transform, 0);
        return [t[0], t[1], t[2]];
      }
      getCameraToWorld(t, i) {
        const o = new Float64Array(16);
        return e.invert(o, this.getWorldToCamera(t, i)), o;
      }
      getWorldToCameraPosition(t, i, o) {
        const r = this.position;
        e.scale$2(r, r, -t);
        const n = new Float64Array(16);
        return e.fromScaling(n, [o, o, o]), e.translate(n, n, r), n[10] *= i, n;
      }
      getWorldToCamera(t, i) {
        const o = new Float64Array(16),
          r = new Float64Array(4),
          n = this.position;
        return e.conjugate(r, this._orientation), e.scale$2(n, n, -t), e.fromQuat(o, r), e.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
      }
      getCameraToClipPerspective(t, i, o, r) {
        const n = new Float64Array(16);
        return e.perspective(n, t, i, o, r), n;
      }
      getDistanceToElevation(t, i = !1) {
        const o = 0 === t ? 0 : e.mercatorZfromAltitude(t, i ? e.latFromMercatorY(this.position[1]) : this.position[1]),
          r = this.forward();
        return (o - this.position[2]) / r[2];
      }
      clone() {
        return new Vo([...this.position], [...this.orientation]);
      }
    }
    function Wo(t, i) {
      const o = qo(t.projection, t.zoom, t.width, t.height),
        r = function (t, i, o, r, n) {
          const s = new e.LngLat(o.lng - 180 * $o, o.lat),
            a = new e.LngLat(o.lng + 180 * $o, o.lat),
            l = t.project(s.lng, s.lat),
            c = t.project(a.lng, a.lat),
            h = -Math.atan2(c.y - l.y, c.x - l.x),
            u = e.MercatorCoordinate.fromLngLat(o);
          u.y = e.clamp(u.y, -.999975, .999975);
          const _ = u.toLngLat(),
            d = t.project(_.lng, _.lat),
            p = e.MercatorCoordinate.fromLngLat(_);
          p.x += $o;
          const m = p.toLngLat(),
            f = t.project(m.lng, m.lat),
            g = Yo(f.x - d.x, f.y - d.y, h),
            v = e.MercatorCoordinate.fromLngLat(_);
          v.y += $o;
          const x = v.toLngLat(),
            y = t.project(x.lng, x.lat),
            b = Yo(y.x - d.x, y.y - d.y, h),
            w = Math.abs(g.x) / Math.abs(b.y),
            T = e.identity([]);
          e.rotateZ(T, T, -h * (1 - (n ? 0 : r)));
          const E = e.identity([]);
          return e.scale(E, E, [1, 1 - (1 - w) * r, 1]), E[4] = -b.x / b.y * r, e.rotateZ(E, E, h), e.multiply(E, T, E), E;
        }(t.projection, 0, t.center, o, i),
        n = Xo(t);
      return e.scale(r, r, [n, n, 1]), r;
    }
    function Xo(t) {
      const i = t.projection,
        o = qo(t.projection, t.zoom, t.width, t.height),
        r = Ho(i, t.center),
        n = Ho(i, e.LngLat.convert(i.center));
      return Math.pow(2, r * o + (1 - o) * n);
    }
    function qo(t, i, o, r, n = 1 / 0) {
      const s = t.range;
      if (!s) return 0;
      const a = Math.min(n, Math.max(o, r)),
        l = Math.log(a / 1024) / Math.LN2;
      return e.smoothstep(s[0] + l, s[1] + l, i);
    }
    const $o = 1 / 4e4;
    function Ho(t, i) {
      const o = e.clamp(i.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
        r = new e.LngLat(i.lng - 180 * $o, o),
        n = new e.LngLat(i.lng + 180 * $o, o),
        s = t.project(r.lng, o),
        a = t.project(n.lng, o),
        l = e.MercatorCoordinate.fromLngLat(r),
        c = e.MercatorCoordinate.fromLngLat(n),
        h = a.x - s.x,
        u = a.y - s.y,
        _ = c.x - l.x,
        d = c.y - l.y,
        p = Math.sqrt((_ * _ + d * d) / (h * h + u * u));
      return Math.log(p) / Math.LN2;
    }
    function Yo(e, t, i) {
      const o = Math.cos(i),
        r = Math.sin(i);
      return {
        x: e * o - t * r,
        y: e * r + t * o
      };
    }
    class Ko {
      constructor(t, i, o, r, n, s, a) {
        this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(s), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Uo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Vo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = .1;
      }
      clone() {
        const e = new Ko(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e;
      }
      get elevation() {
        return this._elevation;
      }
      set elevation(e) {
        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
      }
      updateElevation(e, t = !1) {
        const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
        (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t), this._calcMatrices();
      }
      getProjection() {
        return e.pick(this.projection, ["name", "center", "parallels"]);
      }
      setProjection(i) {
        this.projectionOptions = i || {
          name: "mercator"
        };
        const o = this.projection ? this.getProjection() : void 0;
        this.projection = e.getProjection(this.projectionOptions);
        const r = !t(o, this.getProjection());
        return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;
      }
      setMercatorFromTransition() {
        const t = this.projection.name;
        this.mercatorFromTransition = !0, this.projectionOptions = {
          name: "mercator"
        }, this.projection = e.getProjection({
          name: "mercator"
        });
        const i = t !== this.projection.name;
        return i && this._calcMatrices(), i;
      }
      get minZoom() {
        return this._minZoom;
      }
      set minZoom(e) {
        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
      }
      get maxZoom() {
        return this._maxZoom;
      }
      set maxZoom(e) {
        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
      }
      get minPitch() {
        return this._minPitch;
      }
      set minPitch(e) {
        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
      }
      get maxPitch() {
        return this._maxPitch;
      }
      set maxPitch(e) {
        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
      }
      get renderWorldCopies() {
        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
      }
      set renderWorldCopies(e) {
        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
      }
      get worldSize() {
        return this.tileSize * this.scale;
      }
      get cameraWorldSizeForFog() {
        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
      }
      get cameraWorldSize() {
        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
      }
      get pixelsPerMeter() {
        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
      }
      get cameraPixelsPerMeter() {
        return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
      }
      get centerOffset() {
        return this.centerPoint._sub(this.size._div(2));
      }
      get size() {
        return new e.pointGeometry(this.width, this.height);
      }
      get bearing() {
        return e.wrap(this.rotation, -180, 180);
      }
      set bearing(e) {
        this.rotation = e;
      }
      get rotation() {
        return -this.angle / Math.PI * 180;
      }
      set rotation(t) {
        const i = -t * Math.PI / 180;
        var o;
        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function (e, t, i) {
          var o = t[0],
            r = t[1],
            n = t[2],
            s = t[3],
            a = Math.sin(i),
            l = Math.cos(i);
          e[0] = o * l + n * a, e[1] = r * l + s * a, e[2] = o * -a + n * l, e[3] = r * -a + s * l;
        }(this.rotationMatrix, this.rotationMatrix, this.angle));
      }
      get pitch() {
        return this._pitch / Math.PI * 180;
      }
      set pitch(t) {
        const i = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
      }
      get aspect() {
        return this.width / this.height;
      }
      get fovX() {
        return this._fov;
      }
      get fovY() {
        const e = 1 / Math.tan(.5 * this.fovX);
        return 2 * Math.atan(1 / this.aspect / e);
      }
      set fov(t) {
        t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.degToRad(t), this._calcMatrices());
      }
      get averageElevation() {
        return this._averageElevation;
      }
      set averageElevation(e) {
        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
      }
      get zoom() {
        return this._zoom;
      }
      set zoom(e) {
        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);
        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
      }
      _setZoom(e) {
        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
      }
      _updateCameraOnTerrain() {
        if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
        const e = this._elevation;
        this._centerAltitude = e.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e.exaggeration(), this._updateSeaLevelZoom();
      }
      _updateSeaLevelZoom() {
        void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
      }
      sampleAverageElevation() {
        if (!this._elevation) return 0;
        const t = this._elevation,
          i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],
          o = this.horizonLineFromTop();
        let r = 0,
          n = 0;
        for (let s = 0; s < i.length; s++) {
          const a = new e.pointGeometry(i[s][0] * this.width, o + i[s][1] * (this.height - o)),
            l = t.pointCoordinate(a);
          if (!l) continue;
          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
          r += l[3] * c, n += c;
        }
        return 0 === n ? NaN : r / n;
      }
      get center() {
        return this._center;
      }
      set center(e) {
        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
      }
      _updateZoomFromElevation() {
        if (null == this._seaLevelZoom || !this._elevation) return;
        const e = this._seaLevelZoom,
          t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),
          i = this.pixelsPerMeter / this.worldSize * t,
          o = this._mercatorZfromZoom(e),
          r = this._mercatorZfromZoom(this._maxZoom),
          n = Math.max(o - i, r);
        this._setZoom(this._zoomFromMercatorZ(n));
      }
      get padding() {
        return this._edgeInsets.toJSON();
      }
      set padding(e) {
        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
      }
      computeZoomRelativeTo(t) {
        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
        let o;
        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];
        const r = e.length(e.sub([], this._camera.position, o));
        return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
      }
      setFreeCameraOptions(t) {
        if (!this.height) return;
        if (!t.position && !t.orientation) return;
        this._updateCameraState();
        let i = !1;
        if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {
          const o = [t.position.x, t.position.y, t.position.z];
          e.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
        }
        i && (this._updateStateFromCamera(), this.recenterOnTerrain());
      }
      getFreeCameraOptions() {
        this._updateCameraState();
        const t = this._camera.position,
          i = new Zo();
        return i.position = new e.MercatorCoordinate(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
      }
      _setCameraOrientation(t) {
        if (!e.length$1(t)) return !1;
        e.normalize$1(t, t);
        const i = e.transformQuat([], [0, 0, -1], t),
          o = e.transformQuat([], [0, -1, 0], t);
        if (o[2] < 0) return !1;
        const r = jo(i, o);
        return !!r && (this._camera.orientation = r, !0);
      }
      _setCameraPosition(t) {
        const i = this.zoomScale(this.minZoom) * this.tileSize,
          o = this.zoomScale(this.maxZoom) * this.tileSize,
          r = this.cameraToCenterDistance;
        t[2] = e.clamp(t[2], r / o, r / i), this._camera.position = t;
      }
      get centerPoint() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }
      get fovAboveCenter() {
        return this._fov * (.5 + this.centerOffset.y / this.height);
      }
      isPaddingEqual(e) {
        return this._edgeInsets.equals(e);
      }
      interpolatePadding(e, t, i) {
        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();
      }
      coveringZoomLevel(e) {
        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
        return Math.max(0, t);
      }
      getVisibleUnwrappedCoordinates(t) {
        const i = [new e.UnwrappedTileID(0, t)];
        if (this.renderWorldCopies) {
          const o = this.pointCoordinate(new e.pointGeometry(0, 0)),
            r = this.pointCoordinate(new e.pointGeometry(this.width, 0)),
            n = this.pointCoordinate(new e.pointGeometry(this.width, this.height)),
            s = this.pointCoordinate(new e.pointGeometry(0, this.height)),
            a = Math.floor(Math.min(o.x, r.x, n.x, s.x)),
            l = Math.floor(Math.max(o.x, r.x, n.x, s.x)),
            c = 1;
          for (let o = a - c; o <= l + c; o++) 0 !== o && i.push(new e.UnwrappedTileID(o, t));
        }
        return i;
      }
      coveringTiles(t) {
        let i = this.coveringZoomLevel(t);
        const o = i,
          r = this.elevation && !t.isTerrainDEM,
          n = "mercator" === this.projection.name;
        if (void 0 !== t.minzoom && i < t.minzoom) return [];
        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);
        const s = this.locationCoordinate(this.center),
          a = this.center.lat,
          l = 1 << i,
          c = [l * s.x, l * s.y, 0],
          h = "globe" === this.projection.name,
          u = !h,
          _ = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u),
          d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),
          p = l * e.mercatorZfromAltitude(1, this.center.lat),
          m = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat),
          f = [l * d.x, l * d.y, m * (u ? 1 : p)],
          g = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),
          v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0,
          x = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude,
          y = t.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,
          b = this.projection.isReprojectedInTileSpace ? Xo(this) : 1,
          w = t => {
            const i = 1 / 4e4,
              o = new e.MercatorCoordinate(t.x + i, t.y, t.z),
              r = new e.MercatorCoordinate(t.x, t.y + i, t.z),
              n = t.toLngLat(),
              s = o.toLngLat(),
              a = r.toLngLat(),
              l = this.locationCoordinate(n),
              c = this.locationCoordinate(s),
              h = this.locationCoordinate(a),
              u = Math.hypot(c.x - l.x, c.y - l.y),
              _ = Math.hypot(h.x - l.x, h.y - l.y);
            return Math.sqrt(u * _) * b / i;
          },
          T = t => {
            const i = x,
              o = y;
            return {
              aabb: e.tileAABB(this, l, 0, 0, 0, t, o, i, this.projection),
              zoom: 0,
              x: 0,
              y: 0,
              minZ: o,
              maxZ: i,
              wrap: t,
              fullyVisible: !1
            };
          },
          E = [];
        let C = [];
        const M = i,
          I = t.reparseOverscaled ? o : i,
          S = e => e * e,
          D = S((m - this._centerAltitude) * p),
          L = e => {
            if (!this._elevation || !e.tileID || !n) return;
            const t = this._elevation.getMinMaxForTile(e.tileID),
              i = e.aabb;
            t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = A(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
          },
          A = t => {
            if (t.zoom < v) return !0;
            if (t.zoom === M) return !1;
            if (null != t.shouldSplit) return t.shouldSplit;
            const i = t.aabb.distanceX(f),
              n = t.aabb.distanceY(f);
            let s = D,
              l = 1;
            if (h) {
              s = S(t.aabb.distanceZ(f));
              const i = Math.pow(2, t.zoom),
                o = e.latFromMercatorY((t.y + 1) / i),
                r = e.latFromMercatorY(t.y / i),
                n = Math.min(Math.max(a, o), r),
                c = e.circumferenceAtLatitude(n) / e.circumferenceAtLatitude(a);
              if (l = n === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t.zoom === M - 1 && c >= .9) return !0;
            } else if (r && (s = S(t.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {
              const i = Math.pow(2, t.zoom),
                o = w(new e.MercatorCoordinate((t.x + .5) / i, (t.y + .5) / i));
              l = o > .85 ? 1 : o;
            }
            const c = i * i + n * n + s,
              u = S((1 << M - t.zoom) * g * l * ((e, t) => {
                if (t * S(.707) < e) return 1;
                const i = Math.sqrt(t / e);
                return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(s, D), c));
            return c < u;
          };
        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) E.push(T(-e)), E.push(T(e));
        for (E.push(T(0)); E.length > 0;) {
          const o = E.pop(),
            s = o.x,
            a = o.y;
          let u = o.fullyVisible;
          if (!u) {
            const e = o.aabb.intersects(_);
            if (0 === e) continue;
            u = 2 === e;
          }
          if (o.zoom !== M && A(o)) for (let t = 0; t < 4; t++) {
            const i = (s << 1) + t % 2,
              c = (a << 1) + (t >> 1),
              _ = {
                aabb: n ? o.aabb.quadrant(t) : e.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection),
                zoom: o.zoom + 1,
                x: i,
                y: c,
                wrap: o.wrap,
                fullyVisible: u,
                tileID: void 0,
                shouldSplit: void 0,
                minZ: o.minZ,
                maxZ: o.maxZ
              };
            r && !h && (_.tileID = new e.OverscaledTileID(o.zoom + 1 === M ? I : o.zoom + 1, o.wrap, o.zoom + 1, i, c), L(_)), E.push(_);
          } else {
            const r = o.zoom === M ? I : o.zoom;
            if (t.minzoom && t.minzoom > r) continue;
            const n = c[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom),
              l = c[1] - .5 - a,
              h = o.tileID ? o.tileID : new e.OverscaledTileID(r, o.wrap, o.zoom, s, a);
            C.push({
              tileID: h,
              distanceSq: n * n + l * l
            });
          }
        }
        if (this.fogCullDistSq) {
          const i = this.fogCullDistSq,
            o = this.horizonLineFromTop();
          C = C.filter(r => {
            const n = [0, 0, 0, 1],
              s = [e.EXTENT, e.EXTENT, 0, 1],
              a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
            e.transformMat4$1(n, n, a), e.transformMat4$1(s, s, a);
            const l = e.getAABBPointSquareDist(n, s);
            if (0 === l) return !0;
            let c = !1;
            const h = this._elevation;
            if (h && l > i && 0 !== o) {
              const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
              let n;
              t.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = {
                min: y,
                max: x
              });
              const s = e.furthestTileCorner(this.rotation),
                a = [s[0] * e.EXTENT, s[1] * e.EXTENT, n.max];
              e.transformMat4(a, a, i), c = (1 - a[1]) * this.height * .5 < o;
            }
            return l < i || c;
          });
        }
        return C.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);
      }
      resize(e, t) {
        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();
      }
      get unmodified() {
        return this._unmodified;
      }
      zoomScale(e) {
        return Math.pow(2, e);
      }
      scaleZoom(e) {
        return Math.log(e) / Math.LN2;
      }
      project(t) {
        const i = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
          o = this.projection.project(t.lng, i);
        return new e.pointGeometry(o.x * this.worldSize, o.y * this.worldSize);
      }
      unproject(e) {
        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
      }
      get point() {
        return this.project(this.center);
      }
      get pointMerc() {
        return this.point._div(this.worldSize);
      }
      get pixelsPerMeterRatio() {
        return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
      }
      setLocationAtPoint(t, i) {
        let o, r;
        const n = this.centerPoint;
        if ("globe" === this.projection.name) {
          const e = this.worldSize;
          o = (i.x - n.x) / e, r = (i.y - n.y) / e;
        } else {
          const e = this.pointCoordinate(i),
            t = this.pointCoordinate(n);
          o = e.x - t.x, r = e.y - t.y;
        }
        const s = this.locationCoordinate(t);
        this.setLocation(new e.MercatorCoordinate(s.x - o, s.y - r));
      }
      setLocation(e) {
        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
      }
      locationPoint(e) {
        return this.projection.locationPoint(this, e);
      }
      locationPoint3D(e) {
        return this.projection.locationPoint(this, e, !0);
      }
      pointLocation(e) {
        return this.coordinateLocation(this.pointCoordinate(e));
      }
      pointLocation3D(e) {
        return this.coordinateLocation(this.pointCoordinate3D(e));
      }
      locationCoordinate(t, i) {
        const o = i ? e.mercatorZfromAltitude(i, t.lat) : void 0,
          r = this.projection.project(t.lng, t.lat);
        return new e.MercatorCoordinate(r.x, r.y, o);
      }
      coordinateLocation(e) {
        return this.projection.unproject(e.x, e.y);
      }
      pointRayIntersection(t, i) {
        const o = null != i ? i : this._centerAltitude,
          r = [t.x, t.y, 0, 1],
          n = [t.x, t.y, 1, 1];
        e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n, n, this.pixelMatrixInverse);
        const s = n[3];
        e.scale$1(r, r, 1 / r[3]), e.scale$1(n, n, 1 / s);
        const a = r[2],
          l = n[2];
        return {
          p0: r,
          p1: n,
          t: a === l ? 0 : (o - a) / (l - a)
        };
      }
      screenPointToMercatorRay(t) {
        const i = [t.x, t.y, 0, 1],
          o = [t.x, t.y, 1, 1];
        return e.transformMat4$1(i, i, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse), e.scale$1(i, i, 1 / i[3]), e.scale$1(o, o, 1 / o[3]), i[2] = e.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e.scale$1(i, i, 1 / this.worldSize), e.scale$1(o, o, 1 / this.worldSize), new e.Ray([i[0], i[1], i[2]], e.normalize([], e.sub([], o, i)));
      }
      rayIntersectionCoordinate(t) {
        const {
            p0: i,
            p1: o,
            t: r
          } = t,
          n = e.mercatorZfromAltitude(i[2], this._center.lat),
          s = e.mercatorZfromAltitude(o[2], this._center.lat);
        return new e.MercatorCoordinate(e.number(i[0], o[0], r) / this.worldSize, e.number(i[1], o[1], r) / this.worldSize, e.number(n, s, r));
      }
      pointCoordinate(e, t = this._centerAltitude) {
        return this.projection.pointCoordinate(this, e.x, e.y, t);
      }
      pointCoordinate3D(t) {
        if (!this.elevation) return this.pointCoordinate(t);
        let i = this.projection.pointCoordinate3D(this, t.x, t.y);
        if (i) return new e.MercatorCoordinate(i[0], i[1], i[2]);
        let o = 0,
          r = this.horizonLineFromTop();
        if (t.y > r) return this.pointCoordinate(t);
        const n = .02 * r,
          s = t.clone();
        for (let t = 0; t < 10 && r - o > n; t++) {
          s.y = e.number(o, r, .66);
          const t = this.projection.pointCoordinate3D(this, s.x, s.y);
          t ? (r = s.y, i = t) : o = s.y;
        }
        return i ? new e.MercatorCoordinate(i[0], i[1], i[2]) : this.pointCoordinate(t);
      }
      isPointAboveHorizon(e) {
        return this.projection.isPointAboveHorizon(this, e);
      }
      _coordinatePoint(t, i) {
        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,
          r = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];
        return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
      }
      _getBoundsNonRectangular() {
        const {
            top: t,
            left: i
          } = this._edgeInsets,
          o = this.height - this._edgeInsets.bottom,
          r = this.width - this._edgeInsets.right,
          n = this.pointLocation3D(new e.pointGeometry(i, t)),
          s = this.pointLocation3D(new e.pointGeometry(r, t)),
          a = this.pointLocation3D(new e.pointGeometry(r, o)),
          l = this.pointLocation3D(new e.pointGeometry(i, o));
        let c = Math.min(n.lng, s.lng, a.lng, l.lng),
          h = Math.max(n.lng, s.lng, a.lng, l.lng),
          u = Math.min(n.lat, s.lat, a.lat, l.lat),
          _ = Math.max(n.lat, s.lat, a.lat, l.lat);
        const d = Math.pow(2, -this.zoom) / 16 * 270,
          p = "globe" === this.projection.name ? 1 : 4,
          m = (t, i, o, r, n) => {
            const s = (t + o) / 2,
              a = (i + r) / 2,
              l = new e.pointGeometry(s, a),
              {
                lng: f,
                lat: g
              } = this.pointLocation3D(l),
              v = Math.max(0, c - f, u - g, f - h, g - _);
            c = Math.min(c, f), h = Math.max(h, f), u = Math.min(u, g), _ = Math.max(_, g), (n < p || v > d) && (m(t, i, s, a, n + 1), m(s, a, o, r, n + 1));
          };
        if (m(i, t, r, t, 1), m(r, t, r, o, 1), m(r, o, i, o, 1), m(i, o, i, t, 1), "globe" === this.projection.name) {
          const [t, i] = e.polesInViewport(this);
          t ? (_ = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);
        }
        return new e.LngLatBounds(new e.LngLat(c, u), new e.LngLat(h, _));
      }
      _getBoundsRectangular(t, i) {
        const {
            top: o,
            left: r
          } = this._edgeInsets,
          n = this.height - this._edgeInsets.bottom,
          s = this.width - this._edgeInsets.right,
          a = new e.pointGeometry(r, o),
          l = new e.pointGeometry(s, o),
          c = new e.pointGeometry(s, n),
          h = new e.pointGeometry(r, n);
        let u = this.pointCoordinate(a, t),
          _ = this.pointCoordinate(l, t);
        const d = this.pointCoordinate(c, i),
          p = this.pointCoordinate(h, i),
          m = (e, t) => (t.y - e.y) / (t.x - e.x);
        return u.y > 1 && _.y >= 0 ? u = new e.MercatorCoordinate((1 - p.y) / m(p, u) + p.x, 1) : u.y < 0 && _.y <= 1 && (u = new e.MercatorCoordinate(-p.y / m(p, u) + p.x, 0)), _.y > 1 && u.y >= 0 ? _ = new e.MercatorCoordinate((1 - d.y) / m(d, _) + d.x, 1) : _.y < 0 && u.y <= 1 && (_ = new e.MercatorCoordinate(-d.y / m(d, _) + d.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u)).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d));
      }
      _getBoundsRectangularTerrain() {
        const e = this.elevation;
        if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
        const t = e.visibleDemTiles.reduce((e, t) => {
          if (t.dem) {
            const i = t.dem.tree;
            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
          }
          return e;
        }, {
          min: Number.MAX_VALUE,
          max: 0
        });
        return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration());
      }
      getBounds() {
        return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
      }
      horizonLineFromTop(e = !0) {
        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y,
          i = this.height / 2 - t * (1 - this._horizonShift);
        return e ? Math.max(0, i) : i;
      }
      getMaxBounds() {
        return this.maxBounds;
      }
      setMaxBounds(t) {
        this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
      }
      calculatePosMatrix(e, t) {
        return this.projection.createTileMatrix(this, t, e);
      }
      calculateDistanceTileData(t) {
        const i = t.key,
          o = this._distanceTileDataCache;
        if (o[i]) return o[i];
        const r = t.canonical,
          n = 1 / this.height,
          s = this.cameraWorldSize,
          a = s / this.zoomScale(r.z),
          l = (r.x + Math.pow(2, r.z) * t.wrap) * a,
          c = r.y * a,
          h = this.point;
        h.x *= s / this.worldSize, h.y *= s / this.worldSize;
        const u = this.angle,
          _ = Math.sin(-u),
          d = -Math.cos(-u);
        return o[i] = {
          bearing: [_, d],
          center: [(h.x - l) * n, (h.y - c) * n],
          scale: a / e.EXTENT * n
        }, o[i];
      }
      calculateFogTileMatrix(t) {
        const i = t.key,
          o = this._fogTileMatrixCache;
        if (o[i]) return o[i];
        const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
        return e.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
      }
      calculateProjMatrix(t, i = !1) {
        const o = t.key,
          r = i ? this._alignedProjMatrixCache : this._projMatrixCache;
        if (r[o]) return r[o];
        const n = this.calculatePosMatrix(t, this.worldSize);
        return e.multiply(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];
      }
      calculatePixelsToTileUnitsMatrix(t) {
        const i = t.tileID.key,
          o = this._pixelsToTileUnitsCache;
        if (o[i]) return o[i];
        const r = function (t, i) {
          const {
              scale: o
            } = t.tileTransform,
            r = o * e.EXTENT / (t.tileSize * Math.pow(2, i.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));
          return n = new Float32Array(4), l = (s = i.inverseAdjustmentMatrix)[1], c = s[2], h = s[3], _ = (a = [r, r])[1], n[0] = s[0] * (u = a[0]), n[1] = l * u, n[2] = c * _, n[3] = h * _, n;
          var n, s, a, l, c, h, u, _;
        }(t, this);
        return o[i] = r, o[i];
      }
      customLayerMatrix() {
        return this.mercatorMatrix.slice();
      }
      globeToMercatorMatrix() {
        if ("globe" === this.projection.name) {
          const t = 1 / this.worldSize,
            i = e.fromScaling([], [t, t, t]);
          return e.multiply(i, i, this.globeMatrix), i;
        }
      }
      recenterOnTerrain() {
        if (!this._elevation || "globe" === this.projection.name) return;
        const t = this._elevation;
        this._updateCameraState();
        const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
          o = this._computeCameraPosition(i),
          r = this._camera.forward(),
          n = e.mercatorZfromAltitude(1, this._center.lat);
        o[2] /= n, r[2] /= n, e.normalize(r, r);
        const s = t.raycast(o, r, t.exaggeration());
        if (s) {
          const t = e.scaleAndAdd([], o, r, s),
            i = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))),
            a = (i.z + e.length([i.x - o[0], i.y - o[1], i.z - o[2] * n])) * this._pixelsPerMercatorPixel;
          this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
        }
      }
      _constrainCamera(t = !1) {
        if (!this._elevation) return;
        const i = this._elevation,
          o = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
          r = this._computeCameraPosition(o),
          n = i.getAtPointOrZero(new e.MercatorCoordinate(...r)),
          s = this.pixelsPerMeter / this.worldSize * n,
          a = this._minimumHeightOverTerrain(),
          l = r[2] - s;
        if (l <= a) if (l < 0 || t) {
          const t = this.locationCoordinate(this._center, this._centerAltitude),
            i = [r[0], r[1], t.z - r[2]],
            o = e.length(i);
          i[2] -= (a - l) / this._pixelsPerMercatorPixel;
          const n = e.length(i);
          if (0 === n) return;
          e.scale$2(i, i, o / n * this._pixelsPerMercatorPixel), this._camera.position = [r[0], r[1], t.z * this._pixelsPerMercatorPixel - i[2]], this._updateStateFromCamera();
        } else this._isCameraConstrained = !0;
      }
      _constrain() {
        if (!this.center || !this.width || !this.height || this._constraining) return;
        this._constraining = !0;
        const t = "globe" === this.projection.name || this.mercatorFromTransition;
        if (this.projection.isReprojectedInTileSpace || t) {
          const i = this.center;
          return i.lat = e.clamp(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (i.lng = e.clamp(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
        }
        const i = this._unmodified,
          {
            x: o,
            y: r
          } = this.point;
        let n = 0,
          s = o,
          a = r;
        const l = this.width / 2,
          c = this.height / 2,
          h = this.worldMinY * this.scale,
          u = this.worldMaxY * this.scale;
        if (r - c < h && (a = h + c), r + c > u && (a = u - c), u - h < this.height && (n = Math.max(n, this.height / (u - h)), a = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
          const e = this.worldMinX * this.scale,
            t = this.worldMaxX * this.scale,
            i = this.worldSize / 2 - (e + t) / 2;
          s = (o + i + this.worldSize) % this.worldSize - i, s - l < e && (s = e + l), s + l > t && (s = t - l), t - e < this.width && (n = Math.max(n, this.width / (t - e)), s = (t + e) / 2);
        }
        s === o && a === r || (this.center = this.unproject(new e.pointGeometry(s, a))), n && (this.zoom += this.scaleZoom(n)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
      }
      _minZoomForBounds() {
        let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
      }
      _maxCameraBoundsDistance() {
        return this._mercatorZfromZoom(this._minZoomForBounds());
      }
      _calcMatrices() {
        if (!this.height) return;
        const t = this.centerOffset,
          i = this.pixelsPerMeter;
        "globe" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));
        const o = qo(this.projection, this.zoom, this.width, this.height, 1024);
        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
        const r = "meters" === this.projection.zAxisUnit ? i : 1,
          n = this._camera.getWorldToCamera(this.worldSize, r),
          s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
        s[8] = 2 * -t.x / this.width, s[9] = 2 * t.y / this.height;
        let a = e.mul([], s, n);
        if (this.projection.isReprojectedInTileSpace) {
          const t = this.locationCoordinate(this.center),
            i = e.identity([]);
          e.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply(i, i, Wo(this)), e.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply(a, a, i), this.inverseAdjustmentMatrix = function (e) {
            const t = Wo(e, !0);
            return v([], [t[0], t[1], t[4], t[5]]);
          }(this);
        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
        this.mercatorMatrix = e.scale([], a, [this.worldSize, this.worldSize, this.worldSize / r, 1]), this.projMatrix = a, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
        const l = e.invert([], s);
        this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l, this.horizonLineFromTop(), this.height);
        const c = new Float32Array(16);
        e.identity(c), e.scale(c, c, [1, -1, 1]), e.rotateX(c, c, this._pitch), e.rotateZ(c, c, this.angle);
        const h = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ),
          u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
        h[8] = 2 * -t.x / this.width, h[9] = 2 * (t.y + u) / this.height, this.skyboxMatrix = e.multiply(c, h, c);
        const _ = this.point,
          d = _.x,
          p = _.y,
          m = this.width % 2 / 2,
          f = this.height % 2 / 2,
          g = Math.cos(this.angle),
          x = Math.sin(this.angle),
          y = d - Math.round(d) + g * m + x * f,
          b = p - Math.round(p) + g * f + x * m,
          w = new Float64Array(a);
        if (e.translate(w, w, [y > .5 ? y - 1 : y, b > .5 ? b - 1 : b, 0]), this.alignedProjMatrix = w, a = e.create(), e.scale(a, a, [this.width / 2, -this.height / 2, 1]), e.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = e.create(), e.scale(a, a, [1, -1, 1]), e.translate(a, a, [-1, -1, 0]), e.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix");
        if (this.pixelMatrixInverse = a, "globe" === this.projection.name || this.mercatorFromTransition) {
          this.globeMatrix = e.calculateGlobeMatrix(this);
          const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
          this.globeCenterInViewSpace = e.transformMat4(t, t, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
        } else this.globeMatrix = a;
        this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
      }
      _calcFogMatrices() {
        this._fogTileMatrixCache = {};
        const t = this.cameraWorldSizeForFog,
          i = this.cameraPixelsPerMeter,
          o = this._camera.position,
          r = 1 / this.height / this._pixelsPerMercatorPixel,
          n = [t, t, i];
        e.scale$2(n, n, r), e.scale$2(o, o, -1), e.multiply$2(o, o, n);
        const s = e.create();
        e.translate(s, s, o), e.scale(s, s, n), this.mercatorFogMatrix = s, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, r);
      }
      _computeCameraPosition(e) {
        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,
          i = this._camera.forward(),
          o = this.point,
          r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;
        return [o.x / this.worldSize - i[0] * r, o.y / this.worldSize - i[1] * r, e / this.worldSize * this._centerAltitude - i[2] * r];
      }
      _updateCameraState() {
        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
      }
      _translateCameraConstrained(t) {
        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),
          o = this._camera.position[2],
          r = t[2];
        let n = 1;
        this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (n = Math.min((i - o) / r, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, n), this._updateStateFromCamera();
      }
      _updateStateFromCamera() {
        const t = this._camera.position,
          i = this._camera.forward(),
          {
            pitch: o,
            bearing: r
          } = this._camera.getPitchBearing(),
          n = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,
          s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)),
          a = Math.max((t[2] - n) / Math.cos(o), s),
          l = this._zoomFromMercatorZ(a);
        e.scaleAndAdd(t, t, i, a), this._pitch = e.clamp(o, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
      }
      _worldSizeFromZoom(e) {
        return Math.pow(2, e) * this.tileSize;
      }
      _mercatorZfromZoom(e) {
        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
      }
      _minimumHeightOverTerrain() {
        const e = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
        return this._mercatorZfromZoom(e);
      }
      _zoomFromMercatorZ(e) {
        return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));
      }
      zoomFromMercatorZAdjusted(t) {
        let i = 0,
          o = e.GLOBE_ZOOM_THRESHOLD_MAX,
          r = 0,
          n = 1 / 0;
        for (; o - i > 1e-6 && o > i;) {
          const e = i + .5 * (o - i),
            s = this.tileSize * Math.pow(2, e),
            a = this.getCameraToCenterDistance(this.projection, e, s),
            l = this.scaleZoom(a / (t * this.tileSize)),
            c = Math.abs(e - l);
          c < n && (n = c, r = e), e < l ? i = e : o = e;
        }
        return r;
      }
      _terrainEnabled() {
        return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
      }
      anyCornerOffEdge(t, i) {
        const o = Math.min(t.x, i.x),
          r = Math.max(t.x, i.x),
          n = Math.min(t.y, i.y),
          s = Math.max(t.y, i.y);
        if (n < this.horizonLineFromTop(!1)) return !0;
        if ("mercator" !== this.projection.name) return !1;
        const a = [new e.pointGeometry(o, n), new e.pointGeometry(r, s), new e.pointGeometry(o, s), new e.pointGeometry(r, n)],
          l = this.renderWorldCopies ? -3 : 0,
          c = this.renderWorldCopies ? 4 : 1;
        for (const e of a) {
          const t = this.pointRayIntersection(e);
          if (t.t < 0) return !0;
          const i = this.rayIntersectionCoordinate(t);
          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
        }
        return !1;
      }
      isHorizonVisible() {
        return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
      }
      zoomDeltaToMovement(t, i) {
        const o = e.length(e.sub([], this._camera.position, t)),
          r = this._zoomFromMercatorZ(o) + i;
        return o - this._mercatorZfromZoom(r);
      }
      getCameraPoint() {
        if ("globe" === this.projection.name) {
          const t = function ([t, i, o], r) {
            const n = [t, i, o, 1];
            e.transformMat4$1(n, n, r);
            const s = n[3] = Math.max(n[3], 1e-6);
            return n[0] /= s, n[1] /= s, n[2] /= s, n;
          }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
          return new e.pointGeometry(t[0], t[1]);
        }
        {
          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new e.pointGeometry(0, t));
        }
      }
      getCameraToCenterDistance(e, t = this.zoom, i = this.worldSize) {
        const o = qo(e, t, this.width, this.height, 1024),
          r = e.pixelSpaceConversion(this.center.lat, i, o);
        return .5 / Math.tan(.5 * this._fov) * this.height * r;
      }
      getWorldToCameraMatrix() {
        const t = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
        return "globe" === this.projection.name && e.multiply(t, t, this.globeMatrix), t;
      }
    }
    function Jo(e, t) {
      let i = !1,
        o = null;
      const r = () => {
        o = null, i && (e(), o = setTimeout(r, t), i = !1);
      };
      return () => (i = !0, o || r(), o);
    }
    class Qo {
      constructor(t) {
        this._hashName = t && encodeURIComponent(t), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Jo(this._updateHashUnthrottled.bind(this), 300);
      }
      addTo(t) {
        return this._map = t, e.window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
      }
      remove() {
        return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
      }
      getHashString() {
        const t = this._map;
        if (!t) return "";
        const i = er(t);
        if (this._hashName) {
          const t = this._hashName;
          let o = !1;
          const r = e.window.location.hash.slice(1).split("&").map(e => {
            const r = e.split("=")[0];
            return r === t ? (o = !0, `${r}=${i}`) : e;
          }).filter(e => e);
          return o || r.push(`${t}=${i}`), `#${r.join("&")}`;
        }
        return `#${i}`;
      }
      _getCurrentHash() {
        const t = e.window.location.hash.replace("#", "");
        if (this._hashName) {
          let e;
          return t.split("&").map(e => e.split("=")).forEach(t => {
            t[0] === this._hashName && (e = t);
          }), (e && e[1] || "").split("/");
        }
        return t.split("/");
      }
      _onHashChange() {
        const e = this._map;
        if (!e) return !1;
        const t = this._getCurrentHash();
        if (t.length >= 3 && !t.some(e => isNaN(e))) {
          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();
          return e.jumpTo({
            center: [+t[2], +t[1]],
            zoom: +t[0],
            bearing: i,
            pitch: +(t[4] || 0)
          }), !0;
        }
        return !1;
      }
      _updateHashUnthrottled() {
        const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
        e.window.history.replaceState(e.window.history.state, null, t);
      }
    }
    function er(e, t) {
      const i = e.getCenter(),
        o = Math.round(100 * e.getZoom()) / 100,
        r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
        n = Math.pow(10, r),
        s = Math.round(i.lng * n) / n,
        a = Math.round(i.lat * n) / n,
        l = e.getBearing(),
        c = e.getPitch();
      let h = t ? `/${s}/${a}/${o}` : `${o}/${a}/${s}`;
      return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
    }
    const tr = {
        linearity: .3,
        easing: e.bezier(0, 0, .3, 1)
      },
      ir = e.extend({
        deceleration: 2500,
        maxSpeed: 1400
      }, tr),
      or = e.extend({
        deceleration: 20,
        maxSpeed: 1400
      }, tr),
      rr = e.extend({
        deceleration: 1e3,
        maxSpeed: 360
      }, tr),
      nr = e.extend({
        deceleration: 1e3,
        maxSpeed: 90
      }, tr);
    class sr {
      constructor(e) {
        this._map = e, this.clear();
      }
      clear() {
        this._inertiaBuffer = [];
      }
      record(t) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({
          time: e.exported.now(),
          settings: t
        });
      }
      _drainInertiaBuffer() {
        const t = this._inertiaBuffer,
          i = e.exported.now();
        for (; t.length > 0 && i - t[0].time > 160;) t.shift();
      }
      _onMoveEnd(t) {
        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
        const i = {
          zoom: 0,
          bearing: 0,
          pitch: 0,
          pan: new e.pointGeometry(0, 0),
          pinchAround: void 0,
          around: void 0
        };
        for (const {
          settings: e
        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);
        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
          r = {};
        if (i.pan.mag()) {
          const n = lr(i.pan.mag(), o, e.extend({}, ir, t || {}));
          r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, ar(r, n);
        }
        if (i.zoom) {
          const e = lr(i.zoom, o, or);
          r.zoom = this._map.transform.zoom + e.amount, ar(r, e);
        }
        if (i.bearing) {
          const t = lr(i.bearing, o, rr);
          r.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), ar(r, t);
        }
        if (i.pitch) {
          const e = lr(i.pitch, o, nr);
          r.pitch = this._map.transform.pitch + e.amount, ar(r, e);
        }
        if (r.zoom || r.bearing) {
          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
          r.around = e ? this._map.unproject(e) : this._map.getCenter();
        }
        return this.clear(), r.noMoveStart = !0, r;
      }
    }
    function ar(e, t) {
      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);
    }
    function lr(t, i, o) {
      const {
          maxSpeed: r,
          linearity: n,
          deceleration: s
        } = o,
        a = e.clamp(t * n / (i / 1e3), -r, r),
        l = Math.abs(a) / (s * n);
      return {
        easing: o.easing,
        duration: 1e3 * l,
        amount: a * (l / 2)
      };
    }
    class cr extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }
      get defaultPrevented() {
        return this._defaultPrevented;
      }
      constructor(t, i, o, r = {}) {
        const n = p(i.getCanvasContainer(), o),
          s = i.unproject(n);
        super(t, e.extend({
          point: n,
          lngLat: s,
          originalEvent: o
        }, r)), this._defaultPrevented = !1, this.target = i;
      }
    }
    class hr extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }
      get defaultPrevented() {
        return this._defaultPrevented;
      }
      constructor(t, i, o) {
        const r = "touchend" === t ? o.changedTouches : o.touches,
          n = m(i.getCanvasContainer(), r),
          s = n.map(e => i.unproject(e)),
          a = n.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.pointGeometry(0, 0));
        super(t, {
          points: n,
          point: a,
          lngLats: s,
          lngLat: i.unproject(a),
          originalEvent: o
        }), this._defaultPrevented = !1;
      }
    }
    class ur extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }
      get defaultPrevented() {
        return this._defaultPrevented;
      }
      constructor(e, t, i) {
        super(e, {
          originalEvent: i
        }), this._defaultPrevented = !1;
      }
    }
    class _r {
      constructor(e, t) {
        this._map = e, this._clickTolerance = t.clickTolerance;
      }
      reset() {
        this._mousedownPos = void 0;
      }
      wheel(e) {
        return this._firePreventable(new ur(e.type, this._map, e));
      }
      mousedown(e, t) {
        return this._mousedownPos = t, this._firePreventable(new cr(e.type, this._map, e));
      }
      mouseup(e) {
        this._map.fire(new cr(e.type, this._map, e));
      }
      preclick(t) {
        const i = e.extend({}, t);
        i.type = "preclick", this._map.fire(new cr(i.type, this._map, i));
      }
      click(e, t) {
        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new cr(e.type, this._map, e)));
      }
      dblclick(e) {
        return this._firePreventable(new cr(e.type, this._map, e));
      }
      mouseover(e) {
        this._map.fire(new cr(e.type, this._map, e));
      }
      mouseout(e) {
        this._map.fire(new cr(e.type, this._map, e));
      }
      touchstart(e) {
        return this._firePreventable(new hr(e.type, this._map, e));
      }
      touchmove(e) {
        this._map.fire(new hr(e.type, this._map, e));
      }
      touchend(e) {
        this._map.fire(new hr(e.type, this._map, e));
      }
      touchcancel(e) {
        this._map.fire(new hr(e.type, this._map, e));
      }
      _firePreventable(e) {
        if (this._map.fire(e), e.defaultPrevented) return {};
      }
      isEnabled() {
        return !0;
      }
      isActive() {
        return !1;
      }
      enable() {}
      disable() {}
    }
    class dr {
      constructor(e) {
        this._map = e;
      }
      reset() {
        this._delayContextMenu = !1, this._contextMenuEvent = void 0;
      }
      mousemove(e) {
        this._map.fire(new cr(e.type, this._map, e));
      }
      mousedown() {
        this._delayContextMenu = !0;
      }
      mouseup() {
        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new cr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }
      contextmenu(e) {
        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new cr(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
      }
      isEnabled() {
        return !0;
      }
      isActive() {
        return !1;
      }
      enable() {}
      disable() {}
    }
    class pr {
      constructor(e, t) {
        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
      }
      isEnabled() {
        return !!this._enabled;
      }
      isActive() {
        return !!this._active;
      }
      enable() {
        this.isEnabled() || (this._enabled = !0);
      }
      disable() {
        this.isEnabled() && (this._enabled = !1);
      }
      mousedown(e, t) {
        this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t, this._active = !0);
      }
      mousemoveWindow(e, t) {
        if (!this._active) return;
        const i = t,
          o = this._startPos,
          r = this._lastPos;
        if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
        this._lastPos = i, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
        const s = Math.min(o.x, i.x),
          a = Math.max(o.x, i.x),
          l = Math.min(o.y, i.y),
          c = Math.max(o.y, i.y);
        this._map._requestDomTask(() => {
          this._box && (this._box.style.transform = `translate(${s}px,${l}px)`, this._box.style.width = a - s + "px", this._box.style.height = c - l + "px");
        });
      }
      mouseupWindow(t, i) {
        if (!this._active) return;
        const o = this._startPos,
          r = i;
        if (o && 0 === t.button) {
          if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.Event("boxzoomend", {
            originalEvent: t
          })), {
            cameraAnimation: e => e.fitScreenCoordinates(o, r, this._map.getBearing(), {
              linear: !1
            })
          };
          this._fireEvent("boxzoomcancel", t);
        }
      }
      keydown(e) {
        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
      }
      blur() {
        this.reset();
      }
      reset() {
        this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;
      }
      _fireEvent(t, i) {
        return this._map.fire(new e.Event(t, {
          originalEvent: i
        }));
      }
    }
    function mr(e, t) {
      const i = {};
      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];
      return i;
    }
    class fr {
      constructor(e) {
        this.reset(), this.numTouches = e.numTouches;
      }
      reset() {
        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
      }
      touchstart(t, i, o) {
        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {
          const i = new e.pointGeometry(0, 0);
          for (const e of t) i._add(e);
          return i.div(t.length);
        }(i), this.touches = mr(o, i)));
      }
      touchmove(e, t, i) {
        if (this.aborted || !this.centroid) return;
        const o = mr(i, t);
        for (const e in this.touches) {
          const t = this.touches[e],
            i = o[e];
          (!i || i.dist(t) > 30) && (this.aborted = !0);
        }
      }
      touchend(e, t, i) {
        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
          const e = !this.aborted && this.centroid;
          if (this.reset(), e) return e;
        }
      }
    }
    class gr {
      constructor(e) {
        this.singleTap = new fr(e), this.numTaps = e.numTaps, this.reset();
      }
      reset() {
        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
      }
      touchstart(e, t, i) {
        this.singleTap.touchstart(e, t, i);
      }
      touchmove(e, t, i) {
        this.singleTap.touchmove(e, t, i);
      }
      touchend(e, t, i) {
        const o = this.singleTap.touchend(e, t, i);
        if (o) {
          const t = e.timeStamp - this.lastTime < 500,
            i = !this.lastTap || this.lastTap.dist(o) < 30;
          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
        }
      }
    }
    class vr {
      constructor() {
        this._zoomIn = new gr({
          numTouches: 1,
          numTaps: 2
        }), this._zoomOut = new gr({
          numTouches: 2,
          numTaps: 1
        }), this.reset();
      }
      reset() {
        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
      }
      touchstart(e, t, i) {
        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
      }
      touchmove(e, t, i) {
        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
      }
      touchend(e, t, i) {
        const o = this._zoomIn.touchend(e, t, i),
          r = this._zoomOut.touchend(e, t, i);
        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {
          cameraAnimation: t => t.easeTo({
            duration: 300,
            zoom: t.getZoom() + 1,
            around: t.unproject(o)
          }, {
            originalEvent: e
          })
        }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {
          cameraAnimation: t => t.easeTo({
            duration: 300,
            zoom: t.getZoom() - 1,
            around: t.unproject(r)
          }, {
            originalEvent: e
          })
        }) : void 0;
      }
      touchcancel() {
        this.reset();
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        this._enabled = !1, this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    const xr = {
      0: 1,
      2: 2
    };
    class yr {
      constructor(e) {
        this.reset(), this._clickTolerance = e.clickTolerance || 1;
      }
      blur() {
        this.reset();
      }
      reset() {
        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
      }
      _correctButton(e, t) {
        return !1;
      }
      _move(e, t) {
        return {};
      }
      mousedown(e, t) {
        if (this._lastPoint) return;
        const i = f(e);
        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);
      }
      mousemoveWindow(e, t) {
        const i = this._lastPoint;
        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {
          const i = xr[t];
          return void 0 === e.buttons || (e.buttons & i) !== i;
        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);
      }
      mouseupWindow(e) {
        this._lastPoint && f(e) === this._eventButton && (this._moved && d(), this.reset());
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        this._enabled = !1, this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    class br extends yr {
      mousedown(e, t) {
        super.mousedown(e, t), this._lastPoint && (this._active = !0);
      }
      _correctButton(e, t) {
        return 0 === t && !e.ctrlKey;
      }
      _move(e, t) {
        return {
          around: t,
          panDelta: t.sub(e)
        };
      }
    }
    class wr extends yr {
      _correctButton(e, t) {
        return 0 === t && e.ctrlKey || 2 === t;
      }
      _move(e, t) {
        const i = .8 * (t.x - e.x);
        if (i) return this._active = !0, {
          bearingDelta: i
        };
      }
      contextmenu(e) {
        e.preventDefault();
      }
    }
    class Tr extends yr {
      _correctButton(e, t) {
        return 0 === t && e.ctrlKey || 2 === t;
      }
      _move(e, t) {
        const i = -.5 * (t.y - e.y);
        if (i) return this._active = !0, {
          pitchDelta: i
        };
      }
      contextmenu(e) {
        e.preventDefault();
      }
    }
    class Er {
      constructor(t, i) {
        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
      }
      reset() {
        this._active = !1, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
      }
      touchstart(e, t, i) {
        return this._calculateTransform(e, t, i);
      }
      touchmove(t, i, o) {
        if (this._active && !(o.length < this._minTouches)) {
          if (this._map._cooperativeGestures && !this._map.isMoving()) {
            if (1 === o.length && !e.isFullscreen()) return void this._showTouchPanBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);
        }
      }
      touchend(e, t, i) {
        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();
      }
      touchcancel() {
        this.reset();
      }
      _calculateTransform(t, i, o) {
        o.length > 0 && (this._active = !0);
        const r = mr(o, i),
          n = new e.pointGeometry(0, 0),
          s = new e.pointGeometry(0, 0);
        let a = 0;
        for (const e in r) {
          const t = r[e],
            i = this._touches[e];
          i && (n._add(t), s._add(t.sub(i)), a++, r[e] = t);
        }
        if (this._touches = r, a < this._minTouches || !s.mag()) return;
        const l = s.div(a);
        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
          around: n.div(a),
          panDelta: l
        };
      }
      enable() {
        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
      }
      disable() {
        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
      }
      isEnabled() {
        return !!this._enabled;
      }
      isActive() {
        return !!this._active;
      }
      _addTouchPanBlocker() {
        this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
      }
      _showTouchPanBlockerAlert() {
        this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
          this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
        }, 500);
      }
    }
    class Cr {
      constructor() {
        this.reset();
      }
      reset() {
        this._active = !1, this._firstTwoTouches = void 0;
      }
      _start(e) {}
      _move(e, t, i) {
        return {};
      }
      touchstart(e, t, i) {
        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));
      }
      touchmove(e, t, i) {
        const o = this._firstTwoTouches;
        if (!o) return;
        e.preventDefault();
        const [r, n] = o,
          s = Mr(i, t, r),
          a = Mr(i, t, n);
        if (!s || !a) return;
        const l = this._aroundCenter ? null : s.add(a).div(2);
        return this._move([s, a], l, e);
      }
      touchend(e, t, i) {
        if (!this._firstTwoTouches) return;
        const [o, r] = this._firstTwoTouches,
          n = Mr(i, t, o),
          s = Mr(i, t, r);
        n && s || (this._active && d(), this.reset());
      }
      touchcancel() {
        this.reset();
      }
      enable(e) {
        this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
      }
      disable() {
        this._enabled = !1, this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    function Mr(e, t, i) {
      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];
    }
    function Ir(e, t) {
      return Math.log(e / t) / Math.LN2;
    }
    class Sr extends Cr {
      reset() {
        super.reset(), this._distance = 0, this._startDistance = 0;
      }
      _start(e) {
        this._startDistance = this._distance = e[0].dist(e[1]);
      }
      _move(e, t) {
        const i = this._distance;
        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Ir(this._distance, this._startDistance)) < .1)) return this._active = !0, {
          zoomDelta: Ir(this._distance, i),
          pinchAround: t
        };
      }
    }
    function Dr(e, t) {
      return 180 * e.angleWith(t) / Math.PI;
    }
    class Lr extends Cr {
      reset() {
        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
      }
      _start(e) {
        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
      }
      _move(e, t) {
        const i = this._vector;
        if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
          bearingDelta: Dr(this._vector, i),
          pinchAround: t
        };
      }
      _isBelowThreshold(e) {
        this._minDiameter = Math.min(this._minDiameter, e.mag());
        const t = 25 / (Math.PI * this._minDiameter) * 360,
          i = this._startVector;
        if (!i) return !1;
        const o = Dr(e, i);
        return Math.abs(o) < t;
      }
    }
    function Ar(e) {
      return Math.abs(e.y) > Math.abs(e.x);
    }
    class zr extends Cr {
      constructor(e) {
        super(), this._map = e;
      }
      reset() {
        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
      }
      _start(e) {
        this._lastPoints = e, Ar(e[0].sub(e[1])) && (this._valid = !1);
      }
      _move(t, i, o) {
        const r = this._lastPoints;
        if (!r) return;
        const n = t[0].sub(r[0]),
          s = t[1].sub(r[1]);
        return this._map._cooperativeGestures && !e.isFullscreen() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n, s, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {
          pitchDelta: (n.y + s.y) / 2 * -.5
        });
      }
      gestureBeginsVertically(e, t, i) {
        if (void 0 !== this._valid) return this._valid;
        const o = e.mag() >= 2,
          r = t.mag() >= 2;
        if (!o && !r) return;
        if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
        const n = e.y > 0 == t.y > 0;
        return Ar(e) && Ar(t) && n;
      }
    }
    const Pr = {
      panStep: 100,
      bearingStep: 15,
      pitchStep: 10
    };
    class Rr {
      constructor() {
        const e = Pr;
        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
      }
      blur() {
        this.reset();
      }
      reset() {
        this._active = !1;
      }
      keydown(e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;
        let t = 0,
          i = 0,
          o = 0,
          r = 0,
          n = 0;
        switch (e.keyCode) {
          case 61:
          case 107:
          case 171:
          case 187:
            t = 1;
            break;
          case 189:
          case 109:
          case 173:
            t = -1;
            break;
          case 37:
            e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);
            break;
          case 39:
            e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);
            break;
          case 38:
            e.shiftKey ? o = 1 : (e.preventDefault(), n = -1);
            break;
          case 40:
            e.shiftKey ? o = -1 : (e.preventDefault(), n = 1);
            break;
          default:
            return;
        }
        return this._rotationDisabled && (i = 0, o = 0), {
          cameraAnimation: s => {
            const a = s.getZoom();
            s.easeTo({
              duration: 300,
              easeId: "keyboardHandler",
              easing: Or,
              zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a,
              bearing: s.getBearing() + i * this._bearingStep,
              pitch: s.getPitch() + o * this._pitchStep,
              offset: [-r * this._panStep, -n * this._panStep],
              center: s.getCenter()
            }, {
              originalEvent: e
            });
          }
        };
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        this._enabled = !1, this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
      disableRotation() {
        this._rotationDisabled = !0;
      }
      enableRotation() {
        this._rotationDisabled = !1;
      }
    }
    function Or(e) {
      return e * (2 - e);
    }
    const Br = 4.000244140625;
    class kr {
      constructor(t, i) {
        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
      }
      setZoomRate(e) {
        this._defaultZoomRate = e;
      }
      setWheelZoomRate(e) {
        this._wheelZoomRate = e;
      }
      isEnabled() {
        return !!this._enabled;
      }
      isActive() {
        return this._active || void 0 !== this._finishTimeout;
      }
      isZooming() {
        return !!this._zooming;
      }
      enable(e) {
        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
      }
      disable() {
        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
      }
      wheel(t) {
        if (!this.isEnabled()) return;
        if (this._map._cooperativeGestures) {
          if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.isFullscreen())) return void this._showBlockerAlert();
          "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
        }
        let i = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
        const o = e.exported.now(),
          r = o - (this._lastWheelEventTime || 0);
        this._lastWheelEventTime = o, 0 !== i && i % Br == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();
      }
      _onTimeout(e) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
      }
      _start(e) {
        if (!this._delta) return;
        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        const t = p(this._el, e);
        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
      }
      renderFrame() {
        if (!this._frameId) return;
        if (this._frameId = null, !this.isActive()) return;
        const t = this._map.transform;
        "wheel" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
        const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
        if (0 !== this._delta) {
          const e = "wheel" === this._type && Math.abs(this._delta) > Br ? this._wheelZoomRate : this._defaultZoomRate;
          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
          this._delta < 0 && 0 !== o && (o = 1 / o);
          const r = i(),
            n = Math.pow(2, r),
            s = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : n;
          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(s * o))), "wheel" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._delta = 0;
        }
        const o = "number" == typeof this._targetZoom ? this._targetZoom : i(),
          r = this._startZoom,
          n = this._easing;
        let s,
          a = !1;
        if ("wheel" === this._type && r && n) {
          const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1),
            i = n(t);
          s = e.number(r, o, i), t < 1 ? this._frameId || (this._frameId = !0) : a = !0;
        } else s = o, a = !0;
        return this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout(() => {
          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
        }, 200)), {
          noInertia: !0,
          needsRenderFrame: !a,
          zoomDelta: s - i(),
          around: this._aroundPoint,
          aroundCoord: this._aroundCoord,
          originalEvent: this._lastWheelEvent
        };
      }
      _smoothOutEasing(t) {
        let i = e.ease;
        if (this._prevEase) {
          const t = this._prevEase,
            o = (e.exported.now() - t.start) / t.duration,
            r = t.easing(o + .01) - t.easing(o),
            n = .27 / Math.sqrt(r * r + 1e-4) * .01,
            s = Math.sqrt(.0729 - n * n);
          i = e.bezier(n, s, .25, 1);
        }
        return this._prevEase = {
          start: e.exported.now(),
          duration: t,
          easing: i
        }, i;
      }
      blur() {
        this.reset();
      }
      reset() {
        this._active = !1;
      }
      _addScrollZoomBlocker() {
        this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
      }
      _showBlockerAlert() {
        this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
          this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
        }, 200);
      }
    }
    class Fr {
      constructor(e, t) {
        this._clickZoom = e, this._tapZoom = t;
      }
      enable() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }
      disable() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }
      isEnabled() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }
      isActive() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      }
    }
    class Ur {
      constructor() {
        this.reset();
      }
      reset() {
        this._active = !1;
      }
      blur() {
        this.reset();
      }
      dblclick(e, t) {
        return e.preventDefault(), {
          cameraAnimation: i => {
            i.easeTo({
              duration: 300,
              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),
              around: i.unproject(t)
            }, {
              originalEvent: e
            });
          }
        };
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        this._enabled = !1, this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    class Nr {
      constructor() {
        this._tap = new gr({
          numTouches: 1,
          numTaps: 1
        }), this.reset();
      }
      reset() {
        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
      }
      touchstart(e, t, i) {
        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));
      }
      touchmove(e, t, i) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (i[0].identifier !== this._swipeTouch) return;
            const o = t[0],
              r = o.y - this._swipePoint.y;
            return this._swipePoint = o, e.preventDefault(), this._active = !0, {
              zoomDelta: r / 128
            };
          }
        } else this._tap.touchmove(e, t, i);
      }
      touchend(e, t, i) {
        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);
      }
      touchcancel() {
        this.reset();
      }
      enable() {
        this._enabled = !0;
      }
      disable() {
        this._enabled = !1, this.reset();
      }
      isEnabled() {
        return this._enabled;
      }
      isActive() {
        return this._active;
      }
    }
    class Gr {
      constructor(e, t, i) {
        this._el = e, this._mousePan = t, this._touchPan = i;
      }
      enable(e) {
        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }
      disable() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }
      isEnabled() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }
      isActive() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      }
    }
    class jr {
      constructor(e, t, i) {
        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;
      }
      enable() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }
      disable() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }
      isEnabled() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }
      isActive() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      }
    }
    class Zr {
      constructor(e, t, i, o) {
        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
      }
      enable(e) {
        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }
      disable() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }
      isEnabled() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }
      isActive() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }
      disableRotation() {
        this._rotationDisabled = !0, this._touchRotate.disable();
      }
      enableRotation() {
        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
      }
    }
    const Vr = e => e.zoom || e.drag || e.pitch || e.rotate;
    class Wr extends e.Event {}
    class Xr {
      constructor() {
        this.constants = [1, 1, .01], this.radius = 0;
      }
      setup(t, i) {
        const o = e.sub([], i, t);
        this.radius = e.length(o[2] < 0 ? e.div([], o, this.constants) : [o[0], o[1], 0]);
      }
      projectRay(t) {
        e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants);
        const i = e.scale$2([], t, this.radius);
        if (i[2] > 0) {
          const t = e.scale$2([], [0, 0, 1], e.dot(i, [0, 0, 1])),
            o = e.scale$2([], e.normalize([], [i[0], i[1], 0]), this.radius),
            r = e.add([], i, e.scale$2([], e.sub([], e.add([], o, t), i), 2));
          i[0] = r[0], i[1] = r[1];
        }
        return i;
      }
    }
    function qr(e) {
      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
    }
    class $r {
      constructor(t, i) {
        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new sr(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Xr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.bindAll(["handleEvent", "handleWindowEvent"], this);
        const o = this._el;
        this._listeners = [[o, "touchstart", {
          passive: !0
        }], [o, "touchmove", {
          passive: !1
        }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [e.window.document, "mousemove", {
          capture: !0
        }], [e.window.document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", {
          capture: !1
        }], [o, "keyup", void 0], [o, "wheel", {
          passive: !1
        }], [o, "contextmenu", void 0], [e.window, "blur", void 0]];
        for (const [t, i, o] of this._listeners) t.addEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);
      }
      destroy() {
        for (const [t, i, o] of this._listeners) t.removeEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);
      }
      _addDefaultHandlers(e) {
        const t = this._map,
          i = t.getCanvasContainer();
        this._add("mapEvent", new _r(t, e));
        const o = t.boxZoom = new pr(t, e);
        this._add("boxZoom", o);
        const r = new vr(),
          n = new Ur();
        t.doubleClickZoom = new Fr(n, r), this._add("tapZoom", r), this._add("clickZoom", n);
        const s = new Nr();
        this._add("tapDragZoom", s);
        const a = t.touchPitch = new zr(t);
        this._add("touchPitch", a);
        const l = new wr(e),
          c = new Tr(e);
        t.dragRotate = new jr(e, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);
        const h = new br(e),
          u = new Er(t, e);
        t.dragPan = new Gr(i, h, u), this._add("mousePan", h), this._add("touchPan", u, ["touchZoom", "touchRotate"]);
        const _ = new Lr(),
          d = new Sr();
        t.touchZoomRotate = new Zr(i, d, _, s), this._add("touchRotate", _, ["touchPan", "touchZoom"]), this._add("touchZoom", d, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new dr(t));
        const p = t.scrollZoom = new kr(t, this);
        this._add("scrollZoom", p, ["mousePan"]);
        const m = t.keyboard = new Rr();
        this._add("keyboard", m);
        for (const i of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e.interactive && e[i] && t[i].enable(e[i]);
      }
      _add(e, t, i) {
        this._handlers.push({
          handlerName: e,
          handler: t,
          allowed: i
        }), this._handlersById[e] = t;
      }
      stop(e) {
        if (!this._updatingCamera) {
          for (const {
            handler: e
          } of this._handlers) e.reset();
          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
        }
      }
      isActive() {
        for (const {
          handler: e
        } of this._handlers) if (e.isActive()) return !0;
        return !1;
      }
      isZooming() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }
      isRotating() {
        return !!this._eventsInProgress.rotate;
      }
      isMoving() {
        return !!Vr(this._eventsInProgress) || this.isZooming();
      }
      _isDragging() {
        return !!this._eventsInProgress.drag;
      }
      _blockedByActive(e, t, i) {
        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;
        return !1;
      }
      handleWindowEvent(e) {
        this.handleEvent(e, `${e.type}Window`);
      }
      _getMapTouches(e) {
        const t = [];
        for (const i of e) this._el.contains(i.target) && t.push(i);
        return t;
      }
      handleEvent(e, t) {
        this._updatingCamera = !0;
        const i = "renderFrame" === e.type,
          o = i ? void 0 : e,
          r = {
            needsRenderFrame: !1
          },
          n = {},
          s = {},
          a = e.touches ? this._getMapTouches(e.touches) : void 0,
          l = a ? m(this._el, a) : i ? void 0 : p(this._el, e);
        for (const {
          handlerName: i,
          handler: c,
          allowed: h
        } of this._handlers) {
          if (!c.isEnabled()) continue;
          let u;
          this._blockedByActive(s, h, i) ? c.reset() : c[t || e.type] && (u = c[t || e.type](e, l, a), this.mergeHandlerResult(r, n, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (s[i] = c);
        }
        const c = {};
        for (const e in this._previousActiveHandlers) s[e] || (c[e] = o);
        this._previousActiveHandlers = s, (Object.keys(c).length || qr(r)) && (this._changes.push([r, n, c]), this._triggerRenderFrame()), (Object.keys(s).length || qr(r)) && this._map._stop(!0), this._updatingCamera = !1;
        const {
          cameraAnimation: h
        } = r;
        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
      }
      mergeHandlerResult(t, i, o, r, n) {
        if (!o) return;
        e.extend(t, o);
        const s = {
          handlerName: r,
          originalEvent: o.originalEvent || n
        };
        void 0 !== o.zoomDelta && (i.zoom = s), void 0 !== o.panDelta && (i.drag = s), void 0 !== o.pitchDelta && (i.pitch = s), void 0 !== o.bearingDelta && (i.rotate = s);
      }
      _applyChanges() {
        const t = {},
          i = {},
          o = {};
        for (const [r, n, s] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.extend(i, n), e.extend(o, s);
        this._updateMapTransform(t, i, o), this._changes = [];
      }
      _updateMapTransform(t, i, o) {
        const r = this._map,
          n = r.transform,
          s = e => [e.x, e.y, e.z];
        if ((e => {
          const t = this._eventsInProgress.drag;
          return t && !this._handlersById[t.handlerName].isActive();
        })() && !qr(t)) {
          const e = n.zoom;
          n.cameraElevationReference = "sea", n.recenterOnTerrain(), n.cameraElevationReference = "ground", e !== n.zoom && this._map._update(!0);
        }
        if (n._isCameraConstrained && r._stop(!0), !qr(t)) return void this._fireEvents(i, o, !0);
        let {
          panDelta: a,
          zoomDelta: l,
          bearingDelta: c,
          pitchDelta: h,
          around: u,
          aroundCoord: _,
          pinchAround: d
        } = t;
        n._isCameraConstrained && (l > 0 && (l = 0), n._isCameraConstrained = !1), void 0 !== d && (u = d), (l || (e => i.drag && !this._eventsInProgress.drag)()) && u && (this._dragOrigin = s(n.pointCoordinate3D(u)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = "sea", r._stop(!0), u = u || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();
        const p = [0, 0, 0];
        if (a) if ("mercator" === n.projection.name) {
          const e = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir),
            t = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);
          p[0] = t[0] - e[0], p[1] = t[1] - e[1];
        } else {
          const t = n.pointCoordinate(u);
          if ("globe" === n.projection.name) {
            a = a.rotate(-n.angle);
            const i = n._pixelsPerMercatorPixel / n.worldSize;
            p[0] = -a.x * e.mercatorScale(e.latFromMercatorY(t.y)) * i, p[1] = -a.y * e.mercatorScale(n.center.lat) * i;
          } else {
            const e = n.pointCoordinate(u.sub(a));
            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);
          }
        }
        const m = n.zoom,
          f = [0, 0, 0];
        if (l) {
          const t = s(_ || n.pointCoordinate3D(u)),
            i = {
              dir: e.normalize([], e.sub([], t, n._camera.position))
            };
          if (i.dir[2] < 0) {
            const o = n.zoomDeltaToMovement(t, l);
            e.scale$2(f, i.dir, o);
          }
        }
        const g = e.add(p, p, f);
        n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);
      }
      _fireEvents(t, i, o) {
        const r = Vr(this._eventsInProgress),
          n = Vr(t),
          s = {};
        for (const e in t) {
          const {
            originalEvent: i
          } = t[e];
          this._eventsInProgress[e] || (s[`${e}start`] = i), this._eventsInProgress[e] = t[e];
        }
        !r && n && this._fireEvent("movestart", n.originalEvent);
        for (const e in s) this._fireEvent(e, s[e]);
        n && this._fireEvent("move", n.originalEvent);
        for (const e in t) {
          const {
            originalEvent: i
          } = t[e];
          this._fireEvent(e, i);
        }
        const a = {};
        let l;
        for (const e in this._eventsInProgress) {
          const {
            handlerName: t,
            originalEvent: o
          } = this._eventsInProgress[e];
          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, a[`${e}end`] = l);
        }
        for (const e in a) this._fireEvent(e, a[e]);
        const c = Vr(this._eventsInProgress);
        if (o && (r || n) && !c) {
          this._updatingCamera = !0;
          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
            i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {
            originalEvent: l
          })) : (this._map.fire(new e.Event("moveend", {
            originalEvent: l
          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
        }
      }
      _fireEvent(t, i) {
        this._map.fire(new e.Event(t, i ? {
          originalEvent: i
        } : {}));
      }
      _requestFrame() {
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {
          this._frameId = void 0, this.handleEvent(new Wr("renderFrame", {
            timeStamp: e
          })), this._applyChanges();
        });
      }
      _triggerRenderFrame() {
        void 0 === this._frameId && (this._frameId = this._requestFrame());
      }
    }
    const Hr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
    class Yr extends e.Evented {
      constructor(t, i) {
        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
      }
      getCenter() {
        return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
      }
      setCenter(e, t) {
        return this.jumpTo({
          center: e
        }, t);
      }
      panBy(t, i, o) {
        return t = e.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({
          offset: t
        }, i), o);
      }
      panTo(t, i, o) {
        return this.easeTo(e.extend({
          center: t
        }, i), o);
      }
      getZoom() {
        return this.transform.zoom;
      }
      setZoom(e, t) {
        return this.jumpTo({
          zoom: e
        }, t), this;
      }
      zoomTo(t, i, o) {
        return this.easeTo(e.extend({
          zoom: t
        }, i), o);
      }
      zoomIn(e, t) {
        return this.zoomTo(this.getZoom() + 1, e, t), this;
      }
      zoomOut(e, t) {
        return this.zoomTo(this.getZoom() - 1, e, t), this;
      }
      getBearing() {
        return this.transform.bearing;
      }
      setBearing(e, t) {
        return this.jumpTo({
          bearing: e
        }, t), this;
      }
      getPadding() {
        return this.transform.padding;
      }
      setPadding(e, t) {
        return this.jumpTo({
          padding: e
        }, t), this;
      }
      rotateTo(t, i, o) {
        return this.easeTo(e.extend({
          bearing: t
        }, i), o);
      }
      resetNorth(t, i) {
        return this.rotateTo(0, e.extend({
          duration: 1e3
        }, t), i), this;
      }
      resetNorthPitch(t, i) {
        return this.easeTo(e.extend({
          bearing: 0,
          pitch: 0,
          duration: 1e3
        }, t), i), this;
      }
      snapToNorth(e, t) {
        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
      }
      getPitch() {
        return this.transform.pitch;
      }
      setPitch(e, t) {
        return this.jumpTo({
          pitch: e
        }, t), this;
      }
      cameraForBounds(t, i) {
        t = e.LngLatBounds.convert(t);
        const o = i && i.bearing || 0,
          r = i && i.pitch || 0,
          n = t.getNorthWest(),
          s = t.getSouthEast();
        return this._cameraForBounds(this.transform, n, s, o, r, i);
      }
      _extendCameraOptions(t) {
        const i = {
          top: 0,
          bottom: 0,
          right: 0,
          left: 0
        };
        if ("number" == typeof (t = e.extend({
          padding: i,
          offset: [0, 0],
          maxZoom: this.transform.maxZoom
        }, t)).padding) {
          const e = t.padding;
          t.padding = {
            top: e,
            bottom: e,
            right: e,
            left: e
          };
        }
        return t.padding = e.extend(i, t.padding), t;
      }
      _minimumAABBFrustumDistance(e, t) {
        const i = t.max[0] - t.min[0],
          o = t.max[1] - t.min[1];
        return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);
      }
      _cameraForBoundsOnGlobe(t, i, o, r, n, s) {
        const a = t.clone(),
          l = this._extendCameraOptions(s);
        a.bearing = r, a.pitch = n;
        const c = e.LngLat.convert(i),
          h = e.LngLat.convert(o),
          u = .5 * (c.lat + h.lat),
          _ = .5 * (c.lng + h.lng),
          d = e.latLngToECEF(u, _),
          p = e.normalize([], d),
          m = e.normalize([], e.cross([], p, [0, 1, 0])),
          f = e.cross([], m, p),
          g = [m[0], m[1], m[2], 0, f[0], f[1], f[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],
          v = [d, e.latLngToECEF(c.lat, c.lng), e.latLngToECEF(h.lat, c.lng), e.latLngToECEF(h.lat, h.lng), e.latLngToECEF(c.lat, h.lng), e.latLngToECEF(u, c.lng), e.latLngToECEF(u, h.lng), e.latLngToECEF(c.lat, _), e.latLngToECEF(h.lat, _)];
        let x = e.Aabb.fromPoints(v.map(t => [e.dot(m, t), e.dot(f, t), e.dot(p, t)]));
        const y = e.transformMat4([], x.center, g);
        0 === e.squaredLength(y) && e.set(y, 0, 0, 1), e.normalize(y, y), e.scale$2(y, y, e.GLOBE_RADIUS), a.center = e.ecefToLatLng(y);
        const b = a.getWorldToCameraMatrix(),
          w = e.invert(new Float64Array(16), b);
        x = e.Aabb.applyTransform(x, e.multiply([], b, g)), e.transformMat4(y, y, b);
        const T = .5 * (x.max[2] - x.min[2]),
          E = this._minimumAABBFrustumDistance(a, x),
          C = e.scale$2([], [0, 0, 1], T),
          M = e.add(C, y, C),
          I = E + (0 === a.pitch ? 0 : e.distance(y, M)),
          S = a.globeCenterInViewSpace,
          D = e.sub([], y, [S[0], S[1], S[2]]);
        e.normalize(D, D), e.scale$2(D, D, I);
        const L = e.add([], y, D);
        e.transformMat4(L, L, w);
        const A = e.earthRadius / e.GLOBE_RADIUS,
          z = e.length(L),
          P = e.mercatorZfromAltitude(Math.max(z * A - e.earthRadius, Number.EPSILON), 0),
          R = Math.min(a.zoomFromMercatorZAdjusted(P), l.maxZoom);
        return R > .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
          name: "mercator"
        }), a.zoom = R, this._cameraForBounds(a, i, o, r, n, s)) : {
          center: a.center,
          zoom: R,
          bearing: r,
          pitch: n
        };
      }
      queryTerrainElevation(t, i) {
        const o = this.transform.elevation;
        return o ? (i = e.extend({}, {
          exaggerated: !0
        }, i), o.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, i.exaggerated)) : null;
      }
      _cameraForBounds(t, i, o, r, n, s) {
        if ("globe" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, r, n, s);
        const a = t.clone(),
          l = this._extendCameraOptions(s),
          c = a.padding;
        a.bearing = r, a.pitch = n;
        const h = e.LngLat.convert(i),
          u = e.LngLat.convert(o),
          _ = new e.LngLat(h.lng, u.lat),
          d = new e.LngLat(u.lng, h.lat),
          p = a.project(h),
          m = a.project(u),
          f = this.queryTerrainElevation(h),
          g = this.queryTerrainElevation(u),
          v = this.queryTerrainElevation(_),
          x = this.queryTerrainElevation(d),
          y = [[p.x, p.y, Math.min(f || 0, g || 0, v || 0, x || 0)], [m.x, m.y, Math.max(f || 0, g || 0, v || 0, x || 0)]];
        let b = e.Aabb.fromPoints(y);
        const w = a.getWorldToCameraMatrix(),
          T = e.invert(new Float64Array(16), w);
        b = e.Aabb.applyTransform(b, w);
        const E = e.sub([], b.max, b.min),
          C = c.left || 0,
          M = c.right || 0,
          I = c.bottom || 0,
          S = c.top || 0,
          {
            left: D,
            right: L,
            top: A,
            bottom: z
          } = l.padding,
          P = .5 * (C + M),
          R = .5 * (S + I),
          O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + M + D + L)) / E[0], (a.height - (I + S + z + A)) / E[1])), l.maxZoom),
          B = a.scale / a.zoomScale(O);
        b = new e.Aabb([b.min[0] - (D + P) * B, b.min[1] - (z + R) * B, b.min[2]], [b.max[0] + (L + P) * B, b.max[1] + (A + R) * B, b.max[2]]);
        const k = .5 * E[2],
          F = this._minimumAABBFrustumDistance(a, b),
          U = [0, 0, 1, 0];
        e.transformMat4$1(U, U, w), e.normalize$2(U, U);
        const N = e.scale$2([], U, F + k),
          G = e.add([], b.center, N),
          j = ("number" == typeof l.offset.x && "number" == typeof l.offset.y ? new e.pointGeometry(l.offset.x, l.offset.y) : e.pointGeometry.convert(l.offset)).rotate(-e.degToRad(r));
        b.center[0] -= j.x * B, b.center[1] += j.y * B, e.transformMat4(b.center, b.center, T), e.transformMat4(G, G, T);
        const Z = [b.center[0], b.center[1], G[2] * a.pixelsPerMeter];
        e.scale$2(Z, Z, 1 / a.worldSize);
        const V = e.lngFromMercatorX(Z[0]),
          W = e.latFromMercatorY(Z[1]),
          X = Math.min(a._zoomFromMercatorZ(Z[2]), l.maxZoom),
          q = new e.LngLat(V, W);
        return a.mercatorFromTransition && X < .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
          name: "globe"
        }), a.zoom = X, this._cameraForBounds(a, i, o, r, n, s)) : {
          center: q,
          zoom: X,
          bearing: r,
          pitch: n
        };
      }
      fitBounds(e, t, i) {
        const o = this.cameraForBounds(e, t);
        return this._fitInternal(o, t, i);
      }
      fitScreenCoordinates(t, i, o, r, n) {
        const s = e.pointGeometry.convert(t),
          a = e.pointGeometry.convert(i),
          l = new e.pointGeometry(Math.min(s.x, a.x), Math.min(s.y, a.y)),
          c = new e.pointGeometry(Math.max(s.x, a.x), Math.max(s.y, a.y));
        if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a)) return this;
        const h = this.transform.pointLocation3D(l),
          u = this.transform.pointLocation3D(c),
          _ = this.transform.pointLocation3D(new e.pointGeometry(l.x, c.y)),
          d = this.transform.pointLocation3D(new e.pointGeometry(c.x, l.y)),
          p = [Math.min(h.lng, u.lng, _.lng, d.lng), Math.min(h.lat, u.lat, _.lat, d.lat)],
          m = [Math.max(h.lng, u.lng, _.lng, d.lng), Math.max(h.lat, u.lat, _.lat, d.lat)],
          f = r && r.pitch ? r.pitch : this.getPitch(),
          g = this._cameraForBounds(this.transform, p, m, o, f, r);
        return this._fitInternal(g, r, n);
      }
      _fitInternal(t, i, o) {
        return t ? (delete (i = e.extend(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
      }
      jumpTo(t, i) {
        this.stop();
        const o = t.preloadOnly ? this.transform.clone() : this.transform;
        let r = !1,
          n = !1,
          s = !1;
        return "zoom" in t && o.zoom !== +t.zoom && (r = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.LngLat.convert(t.center)), "bearing" in t && o.bearing !== +t.bearing && (n = !0, o.bearing = +t.bearing), "pitch" in t && o.pitch !== +t.pitch && (s = !0, o.pitch = +t.pitch), null == t.padding || o.isPaddingEqual(t.padding) || (o.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.Event("movestart", i)).fire(new e.Event("move", i)), r && this.fire(new e.Event("zoomstart", i)).fire(new e.Event("zoom", i)).fire(new e.Event("zoomend", i)), n && this.fire(new e.Event("rotatestart", i)).fire(new e.Event("rotate", i)).fire(new e.Event("rotateend", i)), s && this.fire(new e.Event("pitchstart", i)).fire(new e.Event("pitch", i)).fire(new e.Event("pitchend", i)), this.fire(new e.Event("moveend", i)));
      }
      getFreeCameraOptions() {
        return this.transform.projection.supportsFreeCamera || e.warnOnce(Hr), this.transform.getFreeCameraOptions();
      }
      setFreeCameraOptions(t, i) {
        const o = this.transform;
        if (!o.projection.supportsFreeCamera) return e.warnOnce(Hr), this;
        this.stop();
        const r = o.zoom,
          n = o.pitch,
          s = o.bearing;
        o.setFreeCameraOptions(t);
        const a = r !== o.zoom,
          l = n !== o.pitch,
          c = s !== o.bearing;
        return this.fire(new e.Event("movestart", i)).fire(new e.Event("move", i)), a && this.fire(new e.Event("zoomstart", i)).fire(new e.Event("zoom", i)).fire(new e.Event("zoomend", i)), c && this.fire(new e.Event("rotatestart", i)).fire(new e.Event("rotate", i)).fire(new e.Event("rotateend", i)), l && this.fire(new e.Event("pitchstart", i)).fire(new e.Event("pitch", i)).fire(new e.Event("pitchend", i)), this.fire(new e.Event("moveend", i)), this;
      }
      easeTo(t, i) {
        this._stop(!1, t.easeId), (!1 === (t = e.extend({
          offset: [0, 0],
          duration: 500,
          easing: e.ease
        }, t)).animate || !t.essential && e.exported.prefersReducedMotion) && (t.duration = 0);
        const o = this.transform,
          r = this.getZoom(),
          n = this.getBearing(),
          s = this.getPitch(),
          a = this.getPadding(),
          l = "zoom" in t ? +t.zoom : r,
          c = "bearing" in t ? this._normalizeBearing(t.bearing, n) : n,
          h = "pitch" in t ? +t.pitch : s,
          u = "padding" in t ? t.padding : o.padding,
          _ = e.pointGeometry.convert(t.offset);
        let d, p, m;
        if ("globe" === o.projection.name) {
          const i = e.MercatorCoordinate.fromLngLat(o.center),
            r = _.rotate(-o.angle);
          i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;
          const n = i.toLngLat(),
            s = e.LngLat.convert(t.center || n);
          this._normalizeCenter(s), d = o.centerPoint.add(r), p = new e.pointGeometry(i.x, i.y).mult(o.worldSize), m = new e.pointGeometry(e.mercatorXfromLng(s.lng), e.mercatorYfromLat(s.lat)).mult(o.worldSize).sub(p);
        } else {
          d = o.centerPoint.add(_);
          const i = o.pointLocation(d),
            r = e.LngLat.convert(t.center || i);
          this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);
        }
        const f = o.zoomScale(l - r);
        let g, v;
        t.around && (g = e.LngLat.convert(t.around), v = o.locationPoint(g));
        const x = this._zooming || l !== r,
          y = this._rotating || n !== c,
          b = this._pitching || h !== s,
          w = !o.isPaddingEqual(u),
          T = o => T => {
            if (x && (o.zoom = e.number(r, l, T)), y && (o.bearing = e.number(n, c, T)), b && (o.pitch = e.number(s, h, T)), w && (o.interpolatePadding(a, u, T), d = o.centerPoint.add(_)), g) o.setLocationAtPoint(g, v);else {
              const e = o.zoomScale(o.zoom - r),
                t = l > r ? Math.min(2, f) : Math.max(.5, f),
                i = Math.pow(t, 1 - T),
                n = o.unproject(p.add(m.mult(T * i)).mult(e));
              o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);
            }
            return t.preloadOnly || this._fireMoveEvents(i), o;
          };
        if (t.preloadOnly) {
          const e = this._emulate(T, t.duration, o);
          return this._preloadTiles(e), this;
        }
        const E = {
          moving: this._moving,
          zooming: this._zooming,
          rotating: this._rotating,
          pitching: this._pitching
        };
        return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E), this._ease(T(o), e => {
          o.recenterOnTerrain(), this._afterEase(i, e);
        }, t), this;
      }
      _prepareEase(t, i, o = {}) {
        this._moving = !0, this.transform.cameraElevationReference = "sea", i || o.moving || this.fire(new e.Event("movestart", t)), this._zooming && !o.zooming && this.fire(new e.Event("zoomstart", t)), this._rotating && !o.rotating && this.fire(new e.Event("rotatestart", t)), this._pitching && !o.pitching && this.fire(new e.Event("pitchstart", t));
      }
      _fireMoveEvents(t) {
        this.fire(new e.Event("move", t)), this._zooming && this.fire(new e.Event("zoom", t)), this._rotating && this.fire(new e.Event("rotate", t)), this._pitching && this.fire(new e.Event("pitch", t));
      }
      _afterEase(t, i) {
        if (this._easeId && i && this._easeId === i) return;
        this._easeId = void 0, this.transform.cameraElevationReference = "ground";
        const o = this._zooming,
          r = this._rotating,
          n = this._pitching;
        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.Event("zoomend", t)), r && this.fire(new e.Event("rotateend", t)), n && this.fire(new e.Event("pitchend", t)), this.fire(new e.Event("moveend", t));
      }
      flyTo(t, i) {
        if (!t.essential && e.exported.prefersReducedMotion) {
          const o = e.pick(t, ["center", "zoom", "bearing", "pitch", "around"]);
          return this.jumpTo(o, i);
        }
        this.stop(), t = e.extend({
          offset: [0, 0],
          speed: 1.2,
          curve: 1.42,
          easing: e.ease
        }, t);
        const o = this.transform,
          r = this.getZoom(),
          n = this.getBearing(),
          s = this.getPitch(),
          a = this.getPadding(),
          l = "zoom" in t ? e.clamp(+t.zoom, o.minZoom, o.maxZoom) : r,
          c = "bearing" in t ? this._normalizeBearing(t.bearing, n) : n,
          h = "pitch" in t ? +t.pitch : s,
          u = "padding" in t ? t.padding : o.padding,
          _ = o.zoomScale(l - r),
          d = e.pointGeometry.convert(t.offset);
        let p = o.centerPoint.add(d);
        const m = o.pointLocation(p),
          f = e.LngLat.convert(t.center || m);
        this._normalizeCenter(f);
        const g = o.project(m),
          v = o.project(f).sub(g);
        let x = t.curve;
        const y = Math.max(o.width, o.height),
          b = y / _,
          w = v.mag();
        if ("minZoom" in t) {
          const i = e.clamp(Math.min(t.minZoom, r, l), o.minZoom, o.maxZoom),
            n = y / o.zoomScale(i - r);
          x = Math.sqrt(n / w * 2);
        }
        const T = x * x;
        function E(e) {
          const t = (b * b - y * y + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : y) * T * w);
          return Math.log(Math.sqrt(t * t + 1) - t);
        }
        function C(e) {
          return (Math.exp(e) - Math.exp(-e)) / 2;
        }
        function M(e) {
          return (Math.exp(e) + Math.exp(-e)) / 2;
        }
        const I = E(0);
        let S = function (e) {
            return M(I) / M(I + x * e);
          },
          D = function (e) {
            return y * ((M(I) * (C(t = I + x * e) / M(t)) - C(I)) / T) / w;
            var t;
          },
          L = (E(1) - I) / x;
        if (Math.abs(w) < 1e-6 || !isFinite(L)) {
          if (Math.abs(y - b) < 1e-6) return this.easeTo(t, i);
          const e = b < y ? -1 : 1;
          L = Math.abs(Math.log(b / y)) / x, D = function () {
            return 0;
          }, S = function (t) {
            return Math.exp(e * x * t);
          };
        }
        t.duration = "duration" in t ? +t.duration : 1e3 * L / ("screenSpeed" in t ? +t.screenSpeed / x : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
        const A = n !== c,
          z = h !== s,
          P = !o.isPaddingEqual(u),
          R = o => _ => {
            const m = _ * L,
              x = 1 / S(m);
            o.zoom = 1 === _ ? l : r + o.scaleZoom(x), A && (o.bearing = e.number(n, c, _)), z && (o.pitch = e.number(s, h, _)), P && (o.interpolatePadding(a, u, _), p = o.centerPoint.add(d));
            const y = 1 === _ ? f : o.unproject(g.add(v.mult(D(m))).mult(x));
            return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;
          };
        if (t.preloadOnly) {
          const e = this._emulate(R, t.duration, o);
          return this._preloadTiles(e), this;
        }
        return this._zooming = !0, this._rotating = A, this._pitching = z, this._padding = P, this._prepareEase(i, !1), this._ease(R(o), () => this._afterEase(i), t), this;
      }
      isEasing() {
        return !!this._easeFrameId;
      }
      stop() {
        return this._stop();
      }
      _stop(e, t) {
        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
          const e = this._onEaseEnd;
          this._onEaseEnd = void 0, e.call(this, t);
        }
        if (!e) {
          const e = this.handlers;
          e && e.stop(!1);
        }
        return this;
      }
      _ease(t, i, o) {
        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.exported.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
      }
      _renderFrameCallback() {
        const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1),
          i = this._onEaseFrame;
        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
      }
      _normalizeBearing(t, i) {
        t = e.wrap(t, -180, 180);
        const o = Math.abs(t - i);
        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;
      }
      _normalizeCenter(e) {
        const t = this.transform;
        if (!t.renderWorldCopies || t.maxBounds) return;
        const i = e.lng - t.center.lng;
        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
      }
      _emulate(e, t, i) {
        const o = Math.ceil(15 * t / 1e3),
          r = [],
          n = e(i.clone());
        for (let e = 0; e <= o; e++) {
          const t = n(e / o);
          r.push(t.clone());
        }
        return r;
      }
    }
    class Kr {
      constructor(t = {}) {
        this.options = t, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      }
      getDefaultPosition() {
        return "bottom-right";
      }
      onAdd(e) {
        const t = this.options && this.options.compact;
        return this._map = e, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }
      onRemove() {
        this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }
      _setElementTitle(e, t) {
        const i = this._map._getUIString(`AttributionControl.${t}`);
        e.setAttribute("aria-label", i), e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
      }
      _toggleAttribution() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
      }
      _updateEditLink() {
        let t = this._editLink;
        t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        const i = [{
          key: "owner",
          value: this.styleOwner
        }, {
          key: "id",
          value: this.styleId
        }, {
          key: "access_token",
          value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN
        }];
        if (t) {
          const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? "&" : ""}`), e), "?");
          t.href = `${e.config.FEEDBACK_URL}/${o}#${er(this._map, !0)}`, t.rel = "noopener nofollow", this._setElementTitle(t, "MapFeedback");
        }
      }
      _updateData(e) {
        !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
      }
      _updateAttributions() {
        if (!this._map.style) return;
        let e = [];
        if (this._map.style.stylesheet) {
          const e = this._map.style.stylesheet;
          this.styleOwner = e.owner, this.styleId = e.id;
        }
        const t = this._map.style._sourceCaches;
        for (const i in t) {
          const o = t[i];
          if (o.used) {
            const t = o.getSource();
            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);
          }
        }
        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {
          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;
          return !0;
        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));
        const i = e.join(" | ");
        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
      }
      _updateCompact() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      }
    }
    class Jr {
      constructor() {
        e.bindAll(["_updateLogo", "_updateCompact"], this);
      }
      onAdd(e) {
        this._map = e, this._container = n("div", "mapboxgl-ctrl");
        const t = n("a", "mapboxgl-ctrl-logo");
        return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://www.mapbox.com/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }
      onRemove() {
        this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }
      getDefaultPosition() {
        return "bottom-left";
      }
      _updateLogo(e) {
        e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }
      _logoRequired() {
        if (!this._map.style) return !0;
        const e = this._map.style._sourceCaches;
        if (0 === Object.entries(e).length) return !0;
        for (const t in e) {
          const i = e[t].getSource();
          if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
        }
        return !0;
      }
      _updateCompact() {
        const e = this._container.children;
        if (e.length) {
          const t = e[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add("mapboxgl-compact") : t.classList.remove("mapboxgl-compact");
        }
      }
    }
    class Qr {
      constructor() {
        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
      }
      add(e) {
        const t = ++this._id;
        return this._queue.push({
          callback: e,
          id: t,
          cancelled: !1
        }), t;
      }
      remove(e) {
        const t = this._currentlyRunning,
          i = t ? this._queue.concat(t) : this._queue;
        for (const t of i) if (t.id === e) return void (t.cancelled = !0);
      }
      run(e = 0) {
        const t = this._currentlyRunning = this._queue;
        this._queue = [];
        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;
        this._cleared = !1, this._currentlyRunning = !1;
      }
      clear() {
        this._currentlyRunning && (this._cleared = !0), this._queue = [];
      }
    }
    function en(t, i, o) {
      if (t = new e.LngLat(t.lng, t.lat), i) {
        const r = new e.LngLat(t.lng - 360, t.lat),
          n = new e.LngLat(t.lng + 360, t.lat),
          s = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),
          a = o.locationPoint(t).distSqr(i),
          l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
        o.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < s) ? t = r : o.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - o.center.lng) < s) && (t = n);
      }
      for (; Math.abs(t.lng - o.center.lng) > 180;) {
        const e = o.locationPoint(t);
        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;
        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;
      }
      return t;
    }
    const tn = {
      center: "translate(-50%,-50%)",
      top: "translate(-50%,0)",
      "top-left": "translate(0,0)",
      "top-right": "translate(-100%,0)",
      bottom: "translate(-50%,-100%)",
      "bottom-left": "translate(0,-100%)",
      "bottom-right": "translate(-100%,-100%)",
      left: "translate(0,-50%)",
      right: "translate(-100%,-50%)"
    };
    class on extends e.Evented {
      constructor(t, i) {
        if (super(), (t instanceof e.window.HTMLElement || i) && (t = e.extend({
          element: t
        }, i)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || .2, t && t.element) this._element = t.element, this._offset = e.pointGeometry.convert(t && t.offset || [0, 0]);else {
          this._defaultMarker = !0, this._element = n("div");
          const i = 41,
            o = 27,
            r = s("svg", {
              display: "block",
              height: i * this._scale + "px",
              width: o * this._scale + "px",
              viewBox: `0 0 ${o} ${i}`
            }, this._element),
            a = s("radialGradient", {
              id: "shadowGradient"
            }, s("defs", {}, r));
          s("stop", {
            offset: "10%",
            "stop-opacity": .4
          }, a), s("stop", {
            offset: "100%",
            "stop-opacity": .05
          }, a), s("ellipse", {
            cx: 13.5,
            cy: 34.8,
            rx: 10.5,
            ry: 5.25,
            fill: "url(#shadowGradient)"
          }, r), s("path", {
            fill: this._color,
            d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
          }, r), s("path", {
            opacity: .25,
            d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
          }, r), s("circle", {
            fill: "white",
            cx: 13.5,
            cy: 13.5,
            r: 5.5
          }, r), this._offset = e.pointGeometry.convert(t && t.offset || [0, -14]);
        }
        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", e => {
          e.preventDefault();
        }), this._element.addEventListener("mousedown", e => {
          e.preventDefault();
        });
        const o = this._element.classList;
        for (const e in tn) o.remove(`mapboxgl-marker-anchor-${e}`);
        o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
      }
      addTo(e) {
        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
      }
      remove() {
        const e = this._map;
        return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
      }
      getLngLat() {
        return this._lngLat;
      }
      setLngLat(t) {
        return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
      }
      getElement() {
        return this._element;
      }
      setPopup(e) {
        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
          if (!("offset" in e.options)) {
            const t = 38.1,
              i = 13.5,
              o = Math.sqrt(Math.pow(i, 2) / 2);
            e.options.offset = this._defaultMarker ? {
              top: [0, 0],
              "top-left": [0, 0],
              "top-right": [0, 0],
              bottom: [0, -t],
              "bottom-left": [o, -1 * (t - i + o)],
              "bottom-right": [-o, -1 * (t - i + o)],
              left: [i, -1 * (t - i)],
              right: [-i, -1 * (t - i)]
            } : this._offset;
          }
          this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
        }
        return this;
      }
      _onKeyPress(e) {
        const t = e.code,
          i = e.charCode || e.keyCode;
        "Space" !== t && "Enter" !== t && 32 !== i && 13 !== i || this.togglePopup();
      }
      _onMapClick(e) {
        const t = e.originalEvent.target,
          i = this._element;
        this._popup && (t === i || i.contains(t)) && this.togglePopup();
      }
      getPopup() {
        return this._popup;
      }
      togglePopup() {
        const e = this._popup;
        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
      }
      _behindTerrain() {
        const e = this._map,
          t = this._pos;
        if (!e || !t) return !1;
        const i = e.unproject(t),
          o = e.getFreeCameraOptions();
        if (!o.position) return !1;
        const r = o.position.toLngLat();
        return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);
      }
      _evaluateOpacity() {
        const t = this._map;
        if (!t) return;
        const i = this._pos;
        if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();
        const o = t.unproject(i);
        let r;
        t._showingGlobe() && e.isLngLatBehindGlobe(t.transform, this._lngLat) ? r = 0 : (r = 1 - t._queryFogOpacity(o), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;
      }
      _clearFadeTimer() {
        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
      }
      _updateDOM() {
        const e = this._pos;
        if (!e || !this._map) return;
        const t = this._offset.mult(this._scale);
        this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${tn[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t.x}px,${t.y}px)\n        `;
      }
      _calculateXYTransform() {
        const t = this._pos,
          i = this._map,
          o = this.getPitchAlignment();
        if (!i || !t || "map" !== o) return "";
        if (!i._showingGlobe()) {
          const e = i.getPitch();
          return e ? `rotateX(${e}deg)` : "";
        }
        const r = e.radToDeg(e.globeTiltAtLngLat(i.transform, this._lngLat)),
          n = t.sub(e.globeCenterToScreenPoint(i.transform)),
          s = Math.abs(n.x) + Math.abs(n.y);
        if (0 === s) return "";
        const a = r / s;
        return `rotateX(${-n.y * a}deg) rotateY(${n.x * a}deg)`;
      }
      _calculateZTransform() {
        const t = this._pos,
          i = this._map;
        if (!i || !t) return "";
        let o = 0;
        const r = this.getRotationAlignment();
        if ("map" === r) {
          if (i._showingGlobe()) {
            const t = i.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + .001)),
              r = i.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - .001)).sub(t);
            o = e.radToDeg(Math.atan2(r.y, r.x)) - 90;
          } else o = -i.getBearing();
        } else if ("horizon" === r) {
          const r = e.smoothstep(4, 6, i.getZoom()),
            n = e.globeCenterToScreenPoint(i.transform);
          n.y += r * i.transform.height;
          const s = t.sub(n),
            a = e.radToDeg(Math.atan2(s.y, s.x));
          o = (a > 90 ? a - 270 : a + 90) * (1 - r);
        }
        return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
      }
      _update(t) {
        e.window.cancelAnimationFrame(this._updateFrameId);
        const i = this._map;
        i && (i.transform.renderWorldCopies && (this._lngLat = en(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame(() => {
          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
        }) : this._pos = this._pos.round(), i._requestDomTask(() => {
          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
        }));
      }
      getOffset() {
        return this._offset;
      }
      setOffset(t) {
        return this._offset = e.pointGeometry.convert(t), this._update(), this;
      }
      _onMove(t) {
        const i = this._map;
        if (!i) return;
        const o = this._pointerdownPos,
          r = this._positionDelta;
        if (o && r) {
          if (!this._isDragging) {
            const e = this._clickTolerance || i._clickTolerance;
            if (t.point.dist(o) < e) return;
            this._isDragging = !0;
          }
          this._pos = t.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag"));
        }
      }
      _onUp() {
        this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
        const t = this._map;
        t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
      }
      _addDragHandler(e) {
        const t = this._map,
          i = this._pos;
        t && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = "pending", t.on("mousemove", this._onMove), t.on("touchmove", this._onMove), t.once("mouseup", this._onUp), t.once("touchend", this._onUp));
      }
      setDraggable(e) {
        this._draggable = !!e;
        const t = this._map;
        return t && (e ? (t.on("mousedown", this._addDragHandler), t.on("touchstart", this._addDragHandler)) : (t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler))), this;
      }
      isDraggable() {
        return this._draggable;
      }
      setRotation(e) {
        return this._rotation = e || 0, this._update(), this;
      }
      getRotation() {
        return this._rotation;
      }
      setRotationAlignment(e) {
        return this._rotationAlignment = e || "auto", this._update(), this;
      }
      getRotationAlignment() {
        return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
      }
      setPitchAlignment(e) {
        return this._pitchAlignment = e || "auto", this._update(), this;
      }
      getPitchAlignment() {
        return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
      }
      setOccludedOpacity(e) {
        return this._occludedOpacity = e || .2, this._update(), this;
      }
      getOccludedOpacity() {
        return this._occludedOpacity;
      }
    }
    const rn = {
        closeButton: !0,
        closeOnClick: !0,
        focusAfterOpen: !0,
        className: "",
        maxWidth: "240px"
      },
      nn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
    function sn(t = new e.pointGeometry(0, 0), i = "bottom") {
      if ("number" == typeof t) {
        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));
        switch (i) {
          case "top":
            return new e.pointGeometry(0, t);
          case "top-left":
            return new e.pointGeometry(o, o);
          case "top-right":
            return new e.pointGeometry(-o, o);
          case "bottom":
            return new e.pointGeometry(0, -t);
          case "bottom-left":
            return new e.pointGeometry(o, -o);
          case "bottom-right":
            return new e.pointGeometry(-o, -o);
          case "left":
            return new e.pointGeometry(t, 0);
          case "right":
            return new e.pointGeometry(-t, 0);
        }
        return new e.pointGeometry(0, 0);
      }
      return t instanceof e.pointGeometry || Array.isArray(t) ? e.pointGeometry.convert(t) : e.pointGeometry.convert(t[i] || [0, 0]);
    }
    class an {
      constructor(e) {
        this.jumpTo(e);
      }
      getValue(t) {
        if (t <= this._startTime) return this._start;
        if (t >= this._endTime) return this._end;
        const i = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));
        return this._start * (1 - i) + this._end * i;
      }
      isEasing(e) {
        return e >= this._startTime && e <= this._endTime;
      }
      jumpTo(e) {
        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
      }
      easeTo(e, t, i) {
        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;
      }
    }
    const ln = {
        "AttributionControl.ToggleAttribution": "Toggle attribution",
        "AttributionControl.MapFeedback": "Map feedback",
        "FullscreenControl.Enter": "Enter fullscreen",
        "FullscreenControl.Exit": "Exit fullscreen",
        "GeolocateControl.FindMyLocation": "Find my location",
        "GeolocateControl.LocationNotAvailable": "Location not available",
        "LogoControl.Title": "Mapbox logo",
        "Map.Title": "Map",
        "NavigationControl.ResetBearing": "Reset bearing to north",
        "NavigationControl.ZoomIn": "Zoom in",
        "NavigationControl.ZoomOut": "Zoom out",
        "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
        "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map",
        "TouchPanBlocker.Message": "Use two fingers to move the map"
      },
      cn = {
        center: [0, 0],
        zoom: 0,
        bearing: 0,
        pitch: 0,
        minZoom: -2,
        maxZoom: 22,
        minPitch: 0,
        maxPitch: 85,
        interactive: !0,
        scrollZoom: !0,
        boxZoom: !0,
        dragRotate: !0,
        dragPan: !0,
        keyboard: !0,
        doubleClickZoom: !0,
        touchZoomRotate: !0,
        touchPitch: !0,
        cooperativeGestures: !1,
        performanceMetricsCollection: !0,
        bearingSnap: 7,
        clickTolerance: 3,
        pitchWithRotate: !0,
        hash: !1,
        attributionControl: !0,
        failIfMajorPerformanceCaveat: !1,
        preserveDrawingBuffer: !1,
        trackResize: !0,
        optimizeForTerrain: !0,
        renderWorldCopies: !0,
        refreshExpiredTiles: !0,
        minTileCacheSize: null,
        maxTileCacheSize: null,
        localIdeographFontFamily: "sans-serif",
        localFontFamily: null,
        transformRequest: null,
        accessToken: null,
        fadeDuration: 300,
        crossSourceCollisions: !0
      },
      hn = {
        showCompass: !0,
        showZoom: !0,
        visualizePitch: !1
      };
    class un {
      constructor(t, i, o = !1) {
        this._clickTolerance = 10, this.element = i, this.mouseRotate = new wr({
          clickTolerance: t.dragRotate._mouseRotate._clickTolerance
        }), this.map = t, o && (this.mousePitch = new Tr({
          clickTolerance: t.dragRotate._mousePitch._clickTolerance
        })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
          passive: !1
        }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
      }
      down(e, t) {
        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h();
      }
      move(e, t) {
        const i = this.map,
          o = this.mouseRotate.mousemoveWindow(e, t),
          r = o && o.bearingDelta;
        if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
          const o = this.mousePitch.mousemoveWindow(e, t),
            r = o && o.pitchDelta;
          r && i.setPitch(i.getPitch() + r);
        }
      }
      off() {
        const e = this.element;
        e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, {
          passive: !1
        }), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
      }
      offTemp() {
        u(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
      }
      mousedown(t) {
        this.down(e.extend({}, t, {
          ctrlKey: !0,
          preventDefault: () => t.preventDefault()
        }), p(this.element, t)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
      }
      mousemove(e) {
        this.move(e, p(this.element, e));
      }
      mouseup(e) {
        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
      }
      touchstart(e) {
        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e.targetTouches)[0], this.down({
          type: "mousedown",
          button: 0,
          ctrlKey: !0,
          preventDefault: () => e.preventDefault()
        }, this._startPos));
      }
      touchmove(e) {
        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e.targetTouches)[0], this.move({
          preventDefault: () => e.preventDefault()
        }, this._lastPos));
      }
      touchend(e) {
        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }
      reset() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      }
    }
    const _n = {
        positionOptions: {
          enableHighAccuracy: !1,
          maximumAge: 0,
          timeout: 6e3
        },
        fitBoundsOptions: {
          maxZoom: 15
        },
        trackUserLocation: !1,
        showAccuracyCircle: !0,
        showUserLocation: !0,
        showUserHeading: !1
      },
      dn = {
        maxWidth: 100,
        unit: "metric"
      };
    function pn(e, t, i) {
      const o = mn(t),
        r = o / t,
        n = {
          kilometer: "km",
          meter: "m",
          mile: "mi",
          foot: "ft",
          "nautical-mile": "nm"
        }[i];
      this._map._requestDomTask(() => {
        this._container.style.width = e * r + "px", this._container.innerHTML = `${o}&nbsp;${n}`;
      });
    }
    function mn(e) {
      const t = Math.pow(10, `${Math.floor(e)}`.length - 1);
      let i = e / t;
      return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {
        const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
        return Math.round(e * t) / t;
      }(i), t * i;
    }
    const fn = {
      version: e.version,
      supported: i,
      setRTLTextPlugin: e.setRTLTextPlugin,
      getRTLTextPluginStatus: e.getRTLTextPluginStatus,
      Map: class extends Yr {
        constructor(t) {
          if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t = e.extend({}, cn, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t.minPitch && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (null != t.maxPitch && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ko(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._useWebGL2 = t.useWebGL2, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new Qr(), this._domRenderTaskQueue = new Qr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, ln, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new an(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, "string" == typeof t.container) {
            if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);
          } else {
            if (!(t.container instanceof e.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t.container;
          }
          if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, !1), e.window.addEventListener("resize", this._onWindowResize, !1), e.window.addEventListener("orientationchange", this._onWindowResize, !1), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new $r(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, {
            localFontFamily: this._localFontFamily,
            localIdeographFontFamily: this._localIdeographFontFamily
          }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new Qo("string" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
            center: t.center,
            zoom: t.zoom,
            bearing: t.bearing,
            pitch: t.pitch
          }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, {
            duration: 0
          })))), this.resize(), t.attributionControl && this.addControl(new Kr({
            customAttribution: t.customAttribution
          })), this._logoControl = new Jr(), this.addControl(this._logoControl, t.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", t => {
            this._update("style" === t.dataType), this.fire(new e.Event(`${t.dataType}data`, t));
          }), this.on("dataloading", t => {
            this.fire(new e.Event(`${t.dataType}dataloading`, t));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t, i) {
          if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : "top-right"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o = t.onAdd(this);
          this._controls.push(t);
          const r = this._controlPositions[i];
          return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
        }
        removeControl(t) {
          if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i = this._controls.indexOf(t);
          return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;
        }
        hasControl(e) {
          return this._controls.indexOf(e) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i = !this._moving;
          return i && this.fire(new e.Event("movestart", t)).fire(new e.Event("move", t)), this.fire(new e.Event("resize", t)), i && this.fire(new e.Event("moveend", t)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(t) {
          return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update();
        }
        setMinZoom(t) {
          if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t) {
          if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t) {
          if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t) {
          if ((t = null == t ? 85 : t) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e) {
          return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(t) {
          return "auto" === t ? e.window.navigator.language : Array.isArray(t) ? 0 === t.length ? void 0 : t.map(t => "auto" === t ? e.window.navigator.language : t) : t;
        }
        setLanguage(e) {
          const t = this._parseLanguage(e);
          if (!this.style || t === this._language) return this;
          this._language = t, this.style._reloadSources();
          for (const e of this._controls) e._setLanguage && e._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e) {
          return this.style && e !== this._worldview ? (this._worldview = e, this.style._reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? {
            name: "globe",
            center: [0, 0]
          } : this.transform.getProjection();
        }
        _showingGlobe() {
          return "globe" === this.transform.projection.name;
        }
        setProjection(e) {
          return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
            name: e
          }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.stylesheet ? this.style.stylesheet.projection : null);
        }
        _updateProjectionTransition() {
          if ("globe" !== this.getProjection().name) return;
          const t = this.transform,
            i = t.projection.name;
          let o;
          "globe" === i && t.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t.setMercatorFromTransition(), o = !0) : "mercator" === i && t.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t.setProjection({
            name: "globe"
          }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e, t) {
          return this._updateProjection(e || t || {
            name: "mercator"
          });
        }
        _updateProjection(t) {
          let i;
          if (i = "globe" === t.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i) {
            this.painter.clearBackgroundTiles();
            for (const e in this.style._sourceCaches) this.style._sourceCaches[e].clearTiles();
            this._update(!0), this._forceMarkerAndPopupUpdate(!0);
          }
          return this;
        }
        project(t) {
          return this.transform.locationPoint3D(e.LngLat.convert(t));
        }
        unproject(t) {
          return this.transform.pointLocation3D(e.pointGeometry.convert(t));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || !1;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || !1;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || !1;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || !1;
        }
        _createDelegatedListener(e, t, i) {
          if ("mouseenter" === e || "mouseover" === e) {
            let o = !1;
            const r = r => {
                const n = t.filter(e => this.getLayer(e)),
                  s = n.length ? this.queryRenderedFeatures(r.point, {
                    layers: n
                  }) : [];
                s.length ? o || (o = !0, i.call(this, new cr(e, this, r.originalEvent, {
                  features: s
                }))) : o = !1;
              },
              n = () => {
                o = !1;
              };
            return {
              layers: new Set(t),
              listener: i,
              delegates: {
                mousemove: r,
                mouseout: n
              }
            };
          }
          if ("mouseleave" === e || "mouseout" === e) {
            let o = !1;
            const r = r => {
                const n = t.filter(e => this.getLayer(e));
                (n.length ? this.queryRenderedFeatures(r.point, {
                  layers: n
                }) : []).length ? o = !0 : o && (o = !1, i.call(this, new cr(e, this, r.originalEvent)));
              },
              n = t => {
                o && (o = !1, i.call(this, new cr(e, this, t.originalEvent)));
              };
            return {
              layers: new Set(t),
              listener: i,
              delegates: {
                mousemove: r,
                mouseout: n
              }
            };
          }
          {
            const o = e => {
              const o = t.filter(e => this.getLayer(e)),
                r = o.length ? this.queryRenderedFeatures(e.point, {
                  layers: o
                }) : [];
              r.length && (e.features = r, i.call(this, e), delete e.features);
            };
            return {
              layers: new Set(t),
              listener: i,
              delegates: {
                [e]: o
              }
            };
          }
        }
        on(e, t, i) {
          if (void 0 === i) return super.on(e, t);
          Array.isArray(t) || (t = [t]);
          const o = this._createDelegatedListener(e, t, i);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);
          for (const e in o.delegates) this.on(e, o.delegates[e]);
          return this;
        }
        once(e, t, i) {
          if (void 0 === i) return super.once(e, t);
          Array.isArray(t) || (t = [t]);
          const o = this._createDelegatedListener(e, t, i);
          for (const e in o.delegates) this.once(e, o.delegates[e]);
          return this;
        }
        off(e, t, i) {
          if (void 0 === i) return super.off(e, t);
          t = new Set(Array.isArray(t) ? t : [t]);
          const o = (e, t) => {
              if (e.size !== t.size) return !1;
              for (const i of e) if (!t.has(i)) return !1;
              return !0;
            },
            r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
          return r && (e => {
            for (let r = 0; r < e.length; r++) {
              const n = e[r];
              if (n.listener === i && o(n.layers, t)) {
                for (const e in n.delegates) this.off(e, n.delegates[e]);
                return e.splice(r, 1), this;
              }
            }
          })(r), this;
        }
        queryRenderedFeatures(t, i) {
          return this.style ? (void 0 !== i || void 0 === t || t instanceof e.pointGeometry || Array.isArray(t) || (i = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : [];
        }
        querySourceFeatures(e, t) {
          return this.style.querySourceFeatures(e, t);
        }
        setStyle(t, i) {
          return !1 !== (i = e.extend({}, {
            localIdeographFontFamily: this._localIdeographFontFamily,
            localFontFamily: this._localFontFamily
          }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));
        }
        _getUIString(e) {
          const t = this._locale[e];
          if (null == t) throw new Error(`Missing UI string '${e}'`);
          return t;
        }
        _updateStyle(e, t) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new Qt(this, t || {}), this.style.setEventedParent(this, {
            style: this.style
          }), "string" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Qt(this, {}), this.style.setEventedParent(this, {
            style: this.style
          }), this.style.loadEmpty());
        }
        _diffStyle(t, i) {
          if ("string" == typeof t) {
            const o = this._requestManager.normalizeStyleURL(t),
              r = this._requestManager.transformRequest(o, e.ResourceType.Style);
            e.getJSON(r, (t, o) => {
              t ? this.fire(new e.ErrorEvent(t)) : o && this._updateDiff(o, i);
            });
          } else "object" == typeof t && this._updateDiff(t, i);
        }
        _updateDiff(t, i) {
          try {
            this.style.setState(t) && this._update(!0);
          } catch (o) {
            e.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), !1);
        }
        addSource(e, t) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);
        }
        isSourceLoaded(e) {
          return !!this.style && this.style._isSourceCacheLoaded(e);
        }
        areTilesLoaded() {
          const e = this.style && this.style._sourceCaches;
          for (const t in e) {
            const i = e[t]._tiles;
            for (const e in i) {
              const t = i[e];
              if ("loaded" !== t.state && "errored" !== t.state) return !1;
            }
          }
          return !0;
        }
        addSourceType(e, t, i) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);
        }
        removeSource(e) {
          return this.style.removeSource(e), this._updateTerrain(), this._update(!0);
        }
        getSource(e) {
          return this.style.getSource(e);
        }
        addImage(t, i, {
          pixelRatio: o = 1,
          sdf: r = !1,
          stretchX: n,
          stretchY: s,
          content: a
        } = {}) {
          if (this._lazyInitEmptyStyle(), i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap) {
            const {
              width: l,
              height: c,
              data: h
            } = e.exported.getImageData(i);
            this.style.addImage(t, {
              data: new e.RGBAImage({
                width: l,
                height: c
              }, h),
              pixelRatio: o,
              stretchX: n,
              stretchY: s,
              content: a,
              sdf: r,
              version: 0
            });
          } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));else {
            const {
                width: l,
                height: c
              } = i,
              h = i;
            this.style.addImage(t, {
              data: new e.RGBAImage({
                width: l,
                height: c
              }, new Uint8Array(h.data)),
              pixelRatio: o,
              stretchX: n,
              stretchY: s,
              content: a,
              sdf: r,
              version: 0,
              userImage: h
            }), h.onAdd && h.onAdd(this, t);
          }
        }
        updateImage(t, i) {
          const o = this.style.getImage(t);
          if (!o) return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r = i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? e.exported.getImageData(i) : i,
            {
              width: n,
              height: s
            } = r;
          void 0 !== n && void 0 !== s ? n === o.data.width && s === o.data.height ? (o.data.replace(r.data, !(i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap)), this.style.updateImage(t, o)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }
        hasImage(t) {
          return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), !1);
        }
        removeImage(e) {
          this.style.removeImage(e);
        }
        loadImage(t, i) {
          e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), (t, o) => {
            i(t, o instanceof e.window.HTMLImageElement ? e.exported.getImageData(o) : o);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e, t) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);
        }
        moveLayer(e, t) {
          return this.style.moveLayer(e, t), this._update(!0);
        }
        removeLayer(e) {
          return this.style.removeLayer(e), this._update(!0);
        }
        getLayer(e) {
          return this.style.getLayer(e);
        }
        setLayerZoomRange(e, t, i) {
          return this.style.setLayerZoomRange(e, t, i), this._update(!0);
        }
        setFilter(e, t, i = {}) {
          return this.style.setFilter(e, t, i), this._update(!0);
        }
        getFilter(e) {
          return this.style.getFilter(e);
        }
        setPaintProperty(e, t, i, o = {}) {
          return this.style.setPaintProperty(e, t, i, o), this._update(!0);
        }
        getPaintProperty(e, t) {
          return this.style.getPaintProperty(e, t);
        }
        setLayoutProperty(e, t, i, o = {}) {
          return this.style.setLayoutProperty(e, t, i, o), this._update(!0);
        }
        getLayoutProperty(e, t) {
          return this.style.getLayoutProperty(e, t);
        }
        setLight(e, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setTerrain(e) {
          return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        _queryFogOpacity(t) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0;
        }
        setFeatureState(e, t) {
          return this.style.setFeatureState(e, t), this._update();
        }
        removeFeatureState(e, t) {
          return this.style.removeFeatureState(e, t), this._update();
        }
        getFeatureState(e) {
          return this.style.getFeatureState(e);
        }
        _updateContainerDimensions() {
          if (!this._container) return;
          const t = this._container.getBoundingClientRect().width || 400,
            i = this._container.getBoundingClientRect().height || 300;
          let o,
            r,
            n,
            s = this._container;
          for (; s && (!r || !n);) {
            const t = e.window.getComputedStyle(s).transform;
            t && "none" !== t && (o = t.match(/matrix.*\((.+)\)/)[1].split(", "), o[0] && "0" !== o[0] && "1" !== o[0] && (r = o[0]), o[3] && "0" !== o[3] && "1" !== o[3] && (n = o[3])), s = s.parentElement;
          }
          this._containerWidth = r ? Math.abs(t / r) : t, this._containerHeight = n ? Math.abs(i / n) : i;
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e = this._container;
          e.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
          const t = this._canvasContainer = n("div", "mapboxgl-canvas-container", e);
          this._interactive && t.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i = this._controlContainer = n("div", "mapboxgl-control-container", e),
            o = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(e => {
            o[e] = n("div", `mapboxgl-ctrl-${e}`, i);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(t, i) {
          const o = e.exported.devicePixelRatio || 1;
          this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;
        }
        _addMarker(e) {
          this._markers.push(e);
        }
        _removeMarker(e) {
          const t = this._markers.indexOf(e);
          -1 !== t && this._markers.splice(t, 1);
        }
        _addPopup(e) {
          this._popups.push(e);
        }
        _removePopup(e) {
          const t = this._popups.indexOf(e);
          -1 !== t && this._popups.splice(t, 1);
        }
        _setupPainter() {
          const t = e.extend({}, i.webGLContextAttributes, {
              failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
              preserveDrawingBuffer: this._preserveDrawingBuffer,
              antialias: this._antialias || !1
            }),
            o = this._useWebGL2 && this._canvas.getContext("webgl2", t),
            r = o || this._canvas.getContext("webgl", t) || this._canvas.getContext("experimental-webgl", t);
          r ? (this._useWebGL2 && !o && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(r, !0), this.painter = new Fo(r, this.transform, !!o), this.on("data", e => {
            "source" === e.dataType && this.painter.setTileLoadedFlag(!0);
          }), e.exported$1.testSupport(r)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t) {
          t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", {
            originalEvent: t
          }));
        }
        _contextRestored(t) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", {
            originalEvent: t
          }));
        }
        _onMapScroll(e) {
          if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e) {
          return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e) {
          return this._update(), this._renderTaskQueue.add(e);
        }
        _cancelRenderFrame(e) {
          this._renderTaskQueue.remove(e);
        }
        _requestDomTask(e) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
        }
        _render(t) {
          let i;
          const o = this.painter.context.extTimerQuery,
            r = e.exported.now();
          if (this.listens("gpu-timing-frame") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;
          this._updateProjectionTransition();
          const n = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const t = this.transform.zoom,
              i = this.transform.pitch,
              o = e.exported.now(),
              r = new e.EvaluationParameters(t, {
                now: o,
                fadeDuration: n,
                pitch: i,
                transition: this.style.getTransition()
              });
            this.style.update(r);
          }
          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
          let s = !1;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.style && this.painter.render(this.style, {
            showTileBoundaries: this.showTileBoundaries,
            showTerrainWireframe: this.showTerrainWireframe,
            showOverdrawInspector: this._showOverdrawInspector,
            showQueryGeometry: !!this._showQueryGeometry,
            showTileAABBs: this.showTileAABBs,
            rotating: this.isRotating(),
            zooming: this.isZooming(),
            moving: this.isMoving(),
            fadeDuration: n,
            isInitialLoad: this._isInitialLoad,
            showPadding: this.showPadding,
            gpuTiming: !!this.listens("gpu-timing-layer"),
            gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
            speedIndexTiming: this.speedIndexTiming
          }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {
            const t = e.exported.now() - r;
            o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(() => {
              const n = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;
              o.deleteQueryEXT(i), this.fire(new e.Event("gpu-timing-frame", {
                cpuTime: t,
                gpuTime: n
              })), e.window.performance.mark("frame-gpu", {
                startTime: r,
                detail: {
                  gpuTime: n
                }
              });
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i = this.painter.queryGpuTimers(t);
              this.fire(new e.Event("gpu-timing-layer", {
                layerTimes: i
              }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const t = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const i = this.painter.queryGpuTimeDeferredRender(t);
              this.fire(new e.Event("gpu-timing-deferred-render", {
                gpuTime: i
              }));
            }, 50);
          }
          const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
          if (a || this._repaint) this.triggerRepaint();else {
            const t = !this.isMoving() && this.loaded();
            if (t && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
              const t = this._calculateSpeedIndex();
              this.fire(new e.Event("speedindexcompleted", {
                speedIndex: t
              })), this.speedIndexTiming = !1;
            }
          }
          !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, {
            width: this.painter.width,
            height: this.painter.height,
            interactionRange: this._interactionRange,
            visibilityHidden: this._visibilityHidden,
            terrainEnabled: !!this.painter.style.getTerrain(),
            fogEnabled: !!this.painter.style.getFog(),
            projection: this.getProjection().name,
            zoom: this.transform.zoom,
            renderer: this.painter.context.renderer,
            vendor: this.painter.context.vendor
          }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e) {
          for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
          for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
        }
        _updateAverageElevation(e, t = !1) {
          const i = e => (this.transform.averageElevation = e, this._update(!1), !0);
          if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
          if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
            const t = this.transform.averageElevation;
            let o = this.transform.sampleAverageElevation(),
              r = !1;
            this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e;
            const n = Math.abs(t - o);
            if (n > 1) {
              if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);
              this._averageElevation.easeTo(o, e, 300);
            } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);
          }
          return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
        }
        _authenticate() {
          e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {
            if (t && (t.message === e.AUTH_ERR_MSG || 401 === t.status)) {
              const t = this.painter.context.gl;
              e.storeAuthState(t, !1), this._logoControl instanceof Jr && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});
        }
        _updateTerrain() {
          const e = this._isDragging();
          this.painter.updateTerrain(this.style, e);
        }
        _calculateSpeedIndex() {
          const e = this.painter.canvasCopy(),
            t = this.painter.getCanvasCopiesAndTimestamps();
          t.timeStamps.push(performance.now());
          const i = this.painter.context.gl,
            o = i.createFramebuffer();
          function r(e) {
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
            const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
            return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;
          }
          return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps);
        }
        _canvasPixelComparison(e, t, i) {
          let o = i[1] - i[0];
          const r = e.length / 4;
          for (let n = 0; n < t.length; n++) {
            const s = t[n];
            let a = 0;
            for (let t = 0; t < s.length; t += 4) s[t] === e[t] && s[t + 1] === e[t + 1] && s[t + 2] === e[t + 2] && s[t + 3] === e[t + 3] && (a += 1);
            o += (i[n + 2] - i[n + 1]) * (1 - a / r);
          }
          return o;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e of this._controls) e.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, !1), e.window.removeEventListener("orientationchange", this._onWindowResize, !1), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.removeEventListener("online", this._onWindowOnline, !1), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
          const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t && t.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(!0);
        }
        _triggerFrame(t) {
          this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame(e => {
            const t = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t && this._render(e);
          }));
        }
        _preloadTiles(t) {
          const i = this.style ? Object.values(this.style._sourceCaches) : [];
          return e.asyncAll(i, (e, i) => e._preloadTiles(t, i), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e) {
          this._trackResize && this.resize({
            originalEvent: e
          })._update();
        }
        _onVisibilityChange() {
          "hidden" === e.window.document.visibilityState && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e) {
          this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e) {
          this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e) {
          this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e) {
          this._showPadding !== e && (this._showPadding = e, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e) {
          this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e) {
          this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e) {
          this._repaint !== e && (this._repaint = e, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e) {
          this._vertices = e, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e) {
          this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update());
        }
        _setCacheLimits(t, i) {
          e.setCacheLimits(t, i);
        }
        get version() {
          return e.version;
        }
      },
      NavigationControl: class {
        constructor(t) {
          this.options = e.extend({}, hn, t), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", e => e.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", e => {
            this._map && this._map.zoomIn({}, {
              originalEvent: e
            });
          }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", e => {
            this._map && this._map.zoomOut({}, {
              originalEvent: e
            });
          }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", e => {
            const t = this._map;
            t && (this.options.visualizePitch ? t.resetNorthPitch({}, {
              originalEvent: e
            }) : t.resetNorth({}, {
              originalEvent: e
            }));
          }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e = this._map;
          if (!e) return;
          const t = e.getZoom(),
            i = t === e.getMaxZoom(),
            o = t === e.getMinZoom();
          this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
        }
        _rotateCompassArrow() {
          const e = this._map;
          if (!e) return;
          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;
          e._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t);
          });
        }
        onAdd(e) {
          return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new un(e, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e = this._map;
          e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e, t) {
          const i = n("button", e, this._container);
          return i.type = "button", i.addEventListener("click", t), i;
        }
        _setButtonTitle(e, t) {
          if (!this._map) return;
          const i = this._map._getUIString(`NavigationControl.${t}`);
          e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
        }
      },
      GeolocateControl: class extends e.Evented {
        constructor(t) {
          super(), this.options = e.extend({
            geolocation: e.window.navigator.geolocation
          }, _n, t), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Jo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e) {
          return this._map = e, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
        }
        _checkGeolocationSupport(t) {
          const i = (e = !!this.options.geolocation) => {
            this._supportsGeolocation = e, t(e);
          };
          void 0 !== this._supportsGeolocation ? t(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({
            name: "geolocation"
          }).then(e => i("denied" !== e.state)).catch(() => i()) : i();
        }
        _isOutOfMapMaxBounds(e) {
          const t = this._map.getMaxBounds(),
            i = e.coords;
          return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "BACKGROUND":
              case "BACKGROUND_ERROR":
                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
            }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t)), this._finish();
          }
        }
        _updateCamera(t) {
          const i = new e.LngLat(t.coords.longitude, t.coords.latitude),
            o = t.coords.accuracy,
            r = this._map.getBearing(),
            n = e.extend({
              bearing: r
            }, this.options.fitBoundsOptions);
          this._map.fitBounds(i.toBounds(o), n, {
            geolocateSource: !0
          });
        }
        _updateMarker(t) {
          if (t) {
            const i = new e.LngLat(t.coords.longitude, t.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const t = this._map.transform,
            i = e.mercatorZfromAltitude(1, t._center.lat) * t.worldSize,
            o = Math.ceil(2 * this._accuracy * i);
          this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t) {
          if (this._map) {
            if (this.options.trackUserLocation) if (1 === t.code) {
              this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
              const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
            } else {
              if (3 === t.code && this._noTimeout) return;
              this._setErrorState();
            }
            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t) {
          if (void 0 !== this._map) {
            if (this._container.addEventListener("contextmenu", e => e.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t) {
              e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
            } else {
              const e = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new on({
              element: this._dotElement,
              rotationAlignment: "map",
              pitchAlignment: "map"
            }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new on({
              element: this._circleElement,
              pitchAlignment: "map"
            }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", t => {
              t.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t.originalEvent && "resize" === t.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e) {
          this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup) return e.warnOnce("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {
              let e;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {
                maximumAge: 6e5,
                timeout: 0
              }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _addDeviceOrientationListener() {
          const t = () => {
            e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };
          void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(e => {
            "granted" === e && t();
          }).catch(console.error) : t();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      },
      AttributionControl: Kr,
      ScaleControl: class {
        constructor(t) {
          this.options = e.extend({}, dn, t), function () {
            try {
              return new Intl.NumberFormat("en", {
                style: "unit",
                unitDisplay: "narrow",
                unit: "meter"
              }), !0;
            } catch (e) {
              return !1;
            }
          }() || (this._setScale = pn.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e = this.options.maxWidth || 100,
            t = this._map,
            i = t._containerHeight / 2,
            o = t._containerWidth / 2 - e / 2,
            r = t.unproject([o, i]),
            n = t.unproject([o + e, i]),
            s = r.distanceTo(n);
          if ("imperial" === this.options.unit) {
            const t = 3.2808 * s;
            t > 5280 ? this._setScale(e, t / 5280, "mile") : this._setScale(e, t, "foot");
          } else "nautical" === this.options.unit ? this._setScale(e, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(e, s / 1e3, "kilometer") : this._setScale(e, s, "meter");
        }
        _setScale(e, t, i) {
          const o = mn(t),
            r = o / t;
          this._map._requestDomTask(() => {
            this._container.style.width = e * r + "px", this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
              style: "unit",
              unitDisplay: "narrow",
              unit: i
            }).format(o) : `${o}&nbsp;nm`;
          });
        }
        onAdd(e) {
          return this._map = e, this._language = e.getLanguage(), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e) {
          this._language = e, this._update();
        }
        setUnit(e) {
          this.options.unit = e, this._update();
        }
      },
      FullscreenControl: class {
        constructor(t) {
          this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t) {
          return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const t = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          n("span", "mapboxgl-ctrl-icon", t).setAttribute("aria-hidden", "true"), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      },
      Popup: class extends e.Evented {
        constructor(t) {
          super(), this.options = e.extend(Object.create(rn), t), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\s+/) : []);
        }
        addTo(t) {
          return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on("preclick", this._onClose), this.options.closeOnMove && t.on("move", this._onClose), t.on("remove", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on("mousemove", this._onMouseEvent), t.on("mouseup", this._onMouseEvent), t._canvasContainer.classList.add("mapboxgl-track-pointer")) : t.on("move", this._update), this.fire(new e.Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t = this._map;
          return t && (t.off("move", this._update), t.off("move", this._onClose), t.off("preclick", this._onClose), t.off("click", this._onClose), t.off("remove", this.remove), t.off("mousemove", this._onMouseEvent), t.off("mouseup", this._onMouseEvent), t.off("drag", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove("mapboxgl-track-pointer"), t._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update();
          const i = this._map;
          return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = !0, this._pos = null, this._update();
          const e = this._map;
          return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t) {
          return this.setDOMContent(e.window.document.createTextNode(t));
        }
        setHTML(t) {
          const i = e.window.document.createDocumentFragment(),
            o = e.window.document.createElement("body");
          let r;
          for (o.innerHTML = t; r = o.firstChild, r;) i.appendChild(r);
          return this.setDOMContent(i);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e) {
          return this.options.maxWidth = e, this._update(), this;
        }
        setDOMContent(e) {
          let t = this._content;
          if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);
          if (t.appendChild(e), this.options.closeButton) {
            const e = this._closeButton = n("button", "mapboxgl-popup-close-button", t);
            e.type = "button", e.setAttribute("aria-label", "Close popup"), e.setAttribute("aria-hidden", "true"), e.innerHTML = "&#215;", e.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e) {
          return this._classList.add(e), this._updateClassList(), this;
        }
        removeClassName(e) {
          return this._classList.delete(e), this._updateClassList(), this;
        }
        setOffset(e) {
          return this.options.offset = e, this._update(), this;
        }
        toggleClassName(e) {
          let t;
          return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;
        }
        _onMouseEvent(e) {
          this._update(e.point);
        }
        _getAnchor(e) {
          if (this.options.anchor) return this.options.anchor;
          const t = this._map,
            i = this._container,
            o = this._pos;
          if (!t || !i || !o) return "bottom";
          const r = i.offsetWidth,
            n = i.offsetHeight,
            s = o.x < r / 2,
            a = o.x > t.transform.width - r / 2;
          if (o.y + e < n) return s ? "top-left" : a ? "top-right" : "top";
          if (o.y > t.transform.height - n) {
            if (s) return "bottom-left";
            if (a) return "bottom-right";
          }
          return s ? "left" : a ? "right" : "bottom";
        }
        _updateClassList() {
          const e = this._container;
          if (!e) return;
          const t = [...this._classList];
          t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), e.className = t.join(" ");
        }
        _update(t) {
          const i = this._map,
            o = this._content;
          if (!i || !this._lngLat && !this._trackPointer || !o) return;
          let r = this._container;
          if (r || (r = this._container = n("div", "mapboxgl-popup", i.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = en(this._lngLat, this._pos, i.transform)), !this._trackPointer || t) {
            const e = this._pos = this._trackPointer && t ? t : i.project(this._lngLat),
              o = sn(this.options.offset),
              r = this._anchor = this._getAnchor(o.y),
              n = sn(this.options.offset, r),
              s = e.add(n).round();
            i._requestDomTask(() => {
              this._container && r && (this._container.style.transform = `${tn[r]} translate(${s.x}px,${s.y}px)`);
            });
          }
          if (!this._marker && i._showingGlobe()) {
            const t = e.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(t);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const e = this._container.querySelector(nn);
          e && e.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e) {
          this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
        }
      },
      Marker: on,
      Style: Qt,
      LngLat: e.LngLat,
      LngLatBounds: e.LngLatBounds,
      Point: e.pointGeometry,
      MercatorCoordinate: e.MercatorCoordinate,
      FreeCameraOptions: Zo,
      Evented: e.Evented,
      config: e.config,
      prewarm: function () {
        je().acquire(Ue);
      },
      clearPrewarmedResources: function () {
        const e = Ge;
        e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Ue), Ge = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      },
      get accessToken() {
        return e.config.ACCESS_TOKEN;
      },
      set accessToken(t) {
        e.config.ACCESS_TOKEN = t;
      },
      get baseApiUrl() {
        return e.config.API_URL;
      },
      set baseApiUrl(t) {
        e.config.API_URL = t;
      },
      get workerCount() {
        return Ne.workerCount;
      },
      set workerCount(e) {
        Ne.workerCount = e;
      },
      get maxParallelImageRequests() {
        return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
      },
      set maxParallelImageRequests(t) {
        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t;
      },
      clearStorage(t) {
        e.clearTileCache(t);
      },
      workerUrl: "",
      workerClass: null,
      setNow: e.exported.setNow,
      restoreNow: e.exported.restoreNow
    };
    return fn;
  });

  //

  var mapboxgl$1 = mapboxgl;
  return mapboxgl$1;
});
},{}],"src/index.js":[function(require,module,exports) {
"use strict";

var _mapbox = require("@deck.gl/mapbox");
var _layers = require("@deck.gl/layers");
var _mapboxGl = _interopRequireDefault(require("mapbox-gl"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// source: Natural Earth http://www.naturalearthdata.com/ via geojson.xyz
var AIR_PORTS = "https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson";
_mapboxGl.default.accessToken = "pk.eyJ1IjoiZGVhZG5pZ2h0NyIsImEiOiJjanJzeWY1dGkwMWQ4NDNsZmJjaGNsemZ3In0.WglAlgSd9imV5C778hJ0cA";
var map = new _mapboxGl.default.Map({
  container: "map",
  style: "https://basemaps.cartocdn.com/gl/positron-nolabels-gl-style/style.json",
  center: [0.45, 51.47],
  zoom: 4,
  bearing: 0,
  pitch: 30
});
var deckOverlay = new _mapbox.MapboxOverlay({
  layers: [new _layers.GeoJsonLayer({
    id: "airports",
    data: AIR_PORTS,
    // Styles
    filled: true,
    pointRadiusMinPixels: 2,
    pointRadiusScale: 2000,
    getPointRadius: function getPointRadius(f) {
      return 11 - f.properties.scalerank;
    },
    getFillColor: [200, 0, 80, 180],
    // Interactive props
    pickable: true,
    autoHighlight: true,
    onClick: function onClick(info) {
      return (
        // eslint-disable-next-line
        info.object && alert("".concat(info.object.properties.name, " (").concat(info.object.properties.abbrev, ")"))
      );
    }
  }), new _layers.ArcLayer({
    id: "arcs",
    data: AIR_PORTS,
    dataTransform: function dataTransform(d) {
      return d.features.filter(function (f) {
        return f.properties.scalerank < 4;
      });
    },
    // Styles
    getSourcePosition: function getSourcePosition(f) {
      return [-0.4531566, 51.4709959];
    },
    // London
    getTargetPosition: function getTargetPosition(f) {
      return f.geometry.coordinates;
    },
    getSourceColor: [0, 128, 200],
    getTargetColor: [200, 0, 80],
    getWidth: 1
  })]
});
map.addControl(deckOverlay);
map.addControl(new _mapboxGl.default.NavigationControl());
},{"@deck.gl/mapbox":"node_modules/@deck.gl/mapbox/dist/esm/index.js","@deck.gl/layers":"node_modules/@deck.gl/layers/dist/esm/index.js","mapbox-gl":"node_modules/mapbox-gl/dist/mapbox-gl.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "39907" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.js"], null)
//# sourceMappingURL=/src.a2b27638.js.map