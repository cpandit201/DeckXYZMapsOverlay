{"id":"mZ2d","dependencies":[{"name":"/project/deck-gl-examples-01/node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js.map","includedInParent":true,"mtime":1688284132821},{"name":"/project/deck-gl-examples-01/package.json","includedInParent":true,"mtime":1688495957541},{"name":"/project/deck-gl-examples-01/node_modules/@deck.gl/layers/package.json","includedInParent":true,"mtime":1688284132821}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;const n=\"\\nvec3 packUVsIntoRGB(vec2 uv) {\\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\\n  vec2 uv8bit = floor(uv * 256.);\\n\\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\\n  // Scale and clamp to 0-1 range\\n  vec2 uvFraction = fract(uv * 256.);\\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\\n\\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\\n\\n  return vec3(uv8bit, fractions) / 255.;\\n}\\n\";var o=\"\\n#define SHADER_NAME bitmap-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform sampler2D bitmapTexture;\\n\\nvarying vec2 vTexCoord;\\nvarying vec2 vTexPos;\\n\\nuniform float desaturate;\\nuniform vec4 transparentColor;\\nuniform vec3 tintColor;\\nuniform float opacity;\\n\\nuniform float coordinateConversion;\\nuniform vec4 bounds;\\n\\n/* projection utils */\\nconst float TILE_SIZE = 512.0;\\nconst float PI = 3.1415926536;\\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\\n\\n// from degrees to Web Mercator\\nvec2 lnglat_to_mercator(vec2 lnglat) {\\n  float x = lnglat.x;\\n  float y = clamp(lnglat.y, -89.9, 89.9);\\n  return vec2(\\n    radians(x) + PI,\\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\\n  ) * WORLD_SCALE;\\n}\\n\\n// from Web Mercator to degrees\\nvec2 mercator_to_lnglat(vec2 xy) {\\n  xy /= WORLD_SCALE;\\n  return degrees(vec2(\\n    xy.x - PI,\\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\\n  ));\\n}\\n/* End projection utils */\\n\\n// apply desaturation\\nvec3 color_desaturate(vec3 color) {\\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\\n  return mix(color, vec3(luminance), desaturate);\\n}\\n\\n// apply tint\\nvec3 color_tint(vec3 color) {\\n  return color * tintColor;\\n}\\n\\n// blend with background color\\nvec4 apply_opacity(vec3 color, float alpha) {\\n  if (transparentColor.a == 0.0) {\\n    return vec4(color, alpha);\\n  }\\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\\n  float highLightRatio = alpha / blendedAlpha;\\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\\n  return vec4(blendedRGB, blendedAlpha);\\n}\\n\\nvec2 getUV(vec2 pos) {\\n  return vec2(\\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\\n  );\\n}\\n\\n\".concat(n,\"\\n\\nvoid main(void) {\\n  vec2 uv = vTexCoord;\\n  if (coordinateConversion < -0.5) {\\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\\n    uv = getUV(lnglat);\\n  } else if (coordinateConversion > 0.5) {\\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\\n    uv = getUV(commonPos);\\n  }\\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\\n\\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\\n\\n  geometry.uv = uv;\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n\\n  if (picking_uActive && !picking_uAttribute) {\\n    // Since instance information is not used, we can use picking color for pixel index\\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\\n  }\\n}\\n\");exports.default=o;"},"sourceMaps":{"js":{"mappings":[{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":0}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":13}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":20}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":35}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":43}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":56}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":57}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":64}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":68}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":76}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":89}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":10,"column":0},"generated":{"line":1,"column":91}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":"packUVsIntoRGB","original":{"line":10,"column":6},"generated":{"line":1,"column":97}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":10,"column":20},"generated":{"line":1,"column":99}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":10,"column":0},"generated":{"line":1,"column":675}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":10,"column":0},"generated":{"line":1,"column":679}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":681}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":2449}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":"packUVsIntoRGB","original":{"line":101,"column":2},"generated":{"line":1,"column":2456}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":2458}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":3170}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":3178}},{"source":"../../../src/bitmap-layer/bitmap-layer-fragment.ts","name":null,"original":{"line":27,"column":0},"generated":{"line":1,"column":3186}}],"sources":{"../../../src/bitmap-layer/bitmap-layer-fragment.ts":"/**\n * Pack the top 12 bits of two normalized floats into 3 8-bit (rgb) values\n * This enables addressing 4096x4096 individual pixels\n *\n * returns vec3 encoded RGB colors\n *  result.r - top 8 bits of u\n *  result.g - top 8 bits of v\n *  result.b - next 4 bits of u and v: (u + v * 16)\n */\nconst packUVsIntoRGB = `\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n`;\n\nexport default `\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n${packUVsIntoRGB}\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive && !picking_uAttribute) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n`;\n"},"lineCount":null}},"error":null,"hash":"02e1fd9d44e46ce80b1ffee66e2541c6","cacheData":{"env":{}}}